(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["L7"] = factory();
	else
		root["L7"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 77);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Vector3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Math_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Quaternion_js__ = __webpack_require__(24);



/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector3(x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
}

Object.assign(Vector3.prototype, {
  isVector3: true,
  set: function (x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  },
  multiplyVectors: function (a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyEuler: function () {
    var quaternion = new __WEBPACK_IMPORTED_MODULE_2__Quaternion_js__["a" /* Quaternion */]();
    return function applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
      }

      return this.applyQuaternion(quaternion.setFromEuler(euler));
    };
  }(),
  applyAxisAngle: function () {
    var quaternion = new __WEBPACK_IMPORTED_MODULE_2__Quaternion_js__["a" /* Quaternion */]();
    return function applyAxisAngle(axis, angle) {
      return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
    };
  }(),
  applyMatrix3: function (m) {
    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;
    var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  },
  applyQuaternion: function (q) {
    var x = this.x,
        y = this.y,
        z = this.z;
    var qx = q.x,
        qy = q.y,
        qz = q.z,
        qw = q.w; // calculate quat * vector

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  project: function (camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  },
  unproject: function () {
    var matrix = new __WEBPACK_IMPORTED_MODULE_1__Matrix4_js__["a" /* Matrix4 */]();
    return function unproject(camera) {
      return this.applyMatrix4(matrix.getInverse(camera.projectionMatrix)).applyMatrix4(camera.matrixWorld);
    };
  }(),
  transformDirection: function (m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  },
  clampScalar: function () {
    var min = new Vector3();
    var max = new Vector3();
    return function clampScalar(minVal, maxVal) {
      min.set(minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal);
      return this.clamp(min, max);
    };
  }(),
  clampLength: function (min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },
  // TODO lengthSquared?
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  cross: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }

    return this.crossVectors(this, v);
  },
  crossVectors: function (a, b) {
    var ax = a.x,
        ay = a.y,
        az = a.z;
    var bx = b.x,
        by = b.y,
        bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  },
  projectOnVector: function (vector) {
    var scalar = vector.dot(this) / vector.lengthSq();
    return this.copy(vector).multiplyScalar(scalar);
  },
  projectOnPlane: function () {
    var v1 = new Vector3();
    return function projectOnPlane(planeNormal) {
      v1.copy(this).projectOnVector(planeNormal);
      return this.sub(v1);
    };
  }(),
  reflect: function () {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    var v1 = new Vector3();
    return function reflect(normal) {
      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
    };
  }(),
  angleTo: function (v) {
    var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq()); // clamp, to handle numerical problems

    return Math.acos(__WEBPACK_IMPORTED_MODULE_0__Math_js__["a" /* _Math */].clamp(theta, -1, 1));
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x,
        dy = this.y - v.y,
        dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  },
  manhattanDistanceTo: function (v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  },
  setFromSpherical: function (s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  },
  setFromSphericalCoords: function (radius, phi, theta) {
    var sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  },
  setFromCylindrical: function (c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  },
  setFromCylindricalCoords: function (radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  },
  setFromMatrixPosition: function (m) {
    var e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  },
  setFromMatrixScale: function (m) {
    var sx = this.setFromMatrixColumn(m, 0).length();
    var sy = this.setFromMatrixColumn(m, 1).length();
    var sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  },
  setFromMatrixColumn: function (m, index) {
    return this.fromArray(m.elements, index * 4);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
});


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview The util method based on the lodash.
 * @author dxq613@gmail.com
 * @see https://github.com/lodash/lodash
 */
var Utils = __webpack_require__(254);

var Util = Utils.mix({}, Utils, {
  assign: Utils.mix,
  // simple mix
  merge: Utils.deepMix,
  // deep mix
  cloneDeep: Utils.clone,
  isFinite: isFinite,
  isNaN: isNaN,
  snapEqual: Utils.isNumberEqual,
  remove: Utils.pull,
  inArray: Utils.contains,

  /**
   * 将用户输入的 padding 转换成 [top, right, bottom, right] 的模式
   * @param  {Number|Array} padding 输入的padding
   * @return {Array} 四个padding 值
   */
  toAllPadding: function toAllPadding(padding) {
    var top = 0;
    var left = 0;
    var right = 0;
    var bottom = 0;

    if (Util.isNumber(padding) || Util.isString(padding)) {
      top = left = right = bottom = padding;
    } else if (Util.isArray(padding)) {
      top = padding[0];
      right = !Util.isNil(padding[1]) ? padding[1] : padding[0];
      bottom = !Util.isNil(padding[2]) ? padding[2] : padding[0];
      left = !Util.isNil(padding[3]) ? padding[3] : right;
    } else if (Util.isObject(padding)) {
      top = padding.top || 0;
      right = padding.right || 0;
      bottom = padding.bottom || 0;
      left = padding.left || 0;
    }

    return [top, right, bottom, left];
  }
});
Util.Array = {
  groupToMap: Utils.groupToMap,
  group: Utils.group,
  merge: Utils.merge,
  values: Utils.valuesOfKey,
  getRange: Utils.getRange,
  firstValue: Utils.firstValue,
  remove: Utils.pull
};
module.exports = Util;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_three_src_polyfills_js__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_three_src_polyfills_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_three_src_polyfills_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__ = __webpack_require__(3);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_27"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_3"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["s"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["p"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["r"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["G"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["F"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_25"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_26"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["H"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["w"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["D"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_63"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_15"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["C"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_83"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_14"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_17"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_69"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_8"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["t"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_68"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_61"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_5"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_4"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_86"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_20"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_67"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_24"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_65"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_23"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["x"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_21"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["y"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_22"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_66"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_13"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["Q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["R"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["z"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["K"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["J"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_18"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_9"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_7"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_16"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["W"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_59"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_75"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_74"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["l"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["A"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["B"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_64"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["n"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["o"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_60"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_6"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_10"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_12"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_11"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["T"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["V"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["U"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_76"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_62"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_82"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["M"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_78"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["E"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["L"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_79"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_80"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_81"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_77"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_52"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_29"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_2"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_1"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_51"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["u"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["v"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_58"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_46"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_47"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_48"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_57"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_56"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_45"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_44"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_55"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_36"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_37"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_38"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_39"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_40"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_41"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_42"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_43"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_31"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_32"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_33"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_30"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_34"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_35"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["Y"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_0"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["Z"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["N"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["O"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["P"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_85"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_87"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_84"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_73"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_72"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_71"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["S"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_88"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["I"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_50"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["X"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_54"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_53"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_49"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_28"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_70"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return __WEBPACK_IMPORTED_MODULE_1_three_src_constants_js__["_19"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_three_src_scenes_Scene_js__ = __webpack_require__(81);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return __WEBPACK_IMPORTED_MODULE_2_three_src_scenes_Scene_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_three_src_renderers_WebGLRenderer_js__ = __webpack_require__(84);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return __WEBPACK_IMPORTED_MODULE_3_three_src_renderers_WebGLRenderer_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_three_src_textures_CanvasTexture_js__ = __webpack_require__(232);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return __WEBPACK_IMPORTED_MODULE_4_three_src_textures_CanvasTexture_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_three_src_core_Object3D_js__ = __webpack_require__(5);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return __WEBPACK_IMPORTED_MODULE_5_three_src_core_Object3D_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_three_src_core_Clock__ = __webpack_require__(233);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return __WEBPACK_IMPORTED_MODULE_6_three_src_core_Clock__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_three_src_objects_Points_js__ = __webpack_require__(234);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return __WEBPACK_IMPORTED_MODULE_7_three_src_objects_Points_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_three_src_objects_LineSegments_js__ = __webpack_require__(235);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return __WEBPACK_IMPORTED_MODULE_8_three_src_objects_LineSegments_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_three_src_objects_Mesh_js__ = __webpack_require__(52);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return __WEBPACK_IMPORTED_MODULE_9_three_src_objects_Mesh_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_three_src_textures_Texture_js__ = __webpack_require__(10);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return __WEBPACK_IMPORTED_MODULE_10_three_src_textures_Texture_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_three_src_lights_DirectionalLight_js__ = __webpack_require__(236);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return __WEBPACK_IMPORTED_MODULE_11_three_src_lights_DirectionalLight_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_three_src_lights_AmbientLight_js__ = __webpack_require__(239);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return __WEBPACK_IMPORTED_MODULE_12_three_src_lights_AmbientLight_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_three_src_renderers_WebGLRenderTarget_js__ = __webpack_require__(54);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return __WEBPACK_IMPORTED_MODULE_13_three_src_renderers_WebGLRenderTarget_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_three_src_cameras_PerspectiveCamera_js__ = __webpack_require__(26);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return __WEBPACK_IMPORTED_MODULE_14_three_src_cameras_PerspectiveCamera_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_three_src_core_BufferGeometry_js__ = __webpack_require__(14);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return __WEBPACK_IMPORTED_MODULE_15_three_src_core_BufferGeometry_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_three_src_core_Raycaster_js__ = __webpack_require__(240);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return __WEBPACK_IMPORTED_MODULE_16_three_src_core_Raycaster_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_three_src_math_Matrix4_js__ = __webpack_require__(4);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return __WEBPACK_IMPORTED_MODULE_17_three_src_math_Matrix4_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_three_src_math_Matrix3_js__ = __webpack_require__(9);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return __WEBPACK_IMPORTED_MODULE_18_three_src_math_Matrix3_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_three_src_objects_Line_js__ = __webpack_require__(34);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return __WEBPACK_IMPORTED_MODULE_19_three_src_objects_Line_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_three_src_objects_LineLoop_js__ = __webpack_require__(241);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return __WEBPACK_IMPORTED_MODULE_20_three_src_objects_LineLoop_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_three_src_math_Vector4_js__ = __webpack_require__(11);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return __WEBPACK_IMPORTED_MODULE_21_three_src_math_Vector4_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_three_src_math_Vector3_js__ = __webpack_require__(0);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return __WEBPACK_IMPORTED_MODULE_22_three_src_math_Vector3_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_three_src_math_Vector2_js__ = __webpack_require__(8);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return __WEBPACK_IMPORTED_MODULE_23_three_src_math_Vector2_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_three_src_loaders_TextureLoader_js__ = __webpack_require__(242);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return __WEBPACK_IMPORTED_MODULE_24_three_src_loaders_TextureLoader_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_three_src_materials_LineDashedMaterial_js__ = __webpack_require__(245);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return __WEBPACK_IMPORTED_MODULE_25_three_src_materials_LineDashedMaterial_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26_three_src_materials_ShaderMaterial_js__ = __webpack_require__(51);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return __WEBPACK_IMPORTED_MODULE_26_three_src_materials_ShaderMaterial_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27_three_src_materials_PointsMaterial_js__ = __webpack_require__(57);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return __WEBPACK_IMPORTED_MODULE_27_three_src_materials_PointsMaterial_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28_three_src_textures_VideoTexture_js__ = __webpack_require__(246);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return __WEBPACK_IMPORTED_MODULE_28_three_src_textures_VideoTexture_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29_three_src_textures_DataTexture_js__ = __webpack_require__(39);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return __WEBPACK_IMPORTED_MODULE_29_three_src_textures_DataTexture_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__ = __webpack_require__(15);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__["j"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__["i"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return __WEBPACK_IMPORTED_MODULE_30_three_src_core_BufferAttribute_js__["a"]; });






























 // export * from '../../build/Three.js';

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_27", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_3", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return FrontFaceDirectionCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return FrontFaceDirectionCCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_25", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_26", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_63", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_15", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_83", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_14", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_17", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_69", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_8", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_68", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_61", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_5", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_4", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_86", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_20", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_67", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_24", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_65", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_23", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_21", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_22", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_66", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_13", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Q", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_18", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_9", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_7", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_16", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "W", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_59", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_75", function() { return Uncharted2ToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_74", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_64", function() { return SphericalReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_60", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_6", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_10", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_12", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_11", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "V", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "U", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_76", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_62", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_82", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "M", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_78", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "L", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_79", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_80", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_81", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_77", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_52", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_29", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_2", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_1", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_51", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_58", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_46", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_47", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_48", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_57", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_56", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_45", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_44", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_55", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_36", function() { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_37", function() { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_38", function() { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_39", function() { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_40", function() { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_41", function() { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_42", function() { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_43", function() { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_31", function() { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_32", function() { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_33", function() { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_30", function() { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_34", function() { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_35", function() { return RGBA_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_0", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Z", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "N", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "O", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "P", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_85", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_87", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_84", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_73", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_72", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_71", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_88", function() { return sRGBEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_50", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_54", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_53", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_49", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_28", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_70", function() { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_19", function() { return ObjectSpaceNormalMap; });
var REVISION = '96';
var MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Matrix4; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector3_js__ = __webpack_require__(0);

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {
  this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

  if (arguments.length > 0) {
    console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
  }
}

Object.assign(Matrix4.prototype, {
  isMatrix4: true,
  set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    var te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  clone: function () {
    return new Matrix4().fromArray(this.elements);
  },
  copy: function (m) {
    var te = this.elements;
    var me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  },
  copyPosition: function (m) {
    var te = this.elements,
        me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  },
  extractBasis: function (xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  },
  makeBasis: function (xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  },
  extractRotation: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function extractRotation(m) {
      // this method does not support reflection matrices
      var te = this.elements;
      var me = m.elements;
      var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
      var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
      var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    };
  }(),
  makeRotationFromEuler: function (euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }

    var te = this.elements;
    var x = euler.x,
        y = euler.y,
        z = euler.z;
    var a = Math.cos(x),
        b = Math.sin(x);
    var c = Math.cos(y),
        d = Math.sin(y);
    var e = Math.cos(z),
        f = Math.sin(z);

    if (euler.order === 'XYZ') {
      var ae = a * e,
          af = a * f,
          be = b * e,
          bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      var ce = c * e,
          cf = c * f,
          de = d * e,
          df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      var ce = c * e,
          cf = c * f,
          de = d * e,
          df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      var ae = a * e,
          af = a * f,
          be = b * e,
          bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      var ac = a * c,
          ad = a * d,
          bc = b * c,
          bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      var ac = a * c,
          ad = a * d,
          bc = b * c,
          bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    } // bottom row


    te[3] = 0;
    te[7] = 0;
    te[11] = 0; // last column

    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  makeRotationFromQuaternion: function () {
    var zero = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](0, 0, 0);
    var one = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](1, 1, 1);
    return function makeRotationFromQuaternion(q) {
      return this.compose(zero, q, one);
    };
  }(),
  lookAt: function () {
    var x = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var y = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var z = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function lookAt(eye, target, up) {
      var te = this.elements;
      z.subVectors(eye, target);

      if (z.lengthSq() === 0) {
        // eye and target are in the same position
        z.z = 1;
      }

      z.normalize();
      x.crossVectors(up, z);

      if (x.lengthSq() === 0) {
        // up and z are parallel
        if (Math.abs(up.z) === 1) {
          z.x += 0.0001;
        } else {
          z.z += 0.0001;
        }

        z.normalize();
        x.crossVectors(up, z);
      }

      x.normalize();
      y.crossVectors(z, x);
      te[0] = x.x;
      te[4] = y.x;
      te[8] = z.x;
      te[1] = x.y;
      te[5] = y.y;
      te[9] = z.y;
      te[2] = x.z;
      te[6] = y.z;
      te[10] = z.z;
      return this;
    };
  }(),
  multiply: function (m, n) {
    if (n !== undefined) {
      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }

    return this.multiplyMatrices(this, m);
  },
  premultiply: function (m) {
    return this.multiplyMatrices(m, this);
  },
  multiplyMatrices: function (a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0],
        a12 = ae[4],
        a13 = ae[8],
        a14 = ae[12];
    var a21 = ae[1],
        a22 = ae[5],
        a23 = ae[9],
        a24 = ae[13];
    var a31 = ae[2],
        a32 = ae[6],
        a33 = ae[10],
        a34 = ae[14];
    var a41 = ae[3],
        a42 = ae[7],
        a43 = ae[11],
        a44 = ae[15];
    var b11 = be[0],
        b12 = be[4],
        b13 = be[8],
        b14 = be[12];
    var b21 = be[1],
        b22 = be[5],
        b23 = be[9],
        b24 = be[13];
    var b31 = be[2],
        b32 = be[6],
        b33 = be[10],
        b34 = be[14];
    var b41 = be[3],
        b42 = be[7],
        b43 = be[11],
        b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  },
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  },
  applyToBufferAttribute: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function applyToBufferAttribute(attribute) {
      for (var i = 0, l = attribute.count; i < l; i++) {
        v1.x = attribute.getX(i);
        v1.y = attribute.getY(i);
        v1.z = attribute.getZ(i);
        v1.applyMatrix4(this);
        attribute.setXYZ(i, v1.x, v1.y, v1.z);
      }

      return attribute;
    };
  }(),
  determinant: function () {
    var te = this.elements;
    var n11 = te[0],
        n12 = te[4],
        n13 = te[8],
        n14 = te[12];
    var n21 = te[1],
        n22 = te[5],
        n23 = te[9],
        n24 = te[13];
    var n31 = te[2],
        n32 = te[6],
        n33 = te[10],
        n34 = te[14];
    var n41 = te[3],
        n42 = te[7],
        n43 = te[11],
        n44 = te[15]; //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  transpose: function () {
    var te = this.elements;
    var tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  },
  setPosition: function (v) {
    var te = this.elements;
    te[12] = v.x;
    te[13] = v.y;
    te[14] = v.z;
    return this;
  },
  getInverse: function (m, throwOnDegenerate) {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    var te = this.elements,
        me = m.elements,
        n11 = me[0],
        n21 = me[1],
        n31 = me[2],
        n41 = me[3],
        n12 = me[4],
        n22 = me[5],
        n32 = me[6],
        n42 = me[7],
        n13 = me[8],
        n23 = me[9],
        n33 = me[10],
        n43 = me[11],
        n14 = me[12],
        n24 = me[13],
        n34 = me[14],
        n44 = me[15],
        t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
        t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
        t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
        t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    if (det === 0) {
      var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }

      return this.identity();
    }

    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  },
  scale: function (v) {
    var te = this.elements;
    var x = v.x,
        y = v.y,
        z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  },
  getMaxScaleOnAxis: function () {
    var te = this.elements;
    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  },
  makeTranslation: function (x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function (theta) {
    var c = Math.cos(theta),
        s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function (theta) {
    var c = Math.cos(theta),
        s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function (theta) {
    var c = Math.cos(theta),
        s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function (axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = 1 - c;
    var x = axis.x,
        y = axis.y,
        z = axis.z;
    var tx = t * x,
        ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function (x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  },
  makeShear: function (x, y, z) {
    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function (position, quaternion, scale) {
    var te = this.elements;
    var x = quaternion._x,
        y = quaternion._y,
        z = quaternion._z,
        w = quaternion._w;
    var x2 = x + x,
        y2 = y + y,
        z2 = z + z;
    var xx = x * x2,
        xy = x * y2,
        xz = x * z2;
    var yy = y * y2,
        yz = y * z2,
        zz = z * z2;
    var wx = w * x2,
        wy = w * y2,
        wz = w * z2;
    var sx = scale.x,
        sy = scale.y,
        sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  },
  decompose: function () {
    var vector = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var matrix = new Matrix4();
    return function decompose(position, quaternion, scale) {
      var te = this.elements;
      var sx = vector.set(te[0], te[1], te[2]).length();
      var sy = vector.set(te[4], te[5], te[6]).length();
      var sz = vector.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale

      var det = this.determinant();
      if (det < 0) sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14]; // scale the rotation part

      matrix.copy(this);
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      matrix.elements[0] *= invSX;
      matrix.elements[1] *= invSX;
      matrix.elements[2] *= invSX;
      matrix.elements[4] *= invSY;
      matrix.elements[5] *= invSY;
      matrix.elements[6] *= invSY;
      matrix.elements[8] *= invSZ;
      matrix.elements[9] *= invSZ;
      matrix.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(matrix);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    };
  }(),
  makePerspective: function (left, right, top, bottom, near, far) {
    if (far === undefined) {
      console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
    }

    var te = this.elements;
    var x = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);
    var a = (right + left) / (right - left);
    var b = (top + bottom) / (top - bottom);
    var c = -(far + near) / (far - near);
    var d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  },
  makeOrthographic: function (left, right, top, bottom, near, far) {
    var te = this.elements;
    var w = 1.0 / (right - left);
    var h = 1.0 / (top - bottom);
    var p = 1.0 / (far - near);
    var x = (right + left) * w;
    var y = (top + bottom) * h;
    var z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  },
  equals: function (matrix) {
    var te = this.elements;
    var me = matrix.elements;

    for (var i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;

    for (var i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
});


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Object3D; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Quaternion_js__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__EventDispatcher_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Euler_js__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Layers_js__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Matrix3_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Math_js__ = __webpack_require__(6);








/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

var object3DId = 0;

function Object3D() {
  Object.defineProperty(this, 'id', {
    value: object3DId++
  });
  this.uuid = __WEBPACK_IMPORTED_MODULE_7__math_Math_js__["a" /* _Math */].generateUUID();
  this.name = '';
  this.type = 'Object3D';
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  var position = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
  var rotation = new __WEBPACK_IMPORTED_MODULE_4__math_Euler_js__["a" /* Euler */]();
  var quaternion = new __WEBPACK_IMPORTED_MODULE_0__math_Quaternion_js__["a" /* Quaternion */]();
  var scale = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */](1, 1, 1);

  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }

  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, undefined, false);
  }

  rotation.onChange(onRotationChange);
  quaternion.onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      enumerable: true,
      value: position
    },
    rotation: {
      enumerable: true,
      value: rotation
    },
    quaternion: {
      enumerable: true,
      value: quaternion
    },
    scale: {
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__["a" /* Matrix4 */]()
    },
    normalMatrix: {
      value: new __WEBPACK_IMPORTED_MODULE_6__math_Matrix3_js__["a" /* Matrix3 */]()
    }
  });
  this.matrix = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__["a" /* Matrix4 */]();
  this.matrixWorld = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__["a" /* Matrix4 */]();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new __WEBPACK_IMPORTED_MODULE_5__Layers_js__["a" /* Layers */]();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.userData = {};
}

Object3D.DefaultUp = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */](0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_3__EventDispatcher_js__["a" /* EventDispatcher */].prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function () {},
  onAfterRender: function () {},
  applyMatrix: function (matrix) {
    this.matrix.multiplyMatrices(matrix, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function (q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function (axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function (euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function (m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function (q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  },
  rotateOnAxis: function () {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    var q1 = new __WEBPACK_IMPORTED_MODULE_0__math_Quaternion_js__["a" /* Quaternion */]();
    return function rotateOnAxis(axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(q1);
      return this;
    };
  }(),
  rotateOnWorldAxis: function () {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    var q1 = new __WEBPACK_IMPORTED_MODULE_0__math_Quaternion_js__["a" /* Quaternion */]();
    return function rotateOnWorldAxis(axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(q1);
      return this;
    };
  }(),
  rotateX: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */](1, 0, 0);
    return function rotateX(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateY: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */](0, 1, 0);
    return function rotateY(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateZ: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */](0, 0, 1);
    return function rotateZ(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  translateOnAxis: function () {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
    return function translateOnAxis(axis, distance) {
      v1.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(v1.multiplyScalar(distance));
      return this;
    };
  }(),
  translateX: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */](1, 0, 0);
    return function translateX(distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateY: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */](0, 1, 0);
    return function translateY(distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateZ: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */](0, 0, 1);
    return function translateZ(distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  localToWorld: function (vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function () {
    var m1 = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__["a" /* Matrix4 */]();
    return function worldToLocal(vector) {
      return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function () {
    // This method does not support objects having non-uniformly-scaled parent(s)
    var q1 = new __WEBPACK_IMPORTED_MODULE_0__math_Quaternion_js__["a" /* Quaternion */]();
    var m1 = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__["a" /* Matrix4 */]();
    var target = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
    var position = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
    return function lookAt(x, y, z) {
      if (x.isVector3) {
        target.copy(x);
      } else {
        target.set(x, y, z);
      }

      var parent = this.parent;
      this.updateWorldMatrix(true, false);
      position.setFromMatrixPosition(this.matrixWorld);

      if (this.isCamera) {
        m1.lookAt(position, target, this.up);
      } else {
        m1.lookAt(target, position, this.up);
      }

      this.quaternion.setFromRotationMatrix(m1);

      if (parent) {
        m1.extractRotation(parent.matrixWorld);
        q1.setFromRotationMatrix(m1);
        this.quaternion.premultiply(q1.inverse());
      }
    };
  }(),
  add: function (object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      object.dispatchEvent({
        type: 'added'
      });
      this.children.push(object);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }

    return this;
  },
  remove: function (object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    var index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      object.dispatchEvent({
        type: 'removed'
      });
      this.children.splice(index, 1);
    }

    return this;
  },
  getObjectById: function (id) {
    return this.getObjectByProperty('id', id);
  },
  getObjectByName: function (name) {
    return this.getObjectByProperty('name', name);
  },
  getObjectByProperty: function (name, value) {
    if (this[name] === value) return this;

    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      var object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  },
  getWorldPosition: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldPosition() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
    }

    this.updateMatrixWorld(true);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function () {
    var position = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
    var scale = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
    return function getWorldQuaternion(target) {
      if (target === undefined) {
        console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
        target = new __WEBPACK_IMPORTED_MODULE_0__math_Quaternion_js__["a" /* Quaternion */]();
      }

      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, target, scale);
      return target;
    };
  }(),
  getWorldScale: function () {
    var position = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
    var quaternion = new __WEBPACK_IMPORTED_MODULE_0__math_Quaternion_js__["a" /* Quaternion */]();
    return function getWorldScale(target) {
      if (target === undefined) {
        console.warn('THREE.Object3D: .getWorldScale() target is now required');
        target = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
      }

      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, quaternion, target);
      return target;
    };
  }(),
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldDirection() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
    }

    this.updateMatrixWorld(true);
    var e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function () {},
  traverse: function (callback) {
    callback(this);
    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function (callback) {
    if (this.visible === false) return;
    callback(this);
    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function (callback) {
    var parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function (force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function (updateParents, updateChildren) {
    var parent = this.parent;

    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      var children = this.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function (meta) {
    // meta is a string when called from JSON.stringify
    var isRootObject = meta === undefined || typeof meta === 'string';
    var output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      };
      output.metadata = {
        version: 4.5,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    var object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; //

    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      var parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        var shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (var i = 0, l = shapes.length; i < l; i++) {
            var shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        var uuids = [];

        for (var i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (var i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }

    if (isRootObject) {
      var geometries = extractFromCache(meta.geometries);
      var materials = extractFromCache(meta.materials);
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      var shapes = extractFromCache(meta.shapes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      var values = [];

      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  },
  clone: function (recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function (source, recursive) {
    if (recursive === undefined) recursive = true;
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (var i = 0; i < source.children.length; i++) {
        var child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  }
});


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _Math; });
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */
var _Math = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function () {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
    var lut = [];

    for (var i = 0; i < 256; i++) {
      lut[i] = (i < 16 ? '0' : '') + i.toString(16);
    }

    return function generateUUID() {
      var d0 = Math.random() * 0xffffffff | 0;
      var d1 = Math.random() * 0xffffffff | 0;
      var d2 = Math.random() * 0xffffffff | 0;
      var d3 = Math.random() * 0xffffffff | 0;
      var uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

      return uuid.toUpperCase();
    };
  }(),
  clamp: function (value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function (n, m) {
    return (n % m + m) % m;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function (x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function (x, y, t) {
    return (1 - t) * x + t * y;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  // Random integer from <low, high> interval
  randInt: function (low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  // Random float from <low, high> interval
  randFloat: function (low, high) {
    return low + Math.random() * (high - low);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function (range) {
    return range * (0.5 - Math.random());
  },
  degToRad: function (degrees) {
    return degrees * _Math.DEG2RAD;
  },
  radToDeg: function (radians) {
    return radians * _Math.RAD2DEG;
  },
  isPowerOfTwo: function (value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function (value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function (value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
};


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Color; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Math_js__ = __webpack_require__(6);

/**
 * @author mrdoob / http://mrdoob.com/
 */

var ColorKeywords = {
  'aliceblue': 0xF0F8FF,
  'antiquewhite': 0xFAEBD7,
  'aqua': 0x00FFFF,
  'aquamarine': 0x7FFFD4,
  'azure': 0xF0FFFF,
  'beige': 0xF5F5DC,
  'bisque': 0xFFE4C4,
  'black': 0x000000,
  'blanchedalmond': 0xFFEBCD,
  'blue': 0x0000FF,
  'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A,
  'burlywood': 0xDEB887,
  'cadetblue': 0x5F9EA0,
  'chartreuse': 0x7FFF00,
  'chocolate': 0xD2691E,
  'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED,
  'cornsilk': 0xFFF8DC,
  'crimson': 0xDC143C,
  'cyan': 0x00FFFF,
  'darkblue': 0x00008B,
  'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B,
  'darkgray': 0xA9A9A9,
  'darkgreen': 0x006400,
  'darkgrey': 0xA9A9A9,
  'darkkhaki': 0xBDB76B,
  'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F,
  'darkorange': 0xFF8C00,
  'darkorchid': 0x9932CC,
  'darkred': 0x8B0000,
  'darksalmon': 0xE9967A,
  'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B,
  'darkslategray': 0x2F4F4F,
  'darkslategrey': 0x2F4F4F,
  'darkturquoise': 0x00CED1,
  'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493,
  'deepskyblue': 0x00BFFF,
  'dimgray': 0x696969,
  'dimgrey': 0x696969,
  'dodgerblue': 0x1E90FF,
  'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0,
  'forestgreen': 0x228B22,
  'fuchsia': 0xFF00FF,
  'gainsboro': 0xDCDCDC,
  'ghostwhite': 0xF8F8FF,
  'gold': 0xFFD700,
  'goldenrod': 0xDAA520,
  'gray': 0x808080,
  'green': 0x008000,
  'greenyellow': 0xADFF2F,
  'grey': 0x808080,
  'honeydew': 0xF0FFF0,
  'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C,
  'indigo': 0x4B0082,
  'ivory': 0xFFFFF0,
  'khaki': 0xF0E68C,
  'lavender': 0xE6E6FA,
  'lavenderblush': 0xFFF0F5,
  'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD,
  'lightblue': 0xADD8E6,
  'lightcoral': 0xF08080,
  'lightcyan': 0xE0FFFF,
  'lightgoldenrodyellow': 0xFAFAD2,
  'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90,
  'lightgrey': 0xD3D3D3,
  'lightpink': 0xFFB6C1,
  'lightsalmon': 0xFFA07A,
  'lightseagreen': 0x20B2AA,
  'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899,
  'lightslategrey': 0x778899,
  'lightsteelblue': 0xB0C4DE,
  'lightyellow': 0xFFFFE0,
  'lime': 0x00FF00,
  'limegreen': 0x32CD32,
  'linen': 0xFAF0E6,
  'magenta': 0xFF00FF,
  'maroon': 0x800000,
  'mediumaquamarine': 0x66CDAA,
  'mediumblue': 0x0000CD,
  'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB,
  'mediumseagreen': 0x3CB371,
  'mediumslateblue': 0x7B68EE,
  'mediumspringgreen': 0x00FA9A,
  'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585,
  'midnightblue': 0x191970,
  'mintcream': 0xF5FFFA,
  'mistyrose': 0xFFE4E1,
  'moccasin': 0xFFE4B5,
  'navajowhite': 0xFFDEAD,
  'navy': 0x000080,
  'oldlace': 0xFDF5E6,
  'olive': 0x808000,
  'olivedrab': 0x6B8E23,
  'orange': 0xFFA500,
  'orangered': 0xFF4500,
  'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA,
  'palegreen': 0x98FB98,
  'paleturquoise': 0xAFEEEE,
  'palevioletred': 0xDB7093,
  'papayawhip': 0xFFEFD5,
  'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F,
  'pink': 0xFFC0CB,
  'plum': 0xDDA0DD,
  'powderblue': 0xB0E0E6,
  'purple': 0x800080,
  'rebeccapurple': 0x663399,
  'red': 0xFF0000,
  'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1,
  'saddlebrown': 0x8B4513,
  'salmon': 0xFA8072,
  'sandybrown': 0xF4A460,
  'seagreen': 0x2E8B57,
  'seashell': 0xFFF5EE,
  'sienna': 0xA0522D,
  'silver': 0xC0C0C0,
  'skyblue': 0x87CEEB,
  'slateblue': 0x6A5ACD,
  'slategray': 0x708090,
  'slategrey': 0x708090,
  'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F,
  'steelblue': 0x4682B4,
  'tan': 0xD2B48C,
  'teal': 0x008080,
  'thistle': 0xD8BFD8,
  'tomato': 0xFF6347,
  'turquoise': 0x40E0D0,
  'violet': 0xEE82EE,
  'wheat': 0xF5DEB3,
  'white': 0xFFFFFF,
  'whitesmoke': 0xF5F5F5,
  'yellow': 0xFFFF00,
  'yellowgreen': 0x9ACD32
};

function Color(r, g, b) {
  if (g === undefined && b === undefined) {
    // r is THREE.Color, hex or string
    return this.set(r);
  }

  return this.setRGB(r, g, b);
}

Object.assign(Color.prototype, {
  isColor: true,
  r: 1,
  g: 1,
  b: 1,
  set: function (value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === 'number') {
      this.setHex(value);
    } else if (typeof value === 'string') {
      this.setStyle(value);
    }

    return this;
  },
  setScalar: function (scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  },
  setHex: function (hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  },
  setRGB: function (r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  },
  setHSL: function () {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
      return p;
    }

    return function setHSL(h, s, l) {
      // h,s,l ranges are in 0.0 - 1.0
      h = __WEBPACK_IMPORTED_MODULE_0__Math_js__["a" /* _Math */].euclideanModulo(h, 1);
      s = __WEBPACK_IMPORTED_MODULE_0__Math_js__["a" /* _Math */].clamp(s, 0, 1);
      l = __WEBPACK_IMPORTED_MODULE_0__Math_js__["a" /* _Math */].clamp(l, 0, 1);

      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }

      return this;
    };
  }(),
  setStyle: function (style) {
    function handleAlpha(string) {
      if (string === undefined) return;

      if (parseFloat(string) < 1) {
        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
      }
    }

    var m;

    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
      // rgb / hsl
      var color;
      var name = m[1];
      var components = m[2];

      switch (name) {
        case 'rgb':
        case 'rgba':
          if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // rgb(255,0,0) rgba(255,0,0,0.5)
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[5]);
            return this;
          }

          if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[5]);
            return this;
          }

          break;

        case 'hsl':
        case 'hsla':
          if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
            var h = parseFloat(color[1]) / 360;
            var s = parseInt(color[2], 10) / 100;
            var l = parseInt(color[3], 10) / 100;
            handleAlpha(color[5]);
            return this.setHSL(h, s, l);
          }

          break;
      }
    } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
      // hex color
      var hex = m[1];
      var size = hex.length;

      if (size === 3) {
        // #ff0
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        // #ff0000
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }

    if (style && style.length > 0) {
      // color keywords
      var hex = ColorKeywords[style];

      if (hex !== undefined) {
        // red
        this.setHex(hex);
      } else {
        // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
      }
    }

    return this;
  },
  clone: function () {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function (color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  },
  copyGammaToLinear: function (color, gammaFactor) {
    if (gammaFactor === undefined) gammaFactor = 2.0;
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  },
  copyLinearToGamma: function (color, gammaFactor) {
    if (gammaFactor === undefined) gammaFactor = 2.0;
    var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  },
  convertGammaToLinear: function (gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  },
  convertLinearToGamma: function (gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  },
  copySRGBToLinear: function () {
    function SRGBToLinear(c) {
      return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
    }

    return function copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    };
  }(),
  copyLinearToSRGB: function () {
    function LinearToSRGB(c) {
      return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
    }

    return function copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    };
  }(),
  convertSRGBToLinear: function () {
    this.copySRGBToLinear(this);
    return this;
  },
  convertLinearToSRGB: function () {
    this.copyLinearToSRGB(this);
    return this;
  },
  getHex: function () {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function () {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function (target) {
    // h,s,l ranges are in 0.0 - 1.0
    if (target === undefined) {
      console.warn('THREE.Color: .getHSL() target is now required');
      target = {
        h: 0,
        s: 0,
        l: 0
      };
    }

    var r = this.r,
        g = this.g,
        b = this.b;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var hue, saturation;
    var lightness = (min + max) / 2.0;

    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      var delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;

        case g:
          hue = (b - r) / delta + 2;
          break;

        case b:
          hue = (r - g) / delta + 4;
          break;
      }

      hue /= 6;
    }

    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  },
  getStyle: function () {
    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  },
  offsetHSL: function () {
    var hsl = {};
    return function (h, s, l) {
      this.getHSL(hsl);
      hsl.h += h;
      hsl.s += s;
      hsl.l += l;
      this.setHSL(hsl.h, hsl.s, hsl.l);
      return this;
    };
  }(),
  add: function (color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  },
  addColors: function (color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  },
  addScalar: function (s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  },
  sub: function (color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  },
  multiply: function (color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  },
  multiplyScalar: function (s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  },
  lerp: function (color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  },
  lerpHSL: function () {
    var hslA = {
      h: 0,
      s: 0,
      l: 0
    };
    var hslB = {
      h: 0,
      s: 0,
      l: 0
    };
    return function lerpHSL(color, alpha) {
      this.getHSL(hslA);
      color.getHSL(hslB);

      var h = __WEBPACK_IMPORTED_MODULE_0__Math_js__["a" /* _Math */].lerp(hslA.h, hslB.h, alpha);

      var s = __WEBPACK_IMPORTED_MODULE_0__Math_js__["a" /* _Math */].lerp(hslA.s, hslB.s, alpha);

      var l = __WEBPACK_IMPORTED_MODULE_0__Math_js__["a" /* _Math */].lerp(hslA.l, hslB.l, alpha);

      this.setHSL(h, s, l);
      return this;
    };
  }(),
  equals: function (c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  },
  toJSON: function () {
    return this.getHex();
  }
});


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Vector2; });
/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */
function Vector2(x, y) {
  this.x = x || 0;
  this.y = y || 0;
}

Object.defineProperties(Vector2.prototype, {
  "width": {
    get: function () {
      return this.x;
    },
    set: function (value) {
      this.x = value;
    }
  },
  "height": {
    get: function () {
      return this.y;
    },
    set: function (value) {
      this.y = value;
    }
  }
});
Object.assign(Vector2.prototype, {
  isVector2: true,
  set: function (x, y) {
    this.x = x;
    this.y = y;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiply: function (v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  applyMatrix3: function (m) {
    var x = this.x,
        y = this.y;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  },
  clampScalar: function () {
    var min = new Vector2();
    var max = new Vector2();
    return function clampScalar(minVal, maxVal) {
      min.set(minVal, minVal);
      max.set(maxVal, maxVal);
      return this.clamp(min, max);
    };
  }(),
  clampLength: function (min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y;
  },
  cross: function (v) {
    return this.x * v.y - this.y * v.x;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  angle: function () {
    // computes the angle in radians with respect to the positive x-axis
    var angle = Math.atan2(this.y, this.x);
    if (angle < 0) angle += 2 * Math.PI;
    return angle;
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x,
        dy = this.y - v.y;
    return dx * dx + dy * dy;
  },
  manhattanDistanceTo: function (v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  },
  rotateAround: function (center, angle) {
    var c = Math.cos(angle),
        s = Math.sin(angle);
    var x = this.x - center.x;
    var y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
});


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Matrix3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector3_js__ = __webpack_require__(0);

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3() {
  this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

  if (arguments.length > 0) {
    console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
  }
}

Object.assign(Matrix3.prototype, {
  isMatrix3: true,
  set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    var te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  clone: function () {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function (m) {
    var te = this.elements;
    var me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  },
  setFromMatrix4: function (m) {
    var me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  },
  applyToBufferAttribute: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function applyToBufferAttribute(attribute) {
      for (var i = 0, l = attribute.count; i < l; i++) {
        v1.x = attribute.getX(i);
        v1.y = attribute.getY(i);
        v1.z = attribute.getZ(i);
        v1.applyMatrix3(this);
        attribute.setXYZ(i, v1.x, v1.y, v1.z);
      }

      return attribute;
    };
  }(),
  multiply: function (m) {
    return this.multiplyMatrices(this, m);
  },
  premultiply: function (m) {
    return this.multiplyMatrices(m, this);
  },
  multiplyMatrices: function (a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0],
        a12 = ae[3],
        a13 = ae[6];
    var a21 = ae[1],
        a22 = ae[4],
        a23 = ae[7];
    var a31 = ae[2],
        a32 = ae[5],
        a33 = ae[8];
    var b11 = be[0],
        b12 = be[3],
        b13 = be[6];
    var b21 = be[1],
        b22 = be[4],
        b23 = be[7];
    var b31 = be[2],
        b32 = be[5],
        b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  },
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  },
  determinant: function () {
    var te = this.elements;
    var a = te[0],
        b = te[1],
        c = te[2],
        d = te[3],
        e = te[4],
        f = te[5],
        g = te[6],
        h = te[7],
        i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  },
  getInverse: function (matrix, throwOnDegenerate) {
    if (matrix && matrix.isMatrix4) {
      console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
    }

    var me = matrix.elements,
        te = this.elements,
        n11 = me[0],
        n21 = me[1],
        n31 = me[2],
        n12 = me[3],
        n22 = me[4],
        n32 = me[5],
        n13 = me[6],
        n23 = me[7],
        n33 = me[8],
        t11 = n33 * n22 - n32 * n23,
        t12 = n32 * n13 - n33 * n12,
        t13 = n23 * n12 - n22 * n13,
        det = n11 * t11 + n21 * t12 + n31 * t13;

    if (det === 0) {
      var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }

      return this.identity();
    }

    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  },
  transpose: function () {
    var tmp,
        m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  },
  getNormalMatrix: function (matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  },
  transposeIntoArray: function (r) {
    var m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  },
  setUvTransform: function (tx, ty, sx, sy, rotation, cx, cy) {
    var c = Math.cos(rotation);
    var s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
  },
  scale: function (sx, sy) {
    var te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  },
  rotate: function (theta) {
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var te = this.elements;
    var a11 = te[0],
        a12 = te[3],
        a13 = te[6];
    var a21 = te[1],
        a22 = te[4],
        a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  },
  translate: function (tx, ty) {
    var te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  },
  equals: function (matrix) {
    var te = this.elements;
    var me = matrix.elements;

    for (var i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;

    for (var i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
});


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Texture; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_EventDispatcher_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Math_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Matrix3_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__extras_ImageUtils_js__ = __webpack_require__(85);
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */







var textureId = 0;

function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  Object.defineProperty(this, 'id', {
    value: textureId++
  });
  this.uuid = __WEBPACK_IMPORTED_MODULE_2__math_Math_js__["a" /* _Math */].generateUUID();
  this.name = '';
  this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
  this.wrapS = wrapS !== undefined ? wrapS : __WEBPACK_IMPORTED_MODULE_1__constants_js__["k" /* ClampToEdgeWrapping */];
  this.wrapT = wrapT !== undefined ? wrapT : __WEBPACK_IMPORTED_MODULE_1__constants_js__["k" /* ClampToEdgeWrapping */];
  this.magFilter = magFilter !== undefined ? magFilter : __WEBPACK_IMPORTED_MODULE_1__constants_js__["T" /* LinearFilter */];
  this.minFilter = minFilter !== undefined ? minFilter : __WEBPACK_IMPORTED_MODULE_1__constants_js__["U" /* LinearMipMapLinearFilter */];
  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
  this.format = format !== undefined ? format : __WEBPACK_IMPORTED_MODULE_1__constants_js__["_29" /* RGBAFormat */];
  this.type = type !== undefined ? type : __WEBPACK_IMPORTED_MODULE_1__constants_js__["_76" /* UnsignedByteType */];
  this.offset = new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */](0, 0);
  this.repeat = new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */](1, 1);
  this.center = new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */](0, 0);
  this.rotation = 0;
  this.matrixAutoUpdate = true;
  this.matrix = new __WEBPACK_IMPORTED_MODULE_4__math_Matrix3_js__["a" /* Matrix3 */]();
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.

  this.encoding = encoding !== undefined ? encoding : __WEBPACK_IMPORTED_MODULE_1__constants_js__["S" /* LinearEncoding */];
  this.version = 0;
  this.onUpdate = null;
}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = __WEBPACK_IMPORTED_MODULE_1__constants_js__["_74" /* UVMapping */];
Texture.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__core_EventDispatcher_js__["a" /* EventDispatcher */].prototype), {
  constructor: Texture,
  isTexture: true,
  updateMatrix: function () {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  },
  toJSON: function (meta) {
    var isRootObject = meta === undefined || typeof meta === 'string';

    if (!isRootObject && meta.textures[this.uuid] !== undefined) {
      return meta.textures[this.uuid];
    }

    var output = {
      metadata: {
        version: 4.5,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY
    };

    if (this.image !== undefined) {
      // TODO: Move to THREE.Image
      var image = this.image;

      if (image.uuid === undefined) {
        image.uuid = __WEBPACK_IMPORTED_MODULE_2__math_Math_js__["a" /* _Math */].generateUUID(); // UGH
      }

      if (!isRootObject && meta.images[image.uuid] === undefined) {
        var url;

        if (Array.isArray(image)) {
          // process array of images e.g. CubeTexture
          url = [];

          for (var i = 0, l = image.length; i < l; i++) {
            url.push(__WEBPACK_IMPORTED_MODULE_5__extras_ImageUtils_js__["a" /* ImageUtils */].getDataURL(image[i]));
          }
        } else {
          // process single image
          url = __WEBPACK_IMPORTED_MODULE_5__extras_ImageUtils_js__["a" /* ImageUtils */].getDataURL(image);
        }

        meta.images[image.uuid] = {
          uuid: image.uuid,
          url: url
        };
      }

      output.image = image.uuid;
    }

    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }

    return output;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  },
  transformUv: function (uv) {
    if (this.mapping !== __WEBPACK_IMPORTED_MODULE_1__constants_js__["_74" /* UVMapping */]) return uv;
    uv.applyMatrix3(this.matrix);

    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case __WEBPACK_IMPORTED_MODULE_1__constants_js__["_60" /* RepeatWrapping */]:
          uv.x = uv.x - Math.floor(uv.x);
          break;

        case __WEBPACK_IMPORTED_MODULE_1__constants_js__["k" /* ClampToEdgeWrapping */]:
          uv.x = uv.x < 0 ? 0 : 1;
          break;

        case __WEBPACK_IMPORTED_MODULE_1__constants_js__["_6" /* MirroredRepeatWrapping */]:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }

          break;
      }
    }

    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case __WEBPACK_IMPORTED_MODULE_1__constants_js__["_60" /* RepeatWrapping */]:
          uv.y = uv.y - Math.floor(uv.y);
          break;

        case __WEBPACK_IMPORTED_MODULE_1__constants_js__["k" /* ClampToEdgeWrapping */]:
          uv.y = uv.y < 0 ? 0 : 1;
          break;

        case __WEBPACK_IMPORTED_MODULE_1__constants_js__["_6" /* MirroredRepeatWrapping */]:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }

          break;
      }
    }

    if (this.flipY) {
      uv.y = 1 - uv.y;
    }

    return uv;
  }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
  set: function (value) {
    if (value === true) this.version++;
  }
});


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Vector4; });
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */
function Vector4(x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w !== undefined ? w : 1;
}

Object.assign(Vector4.prototype, {
  isVector4: true,
  set: function (x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setW: function (w) {
    this.w = w;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      case 3:
        this.w = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      case 3:
        return this.w;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x,
        y = this.y,
        z = this.z,
        w = this.w;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  setAxisAngleFromQuaternion: function (q) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
    // q is assumed to be normalized
    this.w = 2 * Math.acos(q.w);
    var s = Math.sqrt(1 - q.w * q.w);

    if (s < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }

    return this;
  },
  setAxisAngleFromRotationMatrix: function (m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    var angle,
        x,
        y,
        z,
        // variables for result
    epsilon = 0.01,
        // margin to allow for rounding errors
    epsilon2 = 0.1,
        // margin to distinguish between 0 and 180 degrees
    te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10];

    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        // this singularity is identity matrix so angle = 0
        this.set(1, 0, 0, 0);
        return this; // zero angle, arbitrary axis
      } // otherwise this singularity is angle = 180


      angle = Math.PI;
      var xx = (m11 + 1) / 2;
      var yy = (m22 + 1) / 2;
      var zz = (m33 + 1) / 2;
      var xy = (m12 + m21) / 4;
      var xz = (m13 + m31) / 4;
      var yz = (m23 + m32) / 4;

      if (xx > yy && xx > zz) {
        // m11 is the largest diagonal term
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        // m22 is the largest diagonal term
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        // m33 is the largest diagonal term so base result on this
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }

      this.set(x, y, z, angle);
      return this; // return 180 deg rotation
    } // as we have reached here there are no singularities so we can handle normally


    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

    if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  },
  clampScalar: function () {
    var min, max;
    return function clampScalar(minVal, maxVal) {
      if (min === undefined) {
        min = new Vector4();
        max = new Vector4();
      }

      min.set(minVal, minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal, maxVal);
      return this.clamp(min, max);
    };
  }(),
  clampLength: function (min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
});


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileOverview the Attribute base class
 * @author huangtonger@aliyun.com
 */
var ColorUtil = __webpack_require__(35);

var Util = __webpack_require__(1);

function toScaleString(scale, value) {
  if (Util.isString(value)) {
    return value;
  }

  return scale.invert(scale.scale(value));
}
/**
 * 所有视觉通道属性的基类
 * @class Attr
 */


var AttributeBase =
/*#__PURE__*/
function () {
  function AttributeBase(cfg) {
    _classCallCheck(this, AttributeBase);

    /**
     * 属性的类型
     * @type {String}
     */
    this.type = 'base';
    /**
     * 属性的名称
     * @type {String}
     */

    this.name = null;
    /**
     * 回调函数
     * @type {Function}
     */

    this.method = null;
    /**
     * 备选的值数组
     * @type {Array}
     */

    this.values = [];
    /**
     * 属性内部的度量
     * @type {Array}
     */

    this.scales = [];
    /**
     * 是否通过线性取值, 如果未指定，则根据数值的类型判定
     * @type {Boolean}
     */

    this.linear = null;
    Util.mix(this, cfg);
  }

  _createClass(AttributeBase, [{
    key: "get",
    value: function get(name) {
      return this[name];
    }
  }, {
    key: "set",
    value: function set(name, value) {
      this[name] = value;
    } // 获取属性值，将值映射到视觉通道

  }, {
    key: "_getAttrValue",
    value: function _getAttrValue(scale, value) {
      var values = this.values;

      if (scale.isCategory && !this.linear) {
        var index = scale.translate(value);
        return values[index % values.length];
      }

      var percent = scale.scale(value);
      return this.getLinearValue(percent);
    }
    /**
     * 如果进行线性映射，返回对应的映射值
     * @protected
     * @param  {Number} percent 百分比
     * @return {*}  颜色值、形状、大小等
     */

  }, {
    key: "getLinearValue",
    value: function getLinearValue(percent) {
      var values = this.values;
      var steps = values.length - 1;
      var step = Math.floor(steps * percent);
      var leftPercent = steps * percent - step;
      var start = values[step];
      var end = step === steps ? start : values[step + 1];
      var rstValue = start + (end - start) * leftPercent;
      return rstValue;
    }
    /**
     * 默认的回调函数
     * @param {*} value 回调函数的值
     * @type {Function}
     * @return {Array} 返回映射后的值
     */

  }, {
    key: "callback",
    value: function callback(value) {
      var self = this;
      var scale = self.scales[0];
      var rstValue = null;

      if (scale.type === 'identity') {
        rstValue = scale.value;
      } else {
        rstValue = self._getAttrValue(scale, value);
      }

      return rstValue;
    }
    /**
     * 根据度量获取属性名
     * @return {Array} dims of this Attribute
     */

  }, {
    key: "getNames",
    value: function getNames() {
      var scales = this.scales;
      var names = this.names;
      var length = Math.min(scales.length, names.length);
      var rst = [];

      for (var i = 0; i < length; i++) {
        rst.push(names[i]);
      }

      return rst;
    }
    /**
     * 根据度量获取维度名
     * @return {Array} dims of this Attribute
     */

  }, {
    key: "getFields",
    value: function getFields() {
      var scales = this.scales;
      var rst = [];
      Util.each(scales, function (scale) {
        rst.push(scale.field);
      });
      return rst;
    }
    /**
     * 根据名称获取度量
     * @param  {String} name the name of scale
     * @return {Scale} scale
     */

  }, {
    key: "getScale",
    value: function getScale(name) {
      var scales = this.scales;
      var names = this.names;
      var index = names.indexOf(name);
      return scales[index];
    }
    /**
     * 映射数据
     * @param {*} param1...paramn 多个数值
     * @return {Array} 映射的值组成的数组
     */

  }, {
    key: "mapping",
    value: function mapping() {
      var scales = this.scales;
      var callback = this.callback;

      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }

      var values = params;

      if (callback) {
        for (var i = 0; i < params.length; i++) {
          params[i] = this._toOriginParam(params[i], scales[i]);
        }

        values = callback.apply(this, params);
      }

      if (this.type === 'color' && !Util.isArray(values)) {
        values = ColorUtil.toRGB(values).map(function (e) {
          return e / 255;
        }); // values[3] = values[3] * 255;
      }

      if (!Util.isArray(values)) {
        values = [values];
      }

      return values;
    } // 原始的参数

  }, {
    key: "_toOriginParam",
    value: function _toOriginParam(param, scale) {
      var rst = param;

      if (!scale.isLinear) {
        if (Util.isArray(param)) {
          rst = [];

          for (var i = 0; i < param.length; i++) {
            rst.push(toScaleString(scale, param[i]));
          }
        } else {
          rst = toScaleString(scale, param);
        }
      }

      return rst;
    }
  }]);

  return AttributeBase;
}();

module.exports = AttributeBase;

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Sphere; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Box3_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Vector3_js__ = __webpack_require__(0);


/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Sphere(center, radius) {
  this.center = center !== undefined ? center : new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
  this.radius = radius !== undefined ? radius : 0;
}

Object.assign(Sphere.prototype, {
  set: function (center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  },
  setFromPoints: function () {
    var box = new __WEBPACK_IMPORTED_MODULE_0__Box3_js__["a" /* Box3 */]();
    return function setFromPoints(points, optionalCenter) {
      var center = this.center;

      if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
      } else {
        box.setFromPoints(points).getCenter(center);
      }

      var maxRadiusSq = 0;

      for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }

      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    };
  }(),
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },
  empty: function () {
    return this.radius <= 0;
  },
  containsPoint: function (point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (point) {
    return point.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (sphere) {
    var radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },
  intersectsBox: function (box) {
    return box.intersectsSphere(this);
  },
  intersectsPlane: function (plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function (point, target) {
    var deltaLengthSq = this.center.distanceToSquared(point);

    if (target === undefined) {
      console.warn('THREE.Sphere: .clampPoint() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
    }

    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  },
  getBoundingBox: function (target) {
    if (target === undefined) {
      console.warn('THREE.Sphere: .getBoundingBox() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_0__Box3_js__["a" /* Box3 */]();
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  },
  applyMatrix4: function (matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  },
  translate: function (offset) {
    this.center.add(offset);
    return this;
  },
  equals: function (sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
});


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BufferGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Box3_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__EventDispatcher_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Sphere_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DirectGeometry_js__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Object3D_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Matrix3_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__math_Math_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_js__ = __webpack_require__(49);











/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

function BufferGeometry() {
  Object.defineProperty(this, 'id', {
    value: bufferGeometryId += 2
  });
  this.uuid = __WEBPACK_IMPORTED_MODULE_9__math_Math_js__["a" /* _Math */].generateUUID();
  this.name = '';
  this.type = 'BufferGeometry';
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {
    start: 0,
    count: Infinity
  };
  this.userData = {};
}

BufferGeometry.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_2__EventDispatcher_js__["a" /* EventDispatcher */].prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function () {
    return this.index;
  },
  setIndex: function (index) {
    if (Array.isArray(index)) {
      this.index = new (Object(__WEBPACK_IMPORTED_MODULE_10__utils_js__["a" /* arrayMax */])(index) > 65535 ? __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["h" /* Uint32BufferAttribute */] : __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["g" /* Uint16BufferAttribute */])(index, 1);
    } else {
      this.index = index;
    }
  },
  addAttribute: function (name, attribute) {
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
      return this.addAttribute(name, new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["a" /* BufferAttribute */](arguments[1], arguments[2]));
    }

    if (name === 'index') {
      console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
      this.setIndex(attribute);
      return this;
    }

    this.attributes[name] = attribute;
    return this;
  },
  getAttribute: function (name) {
    return this.attributes[name];
  },
  removeAttribute: function (name) {
    delete this.attributes[name];
    return this;
  },
  addGroup: function (start, count, materialIndex) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex !== undefined ? materialIndex : 0
    });
  },
  clearGroups: function () {
    this.groups = [];
  },
  setDrawRange: function (start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix: function (matrix) {
    var position = this.attributes.position;

    if (position !== undefined) {
      matrix.applyToBufferAttribute(position);
      position.needsUpdate = true;
    }

    var normal = this.attributes.normal;

    if (normal !== undefined) {
      var normalMatrix = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix3_js__["a" /* Matrix3 */]().getNormalMatrix(matrix);
      normalMatrix.applyToBufferAttribute(normal);
      normal.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  },
  rotateX: function () {
    // rotate geometry around world x-axis
    var m1 = new __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__["a" /* Matrix4 */]();
    return function rotateX(angle) {
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function () {
    // rotate geometry around world y-axis
    var m1 = new __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__["a" /* Matrix4 */]();
    return function rotateY(angle) {
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function () {
    // rotate geometry around world z-axis
    var m1 = new __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__["a" /* Matrix4 */]();
    return function rotateZ(angle) {
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function () {
    // translate geometry
    var m1 = new __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__["a" /* Matrix4 */]();
    return function translate(x, y, z) {
      m1.makeTranslation(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function () {
    // scale geometry
    var m1 = new __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__["a" /* Matrix4 */]();
    return function scale(x, y, z) {
      m1.makeScale(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function () {
    var obj = new __WEBPACK_IMPORTED_MODULE_6__Object3D_js__["a" /* Object3D */]();
    return function lookAt(vector) {
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  center: function () {
    var offset = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
    return function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(offset).negate();
      this.translate(offset.x, offset.y, offset.z);
      return this;
    };
  }(),
  setFromObject: function (object) {
    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
    var geometry = object.geometry;

    if (object.isPoints || object.isLine) {
      var positions = new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["b" /* Float32BufferAttribute */](geometry.vertices.length * 3, 3);
      var colors = new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["b" /* Float32BufferAttribute */](geometry.colors.length * 3, 3);
      this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
      this.addAttribute('color', colors.copyColorsArray(geometry.colors));

      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
        var lineDistances = new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["b" /* Float32BufferAttribute */](geometry.lineDistances.length, 1);
        this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
      }

      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }

      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
    } else if (object.isMesh) {
      if (geometry && geometry.isGeometry) {
        this.fromGeometry(geometry);
      }
    }

    return this;
  },
  setFromPoints: function (points) {
    var position = [];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["b" /* Float32BufferAttribute */](position, 3));
    return this;
  },
  updateFromObject: function (object) {
    var geometry = object.geometry;

    if (object.isMesh) {
      var direct = geometry.__directGeometry;

      if (geometry.elementsNeedUpdate === true) {
        direct = undefined;
        geometry.elementsNeedUpdate = false;
      }

      if (direct === undefined) {
        return this.fromGeometry(geometry);
      }

      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.groupsNeedUpdate = false;
      geometry = direct;
    }

    var attribute;

    if (geometry.verticesNeedUpdate === true) {
      attribute = this.attributes.position;

      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.vertices);
        attribute.needsUpdate = true;
      }

      geometry.verticesNeedUpdate = false;
    }

    if (geometry.normalsNeedUpdate === true) {
      attribute = this.attributes.normal;

      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.normals);
        attribute.needsUpdate = true;
      }

      geometry.normalsNeedUpdate = false;
    }

    if (geometry.colorsNeedUpdate === true) {
      attribute = this.attributes.color;

      if (attribute !== undefined) {
        attribute.copyColorsArray(geometry.colors);
        attribute.needsUpdate = true;
      }

      geometry.colorsNeedUpdate = false;
    }

    if (geometry.uvsNeedUpdate) {
      attribute = this.attributes.uv;

      if (attribute !== undefined) {
        attribute.copyVector2sArray(geometry.uvs);
        attribute.needsUpdate = true;
      }

      geometry.uvsNeedUpdate = false;
    }

    if (geometry.lineDistancesNeedUpdate) {
      attribute = this.attributes.lineDistance;

      if (attribute !== undefined) {
        attribute.copyArray(geometry.lineDistances);
        attribute.needsUpdate = true;
      }

      geometry.lineDistancesNeedUpdate = false;
    }

    if (geometry.groupsNeedUpdate) {
      geometry.computeGroups(object.geometry);
      this.groups = geometry.groups;
      geometry.groupsNeedUpdate = false;
    }

    return this;
  },
  fromGeometry: function (geometry) {
    geometry.__directGeometry = new __WEBPACK_IMPORTED_MODULE_5__DirectGeometry_js__["a" /* DirectGeometry */]().fromGeometry(geometry);
    return this.fromDirectGeometry(geometry.__directGeometry);
  },
  fromDirectGeometry: function (geometry) {
    var positions = new Float32Array(geometry.vertices.length * 3);
    this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["a" /* BufferAttribute */](positions, 3).copyVector3sArray(geometry.vertices));

    if (geometry.normals.length > 0) {
      var normals = new Float32Array(geometry.normals.length * 3);
      this.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["a" /* BufferAttribute */](normals, 3).copyVector3sArray(geometry.normals));
    }

    if (geometry.colors.length > 0) {
      var colors = new Float32Array(geometry.colors.length * 3);
      this.addAttribute('color', new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["a" /* BufferAttribute */](colors, 3).copyColorsArray(geometry.colors));
    }

    if (geometry.uvs.length > 0) {
      var uvs = new Float32Array(geometry.uvs.length * 2);
      this.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["a" /* BufferAttribute */](uvs, 2).copyVector2sArray(geometry.uvs));
    }

    if (geometry.uvs2.length > 0) {
      var uvs2 = new Float32Array(geometry.uvs2.length * 2);
      this.addAttribute('uv2', new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["a" /* BufferAttribute */](uvs2, 2).copyVector2sArray(geometry.uvs2));
    } // groups


    this.groups = geometry.groups; // morphs

    for (var name in geometry.morphTargets) {
      var array = [];
      var morphTargets = geometry.morphTargets[name];

      for (var i = 0, l = morphTargets.length; i < l; i++) {
        var morphTarget = morphTargets[i];
        var attribute = new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["b" /* Float32BufferAttribute */](morphTarget.data.length * 3, 3);
        attribute.name = morphTarget.name;
        array.push(attribute.copyVector3sArray(morphTarget.data));
      }

      this.morphAttributes[name] = array;
    } // skinning


    if (geometry.skinIndices.length > 0) {
      var skinIndices = new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["b" /* Float32BufferAttribute */](geometry.skinIndices.length * 4, 4);
      this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
    }

    if (geometry.skinWeights.length > 0) {
      var skinWeights = new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["b" /* Float32BufferAttribute */](geometry.skinWeights.length * 4, 4);
      this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
    } //


    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    return this;
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new __WEBPACK_IMPORTED_MODULE_1__math_Box3_js__["a" /* Box3 */]();
    }

    var position = this.attributes.position;

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position);
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function () {
    var box = new __WEBPACK_IMPORTED_MODULE_1__math_Box3_js__["a" /* Box3 */]();
    var vector = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
    return function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new __WEBPACK_IMPORTED_MODULE_4__math_Sphere_js__["a" /* Sphere */]();
      }

      var position = this.attributes.position;

      if (position) {
        var center = this.boundingSphere.center;
        box.setFromBufferAttribute(position);
        box.getCenter(center); // hoping to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

        var maxRadiusSq = 0;

        for (var i = 0, il = position.count; i < il; i++) {
          vector.x = position.getX(i);
          vector.y = position.getY(i);
          vector.z = position.getZ(i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }

        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    };
  }(),
  computeFaceNormals: function () {// backwards compatibility
  },
  computeVertexNormals: function () {
    var index = this.index;
    var attributes = this.attributes;

    if (attributes.position) {
      var positions = attributes.position.array;

      if (attributes.normal === undefined) {
        this.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["a" /* BufferAttribute */](new Float32Array(positions.length), 3));
      } else {
        // reset existing normals to zero
        var array = attributes.normal.array;

        for (var i = 0, il = array.length; i < il; i++) {
          array[i] = 0;
        }
      }

      var normals = attributes.normal.array;
      var vA, vB, vC;
      var pA = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */](),
          pB = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */](),
          pC = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
      var cb = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */](),
          ab = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */](); // indexed elements

      if (index) {
        var indices = index.array;

        for (var i = 0, il = index.count; i < il; i += 3) {
          vA = indices[i + 0] * 3;
          vB = indices[i + 1] * 3;
          vC = indices[i + 2] * 3;
          pA.fromArray(positions, vA);
          pB.fromArray(positions, vB);
          pC.fromArray(positions, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[vA] += cb.x;
          normals[vA + 1] += cb.y;
          normals[vA + 2] += cb.z;
          normals[vB] += cb.x;
          normals[vB + 1] += cb.y;
          normals[vB + 2] += cb.z;
          normals[vC] += cb.x;
          normals[vC + 1] += cb.y;
          normals[vC + 2] += cb.z;
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (var i = 0, il = positions.length; i < il; i += 9) {
          pA.fromArray(positions, i);
          pB.fromArray(positions, i + 3);
          pC.fromArray(positions, i + 6);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[i] = cb.x;
          normals[i + 1] = cb.y;
          normals[i + 2] = cb.z;
          normals[i + 3] = cb.x;
          normals[i + 4] = cb.y;
          normals[i + 5] = cb.z;
          normals[i + 6] = cb.x;
          normals[i + 7] = cb.y;
          normals[i + 8] = cb.z;
        }
      }

      this.normalizeNormals();
      attributes.normal.needsUpdate = true;
    }
  },
  merge: function (geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
      return;
    }

    if (offset === undefined) {
      offset = 0;
      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
    }

    var attributes = this.attributes;

    for (var key in attributes) {
      if (geometry.attributes[key] === undefined) continue;
      var attribute1 = attributes[key];
      var attributeArray1 = attribute1.array;
      var attribute2 = geometry.attributes[key];
      var attributeArray2 = attribute2.array;
      var attributeSize = attribute2.itemSize;

      for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }

    return this;
  },
  normalizeNormals: function () {
    var vector = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
    return function normalizeNormals() {
      var normals = this.attributes.normal;

      for (var i = 0, il = normals.count; i < il; i++) {
        vector.x = normals.getX(i);
        vector.y = normals.getY(i);
        vector.z = normals.getZ(i);
        vector.normalize();
        normals.setXYZ(i, vector.x, vector.y, vector.z);
      }
    };
  }(),
  toNonIndexed: function () {
    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
      return this;
    }

    var geometry2 = new BufferGeometry();
    var indices = this.index.array;
    var attributes = this.attributes;

    for (var name in attributes) {
      var attribute = attributes[name];
      var array = attribute.array;
      var itemSize = attribute.itemSize;
      var array2 = new array.constructor(indices.length * itemSize);
      var index = 0,
          index2 = 0;

      for (var i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;

        for (var j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      geometry2.addAttribute(name, new __WEBPACK_IMPORTED_MODULE_3__BufferAttribute_js__["a" /* BufferAttribute */](array2, itemSize));
    }

    var groups = this.groups;

    for (var i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  },
  toJSON: function () {
    var data = {
      metadata: {
        version: 4.5,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      var parameters = this.parameters;

      for (var key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    }

    data.data = {
      attributes: {}
    };
    var index = this.index;

    if (index !== null) {
      var array = Array.prototype.slice.call(index.array);
      data.data.index = {
        type: index.array.constructor.name,
        array: array
      };
    }

    var attributes = this.attributes;

    for (var key in attributes) {
      var attribute = attributes[key];
      var array = Array.prototype.slice.call(attribute.array);
      data.data.attributes[key] = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array: array,
        normalized: attribute.normalized
      };
    }

    var groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    var boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 var parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 var values = [];
    	 for ( var key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 var geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new BufferGeometry().copy(this);
  },
  copy: function (source) {
    var name, i, l; // reset

    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // name

    this.name = source.name; // index

    var index = source.index;

    if (index !== null) {
      this.setIndex(index.clone());
    } // attributes


    var attributes = source.attributes;

    for (name in attributes) {
      var attribute = attributes[name];
      this.addAttribute(name, attribute.clone());
    } // morph attributes


    var morphAttributes = source.morphAttributes;

    for (name in morphAttributes) {
      var array = [];
      var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone());
      }

      this.morphAttributes[name] = array;
    } // groups


    var groups = source.groups;

    for (i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    var boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    var boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BufferAttribute; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Vector4_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Color_js__ = __webpack_require__(7);




/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
  }

  this.name = '';
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== undefined ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.dynamic = false;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
}

Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function () {},
  setArray: function (array) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.count = array !== undefined ? array.length / this.itemSize : 0;
    this.array = array;
    return this;
  },
  setDynamic: function (value) {
    this.dynamic = value;
    return this;
  },
  copy: function (source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for (var i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  },
  copyArray: function (array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function (colors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = colors.length; i < l; i++) {
      var color = colors[i];

      if (color === undefined) {
        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
        color = new __WEBPACK_IMPORTED_MODULE_3__math_Color_js__["a" /* Color */]();
      }

      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }

    return this;
  },
  copyVector2sArray: function (vectors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
        vector = new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */]();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }

    return this;
  },
  copyVector3sArray: function (vectors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
        vector = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }

    return this;
  },
  copyVector4sArray: function (vectors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
        vector = new __WEBPACK_IMPORTED_MODULE_0__math_Vector4_js__["a" /* Vector4 */]();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }

    return this;
  },
  set: function (value, offset) {
    if (offset === undefined) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  getX: function (index) {
    return this.array[index * this.itemSize];
  },
  setX: function (index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function (index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function (index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function (index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function (index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function (index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function (index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function (index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function () {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
}); //

function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}

Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}

Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}

Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}

Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}

Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}

Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}

Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}

Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}

Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute; //



/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Material; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_three__ = __webpack_require__(2);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var Material =
/*#__PURE__*/
function (_THREE$ShaderMaterial) {
  _inherits(Material, _THREE$ShaderMaterial);

  function Material() {
    _classCallCheck(this, Material);

    return _possibleConstructorReturn(this, _getPrototypeOf(Material).apply(this, arguments));
  }

  _createClass(Material, [{
    key: "setUniformsValue",
    value: function setUniformsValue(name, value) {
      if (!this.uniforms[name]) {
        return;
      }

      this.uniforms[name].value = value;
      this.uniforms.needsUpdate = true;
    }
  }, {
    key: "setDefinesvalue",
    value: function setDefinesvalue(name, value) {
      this.defines[name] = value;
      this.needsUpdate = true;
    }
  }, {
    key: "setUniform",
    value: function setUniform(option) {
      var uniforms = {};

      for (var key in option) {
        if (key.substr(0, 2) === 'u_') {
          uniforms[key] = {
            value: option[key]
          };
        }
      }

      return uniforms;
    }
  }, {
    key: "upDateUninform",
    value: function upDateUninform(option) {
      for (var key in option) {
        if (key.substr(0, 2) === 'u_') {
          this.setUniformsValue(key, option[key]);
        }
      }
    }
  }]);

  return Material;
}(__WEBPACK_IMPORTED_MODULE_0__core_three__["ShaderMaterial"]);



/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BufferBase; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_base__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__normals__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extrude__ = __webpack_require__(73);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var BufferBase =
/*#__PURE__*/
function (_Base) {
  _inherits(BufferBase, _Base);

  function BufferBase(cfg) {
    var _this;

    _classCallCheck(this, BufferBase);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BufferBase).call(this, cfg));
    _this.bufferStruct = {};

    _this.geometryBuffer();

    return _this;
  }

  _createClass(BufferBase, [{
    key: "geometryBuffer",
    value: function geometryBuffer() {}
  }, {
    key: "_normals",
    value: function _normals() {
      var _this$bufferStruct = this.bufferStruct,
          position = _this$bufferStruct.position,
          indices = _this$bufferStruct.indices,
          _this$bufferStruct$no = _this$bufferStruct.normals,
          normals = _this$bufferStruct$no === void 0 ? [] : _this$bufferStruct$no;
      indices.forEach(function (index, i) {
        normals.push(Object(__WEBPACK_IMPORTED_MODULE_2__normals__["a" /* faceNormals */])(index, position[i]));
      });
      this.bufferStruct.normals = normals;
    }
  }, {
    key: "_extrude",
    value: function _extrude(coordinate, heightValue) {
      var extrudeData = Object(__WEBPACK_IMPORTED_MODULE_3__extrude__["a" /* default */])(coordinate, heightValue);
      return extrudeData;
    }
  }, {
    key: "_mergeAttributes",
    value: function _mergeAttributes(attributes) {
      var lengths = {}; // Find array lengths

      attributes.forEach(function (_attributes) {
        for (var k in _attributes) {
          if (!lengths[k]) {
            lengths[k] = 0;
          }

          lengths[k] += _attributes[k].length;
        }
      });
      var mergedAttributes = {}; // Set up arrays to merge into

      for (var k in lengths) {
        mergedAttributes[k] = new Float32Array(lengths[k]);
      }

      var lastLengths = {};
      attributes.forEach(function (_attributes) {
        for (var _k in _attributes) {
          if (!lastLengths[_k]) {
            lastLengths[_k] = 0;
          }

          mergedAttributes[_k].set(_attributes[_k], lastLengths[_k]);

          lastLengths[_k] += _attributes[_k].length;
        }
      });
      return mergedAttributes;
    }
  }, {
    key: "_toPolygonAttributes",
    value: function _toPolygonAttributes(polygon) {
      // Three components per vertex per face (3 x 3 = 9)
      var style = polygon.style,
          indices = polygon.indices,
          position = polygon.position,
          indexCount = polygon.indexCount;
      var vertices = new Float32Array(indexCount * 3);
      var normals = new Float32Array(indexCount * 3);
      var colors = new Float32Array(indexCount * 4);
      var pickingIds = new Float32Array(indexCount);
      var pA = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Vector3"]();
      var pB = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Vector3"]();
      var pC = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Vector3"]();
      var cb = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Vector3"]();
      var ab = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Vector3"]();
      var lastIndex = 0;
      indices.forEach(function (indice, pIndex) {
        for (var i = 0; i < indice.length / 3; i++) {
          var index = indice[i * 3];
          var color = style[pIndex].color;
          var _pickingId = style[pIndex].id;
          var ax = position[pIndex][index][0];
          var ay = position[pIndex][index][1];
          var az = position[pIndex][index][2];
          index = indice[i * 3 + 1];
          var bx = position[pIndex][index][0];
          var by = position[pIndex][index][1];
          var bz = position[pIndex][index][2];
          index = indice[i * 3 + 2];
          var cx = position[pIndex][index][0];
          var cy = position[pIndex][index][1];
          var cz = position[pIndex][index][2];
          pA.set(ax, ay, az);
          pB.set(bx, by, bz);
          pC.set(cx, cy, cz);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          cb.normalize();
          var nx = cb.x;
          var ny = cb.y;
          var nz = cb.z;
          vertices[lastIndex * 9 + 0] = ax;
          vertices[lastIndex * 9 + 1] = ay;
          vertices[lastIndex * 9 + 2] = az;
          normals[lastIndex * 9 + 0] = nx;
          normals[lastIndex * 9 + 1] = ny;
          normals[lastIndex * 9 + 2] = nz;
          colors[lastIndex * 12 + 0] = color[0];
          colors[lastIndex * 12 + 1] = color[1];
          colors[lastIndex * 12 + 2] = color[2];
          colors[lastIndex * 12 + 3] = color[3];
          vertices[lastIndex * 9 + 3] = bx;
          vertices[lastIndex * 9 + 4] = by;
          vertices[lastIndex * 9 + 5] = bz;
          normals[lastIndex * 9 + 3] = nx;
          normals[lastIndex * 9 + 4] = ny;
          normals[lastIndex * 9 + 5] = nz;
          colors[lastIndex * 12 + 4] = color[0];
          colors[lastIndex * 12 + 5] = color[1];
          colors[lastIndex * 12 + 6] = color[2];
          colors[lastIndex * 12 + 7] = color[3];
          vertices[lastIndex * 9 + 6] = cx;
          vertices[lastIndex * 9 + 7] = cy;
          vertices[lastIndex * 9 + 8] = cz;
          normals[lastIndex * 9 + 6] = nx;
          normals[lastIndex * 9 + 7] = ny;
          normals[lastIndex * 9 + 8] = nz;
          colors[lastIndex * 12 + 8] = color[0];
          colors[lastIndex * 12 + 9] = color[1];
          colors[lastIndex * 12 + 10] = color[2];
          colors[lastIndex * 12 + 11] = color[3];
          pickingIds[lastIndex * 3 + 0] = _pickingId;
          pickingIds[lastIndex * 3 + 1] = _pickingId;
          pickingIds[lastIndex * 3 + 2] = _pickingId;
          lastIndex++;
        }
      });
      var attributes = {
        vertices: vertices,
        normals: normals,
        colors: colors,
        pickingIds: pickingIds,
        faceUv: new Float32Array(polygon.faceUv),
        sizes: new Float32Array(polygon.sizes)
      };
      return attributes;
    }
  }, {
    key: "_toPointShapeAttributes",
    value: function _toPointShapeAttributes(polygon) {
      // Three components per vertex per face (3 x 3 = 9)
      var style = polygon.style,
          indices = polygon.indices,
          position = polygon.position,
          indexCount = polygon.indexCount,
          shapes = polygon.shapes,
          sizes = polygon.sizes;
      var vertices = new Float32Array(indexCount * 3);
      var shapePositions = new Float32Array(indexCount * 3);
      var a_size = new Float32Array(indexCount * 3);
      var normals = new Float32Array(indexCount * 3);
      var colors = new Float32Array(indexCount * 4);
      var pickingIds = new Float32Array(indexCount);
      var pA = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Vector3"]();
      var pB = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Vector3"]();
      var pC = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Vector3"]();
      var cb = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Vector3"]();
      var ab = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Vector3"]();
      var lastIndex = 0;
      indices.forEach(function (indice, pIndex) {
        for (var i = 0; i < indice.length / 3; i++) {
          var index = indice[i * 3];
          var color = style[pIndex].color;
          var coor1 = position[pIndex];
          var size = sizes[pIndex];
          var _pickingId = style[pIndex].id;
          var ax = shapes[pIndex][index][0];
          var ay = shapes[pIndex][index][1];
          var az = shapes[pIndex][index][2];
          index = indice[i * 3 + 1];
          var bx = shapes[pIndex][index][0];
          var by = shapes[pIndex][index][1];
          var bz = shapes[pIndex][index][2];
          index = indice[i * 3 + 2];
          var cx = shapes[pIndex][index][0];
          var cy = shapes[pIndex][index][1];
          var cz = shapes[pIndex][index][2];
          pA.set(ax, ay, az);
          pB.set(bx, by, bz);
          pC.set(cx, cy, cz);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          cb.normalize();
          var nx = cb.x;
          var ny = cb.y;
          var nz = cb.z;
          vertices[lastIndex * 9 + 0] = coor1[0];
          vertices[lastIndex * 9 + 1] = coor1[1];
          vertices[lastIndex * 9 + 2] = coor1[2];
          shapePositions[lastIndex * 9 + 0] = ax;
          shapePositions[lastIndex * 9 + 1] = ay;
          shapePositions[lastIndex * 9 + 2] = az;
          a_size[lastIndex * 9 + 0] = size[0];
          a_size[lastIndex * 9 + 1] = size[1];
          a_size[lastIndex * 9 + 2] = size[2];
          normals[lastIndex * 9 + 0] = nx;
          normals[lastIndex * 9 + 1] = ny;
          normals[lastIndex * 9 + 2] = nz;
          colors[lastIndex * 12 + 0] = color[0];
          colors[lastIndex * 12 + 1] = color[1];
          colors[lastIndex * 12 + 2] = color[2];
          colors[lastIndex * 12 + 3] = color[3];
          vertices[lastIndex * 9 + 3] = coor1[0];
          vertices[lastIndex * 9 + 4] = coor1[1];
          vertices[lastIndex * 9 + 5] = coor1[2];
          shapePositions[lastIndex * 9 + 3] = bx;
          shapePositions[lastIndex * 9 + 4] = by;
          shapePositions[lastIndex * 9 + 5] = bz;
          a_size[lastIndex * 9 + 3] = size[0];
          a_size[lastIndex * 9 + 4] = size[1];
          a_size[lastIndex * 9 + 5] = size[2];
          normals[lastIndex * 9 + 3] = nx;
          normals[lastIndex * 9 + 4] = ny;
          normals[lastIndex * 9 + 5] = nz;
          colors[lastIndex * 12 + 4] = color[0];
          colors[lastIndex * 12 + 5] = color[1];
          colors[lastIndex * 12 + 6] = color[2];
          colors[lastIndex * 12 + 7] = color[3];
          vertices[lastIndex * 9 + 6] = coor1[0];
          vertices[lastIndex * 9 + 7] = coor1[1];
          vertices[lastIndex * 9 + 8] = coor1[2];
          a_size[lastIndex * 9 + 6] = size[0];
          a_size[lastIndex * 9 + 7] = size[1];
          a_size[lastIndex * 9 + 8] = size[2];
          shapePositions[lastIndex * 9 + 6] = cx;
          shapePositions[lastIndex * 9 + 7] = cy;
          shapePositions[lastIndex * 9 + 8] = cz;
          normals[lastIndex * 9 + 6] = nx;
          normals[lastIndex * 9 + 7] = ny;
          normals[lastIndex * 9 + 8] = nz;
          colors[lastIndex * 12 + 8] = color[0];
          colors[lastIndex * 12 + 9] = color[1];
          colors[lastIndex * 12 + 10] = color[2];
          colors[lastIndex * 12 + 11] = color[3];
          pickingIds[lastIndex * 3 + 0] = _pickingId;
          pickingIds[lastIndex * 3 + 1] = _pickingId;
          pickingIds[lastIndex * 3 + 2] = _pickingId;
          lastIndex++;
        }
      });
      var attributes = {
        vertices: vertices,
        normals: normals,
        colors: colors,
        pickingIds: pickingIds,
        shapePositions: shapePositions,
        a_size: a_size,
        faceUv: new Float32Array(polygon.faceUv)
      };
      return attributes;
    }
  }, {
    key: "_toPolygonLineAttributes",
    value: function _toPolygonLineAttributes(polygonline) {
      var style = polygonline.style,
          indices = polygonline.indices,
          position = polygonline.position,
          indexCount = polygonline.indexCount;
      var vertices = new Float32Array(indexCount * 3);
      var colors = new Float32Array(indexCount * 4);
      var pickingIds = new Float32Array(indexCount);
      var lastIndex = 0;
      indices.forEach(function (indice, pIndex) {
        for (var i = 0; i < indice.length; i++) {
          var index = indice[i];
          var color = style[pIndex].color;
          var _pickingId = style[pIndex].id;
          vertices[lastIndex * 3] = position[pIndex][index][0];
          vertices[lastIndex * 3 + 1] = position[pIndex][index][1];
          vertices[lastIndex * 3 + 2] = position[pIndex][index][2];
          colors[lastIndex * 4] = color[0];
          colors[lastIndex * 4 + 1] = color[1];
          colors[lastIndex * 4 + 2] = color[2];
          colors[lastIndex * 4 + 3] = color[3];
          pickingIds[lastIndex] = _pickingId;
          lastIndex++;
        }
      });
      var attributes = {
        vertices: vertices,
        colors: colors,
        pickingIds: pickingIds
      };
      return attributes;
    }
  }, {
    key: "_toPointsAttributes",
    value: function _toPointsAttributes(point) {
      var style = point.style,
          position = point.position;
      var count = position.length;
      var vertices = new Float32Array(count * 3);
      var colors = new Float32Array(count * 4);
      var sizes = new Float32Array(count);
      var shapes = new Float32Array(count);
      var pickingIds = new Float32Array(count);
      position.forEach(function (pos, index) {
        vertices[index * 3] = pos[0];
        vertices[index * 3 + 1] = pos[1];
        vertices[index * 3 + 2] = pos[2];
        colors[index * 4] = style[index].color[0];
        colors[index * 4 + 1] = style[index].color[1];
        colors[index * 4 + 2] = style[index].color[2];
        colors[index * 4 + 3] = style[index].color[3];
        pickingIds[index] = style[index].id;
        sizes[index] = style[index].size * window.devicePixelRatio;

        if (style[index].shape) {
          shapes[index] = style[index].shape;
        }
      });
      var attributes = {
        vertices: vertices,
        colors: colors,
        sizes: sizes,
        shapes: shapes,
        pickingIds: pickingIds
      };
      return attributes;
    }
  }, {
    key: "_generateTexture",
    value: function _generateTexture() {
      // build a small canvas 32x64 and paint it in white
      var canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 64;
      var context = canvas.getContext('2d'); // plain it in white

      context.fillStyle = '#ffffff';
      context.fillRect(0, 0, 32, 64); // draw the window rows - with a small noise to simulate light variations in each room

      for (var y = 8; y < 64; y += 8) {
        for (var x = 0; x < 32; x += 2) {
          var value = Math.floor(Math.random() * 64);
          context.fillStyle = 'rgb(' + [value, value, value].join(',') + ')';
          context.fillRect(x, y, 2, 4);
        }
      }

      context.fillStyle = '#105CB3';
      context.fillRect(0, 60, 32, 64); // build a bigger canvas and copy the small one in it
      // This is a trick to upscale the texture without filtering

      var canvas2 = document.createElement('canvas');
      canvas2.width = 512;
      canvas2.height = 1024;
      var context2 = canvas2.getContext('2d'); // disable smoothing

      context2.imageSmoothingEnabled = false;
      context2.webkitImageSmoothingEnabled = false;
      context2.mozImageSmoothingEnabled = false; // then draw the image

      context2.drawImage(canvas, 0, 0, canvas2.width, canvas2.height); // return the just built canvas2

      var texture = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Texture"](canvas2); // texture.anisotropy = renderer.getMaxAnisotropy();

      texture.needsUpdate = true;
      return texture;
    }
  }]);

  return BufferBase;
}(__WEBPACK_IMPORTED_MODULE_0__core_base__["a" /* default */]);



/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventDispatcher; });
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
function EventDispatcher() {}

Object.assign(EventDispatcher.prototype, {
  addEventListener: function (type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    var listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function (type, listener) {
    if (this._listeners === undefined) return false;
    var listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function (type, listener) {
    if (this._listeners === undefined) return;
    var listeners = this._listeners;
    var listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      var index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function (event) {
    if (this._listeners === undefined) return;
    var listeners = this._listeners;
    var listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this;
      var array = listenerArray.slice(0);

      for (var i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
});


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Material; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_EventDispatcher_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Math_js__ = __webpack_require__(6);



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

var materialId = 0;

function Material() {
  Object.defineProperty(this, 'id', {
    value: materialId++
  });
  this.uuid = __WEBPACK_IMPORTED_MODULE_2__math_Math_js__["a" /* _Math */].generateUUID();
  this.name = '';
  this.type = 'Material';
  this.fog = true;
  this.lights = true;
  this.blending = __WEBPACK_IMPORTED_MODULE_1__constants_js__["_17" /* NormalBlending */];
  this.side = __WEBPACK_IMPORTED_MODULE_1__constants_js__["H" /* FrontSide */];
  this.flatShading = false;
  this.vertexColors = __WEBPACK_IMPORTED_MODULE_1__constants_js__["_15" /* NoColors */]; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = __WEBPACK_IMPORTED_MODULE_1__constants_js__["_65" /* SrcAlphaFactor */];
  this.blendDst = __WEBPACK_IMPORTED_MODULE_1__constants_js__["_23" /* OneMinusSrcAlphaFactor */];
  this.blendEquation = __WEBPACK_IMPORTED_MODULE_1__constants_js__["a" /* AddEquation */];
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = __WEBPACK_IMPORTED_MODULE_1__constants_js__["R" /* LessEqualDepth */];
  this.depthTest = true;
  this.depthWrite = true;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null; // override the renderer's default precision for this material

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

  this.visible = true;
  this.userData = {};
  this.needsUpdate = true;
}

Material.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__core_EventDispatcher_js__["a" /* EventDispatcher */].prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function () {},
  setValues: function (values) {
    if (values === undefined) return;

    for (var key in values) {
      var newValue = values[key];

      if (newValue === undefined) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      } // for backward compatability if shading is set in the constructor


      if (key === 'shading') {
        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        this.flatShading = newValue === __WEBPACK_IMPORTED_MODULE_1__constants_js__["D" /* FlatShading */] ? true : false;
        continue;
      }

      var currentValue = this[key];

      if (currentValue === undefined) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }

      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
        currentValue.copy(newValue);
      } else if (key === 'overdraw') {
        // ensure overdraw is backwards-compatible with legacy boolean type
        this[key] = Number(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function (meta) {
    var isRoot = meta === undefined || typeof meta === 'string';

    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }

    var data = {
      metadata: {
        version: 4.5,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    }; // standard Material serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== undefined) data.roughness = this.roughness;
    if (this.metalness !== undefined) data.metalness = this.metalness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.shininess !== undefined) data.shininess = this.shininess;
    if (this.clearCoat !== undefined) data.clearCoat = this.clearCoat;
    if (this.clearCoatRoughness !== undefined) data.clearCoatRoughness = this.clearCoatRoughness;
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }

    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }

    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }

    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }

    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity; // Scale behind envMap
    }

    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }

    if (this.size !== undefined) data.size = this.size;
    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== __WEBPACK_IMPORTED_MODULE_1__constants_js__["_17" /* NormalBlending */]) data.blending = this.blending;
    if (this.flatShading === true) data.flatShading = this.flatShading;
    if (this.side !== __WEBPACK_IMPORTED_MODULE_1__constants_js__["H" /* FrontSide */]) data.side = this.side;
    if (this.vertexColors !== __WEBPACK_IMPORTED_MODULE_1__constants_js__["_15" /* NoColors */]) data.vertexColors = this.vertexColors;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite; // rotation (SpriteMaterial)

    if (this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== undefined) data.dashSize = this.dashSize;
    if (this.gapSize !== undefined) data.gapSize = this.gapSize;
    if (this.scale !== undefined) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true) data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true) data.morphTargets = true;
    if (this.skinning === true) data.skinning = true;
    if (this.visible === false) data.visible = false;
    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

    function extractFromCache(cache) {
      var values = [];

      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }

    if (isRoot) {
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }

    return data;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.fog = source.fog;
    this.lights = source.lights;
    this.blending = source.blending;
    this.side = source.side;
    this.flatShading = source.flatShading;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.overdraw = source.overdraw;
    this.visible = source.visible;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.clipShadows = source.clipShadows;
    this.clipIntersection = source.clipIntersection;
    var srcPlanes = source.clippingPlanes,
        dstPlanes = null;

    if (srcPlanes !== null) {
      var n = srcPlanes.length;
      dstPlanes = new Array(n);

      for (var i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone();
    }

    this.clippingPlanes = dstPlanes;
    this.shadowSide = source.shadowSide;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});


/***/ }),
/* 20 */
/***/ (function(module, exports) {

/**
 * @fileOverview 全局变量
 * @author dxq613
 */
// const Global = {};
var Global = {
  version: '1.0.0',
  scene: {
    mapType: 'AMAP',
    zoom: 5,
    center: [107.622, 39.266],
    minZoom: 0,
    maxZoom: 22,
    pitch: 0
  },
  trackable: true,
  animate: true,
  snapArray: [0, 1, 2, 4, 5, 10],
  height: 0,
  activeColor: '#2f54eb',
  colors: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)', 'rgb(5,48,97)'],
  // 指定固定 tick 数的逼近值
  snapCountArray: [0, 1, 1.2, 1.5, 1.6, 2, 2.2, 2.4, 2.5, 3, 4, 5, 6, 7.5, 8, 10],
  size: 10000,
  sdfHomeUrl: 'https://sdf.amap.com',
  scales: {}
};
module.exports = Global;

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Layer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__attr_color_util__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__attr_color_util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__attr_color_util__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__source_index__ = __webpack_require__(255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_engine_picking_pickingMaterial__ = __webpack_require__(275);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__attr_index__ = __webpack_require__(278);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__attr_index___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__attr_index__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__util__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview Layer基类
 * @author lzx199065@gmail.com
 */








var Global = __webpack_require__(20);

var id = 1;

function parseFields(field) {
  if (__WEBPACK_IMPORTED_MODULE_6__util___default.a.isArray(field)) {
    return field;
  }

  if (__WEBPACK_IMPORTED_MODULE_6__util___default.a.isString(field)) {
    return field.split('*');
  }

  return [field];
}

var Layer =
/*#__PURE__*/
function (_Base) {
  _inherits(Layer, _Base);

  _createClass(Layer, [{
    key: "getDefaultCfg",
    value: function getDefaultCfg() {
      return {
        visible: true,
        zIndex: 0,
        type: '',
        minZoom: 0,
        maxZoom: 22,
        rotation: 0,
        attrOptions: {},
        scales: {},
        attrs: {},
        // 样式配置项
        styleOptions: {
          stroke: [1.0, 1.0, 1.0, 1.0],
          strokeWidth: 1.0,
          opacity: 1.0,
          texture: false
        },
        // 选中时的配置项
        selectedOptions: null,
        // active 时的配置项
        activedOptions: null,
        animateOptions: {
          enable: false
        }
      };
    }
  }]);

  function Layer(scene, cfg) {
    var _this;

    _classCallCheck(this, Layer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Layer).call(this, cfg));
    _this.scene = scene;
    _this.map = scene.map;
    _this._object3D = new __WEBPACK_IMPORTED_MODULE_1__three__["Object3D"]();
    _this._pickObject3D = new __WEBPACK_IMPORTED_MODULE_1__three__["Object3D"]();
    _this._object3D.visible = _this.get('visible');
    _this._object3D.renderOrder = _this.get('zIndex') || 0;

    var layerId = _this._getUniqueId();

    _this.layerId = layerId;
    _this._activeIds = null;

    scene._engine._scene.add(_this._object3D);

    _this.layerMesh = null;
    return _this;
  }
  /**
   * 将图层添加加到 Object
   * @param {*} object three 物体
   */


  _createClass(Layer, [{
    key: "add",
    value: function add(object) {
      var _this2 = this;

      this.layerMesh = object;

      this._visibleWithZoom();

      this.scene.on('zoomchange', function () {
        _this2._visibleWithZoom();
      });

      this.layerMesh.onBeforeRender = function () {
        var zoom = _this2.scene.getZoom();

        _this2.layerMesh.material.setUniformsValue('u_time', _this2.scene._engine.clock.getElapsedTime());

        _this2.layerMesh.material.setUniformsValue('u_zoom', zoom);
      }; // 更新


      if (this._needUpdateFilter) {
        this._updateFilter();
      }

      this._object3D.add(object);

      this._addPickMesh(object);
    }
  }, {
    key: "remove",
    value: function remove(object) {
      this._object3D.remove(object);
    }
  }, {
    key: "_getUniqueId",
    value: function _getUniqueId() {
      return id++;
    }
  }, {
    key: "_visible",
    value: function _visible(visible) {
      this.set('visible', visible);
      this._object3D.visible = this.get('visible');
    }
  }, {
    key: "source",
    value: function source(data) {
      var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var dataType = this._getDataType(data);

      var _cfg$type = cfg.type,
          type = _cfg$type === void 0 ? dataType : _cfg$type;
      cfg.data = data;
      cfg.mapType = this.get('mapType');
      this.layerSource = new __WEBPACK_IMPORTED_MODULE_3__source_index__[type](cfg);
      return this;
    }
  }, {
    key: "color",
    value: function color(field, values) {
      this._needUpdateColor = true; // 标识颜色是否需要更新

      this._createAttrOption('color', field, values, Global.colors);

      return this;
    }
  }, {
    key: "size",
    value: function size(field, values) {
      var fields = parseFields(field);

      if (fields.indexOf('zoom') !== -1) {
        this._zoomScale = true;
      }

      if (__WEBPACK_IMPORTED_MODULE_6__util___default.a.isArray(fields) && !values) values = fields;

      this._createAttrOption('size', field, values, Global.size);

      return this;
    }
  }, {
    key: "shape",
    value: function shape(field, values) {
      if (field.split(':').length === 2) {
        this.shapeType = field.split(':')[0];
        field = field.split(':')[1];
      }

      values === 'text' ? this.shapeType = values : null;

      this._createAttrOption('shape', field, values, Global.sizes);

      return this;
    }
    /**
     * 是否允许使用默认的图形激活交互
     * @param  {Boolean} enable 是否允许激活开关
     * @param {Object} cfg 激活的配置项
     * @return {Geom}    返回 geom 自身
     */

  }, {
    key: "active",
    value: function active(enable, cfg) {
      if (enable === false) {
        this.set('allowActive', false);
      } else if (__WEBPACK_IMPORTED_MODULE_6__util___default.a.isObject(enable)) {
        this.set('allowActive', true);
        this.set('activedOptions', enable);
      } else {
        this.set('allowActive', true);
        this.set('activedOptions', cfg || {
          fill: Global.activeColor
        });
      }

      return this;
    }
  }, {
    key: "style",
    value: function style(field, cfg) {
      var colorItem = ['fill', 'stroke', 'color', 'baseColor', 'brightColor', 'windowColor'];
      var styleOptions = this.get('styleOptions');

      if (!styleOptions) {
        styleOptions = {};
        this.set('styleOptions', styleOptions);
      }

      if (__WEBPACK_IMPORTED_MODULE_6__util___default.a.isObject(field)) {
        cfg = field;
        field = null;
      }

      var fields;

      if (field) {
        fields = parseFields(field);
      }

      styleOptions.fields = fields;
      __WEBPACK_IMPORTED_MODULE_6__util___default.a.assign(styleOptions, cfg);

      for (var item in cfg) {
        if (colorItem.indexOf(item) !== -1) {
          styleOptions[item] = __WEBPACK_IMPORTED_MODULE_2__attr_color_util___default.a.color2RGBA(styleOptions[item]);
        }

        styleOptions[item] = styleOptions[item];
      }

      this.set('styleOptions', styleOptions);
      return this;
    }
  }, {
    key: "filter",
    value: function filter(field, values) {
      this._needUpdateFilter = true;

      this._createAttrOption('filter', field, values, true);

      return this;
    }
  }, {
    key: "animate",
    value: function animate(field, cfg) {
      var animateOptions = this.get('animateOptions');

      if (!animateOptions) {
        animateOptions = {};
        this.set('animateOptions', animateOptions);
      }

      if (__WEBPACK_IMPORTED_MODULE_6__util___default.a.isObject(field)) {
        cfg = field;
        field = null;
      }

      var fields;

      if (field) {
        fields = parseFields(field);
      }

      animateOptions.fields = fields;
      __WEBPACK_IMPORTED_MODULE_6__util___default.a.assign(animateOptions, cfg);
      this.set('animateOptions', animateOptions);
      return this;
    }
  }, {
    key: "texture",
    value: function texture() {}
  }, {
    key: "hide",
    value: function hide() {
      this._visible(false);

      return this;
    }
  }, {
    key: "show",
    value: function show() {
      this._visible(true);

      return this;
    }
  }, {
    key: "_createScale",
    value: function _createScale(field) {
      var scales = this.get('scales');
      var scale = scales[field];

      if (!scale) {
        scale = this.layerSource.createScale(field);
        scales[field] = scale;
      }

      return scale;
    }
  }, {
    key: "_setAttrOptions",
    value: function _setAttrOptions(attrName, attrCfg) {
      var options = this.get('attrOptions');

      if (attrName === 'size' && this._zoomScale) {
        attrCfg.zoom = this.map.getZoom();
      }

      options[attrName] = attrCfg;
    }
  }, {
    key: "_createAttrOption",
    value: function _createAttrOption(attrName, field, cfg, defaultValues) {
      var attrCfg = {};
      attrCfg.field = field;

      if (cfg) {
        if (__WEBPACK_IMPORTED_MODULE_6__util___default.a.isFunction(cfg)) {
          attrCfg.callback = cfg;
        } else {
          attrCfg.values = cfg;
        }
      } else if (attrName !== 'color') {
        attrCfg.values = defaultValues;
      }

      this._setAttrOptions(attrName, attrCfg);
    } // 初始化图层

  }, {
    key: "init",
    value: function init() {
      this._initAttrs();

      this._scaleByZoom();

      this._mapping();

      var activeHander = this._addActiveFeature.bind(this);

      if (this.get('allowActive')) {
        this.scene.on('pick', activeHander);
      } else {
        this.scene.off('pick', activeHander);
      }
    }
  }, {
    key: "_addActiveFeature",
    value: function _addActiveFeature(e) {
      var featureId = e.featureId;
      var activeStyle = this.get('activedOptions');
      var selectFeatureIds = this.layerSource.getSelectFeatureId(featureId);

      if (this.StyleData[selectFeatureIds[0]].hasOwnProperty('filter') && this.StyleData[selectFeatureIds[0]].filter === false) {
        return;
      }

      var style = __WEBPACK_IMPORTED_MODULE_6__util___default.a.assign({}, this.StyleData[featureId]);
      style.color = __WEBPACK_IMPORTED_MODULE_2__attr_color_util___default.a.toRGB(activeStyle.fill).map(function (e) {
        return e / 255;
      });
      this.updateStyle([featureId], style);
    }
  }, {
    key: "_initAttrs",
    value: function _initAttrs() {
      var attrOptions = this.get('attrOptions');

      for (var type in attrOptions) {
        if (attrOptions.hasOwnProperty(type)) {
          this._updateAttr(type);
        }
      }
    }
  }, {
    key: "_updateAttr",
    value: function _updateAttr(type) {
      var self = this;
      var attrs = this.get('attrs');
      var attrOptions = this.get('attrOptions');
      var option = attrOptions[type];
      option.neadUpdate = true;
      var className = __WEBPACK_IMPORTED_MODULE_6__util___default.a.upperFirst(type);
      var fields = parseFields(option.field);
      var scales = [];

      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];

        var scale = self._createScale(field);

        if (type === 'color' && __WEBPACK_IMPORTED_MODULE_6__util___default.a.isNil(option.values)) {
          // 设置 color 的默认色值
          option.values = Global.colors;
        }

        scales.push(scale);
      }

      option.scales = scales;
      var attr = new __WEBPACK_IMPORTED_MODULE_5__attr_index___default.a[className](option);
      attrs[type] = attr;
    }
  }, {
    key: "_updateSize",
    value: function _updateSize(zoom) {
      var _this3 = this;

      var sizeOption = this.get('attrOptions').size;
      var fields = parseFields(sizeOption.field);
      var data = this.layerSource.propertiesData;
      if (!this.zoomSizeCache) this.zoomSizeCache = {};

      if (!this.zoomSizeCache[zoom]) {
        this.zoomSizeCache[zoom] = [];

        var _loop = function _loop(i) {
          var params = fields.map(function (field) {
            return data[i][field];
          });
          var indexZoom = fields.indexOf('zoom');
          indexZoom !== -1 ? params[indexZoom] = zoom : null;

          _this3.zoomSizeCache[zoom].push(sizeOption.callback.apply(sizeOption, _toConsumableArray(params)));
        };

        for (var i = 0; i < data.length; i++) {
          _loop(i);
        }
      }

      this.emit('sizeUpdated', this.zoomSizeCache[zoom]);
    }
  }, {
    key: "_mapping",
    value: function _mapping() {
      var self = this;
      var attrs = self.get('attrs');
      var mappedData = [];
      var data = this.layerSource.propertiesData;

      for (var i = 0; i < data.length; i++) {
        var record = data[i];
        var newRecord = {};
        newRecord.id = data[i]._id;

        for (var k in attrs) {
          if (attrs.hasOwnProperty(k)) {
            var attr = attrs[k];
            attr.needUpdate = false;
            var names = attr.names;

            var values = self._getAttrValues(attr, record);

            if (names.length > 1) {
              // position 之类的生成多个字段的属性
              for (var j = 0; j < values.length; j++) {
                var val = values[j];
                var name = names[j];
                newRecord[name] = __WEBPACK_IMPORTED_MODULE_6__util___default.a.isArray(val) && val.length === 1 ? val[0] : val; // 只有一个值时返回第一个属性值
              }
            } else {
              newRecord[names[0]] = values.length === 1 ? values[0] : values;
            }
          }
        }

        mappedData.push(newRecord);
      }

      this.StyleData = mappedData;
      return mappedData;
    } // 更新地图映射

  }, {
    key: "_updateMaping",
    value: function _updateMaping() {
      var self = this;
      var attrs = self.get('attrs');
      var data = this.layerSource.propertiesData;

      for (var i = 0; i < data.length; i++) {
        var record = data[i];

        for (var attrName in attrs) {
          if (attrs.hasOwnProperty(attrName) && attrs[attrName].neadUpdate) {
            var attr = attrs[attrName];
            var names = attr.names;

            var values = self._getAttrValues(attr, record);

            if (names.length > 1) {
              // position 之类的生成多个字段的属性
              for (var j = 0; j < values.length; j++) {
                var val = values[j];
                var name = names[j];
                this.StyleData[i][name] = __WEBPACK_IMPORTED_MODULE_6__util___default.a.isArray(val) && val.length === 1 ? val[0] : val; // 只有一个值时返回第一个属性值
              }
            } else {
              this.StyleData[i][names[0]] = values.length === 1 ? values[0] : values;
            }

            attr.neadUpdate = true;
          }
        }
      }
    } // 获取属性映射的值

  }, {
    key: "_getAttrValues",
    value: function _getAttrValues(attr, record) {
      var scales = attr.scales;
      var params = [];

      for (var i = 0; i < scales.length; i++) {
        var scale = scales[i];
        var field = scale.field;

        if (scale.type === 'identity') {
          params.push(scale.value);
        } else {
          params.push(record[field]);
        }
      }

      var indexZoom = params.indexOf('zoom');
      indexZoom !== -1 ? params[indexZoom] = attr.zoom : null;
      var values = attr.mapping.apply(attr, params);
      return values;
    } // temp

  }, {
    key: "_getDataType",
    value: function _getDataType(data) {
      if (data.hasOwnProperty('type')) {
        var type = data.type;

        if (type === 'FeatureCollection') {
          return 'geojson';
        }
      }

      return 'basic';
    }
  }, {
    key: "_scaleByZoom",
    value: function _scaleByZoom() {
      var _this4 = this;

      if (this._zoomScale) {
        this.map.on('zoomend', function () {
          var zoom = _this4.map.getZoom();

          _this4._updateSize(Math.floor(zoom));
        });
      }
    }
  }, {
    key: "on",
    value: function on(type, callback) {
      this._addPickingEvents();

      _get(_getPrototypeOf(Layer.prototype), "on", this).call(this, type, callback);
    }
  }, {
    key: "getPickingId",
    value: function getPickingId() {
      return this.scene._engine._picking.getNextId();
    }
  }, {
    key: "addToPicking",
    value: function addToPicking(object) {
      this.scene._engine._picking.add(object);
    }
  }, {
    key: "removeFromPicking",
    value: function removeFromPicking(object) {
      this.scene._engine._picking.remove(object);
    }
  }, {
    key: "_addPickMesh",
    value: function _addPickMesh(mesh) {
      var _this5 = this;

      this._pickingMesh = new __WEBPACK_IMPORTED_MODULE_1__three__["Object3D"]();

      this._visibleWithZoom();

      this.scene.on('zoomchange', function () {
        _this5._visibleWithZoom();
      });
      this.addToPicking(this._pickingMesh);
      var pickmaterial = new __WEBPACK_IMPORTED_MODULE_4__core_engine_picking_pickingMaterial__["a" /* default */]({
        u_zoom: this.scene.getZoom()
      });
      var pickingMesh = new __WEBPACK_IMPORTED_MODULE_1__three__[mesh.type](mesh.geometry, pickmaterial);
      pickmaterial.setDefinesvalue(this.type, true);

      pickingMesh.onBeforeRender = function () {
        var zoom = _this5.scene.getZoom();

        pickingMesh.material.setUniformsValue('u_zoom', zoom);
      };

      this._pickingMesh.add(pickingMesh);
    }
  }, {
    key: "_setPickingId",
    value: function _setPickingId() {
      this._pickingId = this.getPickingId();
    }
  }, {
    key: "_addPickingEvents",
    value: function _addPickingEvents() {
      var _this6 = this;

      // TODO: Find a way to properly remove this listener on destroy
      this.scene.on('pick', function (e) {
        // Re-emit click event from the layer
        var featureId = e.featureId,
            point2d = e.point2d,
            intersects = e.intersects;

        if (intersects.length === 0) {
          return;
        }

        var source = _this6.layerSource.get('data');

        var feature = source.features[featureId];

        var lnglat = _this6.scene.containerToLngLat(point2d);

        var target = {
          feature: feature,
          pixel: point2d,
          lnglat: {
            lng: lnglat.lng,
            lat: lnglat.lat
          }
        };

        _this6.emit('click', target); // this.emit('move', target);

      });
    }
    /**
     * 更新active操作
     * @param {*} featureStyleId 需要更新的要素Id
     * @param {*} style  更新的要素样式
     */

  }, {
    key: "updateStyle",
    value: function updateStyle(featureStyleId, style) {
      if (this._activeIds) {
        this.resetStyle();
      }

      this._activeIds = featureStyleId;
      var pickingId = this.layerMesh.geometry.attributes.pickingId.array;
      var color = style.color;
      var colorAttr = this.layerMesh.geometry.attributes.a_color;
      var firstId = pickingId.indexOf(featureStyleId[0] + 1);

      for (var i = firstId; i < pickingId.length; i++) {
        if (pickingId[i] === featureStyleId[0] + 1) {
          colorAttr.array[i * 4 + 0] = color[0];
          colorAttr.array[i * 4 + 1] = color[1];
          colorAttr.array[i * 4 + 2] = color[2];
          colorAttr.array[i * 4 + 3] = color[3];
        } else {
          break;
        }
      }

      colorAttr.needsUpdate = true;
      return;
    }
  }, {
    key: "_updateColor",
    value: function _updateColor() {
      this._updateMaping();
    }
    /**
    * 用于过滤数据
    * @param {*} filterData  数据过滤标识符
    */

  }, {
    key: "_updateFilter",
    value: function _updateFilter() {
      var _this7 = this;

      this._updateMaping();

      var filterData = this.StyleData;
      this._activeIds = null; // 清空选中元素

      var colorAttr = this.layerMesh.geometry.attributes.a_color;
      var pickAttr = this.layerMesh.geometry.attributes.pickingId;
      pickAttr.array.forEach(function (id, index) {
        id = Math.abs(id);

        var color = _toConsumableArray(_this7.StyleData[id - 1].color);

        id = Math.abs(id);
        var item = filterData[id - 1];

        if (item.hasOwnProperty('filter') && item.filter === false) {
          colorAttr.array[index * 4 + 0] = 0;
          colorAttr.array[index * 4 + 1] = 0;
          colorAttr.array[index * 4 + 2] = 0;
          colorAttr.array[index * 4 + 3] = 0;
          pickAttr.array[index] = -id;
        } else {
          colorAttr.array[index * 4 + 0] = color[0];
          colorAttr.array[index * 4 + 1] = color[1];
          colorAttr.array[index * 4 + 2] = color[2];
          colorAttr.array[index * 4 + 3] = color[3];
          pickAttr.array[index] = id;
        }
      });
      colorAttr.needsUpdate = true;
      pickAttr.needsUpdate = true;
      this._needUpdateFilter = false;
      this._needUpdateColor = false;
    }
  }, {
    key: "_visibleWithZoom",
    value: function _visibleWithZoom() {
      var zoom = this.scene.getZoom();
      var minZoom = this.get('minZoom');
      var maxZoom = this.get('maxZoom'); // z-fighting

      var offset = 0;

      if (this.type === 'point') {
        offset = 5;
      } else if (this.type === 'polyline') {
        offset = 2;
      }

      this._object3D.position.z = offset * Math.pow(2, 20 - zoom);

      if (zoom < minZoom || zoom > maxZoom) {
        this._object3D.visible = false;
      } else if (this.get('visible')) {
        this._object3D.visible = true;
      }
    }
    /**
     * 重置高亮要素
     */

  }, {
    key: "resetStyle",
    value: function resetStyle() {
      var _this8 = this;

      var pickingId = this.layerMesh.geometry.attributes.pickingId.array;
      var colorAttr = this.layerMesh.geometry.attributes.a_color;

      this._activeIds.forEach(function (index) {
        var color = _this8.StyleData[index].color;
        var firstId = pickingId.indexOf(index + 1);

        for (var i = firstId; i < pickingId.length; i++) {
          if (pickingId[i] === index + 1) {
            colorAttr.array[i * 4 + 0] = color[0];
            colorAttr.array[i * 4 + 1] = color[1];
            colorAttr.array[i * 4 + 2] = color[2];
            colorAttr.array[i * 4 + 3] = color[3];
          }
        }
      });

      colorAttr.needsUpdate = true;
    }
    /**
     * 销毁Layer对象
     */

  }, {
    key: "despose",
    value: function despose() {
      this.destroy();

      if (this._object3D && this._object3D.children) {
        var child;

        for (var i = 0; i < this._object3D.children.length; i++) {
          child = this._object3D.children[i];

          if (!child) {
            continue;
          }

          this.remove(child);

          if (child.geometry) {
            child.geometry.dispose();
            child.geometry = null;
          }

          if (child.material) {
            if (child.material.map) {
              child.material.map.dispose();
              child.material.map = null;
            }

            child.material.dispose();
            child.material = null;
          }
        }
      }

      this._object3D = null;
      this.scene = null;
    }
  }]);

  return Layer;
}(__WEBPACK_IMPORTED_MODULE_0__base__["a" /* default */]);



/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_wolfy87_eventemitter__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_wolfy87_eventemitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_wolfy87_eventemitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__util__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview Chart、View、Geometry 的基类
 * @author dxq613@gmail.com
 */



var Base =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Base, _EventEmitter);

  _createClass(Base, [{
    key: "getDefaultCfg",
    value: function getDefaultCfg() {
      return {};
    }
  }]);

  function Base(cfg) {
    var _this;

    _classCallCheck(this, Base);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Base).call(this));
    var attrs = {
      visible: true
    };

    var defaultCfg = _this.getDefaultCfg();

    _this._attrs = attrs;
    __WEBPACK_IMPORTED_MODULE_1__util___default.a.assign(attrs, defaultCfg, cfg);
    return _this;
  }

  _createClass(Base, [{
    key: "get",
    value: function get(name) {
      return this._attrs[name];
    }
  }, {
    key: "set",
    value: function set(name, value) {
      this._attrs[name] = value;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._attrs = {};
      this.removeAllListeners();
      this.destroyed = true;
    }
  }]);

  return Base;
}(__WEBPACK_IMPORTED_MODULE_0_wolfy87_eventemitter___default.a);

/* harmony default export */ __webpack_exports__["a"] = (Base);

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Source; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geo_project__ = __webpack_require__(267);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/*
 * @Author: ThinkGIS
 * @Date: 2018-06-08 11:19:06
 * @Last Modified by: mikey.zhaopeng
 * @Last Modified time: 2018-11-01 11:50:43
 */


var Controller = __webpack_require__(257);



var Source =
/*#__PURE__*/
function (_Base) {
  _inherits(Source, _Base);

  _createClass(Source, [{
    key: "getDefaultCfg",
    value: function getDefaultCfg() {
      return {
        data: null,
        defs: {},
        scales: {},
        options: {}
      };
    }
  }]);

  function Source(cfg) {
    var _this;

    _classCallCheck(this, Source);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Source).call(this, cfg));

    _this._initControllers();

    _this.prepareData();

    return _this;
  } // 标准化数据


  _createClass(Source, [{
    key: "prepareData",
    value: function prepareData() {
      var _this2 = this;

      var data = this.get('data');
      this.propertiesData = []; // 临时使用

      this.geoData = [];
      data.coordinates.forEach(function (geo) {
        var coord = _this2._coordProject(geo);

        _this2.geoData.push(coord);

        _this2.propertiesData.push([]);
      });
    }
  }, {
    key: "createScale",
    value: function createScale(field) {
      var data = this.propertiesData;
      var scales = this.get('scales');
      var scale = scales[field];
      var scaleController = this.get('scaleController');

      if (!scale) {
        scale = scaleController.createScale(field, data);
        scales[field] = scale;
      }

      return scale;
    }
  }, {
    key: "_initControllers",
    value: function _initControllers() {
      var defs = this.get('defs');
      var scaleController = new Controller.Scale({
        defs: defs
      });
      this.set('scaleController', scaleController);
    }
  }, {
    key: "_getCoord",
    value: function _getCoord(geo) {
      if (geo.geometry) {
        // GeoJSON feature
        geo = geo.geometry.coordinates;
      } else if (geo.coordinates) {
        // GeoJSON geometry
        geo = geo.coordinates;
      }

      return geo;
    }
  }, {
    key: "_coordProject",
    value: function _coordProject(geo) {
      var _this3 = this;

      if (Array.isArray(geo[0][0])) {
        return geo.map(function (coor) {
          return _this3._coordProject(coor);
        });
      }

      if (!Array.isArray(geo[0])) {
        return this._coorConvert(geo);
      }

      return geo.map(function (coor) {
        return _this3._coorConvert(coor);
      });
    }
  }, {
    key: "_coorConvert",
    value: function _coorConvert(geo) {
      var ll = Object(__WEBPACK_IMPORTED_MODULE_1__geo_project__["a" /* aProjectFlat */])(geo);
      return [ll.x, -ll.y, geo[2] || 0];
    }
  }]);

  return Source;
}(__WEBPACK_IMPORTED_MODULE_0__base__["a" /* default */]);



/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Quaternion; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Math_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Vector3_js__ = __webpack_require__(0);


/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion(x, y, z, w) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = w !== undefined ? w : 1;
}

Object.assign(Quaternion, {
  slerp: function (qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  },
  slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    var x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3],
        x1 = src1[srcOffset1 + 0],
        y1 = src1[srcOffset1 + 1],
        z1 = src1[srcOffset1 + 2],
        w1 = src1[srcOffset1 + 3];

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      var s = 1 - t,
          cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
          dir = cos >= 0 ? 1 : -1,
          sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        var sin = Math.sqrt(sqrSin),
            len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      var tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
});
Object.defineProperties(Quaternion.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (value) {
      this._x = value;
      this.onChangeCallback();
    }
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (value) {
      this._y = value;
      this.onChangeCallback();
    }
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (value) {
      this._z = value;
      this.onChangeCallback();
    }
  },
  w: {
    get: function () {
      return this._w;
    },
    set: function (value) {
      this._w = value;
      this.onChangeCallback();
    }
  }
});
Object.assign(Quaternion.prototype, {
  set: function (x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this.onChangeCallback();
    return this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function (quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this.onChangeCallback();
    return this;
  },
  setFromEuler: function (euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    var x = euler._x,
        y = euler._y,
        z = euler._z,
        order = euler.order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    var cos = Math.cos;
    var sin = Math.sin;
    var c1 = cos(x / 2);
    var c2 = cos(y / 2);
    var c3 = cos(z / 2);
    var s1 = sin(x / 2);
    var s2 = sin(y / 2);
    var s3 = sin(z / 2);

    if (order === 'XYZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'YXZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'ZXY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'ZYX') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'YZX') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'XZY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    }

    if (update !== false) this.onChangeCallback();
    return this;
  },
  setFromAxisAngle: function (axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    var halfAngle = angle / 2,
        s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function (m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    var te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10],
        trace = m11 + m22 + m33,
        s;

    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this.onChangeCallback();
    return this;
  },
  setFromUnitVectors: function () {
    // assumes direction vectors vFrom and vTo are normalized
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
    var r;
    var EPS = 0.000001;
    return function setFromUnitVectors(vFrom, vTo) {
      if (v1 === undefined) v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
      r = vFrom.dot(vTo) + 1;

      if (r < EPS) {
        r = 0;

        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          v1.set(-vFrom.y, vFrom.x, 0);
        } else {
          v1.set(0, -vFrom.z, vFrom.y);
        }
      } else {
        v1.crossVectors(vFrom, vTo);
      }

      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;
      return this.normalize();
    };
  }(),
  angleTo: function (q) {
    return 2 * Math.acos(Math.abs(__WEBPACK_IMPORTED_MODULE_0__Math_js__["a" /* _Math */].clamp(this.dot(q), -1, 1)));
  },
  rotateTowards: function (q, step) {
    var angle = this.angleTo(q);
    if (angle === 0) return this;
    var t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  },
  inverse: function () {
    // quaternion is assumed to have unit length
    return this.conjugate();
  },
  conjugate: function () {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this.onChangeCallback();
    return this;
  },
  dot: function (v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    var l = this.length();

    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this.onChangeCallback();
    return this;
  },
  multiply: function (q, p) {
    if (p !== undefined) {
      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }

    return this.multiplyQuaternions(this, q);
  },
  premultiply: function (q) {
    return this.multiplyQuaternions(q, this);
  },
  multiplyQuaternions: function (a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    var qax = a._x,
        qay = a._y,
        qaz = a._z,
        qaw = a._w;
    var qbx = b._x,
        qby = b._y,
        qbz = b._z,
        qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this.onChangeCallback();
    return this;
  },
  slerp: function (qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    var x = this._x,
        y = this._y,
        z = this._z,
        w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }

    var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      var s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      return this.normalize();
    }

    var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
        ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this.onChangeCallback();
    return this;
  },
  equals: function (quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this.onChangeCallback();
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  },
  onChange: function (callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function () {}
});


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Ray; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector3_js__ = __webpack_require__(0);

/**
 * @author bhouston / http://clara.io
 */

function Ray(origin, direction) {
  this.origin = origin !== undefined ? origin : new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
  this.direction = direction !== undefined ? direction : new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
}

Object.assign(Ray.prototype, {
  set: function (origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  },
  at: function (t, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .at() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    }

    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  lookAt: function (v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  },
  recast: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function recast(t) {
      this.origin.copy(this.at(t, v1));
      return this;
    };
  }(),
  closestPointToPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .closestPointToPoint() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    }

    target.subVectors(point, this.origin);
    var directionDistance = target.dot(this.direction);

    if (directionDistance < 0) {
      return target.copy(this.origin);
    }

    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },
  distanceToPoint: function (point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  },
  distanceSqToPoint: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function distanceSqToPoint(point) {
      var directionDistance = v1.subVectors(point, this.origin).dot(this.direction); // point behind the ray

      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }

      v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return v1.distanceToSquared(point);
    };
  }(),
  distanceSqToSegment: function () {
    var segCenter = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var segDir = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var diff = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment
      segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      segDir.copy(v1).sub(v0).normalize();
      diff.copy(this.origin).sub(segCenter);
      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(segDir);
      var b0 = diff.dot(this.direction);
      var b1 = -diff.dot(segDir);
      var c = diff.lengthSq();
      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;

      if (det > 0) {
        // The ray and segment are not parallel.
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;

        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              // region 0
              // Minimum at interior points of ray and segment.
              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              // region 1
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            // region 5
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            // region 4
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            // region 3
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            // region 2
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        // Ray and segment are parallel.
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }

      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }

      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
      }

      return sqrDist;
    };
  }(),
  intersectSphere: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function intersectSphere(sphere, target) {
      v1.subVectors(sphere.center, this.origin);
      var tca = v1.dot(this.direction);
      var d2 = v1.dot(v1) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) return null;
      var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

      var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

      var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

      if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.

      if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

      return this.at(t0, target);
    };
  }(),
  intersectsSphere: function (sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  },
  distanceToPlane: function (plane) {
    var denominator = plane.normal.dot(this.direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      } // Null is preferable to undefined since undefined means.... it is undefined


      return null;
    }

    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

    return t >= 0 ? t : null;
  },
  intersectPlane: function (plane, target) {
    var t = this.distanceToPlane(plane);

    if (t === null) {
      return null;
    }

    return this.at(t, target);
  },
  intersectsPlane: function (plane) {
    // check if the ray lies on the plane first
    var distToPoint = plane.distanceToPoint(this.origin);

    if (distToPoint === 0) {
      return true;
    }

    var denominator = plane.normal.dot(this.direction);

    if (denominator * distToPoint < 0) {
      return true;
    } // ray origin is behind the plane (and is pointing behind it)


    return false;
  },
  intersectBox: function (box, target) {
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    var invdirx = 1 / this.direction.x,
        invdiry = 1 / this.direction.y,
        invdirz = 1 / this.direction.z;
    var origin = this.origin;

    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }

    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }

    if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if (tymin > tmin || tmin !== tmin) tmin = tymin;
    if (tymax < tmax || tmax !== tmax) tmax = tymax;

    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }

    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  },
  intersectsBox: function () {
    var v = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function intersectsBox(box) {
      return this.intersectBox(box, v) !== null;
    };
  }(),
  intersectTriangle: function () {
    // Compute the offset origin, edges, and normal.
    var diff = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var edge1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var edge2 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var normal = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function intersectTriangle(a, b, c, backfaceCulling, target) {
      // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
      edge1.subVectors(b, a);
      edge2.subVectors(c, a);
      normal.crossVectors(edge1, edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)

      var DdN = this.direction.dot(normal);
      var sign;

      if (DdN > 0) {
        if (backfaceCulling) return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }

      diff.subVectors(this.origin, a);
      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2)); // b1 < 0, no intersection

      if (DdQxE2 < 0) {
        return null;
      }

      var DdE1xQ = sign * this.direction.dot(edge1.cross(diff)); // b2 < 0, no intersection

      if (DdE1xQ < 0) {
        return null;
      } // b1+b2 > 1, no intersection


      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      } // Line intersects triangle, check if ray does.


      var QdN = -sign * diff.dot(normal); // t < 0, no intersection

      if (QdN < 0) {
        return null;
      } // Ray intersects triangle.


      return this.at(QdN / DdN, target);
    };
  }(),
  applyMatrix4: function (matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  },
  equals: function (ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
});


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PerspectiveCamera; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Camera_js__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Object3D_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Math_js__ = __webpack_require__(6);



/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera(fov, aspect, near, far) {
  __WEBPACK_IMPORTED_MODULE_0__Camera_js__["a" /* Camera */].call(this);
  this.type = 'PerspectiveCamera';
  this.fov = fov !== undefined ? fov : 50;
  this.zoom = 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.focus = 10;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.view = null;
  this.filmGauge = 35; // width of the film (default in millimeters)

  this.filmOffset = 0; // horizontal film offset (same unit as gauge)

  this.updateProjectionMatrix();
}

PerspectiveCamera.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__Camera_js__["a" /* Camera */].prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function (source, recursive) {
    __WEBPACK_IMPORTED_MODULE_0__Camera_js__["a" /* Camera */].prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },

  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function (focalLength) {
    // see http://www.bobatkins.com/photography/technical/field_of_view.html
    var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = __WEBPACK_IMPORTED_MODULE_2__math_Math_js__["a" /* _Math */].RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },

  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function () {
    var vExtentSlope = Math.tan(__WEBPACK_IMPORTED_MODULE_2__math_Math_js__["a" /* _Math */].DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function () {
    return __WEBPACK_IMPORTED_MODULE_2__math_Math_js__["a" /* _Math */].RAD2DEG * 2 * Math.atan(Math.tan(__WEBPACK_IMPORTED_MODULE_2__math_Math_js__["a" /* _Math */].DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function () {
    // film not completely covered in portrait format (aspect < 1)
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function () {
    // film not completely covered in landscape format (aspect > 1)
    return this.filmGauge / Math.max(this.aspect, 1);
  },

  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   var w = 1920;
   *   var h = 1080;
   *   var fullWidth = w * 3;
   *   var fullHeight = h * 2;
   *
   *   --A--
   *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;

    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    var near = this.near,
        top = near * Math.tan(__WEBPACK_IMPORTED_MODULE_2__math_Math_js__["a" /* _Math */].DEG2RAD * 0.5 * this.fov) / this.zoom,
        height = 2 * top,
        width = this.aspect * height,
        left = -0.5 * width,
        view = this.view;

    if (this.view !== null && this.view.enabled) {
      var fullWidth = view.fullWidth,
          fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }

    var skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (meta) {
    var data = __WEBPACK_IMPORTED_MODULE_1__core_Object3D_js__["a" /* Object3D */].prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileOverview the base class of scale
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(1);
/**
 * 度量的构造函数
 * @class Scale
 */


var Scale =
/*#__PURE__*/
function () {
  _createClass(Scale, [{
    key: "getDefaultCfg",

    /**
     * 获取默认的配置属性
     * @protected
     * @return {Object} 默认属性
     */
    value: function getDefaultCfg() {
      return {
        /**
         * type of the scale
         * @type {String}
         */
        type: 'base',

        /**
         * 格式化函数,输出文本或者tick时的格式化函数
         * @type {Function}
         */
        formatter: null,

        /**
         * 输出的值域
         * @type {Array}
         */
        range: [0, 1],

        /**
         * 度量的标记
         * @type {Array}
         */
        ticks: null,

        /**
         * 参与度量计算的值，可选项
         * @type {Array}
         */
        values: []
      };
    }
  }]);

  function Scale(cfg) {
    _classCallCheck(this, Scale);

    var defaultCfg = this.getDefaultCfg();
    Util.mix(this, defaultCfg, cfg);
    this.init();
  }
  /**
   * 度量初始化
   * @protected
   */


  _createClass(Scale, [{
    key: "init",
    value: function init() {}
    /**
     * 获取该度量的ticks,返回的是多个对象，
     *   - text: tick 的文本
     *   - value: 对应的度量转换后的值
     * <code>
     *   [
     *     {text: 0,value:0}
     *     {text: 1,value:0.2}
     *     {text: 2,value:0.4}
     *     {text: 3,value:0.6}
     *     {text: 4,value:0.8}
     *     {text: 5,value:1}
     *   ]
     * </code>
     * @param {Number} count 输出tick的个数的近似值，默认是 10
     * @return {Array} 返回 ticks 数组
     */

  }, {
    key: "getTicks",
    value: function getTicks() {
      var self = this;
      var ticks = self.ticks;
      var rst = [];
      Util.each(ticks, function (tick) {
        var obj;

        if (Util.isObject(tick)) {
          obj = tick;
        } else {
          obj = {
            text: self.getText(tick),
            tickValue: tick,
            value: self.scale(tick)
          };
        }

        rst.push(obj);
      });
      return rst;
    }
    /**
     * 获取格式化后的文本
     * @param  {*} value 输入的数据
     * @return {String} 格式化的文本
     */

  }, {
    key: "getText",
    value: function getText(value) {
      var formatter = this.formatter;
      value = formatter ? formatter(value) : value;

      if (Util.isNil(value) || !value.toString) {
        value = '';
      }

      return value.toString();
    }
    /**
     * 输出的值域最小值
     * @protected
     * @return {Number} 返回最小的值
     */

  }, {
    key: "rangeMin",
    value: function rangeMin() {
      return this.range[0];
    }
    /**
     * 输出的值域最大值
     * @protected
     * @return {Number} 返回最大的值
     */

  }, {
    key: "rangeMax",
    value: function rangeMax() {
      var range = this.range;
      return range[range.length - 1];
    }
    /**
     * 度量转换后的结果，翻转回输入域
     * @param  {Number} value 需要翻转的数值
     * @return {*} 度量的输入值
     */

  }, {
    key: "invert",
    value: function invert(value) {
      return value;
    }
    /**
     * 将传入的值从非数值转换成数值格式，如分类字符串、时间字符串等
     * @param  {*} value 传入的值
     * @return {Number} 转换的值
     */

  }, {
    key: "translate",
    value: function translate(value) {
      return value;
    }
    /**
     * 进行度量转换
     * @param  {*} value 输入值
     * @return {Number} 输出值，在设定的输出值域之间，默认[0,1]
     */

  }, {
    key: "scale",
    value: function scale(value) {
      return value;
    }
    /**
     * 克隆一个新的scale,拥有跟当前scale相同的输入域、输出域等
     * @return {Scale} 克隆的度量
     */

  }, {
    key: "clone",
    value: function clone() {
      var self = this;
      var constr = self.constructor;
      var cfg = {};
      Util.each(self, function (v, k) {
        cfg[k] = self[k];
      });
      return new constr(cfg);
    }
    /**
     * 更改度量的属性信息
     * @param  {Object} info 属性信息
     * @chainable
     * @return {Scale} 返回自身的引用
     */

  }, {
    key: "change",
    value: function change(info) {
      this.ticks = null;
      Util.mix(this, info);
      this.init();
      return this;
    }
  }]);

  return Scale;
}();

module.exports = Scale;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview The measurement of linear data scale function
 * @author dxq613@gmail.com
 */
var Base = __webpack_require__(27);

var Util = __webpack_require__(1);

var numberAuto = __webpack_require__(260);
/**
 * 线性度量
 * @class Scale.Linear
 */


var Linear =
/*#__PURE__*/
function (_Base) {
  _inherits(Linear, _Base);

  function Linear() {
    _classCallCheck(this, Linear);

    return _possibleConstructorReturn(this, _getPrototypeOf(Linear).apply(this, arguments));
  }

  _createClass(Linear, [{
    key: "getDefaultCfg",

    /**
     * @override
     */
    value: function getDefaultCfg() {
      var cfg = _get(_getPrototypeOf(Linear.prototype), "getDefaultCfg", this).call(this);

      return Util.mix({}, cfg, {
        /**
         * type of the scale
         * @type {String}
         */
        type: 'linear',

        /**
         * 是否线性
         * @type {Boolean}
         * @readOnly
         * @default true
         */
        isLinear: true,

        /**
         * min value of the scale
         * @type {Number}
         * @default null
         */
        min: null,

        /**
         * min value limitted of the scale
         * @type {Number}
         * @default null
         */
        minLimit: null,

        /**
         * max value of the scale
         * @type {Number}
         * @default null
         */
        max: null,

        /**
         * max value limitted of the scale
         * @type {Number}
         * @default null
         */
        maxLimit: null,

        /**
         * 是否为了用户习惯，优化min,max和ticks，如果进行优化，则会根据生成的ticks调整min,max，否则舍弃(min,max)范围之外的ticks
         * @type {Boolean}
         * @default false
         */
        nice: false,

        /**
         * 自动生成标记时的个数
         * @type {Number}
         * @default null
         */
        tickCount: null,

        /**
         * 坐标轴点之间的间距，指的是真实数据的差值
         * @type {Number}
         * @default null
         */
        tickInterval: null,

        /**
         * 用于计算坐标点时逼近的数组
         * @type {Array}
         */
        snapArray: null
      });
    }
    /**
     * @protected
     * @override
     */

  }, {
    key: "init",
    value: function init() {
      var self = this;

      if (!self.ticks) {
        self.min = self.translate(self.min);
        self.max = self.translate(self.max);
        self.initTicks();
      } else {
        var ticks = self.ticks;
        var firstValue = self.translate(ticks[0]);
        var lastValue = self.translate(ticks[ticks.length - 1]);

        if (Util.isNil(self.min) || self.min > firstValue) {
          self.min = firstValue;
        }

        if (Util.isNil(self.max) || self.max < lastValue) {
          self.max = lastValue;
        }
      }
    }
    /**
     * 计算坐标点
     * @protected
     * @return {Array} 计算完成的坐标点
     */

  }, {
    key: "calculateTicks",
    value: function calculateTicks() {
      var self = this;
      var min = self.min;
      var max = self.max;
      var count = self.tickCount;
      var interval = self.tickInterval;

      if (max < min) {
        throw new Error("max: ".concat(max, " should not be less than min: ").concat(min));
      }

      var tmp = numberAuto({
        min: min,
        max: max,
        minLimit: self.minLimit,
        maxLimit: self.maxLimit,
        minCount: count,
        maxCount: count,
        interval: interval,
        snapArray: this.snapArray
      });
      return tmp.ticks;
    } // 初始化ticks

  }, {
    key: "initTicks",
    value: function initTicks() {
      var self = this;
      var calTicks = self.calculateTicks();

      if (self.nice) {
        // 如果需要优化显示的tick
        self.ticks = calTicks;
        self.min = calTicks[0];
        self.max = calTicks[calTicks.length - 1];
      } else {
        var ticks = [];
        Util.each(calTicks, function (tick) {
          if (tick >= self.min && tick <= self.max) {
            ticks.push(tick);
          }
        }); // 如果 ticks 为空，直接输入最小值、最大值

        if (!ticks.length) {
          ticks.push(self.min);
          ticks.push(self.max);
        }

        self.ticks = ticks;
      }
    }
    /**
     * @override
     */

  }, {
    key: "scale",
    value: function scale(value) {
      if (value === null || value === undefined) {
        return NaN;
      }

      var max = this.max;
      var min = this.min;

      if (max === min) {
        return 0;
      }

      var percent = (value - min) / (max - min);
      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      return rangeMin + percent * (rangeMax - rangeMin);
    }
    /**
     * @override
     */

  }, {
    key: "invert",
    value: function invert(value) {
      var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
      return this.min + percent * (this.max - this.min);
    }
  }]);

  return Linear;
}(Base);

module.exports = Linear;

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__point__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polygon__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__line__ = __webpack_require__(288);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__point__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__polygon__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__line__; });





/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * EventEmitter v5.2.5 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - http://oli.me.uk/
 * @preserve
 */
;

(function (exports) {
  'use strict';
  /**
   * Class for managing events.
   * Can be extended to provide event functionality in other classes.
   *
   * @class EventEmitter Manages event registering and emitting.
   */

  function EventEmitter() {} // Shortcuts to improve speed and size


  var proto = EventEmitter.prototype;
  var originalGlobalValue = exports.EventEmitter;
  /**
   * Finds the index of the listener for the event in its storage array.
   *
   * @param {Function[]} listeners Array of listeners to search through.
   * @param {Function} listener Method to look for.
   * @return {Number} Index of the specified listener, -1 if not found
   * @api private
   */

  function indexOfListener(listeners, listener) {
    var i = listeners.length;

    while (i--) {
      if (listeners[i].listener === listener) {
        return i;
      }
    }

    return -1;
  }
  /**
   * Alias a method while keeping the context correct, to allow for overwriting of target method.
   *
   * @param {String} name The name of the target method.
   * @return {Function} The aliased method
   * @api private
   */


  function alias(name) {
    return function aliasClosure() {
      return this[name].apply(this, arguments);
    };
  }
  /**
   * Returns the listener array for the specified event.
   * Will initialise the event object and listener arrays if required.
   * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
   * Each property in the object response is an array of listener functions.
   *
   * @param {String|RegExp} evt Name of the event to return the listeners from.
   * @return {Function[]|Object} All listener functions for the event.
   */


  proto.getListeners = function getListeners(evt) {
    var events = this._getEvents();

    var response;
    var key; // Return a concatenated array of all matching events if
    // the selector is a regular expression.

    if (evt instanceof RegExp) {
      response = {};

      for (key in events) {
        if (events.hasOwnProperty(key) && evt.test(key)) {
          response[key] = events[key];
        }
      }
    } else {
      response = events[evt] || (events[evt] = []);
    }

    return response;
  };
  /**
   * Takes a list of listener objects and flattens it into a list of listener functions.
   *
   * @param {Object[]} listeners Raw listener objects.
   * @return {Function[]} Just the listener functions.
   */


  proto.flattenListeners = function flattenListeners(listeners) {
    var flatListeners = [];
    var i;

    for (i = 0; i < listeners.length; i += 1) {
      flatListeners.push(listeners[i].listener);
    }

    return flatListeners;
  };
  /**
   * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
   *
   * @param {String|RegExp} evt Name of the event to return the listeners from.
   * @return {Object} All listener functions for an event in an object.
   */


  proto.getListenersAsObject = function getListenersAsObject(evt) {
    var listeners = this.getListeners(evt);
    var response;

    if (listeners instanceof Array) {
      response = {};
      response[evt] = listeners;
    }

    return response || listeners;
  };

  function isValidListener(listener) {
    if (typeof listener === 'function' || listener instanceof RegExp) {
      return true;
    } else if (listener && typeof listener === 'object') {
      return isValidListener(listener.listener);
    } else {
      return false;
    }
  }
  /**
   * Adds a listener function to the specified event.
   * The listener will not be added if it is a duplicate.
   * If the listener returns true then it will be removed after it is called.
   * If you pass a regular expression as the event name then the listener will be added to all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to attach the listener to.
   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
   * @return {Object} Current instance of EventEmitter for chaining.
   */


  proto.addListener = function addListener(evt, listener) {
    if (!isValidListener(listener)) {
      throw new TypeError('listener must be a function');
    }

    var listeners = this.getListenersAsObject(evt);
    var listenerIsWrapped = typeof listener === 'object';
    var key;

    for (key in listeners) {
      if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
        listeners[key].push(listenerIsWrapped ? listener : {
          listener: listener,
          once: false
        });
      }
    }

    return this;
  };
  /**
   * Alias of addListener
   */


  proto.on = alias('addListener');
  /**
   * Semi-alias of addListener. It will add a listener that will be
   * automatically removed after its first execution.
   *
   * @param {String|RegExp} evt Name of the event to attach the listener to.
   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
   * @return {Object} Current instance of EventEmitter for chaining.
   */

  proto.addOnceListener = function addOnceListener(evt, listener) {
    return this.addListener(evt, {
      listener: listener,
      once: true
    });
  };
  /**
   * Alias of addOnceListener.
   */


  proto.once = alias('addOnceListener');
  /**
   * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
   * You need to tell it what event names should be matched by a regex.
   *
   * @param {String} evt Name of the event to create.
   * @return {Object} Current instance of EventEmitter for chaining.
   */

  proto.defineEvent = function defineEvent(evt) {
    this.getListeners(evt);
    return this;
  };
  /**
   * Uses defineEvent to define multiple events.
   *
   * @param {String[]} evts An array of event names to define.
   * @return {Object} Current instance of EventEmitter for chaining.
   */


  proto.defineEvents = function defineEvents(evts) {
    for (var i = 0; i < evts.length; i += 1) {
      this.defineEvent(evts[i]);
    }

    return this;
  };
  /**
   * Removes a listener function from the specified event.
   * When passed a regular expression as the event name, it will remove the listener from all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to remove the listener from.
   * @param {Function} listener Method to remove from the event.
   * @return {Object} Current instance of EventEmitter for chaining.
   */


  proto.removeListener = function removeListener(evt, listener) {
    var listeners = this.getListenersAsObject(evt);
    var index;
    var key;

    for (key in listeners) {
      if (listeners.hasOwnProperty(key)) {
        index = indexOfListener(listeners[key], listener);

        if (index !== -1) {
          listeners[key].splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Alias of removeListener
   */


  proto.off = alias('removeListener');
  /**
   * Adds listeners in bulk using the manipulateListeners method.
   * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
   * You can also pass it a regular expression to add the array of listeners to all events that match it.
   * Yeah, this function does quite a bit. That's probably a bad thing.
   *
   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
   * @param {Function[]} [listeners] An optional array of listener functions to add.
   * @return {Object} Current instance of EventEmitter for chaining.
   */

  proto.addListeners = function addListeners(evt, listeners) {
    // Pass through to manipulateListeners
    return this.manipulateListeners(false, evt, listeners);
  };
  /**
   * Removes listeners in bulk using the manipulateListeners method.
   * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
   * You can also pass it an event name and an array of listeners to be removed.
   * You can also pass it a regular expression to remove the listeners from all events that match it.
   *
   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
   * @param {Function[]} [listeners] An optional array of listener functions to remove.
   * @return {Object} Current instance of EventEmitter for chaining.
   */


  proto.removeListeners = function removeListeners(evt, listeners) {
    // Pass through to manipulateListeners
    return this.manipulateListeners(true, evt, listeners);
  };
  /**
   * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
   * The first argument will determine if the listeners are removed (true) or added (false).
   * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
   * You can also pass it an event name and an array of listeners to be added/removed.
   * You can also pass it a regular expression to manipulate the listeners of all events that match it.
   *
   * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
   * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
   * @return {Object} Current instance of EventEmitter for chaining.
   */


  proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
    var i;
    var value;
    var single = remove ? this.removeListener : this.addListener;
    var multiple = remove ? this.removeListeners : this.addListeners; // If evt is an object then pass each of its properties to this method

    if (typeof evt === 'object' && !(evt instanceof RegExp)) {
      for (i in evt) {
        if (evt.hasOwnProperty(i) && (value = evt[i])) {
          // Pass the single listener straight through to the singular method
          if (typeof value === 'function') {
            single.call(this, i, value);
          } else {
            // Otherwise pass back to the multiple function
            multiple.call(this, i, value);
          }
        }
      }
    } else {
      // So evt must be a string
      // And listeners must be an array of listeners
      // Loop over it and pass each one to the multiple method
      i = listeners.length;

      while (i--) {
        single.call(this, evt, listeners[i]);
      }
    }

    return this;
  };
  /**
   * Removes all listeners from a specified event.
   * If you do not specify an event then all listeners will be removed.
   * That means every event will be emptied.
   * You can also pass a regex to remove all events that match it.
   *
   * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
   * @return {Object} Current instance of EventEmitter for chaining.
   */


  proto.removeEvent = function removeEvent(evt) {
    var type = typeof evt;

    var events = this._getEvents();

    var key; // Remove different things depending on the state of evt

    if (type === 'string') {
      // Remove all listeners for the specified event
      delete events[evt];
    } else if (evt instanceof RegExp) {
      // Remove all events matching the regex.
      for (key in events) {
        if (events.hasOwnProperty(key) && evt.test(key)) {
          delete events[key];
        }
      }
    } else {
      // Remove all listeners in all events
      delete this._events;
    }

    return this;
  };
  /**
   * Alias of removeEvent.
   *
   * Added to mirror the node API.
   */


  proto.removeAllListeners = alias('removeEvent');
  /**
   * Emits an event of your choice.
   * When emitted, every listener attached to that event will be executed.
   * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
   * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
   * So they will not arrive within the array on the other side, they will be separate.
   * You can also pass a regular expression to emit to all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
   * @param {Array} [args] Optional array of arguments to be passed to each listener.
   * @return {Object} Current instance of EventEmitter for chaining.
   */

  proto.emitEvent = function emitEvent(evt, args) {
    var listenersMap = this.getListenersAsObject(evt);
    var listeners;
    var listener;
    var i;
    var key;
    var response;

    for (key in listenersMap) {
      if (listenersMap.hasOwnProperty(key)) {
        listeners = listenersMap[key].slice(0);

        for (i = 0; i < listeners.length; i++) {
          // If the listener returns true then it shall be removed from the event
          // The function is executed either with a basic call or an apply if there is an args array
          listener = listeners[i];

          if (listener.once === true) {
            this.removeListener(evt, listener.listener);
          }

          response = listener.listener.apply(this, args || []);

          if (response === this._getOnceReturnValue()) {
            this.removeListener(evt, listener.listener);
          }
        }
      }
    }

    return this;
  };
  /**
   * Alias of emitEvent
   */


  proto.trigger = alias('emitEvent');
  /**
   * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
   * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
   * @param {...*} Optional additional arguments to be passed to each listener.
   * @return {Object} Current instance of EventEmitter for chaining.
   */

  proto.emit = function emit(evt) {
    var args = Array.prototype.slice.call(arguments, 1);
    return this.emitEvent(evt, args);
  };
  /**
   * Sets the current value to check against when executing listeners. If a
   * listeners return value matches the one set here then it will be removed
   * after execution. This value defaults to true.
   *
   * @param {*} value The new value to check for when executing listeners.
   * @return {Object} Current instance of EventEmitter for chaining.
   */


  proto.setOnceReturnValue = function setOnceReturnValue(value) {
    this._onceReturnValue = value;
    return this;
  };
  /**
   * Fetches the current value to check against when executing listeners. If
   * the listeners return value matches this one then it should be removed
   * automatically. It will return true by default.
   *
   * @return {*|Boolean} The current value to check for or the default, true.
   * @api private
   */


  proto._getOnceReturnValue = function _getOnceReturnValue() {
    if (this.hasOwnProperty('_onceReturnValue')) {
      return this._onceReturnValue;
    } else {
      return true;
    }
  };
  /**
   * Fetches the events object and creates one if required.
   *
   * @return {Object} The events storage object.
   * @api private
   */


  proto._getEvents = function _getEvents() {
    return this._events || (this._events = {});
  };
  /**
   * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
   *
   * @return {Function} Non conflicting EventEmitter class.
   */


  EventEmitter.noConflict = function noConflict() {
    exports.EventEmitter = originalGlobalValue;
    return EventEmitter;
  }; // Expose the class either via AMD, CommonJS or the global object


  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return EventEmitter;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof module === 'object' && module.exports) {
    module.exports = EventEmitter;
  } else {
    exports.EventEmitter = EventEmitter;
  }
})(typeof window !== 'undefined' ? window : this || {});

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Box3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Sphere_js__ = __webpack_require__(13);


/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3(min, max) {
  this.min = min !== undefined ? min : new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](+Infinity, +Infinity, +Infinity);
  this.max = max !== undefined ? max : new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](-Infinity, -Infinity, -Infinity);
}

Object.assign(Box3.prototype, {
  isBox3: true,
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromArray: function (array) {
    var minX = +Infinity;
    var minY = +Infinity;
    var minZ = +Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;

    for (var i = 0, l = array.length; i < l; i += 3) {
      var x = array[i];
      var y = array[i + 1];
      var z = array[i + 2];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromBufferAttribute: function (attribute) {
    var minX = +Infinity;
    var minY = +Infinity;
    var minZ = +Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;

    for (var i = 0, l = attribute.count; i < l; i++) {
      var x = attribute.getX(i);
      var y = attribute.getY(i);
      var z = attribute.getZ(i);
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromPoints: function (points) {
    this.makeEmpty();

    for (var i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  },
  setFromCenterAndSize: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function setFromCenterAndSize(center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  setFromObject: function (object) {
    this.makeEmpty();
    return this.expandByObject(object);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  isEmpty: function () {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getCenter() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getSize() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  expandByObject: function () {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    var scope, i, l;
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();

    function traverse(node) {
      var geometry = node.geometry;

      if (geometry !== undefined) {
        if (geometry.isGeometry) {
          var vertices = geometry.vertices;

          for (i = 0, l = vertices.length; i < l; i++) {
            v1.copy(vertices[i]);
            v1.applyMatrix4(node.matrixWorld);
            scope.expandByPoint(v1);
          }
        } else if (geometry.isBufferGeometry) {
          var attribute = geometry.attributes.position;

          if (attribute !== undefined) {
            for (i = 0, l = attribute.count; i < l; i++) {
              v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
              scope.expandByPoint(v1);
            }
          }
        }
      }
    }

    return function expandByObject(object) {
      scope = this;
      object.updateMatrixWorld(true);
      object.traverse(traverse);
      return this;
    };
  }(),
  containsPoint: function (point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  },
  containsBox: function (box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  },
  getParameter: function (point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box3: .getParameter() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  },
  intersectsBox: function (box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  },
  intersectsSphere: function () {
    var closestPoint = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function intersectsSphere(sphere) {
      // Find the point on the AABB closest to the sphere center.
      this.clampPoint(sphere.center, closestPoint); // If that point is inside the sphere, the AABB and sphere intersect.

      return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    };
  }(),
  intersectsPlane: function (plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    var min, max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= plane.constant && max >= plane.constant;
  },
  intersectsTriangle: function () {
    // triangle centered vertices
    var v0 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var v2 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](); // triangle edge vectors

    var f0 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var f1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var f2 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var testAxis = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var center = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var extents = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var triangleNormal = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();

    function satForAxes(axes) {
      var i, j;

      for (i = 0, j = axes.length - 3; i <= j; i += 3) {
        testAxis.fromArray(axes, i); // project the aabb onto the seperating axis

        var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

        var p0 = v0.dot(testAxis);
        var p1 = v1.dot(testAxis);
        var p2 = v2.dot(testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
          // points of the projected triangle are outside the projected half-length of the aabb
          // the axis is seperating and we can exit
          return false;
        }
      }

      return true;
    }

    return function intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      } // compute box center and extents


      this.getCenter(center);
      extents.subVectors(this.max, center); // translate triangle to aabb origin

      v0.subVectors(triangle.a, center);
      v1.subVectors(triangle.b, center);
      v2.subVectors(triangle.c, center); // compute edge vectors for triangle

      f0.subVectors(v1, v0);
      f1.subVectors(v2, v1);
      f2.subVectors(v0, v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
      // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
      // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)

      var axes = [0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y, f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x, -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0];

      if (!satForAxes(axes)) {
        return false;
      } // test 3 face normals from the aabb


      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

      if (!satForAxes(axes)) {
        return false;
      } // finally testing the face normal of the triangle
      // use already existing triangle edge vectors here


      triangleNormal.crossVectors(f0, f1);
      axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];
      return satForAxes(axes);
    };
  }(),
  clampPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .clampPoint() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    }

    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function distanceToPoint(point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  getBoundingSphere: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function getBoundingSphere(target) {
      if (target === undefined) {
        console.warn('THREE.Box3: .getBoundingSphere() target is now required');
        target = new __WEBPACK_IMPORTED_MODULE_1__Sphere_js__["a" /* Sphere */]();
      }

      this.getCenter(target.center);
      target.radius = this.getSize(v1).length() * 0.5;
      return target;
    };
  }(),
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

    if (this.isEmpty()) this.makeEmpty();
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  applyMatrix4: function () {
    var points = [new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]()];
    return function applyMatrix4(matrix) {
      // transform of empty box is an empty box.
      if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000

      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001

      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010

      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011

      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100

      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101

      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110

      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

      this.setFromPoints(points);
      return this;
    };
  }(),
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniformsUtils; });
/**
 * Uniform Utilities
 */
var UniformsUtils = {
  merge: function (uniforms) {
    var merged = {};

    for (var u = 0; u < uniforms.length; u++) {
      var tmp = this.clone(uniforms[u]);

      for (var p in tmp) {
        merged[p] = tmp[p];
      }
    }

    return merged;
  },
  clone: function (uniforms_src) {
    var uniforms_dst = {};

    for (var u in uniforms_src) {
      uniforms_dst[u] = {};

      for (var p in uniforms_src[u]) {
        var parameter_src = uniforms_src[u][p];

        if (parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture)) {
          uniforms_dst[u][p] = parameter_src.clone();
        } else if (Array.isArray(parameter_src)) {
          uniforms_dst[u][p] = parameter_src.slice();
        } else {
          uniforms_dst[u][p] = parameter_src;
        }
      }
    }

    return uniforms_dst;
  }
};


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLAnimation; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function WebGLAnimation() {
  var context = null;
  var isAnimating = false;
  var animationLoop = null;

  function onAnimationFrame(time, frame) {
    if (isAnimating === false) return;
    animationLoop(time, frame);
    context.requestAnimationFrame(onAnimationFrame);
  }

  return {
    start: function () {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function () {
      isAnimating = false;
    },
    setAnimationLoop: function (callback) {
      animationLoop = callback;
    },
    setContext: function (value) {
      context = value;
    }
  };
}



/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Line; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Sphere_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Ray_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__materials_LineBasicMaterial_js__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_BufferGeometry_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_BufferAttribute_js__ = __webpack_require__(15);








/**
 * @author mrdoob / http://mrdoob.com/
 */

function Line(geometry, material, mode) {
  if (mode === 1) {
    console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
  }

  __WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__["a" /* Object3D */].call(this);
  this.type = 'Line';
  this.geometry = geometry !== undefined ? geometry : new __WEBPACK_IMPORTED_MODULE_6__core_BufferGeometry_js__["a" /* BufferGeometry */]();
  this.material = material !== undefined ? material : new __WEBPACK_IMPORTED_MODULE_5__materials_LineBasicMaterial_js__["a" /* LineBasicMaterial */]({
    color: Math.random() * 0xffffff
  });
}

Line.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__["a" /* Object3D */].prototype), {
  constructor: Line,
  isLine: true,
  computeLineDistances: function () {
    var start = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();
    var end = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();
    return function computeLineDistances() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        // we assume non-indexed geometry
        if (geometry.index === null) {
          var positionAttribute = geometry.attributes.position;
          var lineDistances = [0];

          for (var i = 1, l = positionAttribute.count; i < l; i++) {
            start.fromBufferAttribute(positionAttribute, i - 1);
            end.fromBufferAttribute(positionAttribute, i);
            lineDistances[i] = lineDistances[i - 1];
            lineDistances[i] += start.distanceTo(end);
          }

          geometry.addAttribute('lineDistance', new __WEBPACK_IMPORTED_MODULE_7__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](lineDistances, 1));
        } else {
          console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
      } else if (geometry.isGeometry) {
        var vertices = geometry.vertices;
        var lineDistances = geometry.lineDistances;
        lineDistances[0] = 0;

        for (var i = 1, l = vertices.length; i < l; i++) {
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
        }
      }

      return this;
    };
  }(),
  raycast: function () {
    var inverseMatrix = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__["a" /* Matrix4 */]();
    var ray = new __WEBPACK_IMPORTED_MODULE_1__math_Ray_js__["a" /* Ray */]();
    var sphere = new __WEBPACK_IMPORTED_MODULE_0__math_Sphere_js__["a" /* Sphere */]();
    return function raycast(raycaster, intersects) {
      var precision = raycaster.linePrecision;
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld; // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      sphere.radius += precision;
      if (raycaster.ray.intersectsSphere(sphere) === false) return; //

      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localPrecisionSq = localPrecision * localPrecision;
      var vStart = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();
      var vEnd = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();
      var interSegment = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();
      var interRay = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();
      var step = this && this.isLineSegments ? 2 : 1;

      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;

        if (index !== null) {
          var indices = index.array;

          for (var i = 0, l = indices.length - 1; i < l; i += step) {
            var a = indices[i];
            var b = indices[i + 1];
            vStart.fromArray(positions, a * 3);
            vEnd.fromArray(positions, b * 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localPrecisionSq) continue;
            interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far) continue;
            intersects.push({
              distance: distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
            vStart.fromArray(positions, 3 * i);
            vEnd.fromArray(positions, 3 * i + 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localPrecisionSq) continue;
            interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far) continue;
            intersects.push({
              distance: distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry.isGeometry) {
        var vertices = geometry.vertices;
        var nbVertices = vertices.length;

        for (var i = 0; i < nbVertices - 1; i += step) {
          var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
          if (distSq > localPrecisionSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          var distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    };
  }(),
  clone: function () {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 颜色计算的辅助方法
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(1);

var RGB_REG = /rgba?\(([\s.,0-9]+)\)/; // const RGBA_REG = /rgba\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(\d+)\s*\)/;
// 创建辅助 tag 取颜色

function createTmp() {
  var i = document.createElement('i');
  i.title = 'Web Colour Picker';
  i.style.display = 'none';
  document.body.appendChild(i);
  return i;
} // 获取颜色之间的插值


function getValue(start, end, percent, index) {
  var value = start[index] + (end[index] - start[index]) * percent;
  return value;
}

function calColor(colors, percent) {
  if (Util.isNaN(percent) || !Util.isNumber(percent)) {
    percent = 0;
  }

  var steps = colors.length - 1;
  var step = Math.floor(steps * percent);
  var left = steps * percent - step;
  var start = colors[step];
  var end = step === steps ? start : colors[step + 1];
  return [getValue(start, end, left, 0), getValue(start, end, left, 1), getValue(start, end, left, 2), getValue(start, end, left, 3)];
} // rgb 颜色转换成数组


function rgb2arr(str) {
  var arr = [];
  arr.push(parseInt(str.substr(1, 2), 16));
  arr.push(parseInt(str.substr(3, 2), 16));
  arr.push(parseInt(str.substr(5, 2), 16));
  return arr;
}

var colorCache = {};
var iEl = null;
var ColorUtil = {
  /**
   * 将颜色转换到 rgb 的格式
   * @param  {String} color 颜色
   * @return {String} 将颜色转换到 '#ffffff' 的格式
   */
  toRGB: function toRGB(color) {
    // 如果已经是 rgb的格式
    if (color[0] === '#' && color.length === 7) {
      var colorArray = rgb2arr(color);
      colorArray.push(255.0);
      return colorArray;
    }

    if (!iEl) {
      // 防止防止在页头报错
      iEl = createTmp();
    }

    var rst;

    if (colorCache[color]) {
      rst = colorCache[color];
    } else {
      iEl.style.color = color;
      rst = document.defaultView.getComputedStyle(iEl, '').getPropertyValue('color');
      var matchs = RGB_REG.exec(rst);
      var cArray = matchs[1].split(/\s*,\s*/);

      if (cArray.length === 4) {
        cArray[3] *= 255;
      }

      if (cArray.length === 3) {
        cArray.push(255.0);
      }

      colorCache[color] = cArray;
      rst = cArray;
    }

    return rst;
  },
  // 转成 WebGl color buffer
  color2Arr: function color2Arr(str) {
    var rgba = this.toRGB(str);
    return rgba.map(function (v) {
      return v / 255;
    });
  },
  color2RGBA: function color2RGBA(str) {
    return this.color2Arr(str);
  },
  rgb2arr: rgb2arr,

  /**
   * 获取渐变函数
   * @param  {Array} colors 多个颜色
   * @return {String} 颜色值
   */
  gradient: function gradient(colors) {
    var points = [];

    if (Util.isString(colors)) {
      colors = colors.split('-');
    }

    Util.each(colors, function (color) {
      var colorArray = ColorUtil.toRGB(color).map(function (e) {
        return e / 255;
      }); // colorArray[3] = colorArray[3] * 255;

      points.push(colorArray);
    });
    return function (percent) {
      return calColor(points, percent);
    };
  }
};
module.exports = ColorUtil;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module helpers
 */

/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */

exports.earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */

exports.factors = {
  centimeters: exports.earthRadius * 100,
  centimetres: exports.earthRadius * 100,
  degrees: exports.earthRadius / 111325,
  feet: exports.earthRadius * 3.28084,
  inches: exports.earthRadius * 39.370,
  kilometers: exports.earthRadius / 1000,
  kilometres: exports.earthRadius / 1000,
  meters: exports.earthRadius,
  metres: exports.earthRadius,
  miles: exports.earthRadius / 1609.344,
  millimeters: exports.earthRadius * 1000,
  millimetres: exports.earthRadius * 1000,
  nauticalmiles: exports.earthRadius / 1852,
  radians: 1,
  yards: exports.earthRadius / 1.0936
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */

exports.unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.370,
  kilometers: 1 / 1000,
  kilometres: 1 / 1000,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1000,
  millimetres: 1000,
  nauticalmiles: 1 / 1852,
  radians: 1 / exports.earthRadius,
  yards: 1 / 1.0936
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */

exports.areaFactors = {
  acres: 0.000247105,
  centimeters: 10000,
  centimetres: 10000,
  feet: 10.763910417,
  inches: 1550.003100006,
  kilometers: 0.000001,
  kilometres: 0.000001,
  meters: 1,
  metres: 1,
  miles: 3.86e-7,
  millimeters: 1000000,
  millimetres: 1000000,
  yards: 1.195990046
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */

function feature(geom, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var feat = {
    type: "Feature"
  };

  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }

  if (options.bbox) {
    feat.bbox = options.bbox;
  }

  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}

exports.feature = feature;
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */

function geometry(type, coordinates, options) {
  if (options === void 0) {
    options = {};
  }

  switch (type) {
    case "Point":
      return point(coordinates).geometry;

    case "LineString":
      return lineString(coordinates).geometry;

    case "Polygon":
      return polygon(coordinates).geometry;

    case "MultiPoint":
      return multiPoint(coordinates).geometry;

    case "MultiLineString":
      return multiLineString(coordinates).geometry;

    case "MultiPolygon":
      return multiPolygon(coordinates).geometry;

    default:
      throw new Error(type + " is invalid");
  }
}

exports.geometry = geometry;
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */

function point(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "Point",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}

exports.point = point;
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */

function points(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  return featureCollection(coordinates.map(function (coords) {
    return point(coords, properties);
  }), options);
}

exports.points = points;
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */

function polygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
    var ring = coordinates_1[_i];

    if (ring.length < 4) {
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    }

    for (var j = 0; j < ring[ring.length - 1].length; j++) {
      // Check if first point of Polygon contains two numbers
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }

  var geom = {
    type: "Polygon",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}

exports.polygon = polygon;
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */

function polygons(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  return featureCollection(coordinates.map(function (coords) {
    return polygon(coords, properties);
  }), options);
}

exports.polygons = polygons;
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */

function lineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }

  var geom = {
    type: "LineString",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}

exports.lineString = lineString;
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */

function lineStrings(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  return featureCollection(coordinates.map(function (coords) {
    return lineString(coords, properties);
  }), options);
}

exports.lineStrings = lineStrings;
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */

function featureCollection(features, options) {
  if (options === void 0) {
    options = {};
  }

  var fc = {
    type: "FeatureCollection"
  };

  if (options.id) {
    fc.id = options.id;
  }

  if (options.bbox) {
    fc.bbox = options.bbox;
  }

  fc.features = features;
  return fc;
}

exports.featureCollection = featureCollection;
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */

function multiLineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "MultiLineString",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}

exports.multiLineString = multiLineString;
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */

function multiPoint(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "MultiPoint",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}

exports.multiPoint = multiPoint;
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */

function multiPolygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "MultiPolygon",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}

exports.multiPolygon = multiPolygon;
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */

function geometryCollection(geometries, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "GeometryCollection",
    geometries: geometries
  };
  return feature(geom, properties, options);
}

exports.geometryCollection = geometryCollection;
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */

function round(num, precision) {
  if (precision === void 0) {
    precision = 0;
  }

  if (precision && !(precision >= 0)) {
    throw new Error("precision must be a positive number");
  }

  var multiplier = Math.pow(10, precision || 0);
  return Math.round(num * multiplier) / multiplier;
}

exports.round = round;
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */

function radiansToLength(radians, units) {
  if (units === void 0) {
    units = "kilometers";
  }

  var factor = exports.factors[units];

  if (!factor) {
    throw new Error(units + " units is invalid");
  }

  return radians * factor;
}

exports.radiansToLength = radiansToLength;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */

function lengthToRadians(distance, units) {
  if (units === void 0) {
    units = "kilometers";
  }

  var factor = exports.factors[units];

  if (!factor) {
    throw new Error(units + " units is invalid");
  }

  return distance / factor;
}

exports.lengthToRadians = lengthToRadians;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */

function lengthToDegrees(distance, units) {
  return radiansToDegrees(lengthToRadians(distance, units));
}

exports.lengthToDegrees = lengthToDegrees;
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */

function bearingToAzimuth(bearing) {
  var angle = bearing % 360;

  if (angle < 0) {
    angle += 360;
  }

  return angle;
}

exports.bearingToAzimuth = bearingToAzimuth;
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */

function radiansToDegrees(radians) {
  var degrees = radians % (2 * Math.PI);
  return degrees * 180 / Math.PI;
}

exports.radiansToDegrees = radiansToDegrees;
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */

function degreesToRadians(degrees) {
  var radians = degrees % 360;
  return radians * Math.PI / 180;
}

exports.degreesToRadians = degreesToRadians;
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */

function convertLength(length, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "kilometers";
  }

  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }

  if (!(length >= 0)) {
    throw new Error("length must be a positive number");
  }

  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}

exports.convertLength = convertLength;
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted distance
 */

function convertArea(area, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "meters";
  }

  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }

  if (!(area >= 0)) {
    throw new Error("area must be a positive number");
  }

  var startFactor = exports.areaFactors[originalUnit];

  if (!startFactor) {
    throw new Error("invalid original units");
  }

  var finalFactor = exports.areaFactors[finalUnit];

  if (!finalFactor) {
    throw new Error("invalid final units");
  }

  return area / startFactor * finalFactor;
}

exports.convertArea = convertArea;
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */

function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\s*$/.test(num);
}

exports.isNumber = isNumber;
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */

function isObject(input) {
  return !!input && input.constructor === Object;
}

exports.isObject = isObject;
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */

function validateBBox(bbox) {
  if (!bbox) {
    throw new Error("bbox is required");
  }

  if (!Array.isArray(bbox)) {
    throw new Error("bbox must be an Array");
  }

  if (bbox.length !== 4 && bbox.length !== 6) {
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  }

  bbox.forEach(function (num) {
    if (!isNumber(num)) {
      throw new Error("bbox must only contain numbers");
    }
  });
}

exports.validateBBox = validateBBox;
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */

function validateId(id) {
  if (!id) {
    throw new Error("id is required");
  }

  if (["string", "number"].indexOf(typeof id) === -1) {
    throw new Error("id must be a number or a string");
  }
}

exports.validateId = validateId; // Deprecated methods

function radians2degrees() {
  throw new Error("method has been renamed to `radiansToDegrees`");
}

exports.radians2degrees = radians2degrees;

function degrees2radians() {
  throw new Error("method has been renamed to `degreesToRadians`");
}

exports.degrees2radians = degrees2radians;

function distanceToDegrees() {
  throw new Error("method has been renamed to `lengthToDegrees`");
}

exports.distanceToDegrees = distanceToDegrees;

function distanceToRadians() {
  throw new Error("method has been renamed to `lengthToRadians`");
}

exports.distanceToRadians = distanceToRadians;

function radiansToDistance() {
  throw new Error("method has been renamed to `radiansToLength`");
}

exports.radiansToDistance = radiansToDistance;

function bearingToAngle() {
  throw new Error("method has been renamed to `bearingToAzimuth`");
}

exports.bearingToAngle = bearingToAngle;

function convertDistance() {
  throw new Error("method has been renamed to `convertLength`");
}

exports.convertDistance = convertDistance;

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function (name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function (row, i) {
    return f(object(row), i, columns);
  };
} // Compute unique columns in order of discovery.


function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];
  rows.forEach(function (row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}

/* harmony default export */ __webpack_exports__["a"] = (function (delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert,
        columns,
        rows = parseRows(text, function (row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [],
        // output rows
    N = text.length,
        I = 0,
        // current character index
    n = 0,
        // current line number
    t,
        // current token
    eof = N <= 0,
        // current token followed by EOF?
    eol = false; // current token followed by EOL?
    // Strip the trailing newline.

    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL; // Unescape quotes.

      var i,
          j = I,
          c;

      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);

        if ((i = I) >= N) eof = true;else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      } // Find next delimiter or newline.


      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      } // Return last token before EOF.


      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];

      while (t !== EOL && t !== EOF) row.push(t), t = token();

      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
      return columns.map(function (column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? "" : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\"" : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
});

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getJSON; });
/* unused harmony export getArrayBuffer */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getImage; });
/* unused harmony export getVideo */
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AJAXError =
/*#__PURE__*/
function (_Error) {
  _inherits(AJAXError, _Error);

  function AJAXError(message, status, url) {
    var _this;

    _classCallCheck(this, AJAXError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AJAXError).call(this, message));
    _this.status = status;
    _this.url = url; // work around for https://github.com/Rich-Harris/buble/issues/40

    _this.name = _this.constructor.name;
    _this.message = message;
    return _this;
  }

  _createClass(AJAXError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, ": ").concat(this.message, " (").concat(this.status, "): ").concat(this.url);
    }
  }]);

  return AJAXError;
}(_wrapNativeSuper(Error));

function makeRequest(requestParameters) {
  var xhr = new window.XMLHttpRequest();
  xhr.open('GET', requestParameters.url, true);

  for (var k in requestParameters.headers) {
    xhr.setRequestHeader(k, requestParameters.headers[k]);
  }

  xhr.withCredentials = requestParameters.credentials === 'include';
  return xhr;
}

var getJSON = function getJSON(requestParameters, callback) {
  var xhr = makeRequest(requestParameters);
  xhr.setRequestHeader('Accept', 'application/json');

  xhr.onerror = function () {
    callback(new Error(xhr.statusText));
  };

  xhr.onload = function () {
    if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
      var data;

      try {
        data = JSON.parse(xhr.response);
      } catch (err) {
        return callback(err);
      }

      callback(null, data);
    } else {
      if (xhr.status === 401) {
        callback(new AJAXError("".concat(xhr.statusText), xhr.status, requestParameters.url));
      } else {
        callback(new AJAXError(xhr.statusText, xhr.status, requestParameters.url));
      }
    }
  };

  xhr.send();
  return xhr;
};
var getArrayBuffer = function getArrayBuffer(requestParameters, callback) {
  var xhr = makeRequest(requestParameters);
  xhr.responseType = 'arraybuffer';

  xhr.onerror = function () {
    callback(new Error(xhr.statusText));
  };

  xhr.onload = function () {
    var response = xhr.response;

    if (response.byteLength === 0 && xhr.status === 200) {
      return callback(new Error('http status 200 returned without content.'));
    }

    if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
      callback(null, {
        data: response,
        cacheControl: xhr.getResponseHeader('Cache-Control'),
        expires: xhr.getResponseHeader('Expires')
      });
    } else {
      callback(new AJAXError(xhr.statusText, xhr.status, requestParameters.url));
    }
  };

  xhr.send();
  return xhr;
};

function sameOrigin(url) {
  var a = window.document.createElement('a');
  a.href = url;
  return a.protocol === window.document.location.protocol && a.host === window.document.location.host;
}

var transparentPngUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=';
var getImage = function getImage(requestParameters, callback) {
  // request the image with XHR to work around caching issues
  // see https://github.com/mapbox/mapbox-gl-js/issues/1470
  return getArrayBuffer(requestParameters, function (err, imgData) {
    if (err) {
      callback(err);
    } else if (imgData) {
      var img = new window.Image();
      var URL = window.URL || window.webkitURL;

      img.onload = function () {
        callback(null, img);
        URL.revokeObjectURL(img.src);
      };

      var blob = new window.Blob([new Uint8Array(imgData.data)], {
        type: 'image/png'
      });
      img.cacheControl = imgData.cacheControl;
      img.expires = imgData.expires;
      img.src = imgData.data.byteLength ? URL.createObjectURL(blob) : transparentPngUrl;
    }
  });
};
var getVideo = function getVideo(urls, callback) {
  var video = window.document.createElement('video');

  video.onloadstart = function () {
    callback(null, video);
  };

  for (var i = 0; i < urls.length; i++) {
    var s = window.document.createElement('source');

    if (!sameOrigin(urls[i])) {
      video.crossOrigin = 'Anonymous';
    }

    s.src = urls[i];
    video.appendChild(s);
  }

  return video;
};

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DataTexture; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Texture_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_js__ = __webpack_require__(3);
/**
 * @author alteredq / http://alteredqualia.com/
 */



function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  __WEBPACK_IMPORTED_MODULE_0__Texture_js__["a" /* Texture */].call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    data: data,
    width: width,
    height: height
  };
  this.magFilter = magFilter !== undefined ? magFilter : __WEBPACK_IMPORTED_MODULE_1__constants_js__["_10" /* NearestFilter */];
  this.minFilter = minFilter !== undefined ? minFilter : __WEBPACK_IMPORTED_MODULE_1__constants_js__["_10" /* NearestFilter */];
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
}

DataTexture.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__Texture_js__["a" /* Texture */].prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Frustum; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Sphere_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Plane_js__ = __webpack_require__(41);



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

function Frustum(p0, p1, p2, p3, p4, p5) {
  this.planes = [p0 !== undefined ? p0 : new __WEBPACK_IMPORTED_MODULE_2__Plane_js__["a" /* Plane */](), p1 !== undefined ? p1 : new __WEBPACK_IMPORTED_MODULE_2__Plane_js__["a" /* Plane */](), p2 !== undefined ? p2 : new __WEBPACK_IMPORTED_MODULE_2__Plane_js__["a" /* Plane */](), p3 !== undefined ? p3 : new __WEBPACK_IMPORTED_MODULE_2__Plane_js__["a" /* Plane */](), p4 !== undefined ? p4 : new __WEBPACK_IMPORTED_MODULE_2__Plane_js__["a" /* Plane */](), p5 !== undefined ? p5 : new __WEBPACK_IMPORTED_MODULE_2__Plane_js__["a" /* Plane */]()];
}

Object.assign(Frustum.prototype, {
  set: function (p0, p1, p2, p3, p4, p5) {
    var planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (frustum) {
    var planes = this.planes;

    for (var i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }

    return this;
  },
  setFromMatrix: function (m) {
    var planes = this.planes;
    var me = m.elements;
    var me0 = me[0],
        me1 = me[1],
        me2 = me[2],
        me3 = me[3];
    var me4 = me[4],
        me5 = me[5],
        me6 = me[6],
        me7 = me[7];
    var me8 = me[8],
        me9 = me[9],
        me10 = me[10],
        me11 = me[11];
    var me12 = me[12],
        me13 = me[13],
        me14 = me[14],
        me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },
  intersectsObject: function () {
    var sphere = new __WEBPACK_IMPORTED_MODULE_1__Sphere_js__["a" /* Sphere */]();
    return function intersectsObject(object) {
      var geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSprite: function () {
    var sphere = new __WEBPACK_IMPORTED_MODULE_1__Sphere_js__["a" /* Sphere */]();
    return function intersectsSprite(sprite) {
      sphere.center.set(0, 0, 0);
      sphere.radius = 0.7071067811865476;
      sphere.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSphere: function (sphere) {
    var planes = this.planes;
    var center = sphere.center;
    var negRadius = -sphere.radius;

    for (var i = 0; i < 6; i++) {
      var distance = planes[i].distanceToPoint(center);

      if (distance < negRadius) {
        return false;
      }
    }

    return true;
  },
  intersectsBox: function () {
    var p = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function intersectsBox(box) {
      var planes = this.planes;

      for (var i = 0; i < 6; i++) {
        var plane = planes[i]; // corner at max distance

        p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p.z = plane.normal.z > 0 ? box.max.z : box.min.z;

        if (plane.distanceToPoint(p) < 0) {
          return false;
        }
      }

      return true;
    };
  }(),
  containsPoint: function (point) {
    var planes = this.planes;

    for (var i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }

    return true;
  }
});


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Plane; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Matrix3_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Vector3_js__ = __webpack_require__(0);


/**
 * @author bhouston / http://clara.io
 */

function Plane(normal, constant) {
  // normal is assumed to be normalized
  this.normal = normal !== undefined ? normal : new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](1, 0, 0);
  this.constant = constant !== undefined ? constant : 0;
}

Object.assign(Plane.prototype, {
  set: function (normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  },
  setComponents: function (x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  },
  setFromNormalAndCoplanarPoint: function (normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
    var v2 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
    return function setFromCoplanarPoints(a, b, c) {
      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    };
  }(),
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  },
  normalize: function () {
    // Note: will lead to a divide by zero if the plane is invalid.
    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  },
  negate: function () {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function (point) {
    return this.normal.dot(point) + this.constant;
  },
  distanceToSphere: function (sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  },
  projectPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .projectPoint() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
    }

    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  },
  intersectLine: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
    return function intersectLine(line, target) {
      if (target === undefined) {
        console.warn('THREE.Plane: .intersectLine() target is now required');
        target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
      }

      var direction = line.delta(v1);
      var denominator = this.normal.dot(direction);

      if (denominator === 0) {
        // line is coplanar, return origin
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        } // Unsure if this is the correct method to handle this case.


        return undefined;
      }

      var t = -(line.start.dot(this.normal) + this.constant) / denominator;

      if (t < 0 || t > 1) {
        return undefined;
      }

      return target.copy(direction).multiplyScalar(t).add(line.start);
    };
  }(),
  intersectsLine: function (line) {
    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
    var startSign = this.distanceToPoint(line.start);
    var endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },
  intersectsBox: function (box) {
    return box.intersectsPlane(this);
  },
  intersectsSphere: function (sphere) {
    return sphere.intersectsPlane(this);
  },
  coplanarPoint: function (target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .coplanarPoint() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
    }

    return target.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
    var m1 = new __WEBPACK_IMPORTED_MODULE_0__Matrix3_js__["a" /* Matrix3 */]();
    return function applyMatrix4(matrix, optionalNormalMatrix) {
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
      var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
      var normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    };
  }(),
  translate: function (offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  },
  equals: function (plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
});


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShaderLib; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Color_js__ = __webpack_require__(7);





/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

var ShaderLib = {
  basic: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].specularmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].envmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].aomap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lightmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshbasic_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshbasic_frag
  },
  lambert: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].specularmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].envmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].aomap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lightmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].emissivemap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lights, {
      emissive: {
        value: new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x000000)
      }
    }]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshlambert_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshlambert_frag
  },
  phong: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].specularmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].envmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].aomap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lightmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].emissivemap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].bumpmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].normalmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].gradientmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lights, {
      emissive: {
        value: new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x000000)
      },
      specular: {
        value: new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x111111)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphong_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphong_frag
  },
  standard: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].envmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].aomap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lightmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].emissivemap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].bumpmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].normalmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].roughnessmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].metalnessmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lights, {
      emissive: {
        value: new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x000000)
      },
      roughness: {
        value: 0.5
      },
      metalness: {
        value: 0.5
      },
      envMapIntensity: {
        value: 1 // temporary

      }
    }]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphysical_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphysical_frag
  },
  points: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].points, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].points_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].points_frag
  },
  dashed: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].linedashed_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].linedashed_frag
  },
  depth: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].depth_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].depth_frag
  },
  normal: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].bumpmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].normalmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].normal_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].normal_frag
  },
  sprite: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].sprite, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].sprite_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].sprite_frag
  },

  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: {
      tCube: {
        value: null
      },
      tFlip: {
        value: -1
      },
      opacity: {
        value: 1.0
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].cube_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].equirect_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].equirect_frag
  },
  distanceRGBA: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap, {
      referencePosition: {
        value: new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1000
      }
    }]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].distanceRGBA_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].distanceRGBA_frag
  },
  shadow: {
    uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lights, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, {
      color: {
        value: new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x00000)
      },
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].shadow_vert,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["a" /* UniformsUtils */].merge([ShaderLib.standard.uniforms, {
    clearCoat: {
      value: 0
    },
    clearCoatRoughness: {
      value: 0
    }
  }]),
  vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphysical_vert,
  fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphysical_frag
};


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShaderChunk; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_alphamap_fragment_glsl__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_alphamap_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__ShaderChunk_alphamap_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ShaderChunk_alphamap_pars_fragment_glsl__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ShaderChunk_alphamap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__ShaderChunk_alphamap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ShaderChunk_alphatest_fragment_glsl__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ShaderChunk_alphatest_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__ShaderChunk_alphatest_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ShaderChunk_aomap_fragment_glsl__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ShaderChunk_aomap_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__ShaderChunk_aomap_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ShaderChunk_aomap_pars_fragment_glsl__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ShaderChunk_aomap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__ShaderChunk_aomap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ShaderChunk_begin_vertex_glsl__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ShaderChunk_begin_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__ShaderChunk_begin_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ShaderChunk_beginnormal_vertex_glsl__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ShaderChunk_beginnormal_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__ShaderChunk_beginnormal_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ShaderChunk_bsdfs_glsl__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ShaderChunk_bsdfs_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__ShaderChunk_bsdfs_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ShaderChunk_bumpmap_pars_fragment_glsl__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ShaderChunk_bumpmap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__ShaderChunk_bumpmap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ShaderChunk_clipping_planes_fragment_glsl__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ShaderChunk_clipping_planes_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__ShaderChunk_clipping_planes_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ShaderChunk_clipping_planes_pars_fragment_glsl__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ShaderChunk_clipping_planes_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__ShaderChunk_clipping_planes_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ShaderChunk_clipping_planes_pars_vertex_glsl__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ShaderChunk_clipping_planes_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__ShaderChunk_clipping_planes_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ShaderChunk_clipping_planes_vertex_glsl__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ShaderChunk_clipping_planes_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12__ShaderChunk_clipping_planes_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ShaderChunk_color_fragment_glsl__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ShaderChunk_color_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13__ShaderChunk_color_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ShaderChunk_color_pars_fragment_glsl__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ShaderChunk_color_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14__ShaderChunk_color_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__ShaderChunk_color_pars_vertex_glsl__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__ShaderChunk_color_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15__ShaderChunk_color_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__ShaderChunk_color_vertex_glsl__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__ShaderChunk_color_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16__ShaderChunk_color_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__ShaderChunk_common_glsl__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__ShaderChunk_common_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17__ShaderChunk_common_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__ShaderChunk_cube_uv_reflection_fragment_glsl__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__ShaderChunk_cube_uv_reflection_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18__ShaderChunk_cube_uv_reflection_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__ShaderChunk_defaultnormal_vertex_glsl__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__ShaderChunk_defaultnormal_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19__ShaderChunk_defaultnormal_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__ShaderChunk_displacementmap_pars_vertex_glsl__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__ShaderChunk_displacementmap_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20__ShaderChunk_displacementmap_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__ShaderChunk_displacementmap_vertex_glsl__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__ShaderChunk_displacementmap_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21__ShaderChunk_displacementmap_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__ShaderChunk_emissivemap_fragment_glsl__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__ShaderChunk_emissivemap_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22__ShaderChunk_emissivemap_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__ShaderChunk_emissivemap_pars_fragment_glsl__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__ShaderChunk_emissivemap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_23__ShaderChunk_emissivemap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__ShaderChunk_encodings_fragment_glsl__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__ShaderChunk_encodings_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_24__ShaderChunk_encodings_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__ShaderChunk_encodings_pars_fragment_glsl__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__ShaderChunk_encodings_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_25__ShaderChunk_encodings_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__ShaderChunk_envmap_fragment_glsl__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__ShaderChunk_envmap_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_26__ShaderChunk_envmap_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__ShaderChunk_envmap_pars_fragment_glsl__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__ShaderChunk_envmap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_27__ShaderChunk_envmap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__ShaderChunk_envmap_pars_vertex_glsl__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__ShaderChunk_envmap_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_28__ShaderChunk_envmap_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__ShaderChunk_envmap_vertex_glsl__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__ShaderChunk_envmap_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_29__ShaderChunk_envmap_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__ShaderChunk_fog_vertex_glsl__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__ShaderChunk_fog_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_30__ShaderChunk_fog_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__ShaderChunk_fog_pars_vertex_glsl__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__ShaderChunk_fog_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_31__ShaderChunk_fog_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__ShaderChunk_fog_fragment_glsl__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__ShaderChunk_fog_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_32__ShaderChunk_fog_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__ShaderChunk_fog_pars_fragment_glsl__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__ShaderChunk_fog_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_33__ShaderChunk_fog_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__ShaderChunk_gradientmap_pars_fragment_glsl__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__ShaderChunk_gradientmap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_34__ShaderChunk_gradientmap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__ShaderChunk_lightmap_fragment_glsl__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__ShaderChunk_lightmap_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_35__ShaderChunk_lightmap_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__ShaderChunk_lightmap_pars_fragment_glsl__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__ShaderChunk_lightmap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_36__ShaderChunk_lightmap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__ShaderChunk_lights_lambert_vertex_glsl__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__ShaderChunk_lights_lambert_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_37__ShaderChunk_lights_lambert_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__ShaderChunk_lights_pars_begin_glsl__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__ShaderChunk_lights_pars_begin_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_38__ShaderChunk_lights_pars_begin_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__ShaderChunk_envmap_physical_pars_fragment_glsl__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__ShaderChunk_envmap_physical_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_39__ShaderChunk_envmap_physical_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__ShaderChunk_lights_phong_fragment_glsl__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__ShaderChunk_lights_phong_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_40__ShaderChunk_lights_phong_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__ShaderChunk_lights_phong_pars_fragment_glsl__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__ShaderChunk_lights_phong_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_41__ShaderChunk_lights_phong_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__ShaderChunk_lights_physical_fragment_glsl__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__ShaderChunk_lights_physical_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_42__ShaderChunk_lights_physical_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__ShaderChunk_lights_physical_pars_fragment_glsl__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__ShaderChunk_lights_physical_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_43__ShaderChunk_lights_physical_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__ShaderChunk_lights_fragment_begin_glsl__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__ShaderChunk_lights_fragment_begin_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_44__ShaderChunk_lights_fragment_begin_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__ShaderChunk_lights_fragment_maps_glsl__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__ShaderChunk_lights_fragment_maps_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_45__ShaderChunk_lights_fragment_maps_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__ShaderChunk_lights_fragment_end_glsl__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__ShaderChunk_lights_fragment_end_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_46__ShaderChunk_lights_fragment_end_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__ShaderChunk_logdepthbuf_fragment_glsl__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__ShaderChunk_logdepthbuf_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_47__ShaderChunk_logdepthbuf_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__ShaderChunk_logdepthbuf_pars_fragment_glsl__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__ShaderChunk_logdepthbuf_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_48__ShaderChunk_logdepthbuf_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__ShaderChunk_logdepthbuf_pars_vertex_glsl__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__ShaderChunk_logdepthbuf_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_49__ShaderChunk_logdepthbuf_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__ShaderChunk_logdepthbuf_vertex_glsl__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__ShaderChunk_logdepthbuf_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_50__ShaderChunk_logdepthbuf_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__ShaderChunk_map_fragment_glsl__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__ShaderChunk_map_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_51__ShaderChunk_map_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__ShaderChunk_map_pars_fragment_glsl__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__ShaderChunk_map_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_52__ShaderChunk_map_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__ShaderChunk_map_particle_fragment_glsl__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__ShaderChunk_map_particle_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_53__ShaderChunk_map_particle_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__ShaderChunk_map_particle_pars_fragment_glsl__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__ShaderChunk_map_particle_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_54__ShaderChunk_map_particle_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__ShaderChunk_metalnessmap_fragment_glsl__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__ShaderChunk_metalnessmap_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_55__ShaderChunk_metalnessmap_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__ShaderChunk_metalnessmap_pars_fragment_glsl__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__ShaderChunk_metalnessmap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_56__ShaderChunk_metalnessmap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__ShaderChunk_morphnormal_vertex_glsl__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__ShaderChunk_morphnormal_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_57__ShaderChunk_morphnormal_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__ShaderChunk_morphtarget_pars_vertex_glsl__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__ShaderChunk_morphtarget_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_58__ShaderChunk_morphtarget_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__ShaderChunk_morphtarget_vertex_glsl__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__ShaderChunk_morphtarget_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_59__ShaderChunk_morphtarget_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__ShaderChunk_normal_fragment_begin_glsl__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__ShaderChunk_normal_fragment_begin_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_60__ShaderChunk_normal_fragment_begin_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__ShaderChunk_normal_fragment_maps_glsl__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__ShaderChunk_normal_fragment_maps_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_61__ShaderChunk_normal_fragment_maps_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__ShaderChunk_normalmap_pars_fragment_glsl__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__ShaderChunk_normalmap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_62__ShaderChunk_normalmap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__ShaderChunk_packing_glsl__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__ShaderChunk_packing_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_63__ShaderChunk_packing_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__ShaderChunk_premultiplied_alpha_fragment_glsl__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__ShaderChunk_premultiplied_alpha_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_64__ShaderChunk_premultiplied_alpha_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_65__ShaderChunk_project_vertex_glsl__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_65__ShaderChunk_project_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_65__ShaderChunk_project_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_66__ShaderChunk_dithering_fragment_glsl__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_66__ShaderChunk_dithering_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_66__ShaderChunk_dithering_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_67__ShaderChunk_dithering_pars_fragment_glsl__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_67__ShaderChunk_dithering_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_67__ShaderChunk_dithering_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_68__ShaderChunk_roughnessmap_fragment_glsl__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_68__ShaderChunk_roughnessmap_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_68__ShaderChunk_roughnessmap_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_69__ShaderChunk_roughnessmap_pars_fragment_glsl__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_69__ShaderChunk_roughnessmap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_69__ShaderChunk_roughnessmap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_70__ShaderChunk_shadowmap_pars_fragment_glsl__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_70__ShaderChunk_shadowmap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_70__ShaderChunk_shadowmap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_71__ShaderChunk_shadowmap_pars_vertex_glsl__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_71__ShaderChunk_shadowmap_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_71__ShaderChunk_shadowmap_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_72__ShaderChunk_shadowmap_vertex_glsl__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_72__ShaderChunk_shadowmap_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_72__ShaderChunk_shadowmap_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_73__ShaderChunk_shadowmask_pars_fragment_glsl__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_73__ShaderChunk_shadowmask_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_73__ShaderChunk_shadowmask_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_74__ShaderChunk_skinbase_vertex_glsl__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_74__ShaderChunk_skinbase_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_74__ShaderChunk_skinbase_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_75__ShaderChunk_skinning_pars_vertex_glsl__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_75__ShaderChunk_skinning_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_75__ShaderChunk_skinning_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_76__ShaderChunk_skinning_vertex_glsl__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_76__ShaderChunk_skinning_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_76__ShaderChunk_skinning_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_77__ShaderChunk_skinnormal_vertex_glsl__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_77__ShaderChunk_skinnormal_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_77__ShaderChunk_skinnormal_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_78__ShaderChunk_specularmap_fragment_glsl__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_78__ShaderChunk_specularmap_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_78__ShaderChunk_specularmap_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_79__ShaderChunk_specularmap_pars_fragment_glsl__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_79__ShaderChunk_specularmap_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_79__ShaderChunk_specularmap_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_80__ShaderChunk_tonemapping_fragment_glsl__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_80__ShaderChunk_tonemapping_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_80__ShaderChunk_tonemapping_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_81__ShaderChunk_tonemapping_pars_fragment_glsl__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_81__ShaderChunk_tonemapping_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_81__ShaderChunk_tonemapping_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_82__ShaderChunk_uv_pars_fragment_glsl__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_82__ShaderChunk_uv_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_82__ShaderChunk_uv_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_83__ShaderChunk_uv_pars_vertex_glsl__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_83__ShaderChunk_uv_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_83__ShaderChunk_uv_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_84__ShaderChunk_uv_vertex_glsl__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_84__ShaderChunk_uv_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_84__ShaderChunk_uv_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_85__ShaderChunk_uv2_pars_fragment_glsl__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_85__ShaderChunk_uv2_pars_fragment_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_85__ShaderChunk_uv2_pars_fragment_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_86__ShaderChunk_uv2_pars_vertex_glsl__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_86__ShaderChunk_uv2_pars_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_86__ShaderChunk_uv2_pars_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_87__ShaderChunk_uv2_vertex_glsl__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_87__ShaderChunk_uv2_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_87__ShaderChunk_uv2_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_88__ShaderChunk_worldpos_vertex_glsl__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_88__ShaderChunk_worldpos_vertex_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_88__ShaderChunk_worldpos_vertex_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_89__ShaderLib_cube_frag_glsl__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_89__ShaderLib_cube_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_89__ShaderLib_cube_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_90__ShaderLib_cube_vert_glsl__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_90__ShaderLib_cube_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_90__ShaderLib_cube_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_91__ShaderLib_depth_frag_glsl__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_91__ShaderLib_depth_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_91__ShaderLib_depth_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_92__ShaderLib_depth_vert_glsl__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_92__ShaderLib_depth_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_92__ShaderLib_depth_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_93__ShaderLib_distanceRGBA_frag_glsl__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_93__ShaderLib_distanceRGBA_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_93__ShaderLib_distanceRGBA_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_94__ShaderLib_distanceRGBA_vert_glsl__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_94__ShaderLib_distanceRGBA_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_94__ShaderLib_distanceRGBA_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_95__ShaderLib_equirect_frag_glsl__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_95__ShaderLib_equirect_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_95__ShaderLib_equirect_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_96__ShaderLib_equirect_vert_glsl__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_96__ShaderLib_equirect_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_96__ShaderLib_equirect_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_97__ShaderLib_linedashed_frag_glsl__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_97__ShaderLib_linedashed_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_97__ShaderLib_linedashed_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_98__ShaderLib_linedashed_vert_glsl__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_98__ShaderLib_linedashed_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_98__ShaderLib_linedashed_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_99__ShaderLib_meshbasic_frag_glsl__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_99__ShaderLib_meshbasic_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_99__ShaderLib_meshbasic_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_100__ShaderLib_meshbasic_vert_glsl__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_100__ShaderLib_meshbasic_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_100__ShaderLib_meshbasic_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_101__ShaderLib_meshlambert_frag_glsl__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_101__ShaderLib_meshlambert_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_101__ShaderLib_meshlambert_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_102__ShaderLib_meshlambert_vert_glsl__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_102__ShaderLib_meshlambert_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_102__ShaderLib_meshlambert_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_103__ShaderLib_meshphong_frag_glsl__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_103__ShaderLib_meshphong_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_103__ShaderLib_meshphong_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_104__ShaderLib_meshphong_vert_glsl__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_104__ShaderLib_meshphong_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_104__ShaderLib_meshphong_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_105__ShaderLib_meshphysical_frag_glsl__ = __webpack_require__(191);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_105__ShaderLib_meshphysical_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_105__ShaderLib_meshphysical_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_106__ShaderLib_meshphysical_vert_glsl__ = __webpack_require__(192);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_106__ShaderLib_meshphysical_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_106__ShaderLib_meshphysical_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_107__ShaderLib_normal_frag_glsl__ = __webpack_require__(193);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_107__ShaderLib_normal_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_107__ShaderLib_normal_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_108__ShaderLib_normal_vert_glsl__ = __webpack_require__(194);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_108__ShaderLib_normal_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_108__ShaderLib_normal_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_109__ShaderLib_points_frag_glsl__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_109__ShaderLib_points_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_109__ShaderLib_points_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_110__ShaderLib_points_vert_glsl__ = __webpack_require__(196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_110__ShaderLib_points_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_110__ShaderLib_points_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_111__ShaderLib_shadow_frag_glsl__ = __webpack_require__(197);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_111__ShaderLib_shadow_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_111__ShaderLib_shadow_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_112__ShaderLib_shadow_vert_glsl__ = __webpack_require__(198);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_112__ShaderLib_shadow_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_112__ShaderLib_shadow_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_113__ShaderLib_sprite_frag_glsl__ = __webpack_require__(199);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_113__ShaderLib_sprite_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_113__ShaderLib_sprite_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_114__ShaderLib_sprite_vert_glsl__ = __webpack_require__(200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_114__ShaderLib_sprite_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_114__ShaderLib_sprite_vert_glsl__);



















































































































var ShaderChunk = {
  alphamap_fragment: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_alphamap_fragment_glsl___default.a,
  alphamap_pars_fragment: __WEBPACK_IMPORTED_MODULE_1__ShaderChunk_alphamap_pars_fragment_glsl___default.a,
  alphatest_fragment: __WEBPACK_IMPORTED_MODULE_2__ShaderChunk_alphatest_fragment_glsl___default.a,
  aomap_fragment: __WEBPACK_IMPORTED_MODULE_3__ShaderChunk_aomap_fragment_glsl___default.a,
  aomap_pars_fragment: __WEBPACK_IMPORTED_MODULE_4__ShaderChunk_aomap_pars_fragment_glsl___default.a,
  begin_vertex: __WEBPACK_IMPORTED_MODULE_5__ShaderChunk_begin_vertex_glsl___default.a,
  beginnormal_vertex: __WEBPACK_IMPORTED_MODULE_6__ShaderChunk_beginnormal_vertex_glsl___default.a,
  bsdfs: __WEBPACK_IMPORTED_MODULE_7__ShaderChunk_bsdfs_glsl___default.a,
  bumpmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_8__ShaderChunk_bumpmap_pars_fragment_glsl___default.a,
  clipping_planes_fragment: __WEBPACK_IMPORTED_MODULE_9__ShaderChunk_clipping_planes_fragment_glsl___default.a,
  clipping_planes_pars_fragment: __WEBPACK_IMPORTED_MODULE_10__ShaderChunk_clipping_planes_pars_fragment_glsl___default.a,
  clipping_planes_pars_vertex: __WEBPACK_IMPORTED_MODULE_11__ShaderChunk_clipping_planes_pars_vertex_glsl___default.a,
  clipping_planes_vertex: __WEBPACK_IMPORTED_MODULE_12__ShaderChunk_clipping_planes_vertex_glsl___default.a,
  color_fragment: __WEBPACK_IMPORTED_MODULE_13__ShaderChunk_color_fragment_glsl___default.a,
  color_pars_fragment: __WEBPACK_IMPORTED_MODULE_14__ShaderChunk_color_pars_fragment_glsl___default.a,
  color_pars_vertex: __WEBPACK_IMPORTED_MODULE_15__ShaderChunk_color_pars_vertex_glsl___default.a,
  color_vertex: __WEBPACK_IMPORTED_MODULE_16__ShaderChunk_color_vertex_glsl___default.a,
  common: __WEBPACK_IMPORTED_MODULE_17__ShaderChunk_common_glsl___default.a,
  cube_uv_reflection_fragment: __WEBPACK_IMPORTED_MODULE_18__ShaderChunk_cube_uv_reflection_fragment_glsl___default.a,
  defaultnormal_vertex: __WEBPACK_IMPORTED_MODULE_19__ShaderChunk_defaultnormal_vertex_glsl___default.a,
  displacementmap_pars_vertex: __WEBPACK_IMPORTED_MODULE_20__ShaderChunk_displacementmap_pars_vertex_glsl___default.a,
  displacementmap_vertex: __WEBPACK_IMPORTED_MODULE_21__ShaderChunk_displacementmap_vertex_glsl___default.a,
  emissivemap_fragment: __WEBPACK_IMPORTED_MODULE_22__ShaderChunk_emissivemap_fragment_glsl___default.a,
  emissivemap_pars_fragment: __WEBPACK_IMPORTED_MODULE_23__ShaderChunk_emissivemap_pars_fragment_glsl___default.a,
  encodings_fragment: __WEBPACK_IMPORTED_MODULE_24__ShaderChunk_encodings_fragment_glsl___default.a,
  encodings_pars_fragment: __WEBPACK_IMPORTED_MODULE_25__ShaderChunk_encodings_pars_fragment_glsl___default.a,
  envmap_fragment: __WEBPACK_IMPORTED_MODULE_26__ShaderChunk_envmap_fragment_glsl___default.a,
  envmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_27__ShaderChunk_envmap_pars_fragment_glsl___default.a,
  envmap_pars_vertex: __WEBPACK_IMPORTED_MODULE_28__ShaderChunk_envmap_pars_vertex_glsl___default.a,
  envmap_physical_pars_fragment: __WEBPACK_IMPORTED_MODULE_39__ShaderChunk_envmap_physical_pars_fragment_glsl___default.a,
  envmap_vertex: __WEBPACK_IMPORTED_MODULE_29__ShaderChunk_envmap_vertex_glsl___default.a,
  fog_vertex: __WEBPACK_IMPORTED_MODULE_30__ShaderChunk_fog_vertex_glsl___default.a,
  fog_pars_vertex: __WEBPACK_IMPORTED_MODULE_31__ShaderChunk_fog_pars_vertex_glsl___default.a,
  fog_fragment: __WEBPACK_IMPORTED_MODULE_32__ShaderChunk_fog_fragment_glsl___default.a,
  fog_pars_fragment: __WEBPACK_IMPORTED_MODULE_33__ShaderChunk_fog_pars_fragment_glsl___default.a,
  gradientmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_34__ShaderChunk_gradientmap_pars_fragment_glsl___default.a,
  lightmap_fragment: __WEBPACK_IMPORTED_MODULE_35__ShaderChunk_lightmap_fragment_glsl___default.a,
  lightmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_36__ShaderChunk_lightmap_pars_fragment_glsl___default.a,
  lights_lambert_vertex: __WEBPACK_IMPORTED_MODULE_37__ShaderChunk_lights_lambert_vertex_glsl___default.a,
  lights_pars_begin: __WEBPACK_IMPORTED_MODULE_38__ShaderChunk_lights_pars_begin_glsl___default.a,
  lights_phong_fragment: __WEBPACK_IMPORTED_MODULE_40__ShaderChunk_lights_phong_fragment_glsl___default.a,
  lights_phong_pars_fragment: __WEBPACK_IMPORTED_MODULE_41__ShaderChunk_lights_phong_pars_fragment_glsl___default.a,
  lights_physical_fragment: __WEBPACK_IMPORTED_MODULE_42__ShaderChunk_lights_physical_fragment_glsl___default.a,
  lights_physical_pars_fragment: __WEBPACK_IMPORTED_MODULE_43__ShaderChunk_lights_physical_pars_fragment_glsl___default.a,
  lights_fragment_begin: __WEBPACK_IMPORTED_MODULE_44__ShaderChunk_lights_fragment_begin_glsl___default.a,
  lights_fragment_maps: __WEBPACK_IMPORTED_MODULE_45__ShaderChunk_lights_fragment_maps_glsl___default.a,
  lights_fragment_end: __WEBPACK_IMPORTED_MODULE_46__ShaderChunk_lights_fragment_end_glsl___default.a,
  logdepthbuf_fragment: __WEBPACK_IMPORTED_MODULE_47__ShaderChunk_logdepthbuf_fragment_glsl___default.a,
  logdepthbuf_pars_fragment: __WEBPACK_IMPORTED_MODULE_48__ShaderChunk_logdepthbuf_pars_fragment_glsl___default.a,
  logdepthbuf_pars_vertex: __WEBPACK_IMPORTED_MODULE_49__ShaderChunk_logdepthbuf_pars_vertex_glsl___default.a,
  logdepthbuf_vertex: __WEBPACK_IMPORTED_MODULE_50__ShaderChunk_logdepthbuf_vertex_glsl___default.a,
  map_fragment: __WEBPACK_IMPORTED_MODULE_51__ShaderChunk_map_fragment_glsl___default.a,
  map_pars_fragment: __WEBPACK_IMPORTED_MODULE_52__ShaderChunk_map_pars_fragment_glsl___default.a,
  map_particle_fragment: __WEBPACK_IMPORTED_MODULE_53__ShaderChunk_map_particle_fragment_glsl___default.a,
  map_particle_pars_fragment: __WEBPACK_IMPORTED_MODULE_54__ShaderChunk_map_particle_pars_fragment_glsl___default.a,
  metalnessmap_fragment: __WEBPACK_IMPORTED_MODULE_55__ShaderChunk_metalnessmap_fragment_glsl___default.a,
  metalnessmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_56__ShaderChunk_metalnessmap_pars_fragment_glsl___default.a,
  morphnormal_vertex: __WEBPACK_IMPORTED_MODULE_57__ShaderChunk_morphnormal_vertex_glsl___default.a,
  morphtarget_pars_vertex: __WEBPACK_IMPORTED_MODULE_58__ShaderChunk_morphtarget_pars_vertex_glsl___default.a,
  morphtarget_vertex: __WEBPACK_IMPORTED_MODULE_59__ShaderChunk_morphtarget_vertex_glsl___default.a,
  normal_fragment_begin: __WEBPACK_IMPORTED_MODULE_60__ShaderChunk_normal_fragment_begin_glsl___default.a,
  normal_fragment_maps: __WEBPACK_IMPORTED_MODULE_61__ShaderChunk_normal_fragment_maps_glsl___default.a,
  normalmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_62__ShaderChunk_normalmap_pars_fragment_glsl___default.a,
  packing: __WEBPACK_IMPORTED_MODULE_63__ShaderChunk_packing_glsl___default.a,
  premultiplied_alpha_fragment: __WEBPACK_IMPORTED_MODULE_64__ShaderChunk_premultiplied_alpha_fragment_glsl___default.a,
  project_vertex: __WEBPACK_IMPORTED_MODULE_65__ShaderChunk_project_vertex_glsl___default.a,
  dithering_fragment: __WEBPACK_IMPORTED_MODULE_66__ShaderChunk_dithering_fragment_glsl___default.a,
  dithering_pars_fragment: __WEBPACK_IMPORTED_MODULE_67__ShaderChunk_dithering_pars_fragment_glsl___default.a,
  roughnessmap_fragment: __WEBPACK_IMPORTED_MODULE_68__ShaderChunk_roughnessmap_fragment_glsl___default.a,
  roughnessmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_69__ShaderChunk_roughnessmap_pars_fragment_glsl___default.a,
  shadowmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_70__ShaderChunk_shadowmap_pars_fragment_glsl___default.a,
  shadowmap_pars_vertex: __WEBPACK_IMPORTED_MODULE_71__ShaderChunk_shadowmap_pars_vertex_glsl___default.a,
  shadowmap_vertex: __WEBPACK_IMPORTED_MODULE_72__ShaderChunk_shadowmap_vertex_glsl___default.a,
  shadowmask_pars_fragment: __WEBPACK_IMPORTED_MODULE_73__ShaderChunk_shadowmask_pars_fragment_glsl___default.a,
  skinbase_vertex: __WEBPACK_IMPORTED_MODULE_74__ShaderChunk_skinbase_vertex_glsl___default.a,
  skinning_pars_vertex: __WEBPACK_IMPORTED_MODULE_75__ShaderChunk_skinning_pars_vertex_glsl___default.a,
  skinning_vertex: __WEBPACK_IMPORTED_MODULE_76__ShaderChunk_skinning_vertex_glsl___default.a,
  skinnormal_vertex: __WEBPACK_IMPORTED_MODULE_77__ShaderChunk_skinnormal_vertex_glsl___default.a,
  specularmap_fragment: __WEBPACK_IMPORTED_MODULE_78__ShaderChunk_specularmap_fragment_glsl___default.a,
  specularmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_79__ShaderChunk_specularmap_pars_fragment_glsl___default.a,
  tonemapping_fragment: __WEBPACK_IMPORTED_MODULE_80__ShaderChunk_tonemapping_fragment_glsl___default.a,
  tonemapping_pars_fragment: __WEBPACK_IMPORTED_MODULE_81__ShaderChunk_tonemapping_pars_fragment_glsl___default.a,
  uv_pars_fragment: __WEBPACK_IMPORTED_MODULE_82__ShaderChunk_uv_pars_fragment_glsl___default.a,
  uv_pars_vertex: __WEBPACK_IMPORTED_MODULE_83__ShaderChunk_uv_pars_vertex_glsl___default.a,
  uv_vertex: __WEBPACK_IMPORTED_MODULE_84__ShaderChunk_uv_vertex_glsl___default.a,
  uv2_pars_fragment: __WEBPACK_IMPORTED_MODULE_85__ShaderChunk_uv2_pars_fragment_glsl___default.a,
  uv2_pars_vertex: __WEBPACK_IMPORTED_MODULE_86__ShaderChunk_uv2_pars_vertex_glsl___default.a,
  uv2_vertex: __WEBPACK_IMPORTED_MODULE_87__ShaderChunk_uv2_vertex_glsl___default.a,
  worldpos_vertex: __WEBPACK_IMPORTED_MODULE_88__ShaderChunk_worldpos_vertex_glsl___default.a,
  cube_frag: __WEBPACK_IMPORTED_MODULE_89__ShaderLib_cube_frag_glsl___default.a,
  cube_vert: __WEBPACK_IMPORTED_MODULE_90__ShaderLib_cube_vert_glsl___default.a,
  depth_frag: __WEBPACK_IMPORTED_MODULE_91__ShaderLib_depth_frag_glsl___default.a,
  depth_vert: __WEBPACK_IMPORTED_MODULE_92__ShaderLib_depth_vert_glsl___default.a,
  distanceRGBA_frag: __WEBPACK_IMPORTED_MODULE_93__ShaderLib_distanceRGBA_frag_glsl___default.a,
  distanceRGBA_vert: __WEBPACK_IMPORTED_MODULE_94__ShaderLib_distanceRGBA_vert_glsl___default.a,
  equirect_frag: __WEBPACK_IMPORTED_MODULE_95__ShaderLib_equirect_frag_glsl___default.a,
  equirect_vert: __WEBPACK_IMPORTED_MODULE_96__ShaderLib_equirect_vert_glsl___default.a,
  linedashed_frag: __WEBPACK_IMPORTED_MODULE_97__ShaderLib_linedashed_frag_glsl___default.a,
  linedashed_vert: __WEBPACK_IMPORTED_MODULE_98__ShaderLib_linedashed_vert_glsl___default.a,
  meshbasic_frag: __WEBPACK_IMPORTED_MODULE_99__ShaderLib_meshbasic_frag_glsl___default.a,
  meshbasic_vert: __WEBPACK_IMPORTED_MODULE_100__ShaderLib_meshbasic_vert_glsl___default.a,
  meshlambert_frag: __WEBPACK_IMPORTED_MODULE_101__ShaderLib_meshlambert_frag_glsl___default.a,
  meshlambert_vert: __WEBPACK_IMPORTED_MODULE_102__ShaderLib_meshlambert_vert_glsl___default.a,
  meshphong_frag: __WEBPACK_IMPORTED_MODULE_103__ShaderLib_meshphong_frag_glsl___default.a,
  meshphong_vert: __WEBPACK_IMPORTED_MODULE_104__ShaderLib_meshphong_vert_glsl___default.a,
  meshphysical_frag: __WEBPACK_IMPORTED_MODULE_105__ShaderLib_meshphysical_frag_glsl___default.a,
  meshphysical_vert: __WEBPACK_IMPORTED_MODULE_106__ShaderLib_meshphysical_vert_glsl___default.a,
  normal_frag: __WEBPACK_IMPORTED_MODULE_107__ShaderLib_normal_frag_glsl___default.a,
  normal_vert: __WEBPACK_IMPORTED_MODULE_108__ShaderLib_normal_vert_glsl___default.a,
  points_frag: __WEBPACK_IMPORTED_MODULE_109__ShaderLib_points_frag_glsl___default.a,
  points_vert: __WEBPACK_IMPORTED_MODULE_110__ShaderLib_points_vert_glsl___default.a,
  shadow_frag: __WEBPACK_IMPORTED_MODULE_111__ShaderLib_shadow_frag_glsl___default.a,
  shadow_vert: __WEBPACK_IMPORTED_MODULE_112__ShaderLib_shadow_vert_glsl___default.a,
  sprite_frag: __WEBPACK_IMPORTED_MODULE_113__ShaderLib_sprite_frag_glsl___default.a,
  sprite_vert: __WEBPACK_IMPORTED_MODULE_114__ShaderLib_sprite_vert_glsl___default.a
};

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniformsLib; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Color_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__ = __webpack_require__(9);



/**
 * Uniforms library for shared webgl shaders
 */

var UniformsLib = {
  common: {
    diffuse: {
      value: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__["a" /* Matrix3 */]()
    },
    alphaMap: {
      value: null
    }
  },
  specularmap: {
    specularMap: {
      value: null
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1.0
    },
    refractionRatio: {
      value: 0.98
    },
    maxMipLevel: {
      value: 0
    }
  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalScale: {
      value: new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */](1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 0.00025
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2000
    },
    fogColor: {
      value: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](0xffffff)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotShadowMap: {
      value: []
    },
    spotShadowMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    }
  },
  points: {
    diffuse: {
      value: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    size: {
      value: 1.0
    },
    scale: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__["a" /* Matrix3 */]()
    }
  },
  sprite: {
    diffuse: {
      value: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    center: {
      value: new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */](0.5, 0.5)
    },
    rotation: {
      value: 0.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__["a" /* Matrix3 */]()
    }
  }
};


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OrthographicCamera; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Camera_js__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Object3D_js__ = __webpack_require__(5);


/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera(left, right, top, bottom, near, far) {
  __WEBPACK_IMPORTED_MODULE_0__Camera_js__["a" /* Camera */].call(this);
  this.type = 'OrthographicCamera';
  this.zoom = 1;
  this.view = null;
  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
}

OrthographicCamera.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__Camera_js__["a" /* Camera */].prototype), {
  constructor: OrthographicCamera,
  isOrthographicCamera: true,
  copy: function (source, recursive) {
    __WEBPACK_IMPORTED_MODULE_0__Camera_js__["a" /* Camera */].prototype.copy.call(this, source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  },
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    var dx = (this.right - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.right + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    var left = cx - dx;
    var right = cx + dx;
    var top = cy + dy;
    var bottom = cy - dy;

    if (this.view !== null && this.view.enabled) {
      var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
      var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
      var scaleW = (this.right - this.left) / this.view.width;
      var scaleH = (this.top - this.bottom) / this.view.height;
      left += scaleW * (this.view.offsetX / zoomW);
      right = left + scaleW * (this.view.width / zoomW);
      top -= scaleH * (this.view.offsetY / zoomH);
      bottom = top - scaleH * (this.view.height / zoomH);
    }

    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (meta) {
    var data = __WEBPACK_IMPORTED_MODULE_1__core_Object3D_js__["a" /* Object3D */].prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
});


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Camera; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Object3D_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__ = __webpack_require__(0);
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/




function Camera() {
  __WEBPACK_IMPORTED_MODULE_1__core_Object3D_js__["a" /* Object3D */].call(this);
  this.type = 'Camera';
  this.matrixWorldInverse = new __WEBPACK_IMPORTED_MODULE_0__math_Matrix4_js__["a" /* Matrix4 */]();
  this.projectionMatrix = new __WEBPACK_IMPORTED_MODULE_0__math_Matrix4_js__["a" /* Matrix4 */]();
  this.projectionMatrixInverse = new __WEBPACK_IMPORTED_MODULE_0__math_Matrix4_js__["a" /* Matrix4 */]();
}

Camera.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_1__core_Object3D_js__["a" /* Object3D */].prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function (source, recursive) {
    __WEBPACK_IMPORTED_MODULE_1__core_Object3D_js__["a" /* Object3D */].prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Camera: .getWorldDirection() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]();
    }

    this.updateMatrixWorld(true);
    var e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function (force) {
    __WEBPACK_IMPORTED_MODULE_1__core_Object3D_js__["a" /* Object3D */].prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
});


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Geometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__EventDispatcher_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Face3_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Sphere_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Box3_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Vector2_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Color_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Object3D_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__math_Math_js__ = __webpack_require__(6);











/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

var geometryId = 0; // Geometry uses even numbers as Id

function Geometry() {
  Object.defineProperty(this, 'id', {
    value: geometryId += 2
  });
  this.uuid = __WEBPACK_IMPORTED_MODULE_10__math_Math_js__["a" /* _Math */].generateUUID();
  this.name = '';
  this.type = 'Geometry';
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null; // update flags

  this.elementsNeedUpdate = false;
  this.verticesNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;
}

Geometry.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__EventDispatcher_js__["a" /* EventDispatcher */].prototype), {
  constructor: Geometry,
  isGeometry: true,
  applyMatrix: function (matrix) {
    var normalMatrix = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__["a" /* Matrix3 */]().getNormalMatrix(matrix);

    for (var i = 0, il = this.vertices.length; i < il; i++) {
      var vertex = this.vertices[i];
      vertex.applyMatrix4(matrix);
    }

    for (var i = 0, il = this.faces.length; i < il; i++) {
      var face = this.faces[i];
      face.normal.applyMatrix3(normalMatrix).normalize();

      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
      }
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  },
  rotateX: function () {
    // rotate geometry around world x-axis
    var m1 = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();
    return function rotateX(angle) {
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function () {
    // rotate geometry around world y-axis
    var m1 = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();
    return function rotateY(angle) {
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function () {
    // rotate geometry around world z-axis
    var m1 = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();
    return function rotateZ(angle) {
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function () {
    // translate geometry
    var m1 = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();
    return function translate(x, y, z) {
      m1.makeTranslation(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function () {
    // scale geometry
    var m1 = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();
    return function scale(x, y, z) {
      m1.makeScale(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function () {
    var obj = new __WEBPACK_IMPORTED_MODULE_9__Object3D_js__["a" /* Object3D */]();
    return function lookAt(vector) {
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  fromBufferGeometry: function (geometry) {
    var scope = this;
    var indices = geometry.index !== null ? geometry.index.array : undefined;
    var attributes = geometry.attributes;
    var positions = attributes.position.array;
    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
    if (uvs2 !== undefined) this.faceVertexUvs[1] = [];
    var tempNormals = [];
    var tempUVs = [];
    var tempUVs2 = [];

    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
      scope.vertices.push(new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](positions[i], positions[i + 1], positions[i + 2]));

      if (normals !== undefined) {
        tempNormals.push(new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](normals[i], normals[i + 1], normals[i + 2]));
      }

      if (colors !== undefined) {
        scope.colors.push(new __WEBPACK_IMPORTED_MODULE_8__math_Color_js__["a" /* Color */](colors[i], colors[i + 1], colors[i + 2]));
      }

      if (uvs !== undefined) {
        tempUVs.push(new __WEBPACK_IMPORTED_MODULE_7__math_Vector2_js__["a" /* Vector2 */](uvs[j], uvs[j + 1]));
      }

      if (uvs2 !== undefined) {
        tempUVs2.push(new __WEBPACK_IMPORTED_MODULE_7__math_Vector2_js__["a" /* Vector2 */](uvs2[j], uvs2[j + 1]));
      }
    }

    function addFace(a, b, c, materialIndex) {
      var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
      var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
      var face = new __WEBPACK_IMPORTED_MODULE_1__Face3_js__["a" /* Face3 */](a, b, c, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);

      if (uvs !== undefined) {
        scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
      }

      if (uvs2 !== undefined) {
        scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
      }
    }

    var groups = geometry.groups;

    if (groups.length > 0) {
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var start = group.start;
        var count = group.count;

        for (var j = start, jl = start + count; j < jl; j += 3) {
          if (indices !== undefined) {
            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
          } else {
            addFace(j, j + 1, j + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (indices !== undefined) {
        for (var i = 0; i < indices.length; i += 3) {
          addFace(indices[i], indices[i + 1], indices[i + 2]);
        }
      } else {
        for (var i = 0; i < positions.length / 3; i += 3) {
          addFace(i, i + 1, i + 2);
        }
      }
    }

    this.computeFaceNormals();

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    return this;
  },
  center: function () {
    var offset = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
    return function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(offset).negate();
      this.translate(offset.x, offset.y, offset.z);
      return this;
    };
  }(),
  normalize: function () {
    this.computeBoundingSphere();
    var center = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;
    var s = radius === 0 ? 1 : 1.0 / radius;
    var matrix = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();
    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
    this.applyMatrix(matrix);
    return this;
  },
  computeFaceNormals: function () {
    var cb = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](),
        ab = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();

    for (var f = 0, fl = this.faces.length; f < fl; f++) {
      var face = this.faces[f];
      var vA = this.vertices[face.a];
      var vB = this.vertices[face.b];
      var vC = this.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function (areaWeighted) {
    if (areaWeighted === undefined) areaWeighted = true;
    var v, vl, f, fl, face, vertices;
    vertices = new Array(this.vertices.length);

    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v] = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
    }

    if (areaWeighted) {
      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm
      var vA, vB, vC;
      var cb = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](),
          ab = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vA = this.vertices[face.a];
        vB = this.vertices[face.b];
        vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      this.computeFaceNormals();

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }

    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }

    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      var vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }

    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeFlatVertexNormals: function () {
    var f, fl, face;
    this.computeFaceNormals();

    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      var vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }

    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeMorphNormals: function () {
    var i, il, f, fl, face; // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)

    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];

      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }

      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

      for (i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
      }
    } // use temp geometry to compute face and vertex normals for each morph


    var tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;

    for (i = 0, il = this.morphTargets.length; i < il; i++) {
      // create on first access
      if (!this.morphNormals[i]) {
        this.morphNormals[i] = {};
        this.morphNormals[i].faceNormals = [];
        this.morphNormals[i].vertexNormals = [];
        var dstNormalsFace = this.morphNormals[i].faceNormals;
        var dstNormalsVertex = this.morphNormals[i].vertexNormals;
        var faceNormal, vertexNormals;

        for (f = 0, fl = this.faces.length; f < fl; f++) {
          faceNormal = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
          vertexNormals = {
            a: new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](),
            b: new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](),
            c: new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }

      var morphNormals = this.morphNormals[i]; // set vertices to morph target

      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals

      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals(); // store morph normals

      var faceNormal, vertexNormals;

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        faceNormal = morphNormals.faceNormals[f];
        vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    } // restore original normals


    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new __WEBPACK_IMPORTED_MODULE_4__math_Box3_js__["a" /* Box3 */]();
    }

    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new __WEBPACK_IMPORTED_MODULE_3__math_Sphere_js__["a" /* Sphere */]();
    }

    this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function (geometry, matrix, materialIndexOffset) {
    if (!(geometry && geometry.isGeometry)) {
      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
      return;
    }

    var normalMatrix,
        vertexOffset = this.vertices.length,
        vertices1 = this.vertices,
        vertices2 = geometry.vertices,
        faces1 = this.faces,
        faces2 = geometry.faces,
        uvs1 = this.faceVertexUvs[0],
        uvs2 = geometry.faceVertexUvs[0],
        colors1 = this.colors,
        colors2 = geometry.colors;
    if (materialIndexOffset === undefined) materialIndexOffset = 0;

    if (matrix !== undefined) {
      normalMatrix = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__["a" /* Matrix3 */]().getNormalMatrix(matrix);
    } // vertices


    for (var i = 0, il = vertices2.length; i < il; i++) {
      var vertex = vertices2[i];
      var vertexCopy = vertex.clone();
      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
      vertices1.push(vertexCopy);
    } // colors


    for (var i = 0, il = colors2.length; i < il; i++) {
      colors1.push(colors2[i].clone());
    } // faces


    for (i = 0, il = faces2.length; i < il; i++) {
      var face = faces2[i],
          faceCopy,
          normal,
          color,
          faceVertexNormals = face.vertexNormals,
          faceVertexColors = face.vertexColors;
      faceCopy = new __WEBPACK_IMPORTED_MODULE_1__Face3_js__["a" /* Face3 */](face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);

      if (normalMatrix !== undefined) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }

      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();

        if (normalMatrix !== undefined) {
          normal.applyMatrix3(normalMatrix).normalize();
        }

        faceCopy.vertexNormals.push(normal);
      }

      faceCopy.color.copy(face.color);

      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
      }

      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    } // uvs


    for (i = 0, il = uvs2.length; i < il; i++) {
      var uv = uvs2[i],
          uvCopy = [];

      if (uv === undefined) {
        continue;
      }

      for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(uv[j].clone());
      }

      uvs1.push(uvCopy);
    }
  },
  mergeMesh: function (mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
      return;
    }

    if (mesh.matrixAutoUpdate) mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  },

  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function () {
    var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)

    var unique = [],
        changes = [];
    var v, key;
    var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001

    var precision = Math.pow(10, precisionPoints);
    var i, il, face;
    var indices, j, jl;

    for (i = 0, il = this.vertices.length; i < il; i++) {
      v = this.vertices[i];
      key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

      if (verticesMap[key] === undefined) {
        verticesMap[key] = i;
        unique.push(this.vertices[i]);
        changes[i] = unique.length - 1;
      } else {
        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
        changes[i] = changes[verticesMap[key]];
      }
    } // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.


    var faceIndicesToRemove = [];

    for (i = 0, il = this.faces.length; i < il; i++) {
      face = this.faces[i];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved

      for (var n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          faceIndicesToRemove.push(i);
          break;
        }
      }
    }

    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
      var idx = faceIndicesToRemove[i];
      this.faces.splice(idx, 1);

      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(idx, 1);
      }
    } // Use unique set of vertices


    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  },
  setFromPoints: function (points) {
    this.vertices = [];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      this.vertices.push(new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](point.x, point.y, point.z || 0));
    }

    return this;
  },
  sortFacesByMaterialIndex: function () {
    var faces = this.faces;
    var length = faces.length; // tag faces

    for (var i = 0; i < length; i++) {
      faces[i]._id = i;
    } // sort faces


    function materialIndexSort(a, b) {
      return a.materialIndex - b.materialIndex;
    }

    faces.sort(materialIndexSort); // sort uvs

    var uvs1 = this.faceVertexUvs[0];
    var uvs2 = this.faceVertexUvs[1];
    var newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length) newUvs1 = [];
    if (uvs2 && uvs2.length === length) newUvs2 = [];

    for (var i = 0; i < length; i++) {
      var id = faces[i]._id;
      if (newUvs1) newUvs1.push(uvs1[id]);
      if (newUvs2) newUvs2.push(uvs2[id]);
    }

    if (newUvs1) this.faceVertexUvs[0] = newUvs1;
    if (newUvs2) this.faceVertexUvs[1] = newUvs2;
  },
  toJSON: function () {
    var data = {
      metadata: {
        version: 4.5,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
      }
    }; // standard Geometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;

    if (this.parameters !== undefined) {
      var parameters = this.parameters;

      for (var key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    }

    var vertices = [];

    for (var i = 0; i < this.vertices.length; i++) {
      var vertex = this.vertices[i];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }

    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};

    for (var i = 0; i < this.faces.length; i++) {
      var face = this.faces[i];
      var hasMaterial = true;
      var hasFaceUv = false; // deprecated

      var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;
      var faceType = 0;
      faceType = setBit(faceType, 0, 0); // isQuad

      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);

      if (hasFaceVertexUv) {
        var faceVertexUvs = this.faceVertexUvs[0][i];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }

      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }

      if (hasFaceVertexNormal) {
        var vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }

      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }

      if (hasFaceVertexColor) {
        var vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }

    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }

    function getNormalIndex(normal) {
      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

      if (normalsHash[hash] !== undefined) {
        return normalsHash[hash];
      }

      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }

    function getColorIndex(color) {
      var hash = color.r.toString() + color.g.toString() + color.b.toString();

      if (colorsHash[hash] !== undefined) {
        return colorsHash[hash];
      }

      colorsHash[hash] = colors.length;
      colors.push(color.getHex());
      return colorsHash[hash];
    }

    function getUvIndex(uv) {
      var hash = uv.x.toString() + uv.y.toString();

      if (uvsHash[hash] !== undefined) {
        return uvsHash[hash];
      }

      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv.x, uv.y);
      return uvsHash[hash];
    }

    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0) data.data.colors = colors;
    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility

    data.data.faces = faces;
    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 var parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 var values = [];
    	 for ( var key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 var geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new Geometry().copy(this);
  },
  copy: function (source) {
    var i, il, j, jl, k, kl; // reset

    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null; // name

    this.name = source.name; // vertices

    var vertices = source.vertices;

    for (i = 0, il = vertices.length; i < il; i++) {
      this.vertices.push(vertices[i].clone());
    } // colors


    var colors = source.colors;

    for (i = 0, il = colors.length; i < il; i++) {
      this.colors.push(colors[i].clone());
    } // faces


    var faces = source.faces;

    for (i = 0, il = faces.length; i < il; i++) {
      this.faces.push(faces[i].clone());
    } // face vertex uvs


    for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
      var faceVertexUvs = source.faceVertexUvs[i];

      if (this.faceVertexUvs[i] === undefined) {
        this.faceVertexUvs[i] = [];
      }

      for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
        var uvs = faceVertexUvs[j],
            uvsCopy = [];

        for (k = 0, kl = uvs.length; k < kl; k++) {
          var uv = uvs[k];
          uvsCopy.push(uv.clone());
        }

        this.faceVertexUvs[i].push(uvsCopy);
      }
    } // morph targets


    var morphTargets = source.morphTargets;

    for (i = 0, il = morphTargets.length; i < il; i++) {
      var morphTarget = {};
      morphTarget.name = morphTargets[i].name; // vertices

      if (morphTargets[i].vertices !== undefined) {
        morphTarget.vertices = [];

        for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
        }
      } // normals


      if (morphTargets[i].normals !== undefined) {
        morphTarget.normals = [];

        for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
          morphTarget.normals.push(morphTargets[i].normals[j].clone());
        }
      }

      this.morphTargets.push(morphTarget);
    } // morph normals


    var morphNormals = source.morphNormals;

    for (i = 0, il = morphNormals.length; i < il; i++) {
      var morphNormal = {}; // vertex normals

      if (morphNormals[i].vertexNormals !== undefined) {
        morphNormal.vertexNormals = [];

        for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
          var srcVertexNormal = morphNormals[i].vertexNormals[j];
          var destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      } // face normals


      if (morphNormals[i].faceNormals !== undefined) {
        morphNormal.faceNormals = [];

        for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
        }
      }

      this.morphNormals.push(morphNormal);
    } // skin weights


    var skinWeights = source.skinWeights;

    for (i = 0, il = skinWeights.length; i < il; i++) {
      this.skinWeights.push(skinWeights[i].clone());
    } // skin indices


    var skinIndices = source.skinIndices;

    for (i = 0, il = skinIndices.length; i < il; i++) {
      this.skinIndices.push(skinIndices[i].clone());
    } // line distances


    var lineDistances = source.lineDistances;

    for (i = 0, il = lineDistances.length; i < il; i++) {
      this.lineDistances.push(lineDistances[i]);
    } // bounding box


    var boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    var boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // update flags


    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Face3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Color_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__ = __webpack_require__(0);


/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Face3(a, b, c, normal, color, materialIndex) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = normal && normal.isVector3 ? normal : new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
  this.vertexNormals = Array.isArray(normal) ? normal : [];
  this.color = color && color.isColor ? color : new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */]();
  this.vertexColors = Array.isArray(color) ? color : [];
  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
}

Object.assign(Face3.prototype, {
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;

    for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
      this.vertexNormals[i] = source.vertexNormals[i].clone();
    }

    for (var i = 0, il = source.vertexColors.length; i < il; i++) {
      this.vertexColors[i] = source.vertexColors[i].clone();
    }

    return this;
  }
});


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export arrayMin */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayMax; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function arrayMin(array) {
  if (array.length === 0) return Infinity;
  var min = array[0];

  for (var i = 1, l = array.length; i < l; ++i) {
    if (array[i] < min) min = array[i];
  }

  return min;
}

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  var max = array[0];

  for (var i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MeshBasicMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Material_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Color_js__ = __webpack_require__(7);



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial(parameters) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].call(this);
  this.type = 'MeshBasicMaterial';
  this.color = new __WEBPACK_IMPORTED_MODULE_2__math_Color_js__["a" /* Color */](0xffffff); // emissive

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = __WEBPACK_IMPORTED_MODULE_1__constants_js__["_9" /* MultiplyOperation */];
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshBasicMaterial.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function (source) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  return this;
};



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShaderMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Material_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__renderers_shaders_UniformsUtils_js__ = __webpack_require__(32);


/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial(parameters) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].call(this);
  this.type = 'ShaderMaterial';
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
  this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false; // set to use scene fog

  this.lights = false; // set to use scene lights

  this.clipping = false; // set to use user-defined clipping planes

  this.skinning = false; // set to use skinning attribute streams

  this.morphTargets = false; // set to use morph targets

  this.morphNormals = false; // set to use morph normals

  this.extensions = {
    derivatives: false,
    // set to use derivatives
    fragDepth: false,
    // set to use fragment depth values
    drawBuffers: false,
    // set to use draw buffers
    shaderTextureLOD: false // set to use shader texture LOD

  }; // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.

  this.defaultAttributeValues = {
    'color': [1, 1, 1],
    'uv': [0, 0],
    'uv2': [0, 0]
  };
  this.index0AttributeName = undefined;
  this.uniformsNeedUpdate = false;

  if (parameters !== undefined) {
    if (parameters.attributes !== undefined) {
      console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
    }

    this.setValues(parameters);
  }
}

ShaderMaterial.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function (source) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = __WEBPACK_IMPORTED_MODULE_1__renderers_shaders_UniformsUtils_js__["a" /* UniformsUtils */].clone(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = source.extensions;
  return this;
};

ShaderMaterial.prototype.toJSON = function (meta) {
  var data = __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype.toJSON.call(this, meta);
  data.uniforms = {};

  for (var name in this.uniforms) {
    var uniform = this.uniforms[name];
    var value = uniform.value;

    if (value.isTexture) {
      data.uniforms[name] = {
        type: 't',
        value: value.toJSON(meta).uuid
      };
    } else if (value.isColor) {
      data.uniforms[name] = {
        type: 'c',
        value: value.getHex()
      };
    } else if (value.isVector2) {
      data.uniforms[name] = {
        type: 'v2',
        value: value.toArray()
      };
    } else if (value.isVector3) {
      data.uniforms[name] = {
        type: 'v3',
        value: value.toArray()
      };
    } else if (value.isVector4) {
      data.uniforms[name] = {
        type: 'v4',
        value: value.toArray()
      };
    } else if (value.isMatrix4) {
      data.uniforms[name] = {
        type: 'm4',
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value: value
      }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
    }
  }

  if (Object.keys(this.defines).length > 0) data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  return data;
};



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Mesh; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Sphere_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Ray_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_Object3D_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Triangle_js__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_Face3_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__materials_MeshBasicMaterial_js__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_BufferGeometry_js__ = __webpack_require__(14);











/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

function Mesh(geometry, material) {
  __WEBPACK_IMPORTED_MODULE_5__core_Object3D_js__["a" /* Object3D */].call(this);
  this.type = 'Mesh';
  this.geometry = geometry !== undefined ? geometry : new __WEBPACK_IMPORTED_MODULE_10__core_BufferGeometry_js__["a" /* BufferGeometry */]();
  this.material = material !== undefined ? material : new __WEBPACK_IMPORTED_MODULE_9__materials_MeshBasicMaterial_js__["a" /* MeshBasicMaterial */]({
    color: Math.random() * 0xffffff
  });
  this.drawMode = __WEBPACK_IMPORTED_MODULE_8__constants_js__["_73" /* TrianglesDrawMode */];
  this.updateMorphTargets();
}

Mesh.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_5__core_Object3D_js__["a" /* Object3D */].prototype), {
  constructor: Mesh,
  isMesh: true,
  setDrawMode: function (value) {
    this.drawMode = value;
  },
  copy: function (source) {
    __WEBPACK_IMPORTED_MODULE_5__core_Object3D_js__["a" /* Object3D */].prototype.copy.call(this, source);
    this.drawMode = source.drawMode;

    if (source.morphTargetInfluences !== undefined) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }

    if (source.morphTargetDictionary !== undefined) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }

    return this;
  },
  updateMorphTargets: function () {
    var geometry = this.geometry;
    var m, ml, name;

    if (geometry.isBufferGeometry) {
      var morphAttributes = geometry.morphAttributes;
      var keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (m = 0, ml = morphAttribute.length; m < ml; m++) {
            name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      var morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};

        for (m = 0, ml = morphTargets.length; m < ml; m++) {
          name = morphTargets[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  },
  raycast: function () {
    var inverseMatrix = new __WEBPACK_IMPORTED_MODULE_4__math_Matrix4_js__["a" /* Matrix4 */]();
    var ray = new __WEBPACK_IMPORTED_MODULE_3__math_Ray_js__["a" /* Ray */]();
    var sphere = new __WEBPACK_IMPORTED_MODULE_2__math_Sphere_js__["a" /* Sphere */]();
    var vA = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
    var vB = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
    var vC = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
    var tempA = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
    var tempB = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
    var tempC = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
    var uvA = new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */]();
    var uvB = new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */]();
    var uvC = new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */]();
    var intersectionPoint = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
    var intersectionPointWorld = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();

    function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
      var intersect;

      if (material.side === __WEBPACK_IMPORTED_MODULE_8__constants_js__["f" /* BackSide */]) {
        intersect = ray.intersectTriangle(pC, pB, pA, true, point);
      } else {
        intersect = ray.intersectTriangle(pA, pB, pC, material.side !== __WEBPACK_IMPORTED_MODULE_8__constants_js__["w" /* DoubleSide */], point);
      }

      if (intersect === null) return null;
      intersectionPointWorld.copy(point);
      intersectionPointWorld.applyMatrix4(object.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
      if (distance < raycaster.near || distance > raycaster.far) return null;
      return {
        distance: distance,
        point: intersectionPointWorld.clone(),
        object: object
      };
    }

    function checkBufferGeometryIntersection(object, material, raycaster, ray, position, uv, a, b, c) {
      vA.fromBufferAttribute(position, a);
      vB.fromBufferAttribute(position, b);
      vC.fromBufferAttribute(position, c);
      var intersection = checkIntersection(object, material, raycaster, ray, vA, vB, vC, intersectionPoint);

      if (intersection) {
        if (uv) {
          uvA.fromBufferAttribute(uv, a);
          uvB.fromBufferAttribute(uv, b);
          uvC.fromBufferAttribute(uv, c);
          intersection.uv = __WEBPACK_IMPORTED_MODULE_6__math_Triangle_js__["a" /* Triangle */].getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */]());
        }

        var face = new __WEBPACK_IMPORTED_MODULE_7__core_Face3_js__["a" /* Face3 */](a, b, c);
        __WEBPACK_IMPORTED_MODULE_6__math_Triangle_js__["a" /* Triangle */].getNormal(vA, vB, vC, face.normal);
        intersection.face = face;
      }

      return intersection;
    }

    return function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var material = this.material;
      var matrixWorld = this.matrixWorld;
      if (material === undefined) return; // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(sphere) === false) return; //

      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix); // Check boundingBox before continuing

      if (geometry.boundingBox !== null) {
        if (ray.intersectsBox(geometry.boundingBox) === false) return;
      }

      var intersection;

      if (geometry.isBufferGeometry) {
        var a, b, c;
        var index = geometry.index;
        var position = geometry.attributes.position;
        var uv = geometry.attributes.uv;
        var groups = geometry.groups;
        var drawRange = geometry.drawRange;
        var i, j, il, jl;
        var group, groupMaterial;
        var start, end;

        if (index !== null) {
          // indexed buffer geometry
          if (Array.isArray(material)) {
            for (i = 0, il = groups.length; i < il; i++) {
              group = groups[i];
              groupMaterial = material[group.materialIndex];
              start = Math.max(group.start, drawRange.start);
              end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

              for (j = start, jl = end; j < jl; j += 3) {
                a = index.getX(j);
                b = index.getX(j + 1);
                c = index.getX(j + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, uv, a, b, c);

                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

                  intersects.push(intersection);
                }
              }
            }
          } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(index.count, drawRange.start + drawRange.count);

            for (i = start, il = end; i < il; i += 3) {
              a = index.getX(i);
              b = index.getX(i + 1);
              c = index.getX(i + 2);
              intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, uv, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

                intersects.push(intersection);
              }
            }
          }
        } else if (position !== undefined) {
          // non-indexed buffer geometry
          if (Array.isArray(material)) {
            for (i = 0, il = groups.length; i < il; i++) {
              group = groups[i];
              groupMaterial = material[group.materialIndex];
              start = Math.max(group.start, drawRange.start);
              end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

              for (j = start, jl = end; j < jl; j += 3) {
                a = j;
                b = j + 1;
                c = j + 2;
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, uv, a, b, c);

                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

                  intersects.push(intersection);
                }
              }
            }
          } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(position.count, drawRange.start + drawRange.count);

            for (i = start, il = end; i < il; i += 3) {
              a = i;
              b = i + 1;
              c = i + 2;
              intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, uv, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

                intersects.push(intersection);
              }
            }
          }
        }
      } else if (geometry.isGeometry) {
        var fvA, fvB, fvC;
        var isMultiMaterial = Array.isArray(material);
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var uvs;
        var faceVertexUvs = geometry.faceVertexUvs[0];
        if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

        for (var f = 0, fl = faces.length; f < fl; f++) {
          var face = faces[f];
          var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
          if (faceMaterial === undefined) continue;
          fvA = vertices[face.a];
          fvB = vertices[face.b];
          fvC = vertices[face.c];

          if (faceMaterial.morphTargets === true) {
            var morphTargets = geometry.morphTargets;
            var morphInfluences = this.morphTargetInfluences;
            vA.set(0, 0, 0);
            vB.set(0, 0, 0);
            vC.set(0, 0, 0);

            for (var t = 0, tl = morphTargets.length; t < tl; t++) {
              var influence = morphInfluences[t];
              if (influence === 0) continue;
              var targets = morphTargets[t].vertices;
              vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
              vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
              vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
            }

            vA.add(fvA);
            vB.add(fvB);
            vC.add(fvC);
            fvA = vA;
            fvB = vB;
            fvC = vC;
          }

          intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);

          if (intersection) {
            if (uvs && uvs[f]) {
              var uvs_f = uvs[f];
              uvA.copy(uvs_f[0]);
              uvB.copy(uvs_f[1]);
              uvC.copy(uvs_f[2]);
              intersection.uv = __WEBPACK_IMPORTED_MODULE_6__math_Triangle_js__["a" /* Triangle */].getUV(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */]());
            }

            intersection.face = face;
            intersection.faceIndex = f;
            intersects.push(intersection);
          }
        }
      }
    };
  }(),
  clone: function () {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLUniforms; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__textures_CubeTexture_js__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__textures_Texture_js__ = __webpack_require__(10);
/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [renderer] )
 *
 * 		uploads a uniform value(s)
 *  	the 'renderer' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (renderer factorizations):
 *
 * .upload( gl, seq, values, renderer )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (renderer factorizations):
 *
 * .setValue( gl, name, value )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .set( gl, obj, prop )
 *
 * 		sets uniform from object and property with same name than uniform
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */


var emptyTexture = new __WEBPACK_IMPORTED_MODULE_1__textures_Texture_js__["a" /* Texture */]();
var emptyCubeTexture = new __WEBPACK_IMPORTED_MODULE_0__textures_CubeTexture_js__["a" /* CubeTexture */](); // --- Base for inner nodes (including the root) ---

function UniformContainer() {
  this.seq = [];
  this.map = {};
} // --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)


var arrayCacheF32 = [];
var arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
  var firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983

  var n = nBlocks * blockSize,
      r = arrayCacheF32[n];

  if (r === undefined) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }

  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);

    for (var i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }

  return r;
}

function arraysEqual(a, b) {
  if (a.length !== b.length) return false;

  for (var i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }

  return true;
}

function copyArray(a, b) {
  for (var i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
} // Texture unit allocation


function allocTexUnits(renderer, n) {
  var r = arrayCacheI32[n];

  if (r === undefined) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }

  for (var i = 0; i !== n; ++i) r[i] = renderer.allocTextureUnit();

  return r;
} // --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar


function setValue1f(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}

function setValue1i(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
} // Single float vector (from flat array or THREE.VectorN)


function setValue2fv(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValue3fv(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== undefined) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValue4fv(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
} // Single matrix (from flat array or MatrixN)


function setValue2fm(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}

function setValue3fm(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}

function setValue4fm(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
} // Single texture (2D / Cube)


function setValueT1(gl, v, renderer) {
  var cache = this.cache;
  var unit = renderer.allocTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  renderer.setTexture2D(v || emptyTexture, unit);
}

function setValueT6(gl, v, renderer) {
  var cache = this.cache;
  var unit = renderer.allocTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  renderer.setTextureCube(v || emptyCubeTexture, unit);
} // Integer / Boolean vectors or arrays thereof (always flat arrays)


function setValue2iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}

function setValue3iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}

function setValue4iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
} // Helper to pick the right setter for the singular case


function getSingularSetter(type) {
  switch (type) {
    case 0x1406:
      return setValue1f;
    // FLOAT

    case 0x8b50:
      return setValue2fv;
    // _VEC2

    case 0x8b51:
      return setValue3fv;
    // _VEC3

    case 0x8b52:
      return setValue4fv;
    // _VEC4

    case 0x8b5a:
      return setValue2fm;
    // _MAT2

    case 0x8b5b:
      return setValue3fm;
    // _MAT3

    case 0x8b5c:
      return setValue4fm;
    // _MAT4

    case 0x8b5e:
    case 0x8d66:
      return setValueT1;
    // SAMPLER_2D, SAMPLER_EXTERNAL_OES

    case 0x8b60:
      return setValueT6;
    // SAMPLER_CUBE

    case 0x1404:
    case 0x8b56:
      return setValue1i;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValue2iv;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValue3iv;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValue4iv;
    // _VEC4
  }
} // Array of scalars


function setValue1fv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform1fv(this.addr, v);
  copyArray(cache, v);
}

function setValue1iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform1iv(this.addr, v);
  copyArray(cache, v);
} // Array of vectors (flat or from THREE classes)


function setValueV2a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 2);
  if (arraysEqual(cache, data)) return;
  gl.uniform2fv(this.addr, data);
  this.updateCache(data);
}

function setValueV3a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 3);
  if (arraysEqual(cache, data)) return;
  gl.uniform3fv(this.addr, data);
  this.updateCache(data);
}

function setValueV4a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 4);
  if (arraysEqual(cache, data)) return;
  gl.uniform4fv(this.addr, data);
  this.updateCache(data);
} // Array of matrices (flat or from THREE clases)


function setValueM2a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 4);
  if (arraysEqual(cache, data)) return;
  gl.uniformMatrix2fv(this.addr, false, data);
  this.updateCache(data);
}

function setValueM3a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 9);
  if (arraysEqual(cache, data)) return;
  gl.uniformMatrix3fv(this.addr, false, data);
  this.updateCache(data);
}

function setValueM4a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 16);
  if (arraysEqual(cache, data)) return;
  gl.uniformMatrix4fv(this.addr, false, data);
  this.updateCache(data);
} // Array of textures (2D / Cube)


function setValueT1a(gl, v, renderer) {
  var cache = this.cache;
  var n = v.length;
  var units = allocTexUnits(renderer, n);

  if (arraysEqual(cache, units) === false) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }

  for (var i = 0; i !== n; ++i) {
    renderer.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}

function setValueT6a(gl, v, renderer) {
  var cache = this.cache;
  var n = v.length;
  var units = allocTexUnits(renderer, n);

  if (arraysEqual(cache, units) === false) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }

  for (var i = 0; i !== n; ++i) {
    renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
} // Helper to pick the right setter for a pure (bottom-level) array


function getPureArraySetter(type) {
  switch (type) {
    case 0x1406:
      return setValue1fv;
    // FLOAT

    case 0x8b50:
      return setValueV2a;
    // _VEC2

    case 0x8b51:
      return setValueV3a;
    // _VEC3

    case 0x8b52:
      return setValueV4a;
    // _VEC4

    case 0x8b5a:
      return setValueM2a;
    // _MAT2

    case 0x8b5b:
      return setValueM3a;
    // _MAT3

    case 0x8b5c:
      return setValueM4a;
    // _MAT4

    case 0x8b5e:
      return setValueT1a;
    // SAMPLER_2D

    case 0x8b60:
      return setValueT6a;
    // SAMPLER_CUBE

    case 0x1404:
    case 0x8b56:
      return setValue1iv;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValue2iv;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValue3iv;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValue4iv;
    // _VEC4
  }
} // --- Uniform Classes ---


function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

PureArrayUniform.prototype.updateCache = function (data) {
  var cache = this.cache;

  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }

  copyArray(cache, data);
};

function StructuredUniform(id) {
  this.id = id;
  UniformContainer.call(this); // mix-in
}

StructuredUniform.prototype.setValue = function (gl, value, renderer) {
  var seq = this.seq;

  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i];
    u.setValue(gl, value[u.id], renderer);
  }
}; // --- Top-level ---
// Parser - builds up the property tree from the path strings


var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g; // extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}

function parseUniform(activeInfo, addr, container) {
  var path = activeInfo.name,
      pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

  RePathPart.lastIndex = 0;

  while (true) {
    var match = RePathPart.exec(path),
        matchEnd = RePathPart.lastIndex,
        id = match[1],
        idIsIndex = match[2] === ']',
        subscript = match[3];
    if (idIsIndex) id = id | 0; // convert to integer

    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
      // bare name or "pure" bottom-level array "[0]" suffix
      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      // step into inner node / create it in case it doesn't exist
      var map = container.map,
          next = map[id];

      if (next === undefined) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }

      container = next;
    }
  }
} // Root Container


function WebGLUniforms(gl, program, renderer) {
  UniformContainer.call(this);
  this.renderer = renderer;
  var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

  for (var i = 0; i < n; ++i) {
    var info = gl.getActiveUniform(program, i),
        addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}

WebGLUniforms.prototype.setValue = function (gl, name, value) {
  var u = this.map[name];
  if (u !== undefined) u.setValue(gl, value, this.renderer);
};

WebGLUniforms.prototype.setOptional = function (gl, object, name) {
  var v = object[name];
  if (v !== undefined) this.setValue(gl, name, v);
}; // Static interface


WebGLUniforms.upload = function (gl, seq, values, renderer) {
  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i],
        v = values[u.id];

    if (v.needsUpdate !== false) {
      // note: always updating when .needsUpdate is undefined
      u.setValue(gl, v.value, renderer);
    }
  }
};

WebGLUniforms.seqWithValue = function (seq, values) {
  var r = [];

  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i];
    if (u.id in values) r.push(u);
  }

  return r;
};



/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLRenderTarget; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_EventDispatcher_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__textures_Texture_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector4_js__ = __webpack_require__(11);




/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/

function WebGLRenderTarget(width, height, options) {
  this.width = width;
  this.height = height;
  this.scissor = new __WEBPACK_IMPORTED_MODULE_3__math_Vector4_js__["a" /* Vector4 */](0, 0, width, height);
  this.scissorTest = false;
  this.viewport = new __WEBPACK_IMPORTED_MODULE_3__math_Vector4_js__["a" /* Vector4 */](0, 0, width, height);
  options = options || {};
  if (options.minFilter === undefined) options.minFilter = __WEBPACK_IMPORTED_MODULE_2__constants_js__["T" /* LinearFilter */];
  this.texture = new __WEBPACK_IMPORTED_MODULE_1__textures_Texture_js__["a" /* Texture */](undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
  this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : true;
  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}

WebGLRenderTarget.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__core_EventDispatcher_js__["a" /* EventDispatcher */].prototype), {
  constructor: WebGLRenderTarget,
  isWebGLRenderTarget: true,
  setSize: function (width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.dispose();
    }

    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.width = source.width;
    this.height = source.height;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Group; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__ = __webpack_require__(5);

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Group() {
  __WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__["a" /* Object3D */].call(this);
  this.type = 'Group';
}

Group.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__["a" /* Object3D */].prototype), {
  constructor: Group,
  isGroup: true
});


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ArrayCamera; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__PerspectiveCamera_js__ = __webpack_require__(26);
/**
 * @author mrdoob / http://mrdoob.com/
 */


function ArrayCamera(array) {
  __WEBPACK_IMPORTED_MODULE_0__PerspectiveCamera_js__["a" /* PerspectiveCamera */].call(this);
  this.cameras = array || [];
}

ArrayCamera.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__PerspectiveCamera_js__["a" /* PerspectiveCamera */].prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PointsMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Material_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Color_js__ = __webpack_require__(7);


/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial(parameters) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].call(this);
  this.type = 'PointsMaterial';
  this.color = new __WEBPACK_IMPORTED_MODULE_1__math_Color_js__["a" /* Color */](0xffffff);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}

PointsMaterial.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function (source) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;
  this.morphTargets = source.morphTargets;
  return this;
};



/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineBasicMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Material_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Color_js__ = __webpack_require__(7);


/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial(parameters) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].call(this);
  this.type = 'LineBasicMaterial';
  this.color = new __WEBPACK_IMPORTED_MODULE_1__math_Color_js__["a" /* Color */](0xffffff);
  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';
  this.lights = false;
  this.setValues(parameters);
}

LineBasicMaterial.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function (source) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;
  return this;
};



/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Light; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Color_js__ = __webpack_require__(7);


/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Light(color, intensity) {
  __WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__["a" /* Object3D */].call(this);
  this.type = 'Light';
  this.color = new __WEBPACK_IMPORTED_MODULE_1__math_Color_js__["a" /* Color */](color);
  this.intensity = intensity !== undefined ? intensity : 1;
  this.receiveShadow = undefined;
}

Light.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__["a" /* Object3D */].prototype), {
  constructor: Light,
  isLight: true,
  copy: function (source) {
    __WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__["a" /* Object3D */].prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function (meta) {
    var data = __WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__["a" /* Object3D */].prototype.toJSON.call(this, meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== undefined) data.object.distance = this.distance;
    if (this.angle !== undefined) data.object.angle = this.angle;
    if (this.decay !== undefined) data.object.decay = this.decay;
    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
    return data;
  }
});


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DefaultLoadingManager; });
/* unused harmony export LoadingManager */
/**
 * @author mrdoob / http://mrdoob.com/
 */
function LoadingManager(onLoad, onProgress, onError) {
  var scope = this;
  var isLoading = false;
  var itemsLoaded = 0;
  var itemsTotal = 0;
  var urlModifier = undefined; // Refer to #5689 for the reason why we don't set .onStart
  // in the constructor

  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function (url) {
    itemsTotal++;

    if (isLoading === false) {
      if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }

    isLoading = true;
  };

  this.itemEnd = function (url) {
    itemsLoaded++;

    if (scope.onProgress !== undefined) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }

    if (itemsLoaded === itemsTotal) {
      isLoading = false;

      if (scope.onLoad !== undefined) {
        scope.onLoad();
      }
    }
  };

  this.itemError = function (url) {
    if (scope.onError !== undefined) {
      scope.onError(url);
    }
  };

  this.resolveURL = function (url) {
    if (urlModifier) {
      return urlModifier(url);
    }

    return url;
  };

  this.setURLModifier = function (transform) {
    urlModifier = transform;
    return this;
  };
}

var DefaultLoadingManager = new LoadingManager();


/***/ }),
/* 61 */
/***/ (function(module, exports) {

/**
 * @fileOverview 计算方法
 * @author dxq613@gmail.com
 */
// 如果小数点后面超过 10 位浮点数时进行一下处理
var DECIMAL_LENGTH = 12; // 获取系数

function getFactor(v) {
  var factor = 1;

  if (v === Infinity || v === -Infinity) {
    throw new Error('Not support Infinity!');
  }

  if (v < 1) {
    var count = 0;

    while (v < 1) {
      factor = factor / 10;
      v = v * 10;
      count++;
    } // 浮点数计算出现问题


    if (factor.toString().length > DECIMAL_LENGTH) {
      factor = parseFloat(factor.toFixed(count));
    }
  } else {
    while (v > 10) {
      factor = factor * 10;
      v = v / 10;
    }
  }

  return factor;
} // 取小于当前值的


function arrayFloor(values, value) {
  var length = values.length;

  if (length === 0) {
    return NaN;
  }

  var pre = values[0];

  if (value < values[0]) {
    return NaN;
  }

  if (value >= values[length - 1]) {
    return values[length - 1];
  }

  for (var i = 1; i < values.length; i++) {
    if (value < values[i]) {
      break;
    }

    pre = values[i];
  }

  return pre;
} // 大于当前值的第一个


function arrayCeiling(values, value) {
  var length = values.length;

  if (length === 0) {
    return NaN;
  } // var pre = values[0];


  var rst;

  if (value > values[length - 1]) {
    return NaN;
  }

  if (value < values[0]) {
    return values[0];
  }

  for (var i = 1; i < values.length; i++) {
    if (value <= values[i]) {
      rst = values[i];
      break;
    }
  }

  return rst;
}

var Util = {
  // 获取逼近的数值
  snapFactorTo: function snapFactorTo(v, arr, snapType) {
    // 假设 v = -512,isFloor = true
    if (isNaN(v)) {
      return NaN;
    }

    var factor = 1; // 计算系数

    if (v !== 0) {
      if (v < 0) {
        factor = -1;
      }

      v = v * factor; // v = 512

      var tmpFactor = getFactor(v);
      factor = factor * tmpFactor; // factor = -100

      v = v / tmpFactor; // v = 5.12
    }

    if (snapType === 'floor') {
      v = Util.snapFloor(arr, v); // v = 5
    } else if (snapType === 'ceil') {
      v = Util.snapCeiling(arr, v); // v = 6
    } else {
      v = Util.snapTo(arr, v); // 四舍五入 5
    }

    var rst = v * factor; // 如果出现浮点数计算问题，需要处理一下

    if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {
      var decimalVal = parseInt(1 / factor);
      var symbol = factor > 0 ? 1 : -1;
      rst = v / decimalVal * symbol;
    }

    return rst;
  },
  // 获取逼近的倍数
  snapMultiple: function snapMultiple(v, base, snapType) {
    var div;

    if (snapType === 'ceil') {
      div = Math.ceil(v / base);
    } else if (snapType === 'floor') {
      div = Math.floor(v / base);
    } else {
      div = Math.round(v / base);
    }

    return div * base;
  },

  /**
   * 获取逼近的值，用于对齐数据
   * @param  {Array} values   数据集合
   * @param  {Number} value   数值
   * @return {Number} 逼近的值
   */
  snapTo: function snapTo(values, value) {
    // 这里假定values是升序排列
    var floorVal = arrayFloor(values, value);
    var ceilingVal = arrayCeiling(values, value);

    if (isNaN(floorVal) || isNaN(ceilingVal)) {
      if (values[0] >= value) {
        return values[0];
      }

      var last = values[values.length - 1];

      if (last <= value) {
        return last;
      }
    }

    if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {
      return floorVal;
    }

    return ceilingVal;
  },

  /**
   * 获取逼近的最小值，用于对齐数据
   * @param  {Array} values   数据集合
   * @param  {Number} value   数值
   * @return {Number} 逼近的最小值
   */
  snapFloor: function snapFloor(values, value) {
    // 这里假定values是升序排列
    return arrayFloor(values, value);
  },

  /**
   * 获取逼近的最大值，用于对齐数据
   * @param  {Array} values   数据集合
   * @param  {Number} value   数值
   * @return {Number} 逼近的最大值
   */
  snapCeiling: function snapCeiling(values, value) {
    // 这里假定values是升序排列
    return arrayCeiling(values, value);
  }
};
module.exports = Util;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview the scale function to process the categories
 * @author dxq613@gmail.com
 */
var Base = __webpack_require__(27);

var Util = __webpack_require__(1);

var catAuto = __webpack_require__(63);
/**
 * 度量的构造函数
 * @class Scale.Category
 */


var Category =
/*#__PURE__*/
function (_Base) {
  _inherits(Category, _Base);

  function Category() {
    _classCallCheck(this, Category);

    return _possibleConstructorReturn(this, _getPrototypeOf(Category).apply(this, arguments));
  }

  _createClass(Category, [{
    key: "getDefaultCfg",

    /**
     * @override
     */
    value: function getDefaultCfg() {
      var cfg = _get(_getPrototypeOf(Category.prototype), "getDefaultCfg", this).call(this);

      return Util.mix({}, cfg, {
        /**
         * type of the scale
         * @type {String}
         */
        type: 'cat',

        /**
         * 自动生成标记时的个数
         * @type {Number}
         * @default null
         */
        tickCount: null,

        /**
         * 是否分类度量
         * @type {Boolean}
         */
        isCategory: true
      });
    }
    /**
     * @override
     */

  }, {
    key: "init",
    value: function init() {
      var self = this;
      var values = self.values;
      var tickCount = self.tickCount;
      Util.each(values, function (v, i) {
        values[i] = v.toString();
      });

      if (!self.ticks) {
        var ticks = values;

        if (tickCount) {
          var temp = catAuto({
            maxCount: tickCount,
            data: values
          });
          ticks = temp.ticks;
        }

        this.ticks = ticks;
      }
    }
    /**
     * @override
     */

  }, {
    key: "getText",
    value: function getText(value) {
      if (this.values.indexOf(value) === -1 && Util.isNumber(value)) {
        value = this.values[Math.round(value)];
      }

      return _get(_getPrototypeOf(Category.prototype), "getText", this).call(this, value);
    }
    /**
     * @override
     */

  }, {
    key: "translate",
    value: function translate(value) {
      var index = this.values.indexOf(value);

      if (index === -1 && Util.isNumber(value)) {
        index = value;
      } else if (index === -1) {
        index = NaN;
      }

      return index;
    }
    /**
     * @override
     */

  }, {
    key: "scale",
    value: function scale(value) {
      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      var percent;

      if (Util.isString(value) || this.values.indexOf(value) !== -1) {
        value = this.translate(value);
      }

      if (this.values.length > 1) {
        percent = value / (this.values.length - 1);
      } else {
        percent = value;
      }

      return rangeMin + percent * (rangeMax - rangeMin);
    }
    /**
     * @override
     */

  }, {
    key: "invert",
    value: function invert(value) {
      if (Util.isString(value)) {
        // 如果已经是字符串
        return value;
      }

      var min = this.rangeMin();
      var max = this.rangeMax(); // 归一到 范围内

      if (value < min) {
        value = min;
      }

      if (value > max) {
        value = max;
      }

      var percent = (value - min) / (max - min);
      var index = Math.round(percent * (this.values.length - 1)) % this.values.length;
      index = index || 0;
      return this.values[index];
    }
  }]);

  return Category;
}(Base);

module.exports = Category;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 计算分类的的坐标点
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(1);

var MAX_COUNT = 8;
var SUB_COUNT = 4; // 控制个数不能过小

function getSimpleArray(data) {
  var arr = [];
  Util.each(data, function (sub) {
    if (Util.isArray(sub)) {
      arr = arr.concat(sub);
    } else {
      arr.push(sub);
    }
  });
  return arr;
}

function getGreatestFactor(count, number) {
  var i;

  for (i = number; i > 0; i--) {
    if (count % i === 0) {
      break;
    }
  } // 如果是素数，没有可以整除的数字


  if (i === 1) {
    for (i = number; i > 0; i--) {
      if ((count - 1) % i === 0) {
        break;
      }
    }
  }

  return i;
}

module.exports = function (info) {
  var rst = {};
  var ticks = [];
  var maxCount = info.maxCount || MAX_COUNT;
  var categories = getSimpleArray(info.data);
  var length = categories.length;
  var tickCount = getGreatestFactor(length - 1, maxCount - 1) + 1; // 如果计算出来只有两个坐标点，则直接使用传入的 maxCount

  if (tickCount === 2) {
    tickCount = maxCount;
  } else if (tickCount < maxCount - SUB_COUNT) {
    tickCount = maxCount - SUB_COUNT;
  }

  var step = parseInt(length / (tickCount - 1), 10);
  var groups = categories.map(function (e, i) {
    return i % step === 0 ? categories.slice(i, i + step) : null;
  }).filter(function (e) {
    return e;
  });

  if (categories.length) {
    ticks.push(categories[0]);
  }

  for (var i = 1; i < groups.length && i * step < length - step; i++) {
    ticks.push(groups[i][0]);
  }

  if (categories.length) {
    var last = categories[length - 1];

    if (ticks.indexOf(last) === -1) {
      ticks.push(last);
    }
  }

  rst.categories = categories;
  rst.ticks = ticks;
  return rst;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;(function (main) {
  'use strict';
  /**
   * Parse or format dates
   * @class fecha
   */

  var fecha = {};
  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = /\d\d?/;
  var threeDigits = /\d{3}/;
  var fourDigits = /\d{4}/;
  var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var literal = /\[([^]*?)\]/gm;

  var noop = function () {};

  function shorten(arr, sLen) {
    var newArr = [];

    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }

    return newArr;
  }

  function monthUpdate(arrName) {
    return function (d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());

      if (~index) {
        d.month = index;
      }
    };
  }

  function pad(val, len) {
    val = String(val);
    len = len || 2;

    while (val.length < len) {
      val = '0' + val;
    }

    return val;
  }

  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };
  var formatFlags = {
    D: function (dateObj) {
      return dateObj.getDate();
    },
    DD: function (dateObj) {
      return pad(dateObj.getDate());
    },
    Do: function (dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function (dateObj) {
      return dateObj.getDay();
    },
    dd: function (dateObj) {
      return pad(dateObj.getDay());
    },
    ddd: function (dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function (dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function (dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function (dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function (dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function (dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    YY: function (dateObj) {
      return String(dateObj.getFullYear()).substr(2);
    },
    YYYY: function (dateObj) {
      return pad(dateObj.getFullYear(), 4);
    },
    h: function (dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function (dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function (dateObj) {
      return dateObj.getHours();
    },
    HH: function (dateObj) {
      return pad(dateObj.getHours());
    },
    m: function (dateObj) {
      return dateObj.getMinutes();
    },
    mm: function (dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function (dateObj) {
      return dateObj.getSeconds();
    },
    ss: function (dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function (dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function (dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function (dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function (dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function (dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function (dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };
  var parseFlags = {
    D: [twoDigits, function (d, v) {
      d.day = v;
    }],
    Do: [new RegExp(twoDigits.source + word.source), function (d, v) {
      d.day = parseInt(v, 10);
    }],
    M: [twoDigits, function (d, v) {
      d.month = v - 1;
    }],
    YY: [twoDigits, function (d, v) {
      var da = new Date(),
          cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function (d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function (d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function (d, v) {
      d.second = v;
    }],
    YYYY: [fourDigits, function (d, v) {
      d.year = v;
    }],
    S: [/\d/, function (d, v) {
      d.millisecond = v * 100;
    }],
    SS: [/\d{2}/, function (d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function (d, v) {
      d.millisecond = v;
    }],
    d: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function (d, v, i18n) {
      var val = v.toLowerCase();

      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: [/([\+\-]\d\d:?\d\d|Z)/, function (d, v) {
      if (v === 'Z') v = '+00:00';
      var parts = (v + '').match(/([\+\-]|\d\d)/gi),
          minutes;

      if (parts) {
        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.dd = parseFlags.d;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.DD = parseFlags.D;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a; // Some common format strings

  fecha.masks = {
    default: 'ddd MMM DD YYYY HH:mm:ss',
    shortDate: 'M/D/YY',
    mediumDate: 'MMM D, YYYY',
    longDate: 'MMMM D, YYYY',
    fullDate: 'dddd, MMMM D, YYYY',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };
  /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   */

  fecha.format = function (dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }

    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw new Error('Invalid Date in fecha.format');
    }

    mask = fecha.masks[mask] || mask || fecha.masks['default'];
    var literals = []; // Make literals inactive by replacing them with ??

    mask = mask.replace(literal, function ($0, $1) {
      literals.push($1);
      return '??';
    }); // Apply formatting rules

    mask = mask.replace(token, function ($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    }); // Inline literal values back into the formatted value

    return mask.replace(/\?\?/g, function () {
      return literals.shift();
    });
  };
  /**
   * Parse a date string into an object, changes - into /
   * @method parse
   * @param {string} dateStr Date string
   * @param {string} format Date parse format
   * @returns {Date|boolean}
   */


  fecha.parse = function (dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof format !== 'string') {
      throw new Error('Invalid format in fecha.parse');
    }

    format = fecha.masks[format] || format; // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS

    if (dateStr.length > 1000) {
      return false;
    }

    var isValid = true;
    var dateInfo = {};
    format.replace(token, function ($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        var index = dateStr.search(info[0]);

        if (!~index) {
          isValid = false;
        } else {
          dateStr.replace(info[0], function (result) {
            info[1](dateInfo, result, i18n);
            dateStr = dateStr.substr(index + result.length);
            return result;
          });
        }
      }

      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
    });

    if (!isValid) {
      return false;
    }

    var today = new Date();

    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }

    var date;

    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }

    return date;
  };
  /* istanbul ignore next */


  if (typeof module !== 'undefined' && module.exports) {
    module.exports = fecha;
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return fecha;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    main.fecha = fecha;
  }
})(this);

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 提取公共代码到util方法
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(1);

module.exports = {
  toTimeStamp: function toTimeStamp(value) {
    if (Util.isString(value)) {
      if (value.indexOf('T') > 0) {
        value = new Date(value).getTime();
      } else {
        value = new Date(value.replace(/-/ig, '/')).getTime();
      }
    }

    if (Util.isDate(value)) {
      value = value.getTime();
    }

    return value;
  }
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

var helpers = __webpack_require__(36);
/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */


function coordEach(geojson, callback, excludeWrapCoord) {
  // Handles null Geometry -- Skips this GeoJSON
  if (geojson === null) return;
  var j,
      k,
      l,
      geometry,
      stopG,
      coords,
      geometryMaybeCollection,
      wrapShrink = 0,
      coordIndex = 0,
      isGeometryCollection,
      type = geojson.type,
      isFeatureCollection = type === 'FeatureCollection',
      isFeature = type === 'Feature',
      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.

  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection; // Handles null Geometry -- Skips this geometry

      if (geometry === null) continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;
      wrapShrink = excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon') ? 1 : 0;

      switch (geomType) {
        case null:
          break;

        case 'Point':
          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
          coordIndex++;
          multiFeatureIndex++;
          break;

        case 'LineString':
        case 'MultiPoint':
          for (j = 0; j < coords.length; j++) {
            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
            coordIndex++;
            if (geomType === 'MultiPoint') multiFeatureIndex++;
          }

          if (geomType === 'LineString') multiFeatureIndex++;
          break;

        case 'Polygon':
        case 'MultiLineString':
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
              coordIndex++;
            }

            if (geomType === 'MultiLineString') multiFeatureIndex++;
            if (geomType === 'Polygon') geometryIndex++;
          }

          if (geomType === 'Polygon') multiFeatureIndex++;
          break;

        case 'MultiPolygon':
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;

            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                coordIndex++;
              }

              geometryIndex++;
            }

            multiFeatureIndex++;
          }

          break;

        case 'GeometryCollection':
          for (j = 0; j < geometry.geometries.length; j++) if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;

          break;

        default:
          throw new Error('Unknown Geometry Type');
      }
    }
  }
}
/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */


function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
  var previousValue = initialValue;
  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
  }, excludeWrapCoord);
  return previousValue;
}
/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */


function propEach(geojson, callback) {
  var i;

  switch (geojson.type) {
    case 'FeatureCollection':
      for (i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i].properties, i) === false) break;
      }

      break;

    case 'Feature':
      callback(geojson.properties, 0);
      break;
  }
}
/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */


function propReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  propEach(geojson, function (currentProperties, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);
  });
  return previousValue;
}
/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */


function featureEach(geojson, callback) {
  if (geojson.type === 'Feature') {
    callback(geojson, 0);
  } else if (geojson.type === 'FeatureCollection') {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false) break;
    }
  }
}
/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */


function featureReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  featureEach(geojson, function (currentFeature, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);
  });
  return previousValue;
}
/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */


function coordAll(geojson) {
  var coords = [];
  coordEach(geojson, function (coord) {
    coords.push(coord);
  });
  return coords;
}
/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */


function geomEach(geojson, callback) {
  var i,
      j,
      g,
      geometry,
      stopG,
      geometryMaybeCollection,
      isGeometryCollection,
      featureProperties,
      featureBBox,
      featureId,
      featureIndex = 0,
      isFeatureCollection = geojson.type === 'FeatureCollection',
      isFeature = geojson.type === 'Feature',
      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.

  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;
    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection; // Handle null Geometry

      if (geometry === null) {
        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
        continue;
      }

      switch (geometry.type) {
        case 'Point':
        case 'LineString':
        case 'MultiPoint':
        case 'Polygon':
        case 'MultiLineString':
        case 'MultiPolygon':
          {
            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
            break;
          }

        case 'GeometryCollection':
          {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
            }

            break;
          }

        default:
          throw new Error('Unknown Geometry Type');
      }
    } // Only increase `featureIndex` per each feature


    featureIndex++;
  }
}
/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */


function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
  });
  return previousValue;
}
/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */


function flattenEach(geojson, callback) {
  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
    // Callback for single geometry
    var type = geometry === null ? null : geometry.type;

    switch (type) {
      case null:
      case 'Point':
      case 'LineString':
      case 'Polygon':
        if (callback(helpers.feature(geometry, properties, {
          bbox: bbox,
          id: id
        }), featureIndex, 0) === false) return false;
        return;
    }

    var geomType; // Callback for multi-geometry

    switch (type) {
      case 'MultiPoint':
        geomType = 'Point';
        break;

      case 'MultiLineString':
        geomType = 'LineString';
        break;

      case 'MultiPolygon':
        geomType = 'Polygon';
        break;
    }

    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
    }
  });
}
/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */


function flattenReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
  });
  return previousValue;
}
/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */


function segmentEach(geojson, callback) {
  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0; // Exclude null Geometries

    if (!feature.geometry) return; // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.

    var type = feature.geometry.type;
    if (type === 'Point' || type === 'MultiPoint') return; // Generate 2-vertex line segments

    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
      if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
        previousCoords = currentCoord;
        previousFeatureIndex = featureIndex;
        previousMultiIndex = multiPartIndexCoord;
        prevGeomIndex = geometryIndex;
        segmentIndex = 0;
        return;
      }

      var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);
      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
      segmentIndex++;
      previousCoords = currentCoord;
    }) === false) return false;
  });
}
/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */


function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
    started = true;
  });
  return previousValue;
}
/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */


function lineEach(geojson, callback) {
  // validation
  if (!geojson) throw new Error('geojson is required');
  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    if (feature.geometry === null) return;
    var type = feature.geometry.type;
    var coords = feature.geometry.coordinates;

    switch (type) {
      case 'LineString':
        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
        break;

      case 'Polygon':
        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
          if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
        }

        break;
    }
  });
}
/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */


function lineReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
  });
  return previousValue;
}
/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */


function findSegment(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error('options is invalid');
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var segmentIndex = options.segmentIndex || 0; // Find FeatureIndex

  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case 'FeatureCollection':
      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;

    case 'Feature':
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;

    case 'Point':
    case 'MultiPoint':
      return null;

    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
      geometry = geojson;
      break;

    default:
      throw new Error('geojson is invalid');
  } // Find SegmentIndex


  if (geometry === null) return null;
  var coords = geometry.coordinates;

  switch (geometry.type) {
    case 'Point':
    case 'MultiPoint':
      return null;

    case 'LineString':
      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
      return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);

    case 'Polygon':
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
      return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);

    case 'MultiLineString':
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
      return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);

    case 'MultiPolygon':
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
      return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
  }

  throw new Error('geojson is invalid');
}
/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */


function findPoint(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!helpers.isObject(options)) throw new Error('options is invalid');
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var coordIndex = options.coordIndex || 0; // Find FeatureIndex

  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case 'FeatureCollection':
      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;

    case 'Feature':
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;

    case 'Point':
    case 'MultiPoint':
      return null;

    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
      geometry = geojson;
      break;

    default:
      throw new Error('geojson is invalid');
  } // Find Coord Index


  if (geometry === null) return null;
  var coords = geometry.coordinates;

  switch (geometry.type) {
    case 'Point':
      return helpers.point(coords, properties, options);

    case 'MultiPoint':
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      return helpers.point(coords[multiFeatureIndex], properties, options);

    case 'LineString':
      if (coordIndex < 0) coordIndex = coords.length + coordIndex;
      return helpers.point(coords[coordIndex], properties, options);

    case 'Polygon':
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
      return helpers.point(coords[geometryIndex][coordIndex], properties, options);

    case 'MultiLineString':
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);

    case 'MultiPolygon':
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
      return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
  }

  throw new Error('geojson is invalid');
}

exports.coordEach = coordEach;
exports.coordReduce = coordReduce;
exports.propEach = propEach;
exports.propReduce = propReduce;
exports.featureEach = featureEach;
exports.featureReduce = featureReduce;
exports.coordAll = coordAll;
exports.geomEach = geomEach;
exports.geomReduce = geomReduce;
exports.flattenEach = flattenEach;
exports.flattenReduce = flattenReduce;
exports.segmentEach = segmentEach;
exports.segmentReduce = segmentReduce;
exports.lineEach = lineEach;
exports.lineReduce = lineReduce;
exports.findSegment = findSegment;
exports.findPoint = findPoint;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var helpers_1 = __webpack_require__(36);
/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */


function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }

  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return coord.geometry.coordinates;
    }

    if (coord.type === "Point") {
      return coord.coordinates;
    }
  }

  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return coord;
  }

  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}

exports.getCoord = getCoord;
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */

function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  } // Feature


  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    // Geometry
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }

  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}

exports.getCoords = getCoords;
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */

function containsNumber(coordinates) {
  if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {
    return true;
  }

  if (Array.isArray(coordinates[0]) && coordinates[0].length) {
    return containsNumber(coordinates[0]);
  }

  throw new Error("coordinates must only contain numbers");
}

exports.containsNumber = containsNumber;
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */

function geojsonType(value, type, name) {
  if (!type || !name) {
    throw new Error("type and name required");
  }

  if (!value || value.type !== type) {
    throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
  }
}

exports.geojsonType = geojsonType;
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */

function featureOf(feature, type, name) {
  if (!feature) {
    throw new Error("No feature passed");
  }

  if (!name) {
    throw new Error(".featureOf() requires a name");
  }

  if (!feature || feature.type !== "Feature" || !feature.geometry) {
    throw new Error("Invalid input to " + name + ", Feature with geometry required");
  }

  if (!feature.geometry || feature.geometry.type !== type) {
    throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
  }
}

exports.featureOf = featureOf;
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */

function collectionOf(featureCollection, type, name) {
  if (!featureCollection) {
    throw new Error("No featureCollection passed");
  }

  if (!name) {
    throw new Error(".collectionOf() requires a name");
  }

  if (!featureCollection || featureCollection.type !== "FeatureCollection") {
    throw new Error("Invalid input to " + name + ", FeatureCollection required");
  }

  for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
    var feature = _a[_i];

    if (!feature || feature.type !== "Feature" || !feature.geometry) {
      throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }

    if (!feature.geometry || feature.geometry.type !== type) {
      throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
  }
}

exports.collectionOf = collectionOf;
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */

function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }

  return geojson;
}

exports.getGeom = getGeom;
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */

function getType(geojson, name) {
  if (geojson.type === "FeatureCollection") {
    return "FeatureCollection";
  }

  if (geojson.type === "GeometryCollection") {
    return "GeometryCollection";
  }

  if (geojson.type === "Feature" && geojson.geometry !== null) {
    return geojson.geometry.type;
  }

  return geojson.type;
}

exports.getType = getType;

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeatureIndex; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rbush__ = __webpack_require__(269);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rbush___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rbush__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_bbox__ = __webpack_require__(271);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_bbox___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__turf_bbox__);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var FeatureIndex =
/*#__PURE__*/
function () {
  function FeatureIndex(data) {
    var _this = this;

    _classCallCheck(this, FeatureIndex);

    this.tree = __WEBPACK_IMPORTED_MODULE_0_rbush___default()();
    this.rawData = data;
    data.features.forEach(function (feature) {
      _this.insert(feature);
    });
  }

  _createClass(FeatureIndex, [{
    key: "insert",
    value: function insert(feature) {
      var bbox = this.toBBox(feature);
      bbox.feature = feature;
      this.tree.insert(bbox);
    }
  }, {
    key: "search",
    value: function search(feature) {
      return this.tree.search(this.toBBox(feature));
    }
  }, {
    key: "clear",
    value: function clear() {
      this.tree.clear();
    }
  }, {
    key: "all",
    value: function all() {
      return this.tree.all();
    }
  }, {
    key: "toBBox",
    value: function toBBox(feature) {
      var bbox = feature.type === 'Point' ? this.pointBBox(feature) : __WEBPACK_IMPORTED_MODULE_1__turf_bbox___default()(feature);
      return {
        minX: bbox[0],
        minY: bbox[1],
        maxX: bbox[2],
        maxY: bbox[3]
      };
    }
  }, {
    key: "pointBBox",
    value: function pointBBox(feature) {
      var size = 1 / 1000 / 1000; //  1m

      var _feature$geometry$coo = _slicedToArray(feature.geometry.coordinates, 2),
          x = _feature$geometry$coo[0],
          y = _feature$geometry$coo[1];

      return [x - size, y - size, x + size, y + size];
    }
  }]);

  return FeatureIndex;
}();



/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CSVSource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_source__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geo_featureIndex__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_dsv__ = __webpack_require__(272);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var CSVSource =
/*#__PURE__*/
function (_Source) {
  _inherits(CSVSource, _Source);

  function CSVSource() {
    _classCallCheck(this, CSVSource);

    return _possibleConstructorReturn(this, _getPrototypeOf(CSVSource).apply(this, arguments));
  }

  _createClass(CSVSource, [{
    key: "prepareData",
    value: function prepareData() {
      var _this = this;

      this.type = 'csv';
      var data = this.get('data');
      var x = this.get('x');
      var y = this.get('y');
      var x1 = this.get('x1');
      var y1 = this.get('y1');
      var coords = this.get('coordinates');
      this.propertiesData = []; // 临时使用

      this.geoData = [];
      var csvdata = data;
      __WEBPACK_IMPORTED_MODULE_2__util___default.a.isArray(csvdata) || (csvdata = Object(__WEBPACK_IMPORTED_MODULE_3_d3_dsv__["a" /* csvParse */])(data));
      this.propertiesData = csvdata;
      csvdata.forEach(function (col, featureIndex) {
        var coordinates = [];

        if (col.coordinates) {
          coordinates = col.coordinates;
        }

        if (x && y) {
          coordinates = [col[x], col[y]];
        }

        if (x1 && y1) {
          coordinates = [[col[x], col[y]], [col[x1], col[y1]]];
        }

        if (coords && col.coords) {
          coordinates = col.coords;
        }

        col._id = featureIndex + 1;

        _this._coordProject(coordinates);

        _this.geoData.push(_this._coordProject(coordinates));
      });
    }
  }, {
    key: "featureIndex",
    value: function featureIndex() {
      var data = this.get('data');
      this.featureIndex = new __WEBPACK_IMPORTED_MODULE_1__geo_featureIndex__["a" /* default */](data);
    }
  }, {
    key: "getSelectFeatureId",
    value: function getSelectFeatureId(featureId) {
      return [featureId];
    }
  }, {
    key: "_getCoord",
    value: function _getCoord(geo) {
      if (geo.geometry) {
        // GeoJSON feature
        geo = geo.geometry.coordinates;
      } else if (geo.coordinates) {
        // GeoJSON geometry
        geo = geo.coordinates;
      }

      return geo;
    }
  }, {
    key: "_coordProject",
    value: function _coordProject(geo) {
      var _this2 = this;

      if (Array.isArray(geo[0][0])) {
        return geo.map(function (coor) {
          return _this2._coordProject(coor);
        });
      }

      if (!Array.isArray(geo[0])) {
        return this._coorConvert(geo);
      }

      return geo.map(function (coor) {
        return _this2._coorConvert(coor);
      });
    }
  }]);

  return CSVSource;
}(__WEBPACK_IMPORTED_MODULE_0__core_source__["a" /* default */]);



/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ImageSource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_source__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_ajax__ = __webpack_require__(38);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var ImageSource =
/*#__PURE__*/
function (_Source) {
  _inherits(ImageSource, _Source);

  function ImageSource() {
    _classCallCheck(this, ImageSource);

    return _possibleConstructorReturn(this, _getPrototypeOf(ImageSource).apply(this, arguments));
  }

  _createClass(ImageSource, [{
    key: "prepareData",
    value: function prepareData() {
      this.type = 'image';
      var extent = this.get('extent');

      var lb = this._coorConvert(extent.slice(0, 2));

      var tr = this._coorConvert(extent.slice(2, 4));

      this.geoData = [lb, tr];
      this.propertiesData = [];

      this._loadData();
    }
  }, {
    key: "_loadData",
    value: function _loadData() {
      var _this = this;

      var url = this.get('data');
      this.image = [];

      if (typeof url === 'string') {
        Object(__WEBPACK_IMPORTED_MODULE_1__util_ajax__["a" /* getImage */])({
          url: url
        }, function (err, img) {
          _this.image = img;

          _this.emit('imageLoaded');
        });
      } else {
        var imageCount = url.length;
        var imageindex = 0;
        url.forEach(function (item) {
          Object(__WEBPACK_IMPORTED_MODULE_1__util_ajax__["a" /* getImage */])({
            url: item
          }, function (err, img) {
            imageindex++;

            _this.image.push(img);

            if (imageindex === imageCount) {
              _this.emit('imageLoaded');
            }
          });
        });
      }
    }
  }]);

  return ImageSource;
}(__WEBPACK_IMPORTED_MODULE_0__core_source__["a" /* default */]);



/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PolygonBuffer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shape__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bufferBase__ = __webpack_require__(17);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var PolygonBuffer =
/*#__PURE__*/
function (_BufferBase) {
  _inherits(PolygonBuffer, _BufferBase);

  function PolygonBuffer() {
    _classCallCheck(this, PolygonBuffer);

    return _possibleConstructorReturn(this, _getPrototypeOf(PolygonBuffer).apply(this, arguments));
  }

  _createClass(PolygonBuffer, [{
    key: "geometryBuffer",
    value: function geometryBuffer() {
      var coordinates = this.get('coordinates');
      var properties = this.get('properties');
      var shape = this.get('shape');
      var positions = [];
      var faceUv = [];
      var sizes = [];
      var positionsIndex = [];
      var indexCount = 0;
      this.bufferStruct.style = properties;
      var isExtrude = properties[0].hasOwnProperty('size'); // indices, normals, colors, UVs

      coordinates.forEach(function (geo, index) {
        var heightValue = properties[index].size;
        var extrudeData = __WEBPACK_IMPORTED_MODULE_0__shape__["b" /* polygonShape */][shape](geo);

        if (isExtrude && shape === 'extrude') {
          extrudeData = __WEBPACK_IMPORTED_MODULE_0__shape__["b" /* polygonShape */].extrude(geo);
          extrudeData.positions = extrudeData.positions.map(function (pos) {
            pos[2] *= heightValue;
            return pos;
          });
        }

        positions.push(extrudeData.positions);

        if (shape !== 'line') {
          // faceUv.push(...extrudeData.faceUv);
          var count = extrudeData.faceUv.length / 2;

          for (var i = 0; i < count; i++) {
            // uv 系数生成等大小的窗户
            var x = extrudeData.faceUv[i * 2];
            var y = extrudeData.faceUv[i * 2 + 1];

            if (x !== -1) {
              x = x * 0.1;
              y = y * heightValue / 2000;
            }

            faceUv.push(x, y);
            sizes.push((1.0 - extrudeData.faceUv[i * 2 + 1]) * heightValue);
          }
        }

        indexCount += extrudeData.positionsIndex.length;
        positionsIndex.push(extrudeData.positionsIndex);
      });
      this.bufferStruct.indices = positionsIndex;
      this.bufferStruct.position = positions;
      this.bufferStruct.indexCount = indexCount;
      this.bufferStruct.style = properties;
      this.bufferStruct.faceUv = faceUv;
      this.bufferStruct.sizes = sizes;

      if (shape !== 'line') {
        this.attributes = this._toPolygonAttributes(this.bufferStruct);
        this.faceTexture = this._generateTexture();
      } else {
        this.attributes = this._toPolygonLineAttributes(this.bufferStruct);
      }
    }
  }]);

  return PolygonBuffer;
}(__WEBPACK_IMPORTED_MODULE_1__bufferBase__["a" /* default */]);



/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["fill"] = fill;
/* harmony export (immutable) */ __webpack_exports__["extrude"] = extrude;
/* harmony export (immutable) */ __webpack_exports__["line"] = line;
/* harmony export (immutable) */ __webpack_exports__["extrudeline"] = extrudeline;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extrude__ = __webpack_require__(73);

/**
 * 计算平面的 polygon的顶点坐标和索引
 * @param {Array} points 顶点坐标
 * @param {*} extrude 是否拉伸
 * @return {object} 顶点坐标和顶点索引
 */

function fill(points) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__extrude__["a" /* default */])(points, false);
}
/**
 * 计算 extrude 的 polygon的顶点坐标和索引
 * @param {Array} points 顶点坐标
 * @param {*} extrude 是否拉伸
 * @return {object} 顶点坐标和顶点索引
 */

function extrude(points) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__extrude__["a" /* default */])(points, true);
}
/**
 * 绘制多边形轮廓
 * @param {*} points 点数据组
 * @return {object} 顶点坐标和顶点索引
 */

function line(points) {
  var vertIndex = [];
  var vertCount = points[0].length - 1;

  for (var i = 0; i < vertCount; i++) {
    vertIndex.push(i, i + 1);
  }

  vertIndex.push(vertCount, 0);
  return {
    positions: points[0],
    positionsIndex: vertIndex
  };
}
/**
 * 绘制3D多边形轮廓
 * @param {*} points 点数据组
 * @return {object} 顶点坐标和顶点索引
 */

function extrudeline(points) {
  var positions = [];
  points[0].forEach(function (p) {
    positions.push([p[0], p[1], 0]);
  });
  points[0].forEach(function (p) {
    positions.push([p[0], p[1], 1]);
  }); // top

  var vertIndex = [];
  var pointCount = points[0].length;
  var vertCount = pointCount - 1;

  for (var i = 0; i < vertCount; i++) {
    vertIndex.push(i, i + 1);
    vertIndex.push(i + pointCount, i + 1 + pointCount);
    vertIndex.push(i, i + pointCount);
  }

  vertIndex.push(vertCount, 0);
  vertIndex.push(vertCount, vertCount + pointCount);
  vertIndex.push(vertCount + pointCount, pointCount);
  return {
    positions: positions,
    positionsIndex: vertIndex
  };
}

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = extrudePolygon;
/* unused harmony export extrudePolygonLine */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_earcut__ = __webpack_require__(287);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_earcut__);

/**
 * 计算是否拉伸
 * @param {Array} points  点坐标数组
 * @param {boolean} extrude  是否拉伸
 * @return {object} 顶点坐标顶点索引
 */

function extrudePolygon(points, extrude) {
  // height += Math.random() * 100; // 解决 depth
  var p1 = points[0][0];
  var p2 = points[0][points[0].length - 1];
  var faceUv = [];

  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    points[0] = points[0].slice(0, points[0].length - 1);
  }

  var n = points[0].length;
  var flattengeo = __WEBPACK_IMPORTED_MODULE_0_earcut___default.a.flatten(points);
  var positions = [];
  var cells = [];
  var triangles = __WEBPACK_IMPORTED_MODULE_0_earcut___default()(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  cells = triangles;
  var pointCount = flattengeo.vertices.length / 3;
  var vertices = flattengeo.vertices;
  extrude ? full() : flat();

  function flat() {
    for (var i = 0; i < pointCount; i++) {
      positions.push([vertices[i * 3], vertices[i * 3 + 1], 0]);
    }
  }

  function full() {
    // 顶部纹理
    triangles.forEach(function () {
      faceUv.push(-1, -1);
    }); // 顶部坐标

    for (var i = 0; i < pointCount; i++) {
      positions.push([vertices[i * 3], vertices[i * 3 + 1], 1]);
    }

    for (var _i = 0; _i < pointCount; _i++) {
      positions.push([vertices[_i * 3], vertices[_i * 3 + 1], 0]);
    }

    for (var _i2 = 0; _i2 < n; _i2++) {
      if (_i2 === n - 1) {
        cells.push(_i2, n, _i2 + n);
        faceUv.push(1, 0, 0, 1, 1, 1);
        cells.push(_i2, 0, n);
        faceUv.push(1, 0, 0, 0, 0, 1);
      } else {
        cells.push(_i2 + n, _i2, _i2 + n + 1);
        faceUv.push(1, 1, 1, 0, 0, 1);
        cells.push(_i2, _i2 + 1, _i2 + n + 1);
        faceUv.push(1, 0, 0, 0, 0, 1);
      }
    }
  }

  return {
    positions: positions,
    faceUv: faceUv,
    positionsIndex: cells
  };
}
function extrudePolygonLine(points, extrude) {
  // height += Math.random() * 100; // 解决 depth
  var p1 = points[0][0];
  var p2 = points[0][points[0].length - 1];

  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    points[0] = points[0].slice(0, points[0].length - 1);
  }

  var n = points[0].length;
  var flattengeo = __WEBPACK_IMPORTED_MODULE_0_earcut___default.a.flatten(points);
  var positions = [];
  var cells = [];
  var triangles = __WEBPACK_IMPORTED_MODULE_0_earcut___default()(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  cells = triangles.map(function (e) {
    return e;
  });
  extrude === 0 ? flat() : full();

  function flat() {
    points[0].forEach(function (p) {
      positions.push([p[0], p[1], 0]);
    }); // top
  }

  function full() {
    points[0].forEach(function (p) {
      positions.push([p[0], p[1], 1]);
    }); // top

    points[0].forEach(function (p) {
      positions.push([p[0], p[1], 0]);
    }); // bottom

    for (var i = 0; i < n; i++) {
      if (i === n - 1) {
        cells.push(i + n, n, i);
        cells.push(0, i, n);
      } else {
        cells.push(i + n, i + n + 1, i);
        cells.push(i + 1, i, i + n + 1);
      }
    }
  }

  return {
    positions: positions,
    positionsIndex: cells
  };
}

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PolygonMaterial;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_polygon_frag_glsl__ = __webpack_require__(297);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_polygon_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_polygon_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polygon_vert_glsl__ = __webpack_require__(298);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polygon_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_polygon_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material__ = __webpack_require__(16);



function PolygonMaterial(options) {
  var material = new __WEBPACK_IMPORTED_MODULE_2__material__["a" /* default */]({
    uniforms: {
      u_opacity: {
        value: options.u_opacity || 1.0
      },
      u_texture: {
        value: options.u_texture
      },
      u_time: {
        value: options.u_time || 0
      },
      u_zoom: {
        value: options.u_zoom || 0
      },
      u_baseColor: {
        value: options.u_baseColor || [1.0, 0, 0, 1.0]
      },
      u_brightColor: {
        value: options.u_brightColor || [1.0, 0, 0, 1.0]
      },
      u_windowColor: {
        value: options.u_windowColor || [1.0, 0, 0, 1.0]
      },
      u_near: {
        value: options.u_near || 0.0
      },
      u_far: {
        value: options.u_far || 1.0
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_1__shader_polygon_vert_glsl___default.a,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__shader_polygon_frag_glsl___default.a,
    transparent: true,
    defines: {
      TEXCOORD_0: !!options.u_texture
    }
  });
  return material;
}

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = LineMaterial;
/* harmony export (immutable) */ __webpack_exports__["a"] = ArcLineMaterial;
/* harmony export (immutable) */ __webpack_exports__["d"] = MeshLineMaterial;
/* harmony export (immutable) */ __webpack_exports__["b"] = DashLineMaterial;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_line_frag_glsl__ = __webpack_require__(299);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_line_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_line_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shader_line_vert_glsl__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shader_line_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shader_line_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shader_arcline_frag_glsl__ = __webpack_require__(301);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shader_arcline_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__shader_arcline_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shader_arcline_vert_glsl__ = __webpack_require__(302);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shader_arcline_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__shader_arcline_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__shader_meshline_vert_glsl__ = __webpack_require__(303);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__shader_meshline_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__shader_meshline_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__shader_meshline_frag_glsl__ = __webpack_require__(304);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__shader_meshline_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__shader_meshline_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__shader_dashline_frag_glsl__ = __webpack_require__(305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__shader_dashline_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__shader_dashline_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__shader_dashline_vert_glsl__ = __webpack_require__(306);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__shader_dashline_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__shader_dashline_vert_glsl__);










function LineMaterial(options) {
  var material = new __WEBPACK_IMPORTED_MODULE_1__material__["a" /* default */]({
    uniforms: {
      u_opacity: {
        value: options.u_opacity || 1.0
      },
      u_time: {
        value: options.u_time || 0
      },
      u_zoom: {
        value: options.u_zoom || 10
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_3__shader_line_vert_glsl___default.a,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_2__shader_line_frag_glsl___default.a,
    transparent: true,
    blending: __WEBPACK_IMPORTED_MODULE_0__core_three__["AdditiveBlending"]
  });
  return material;
}
function ArcLineMaterial(options) {
  var material = new __WEBPACK_IMPORTED_MODULE_1__material__["a" /* default */]({
    uniforms: {
      u_opacity: {
        value: options.u_opacity || 1.0
      },
      segmentNumber: {
        value: 49
      },
      u_time: {
        value: 0
      },
      u_zoom: {
        value: options.u_zoom || 10
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_5__shader_arcline_vert_glsl___default.a,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_4__shader_arcline_frag_glsl___default.a,
    transparent: true,
    blending: __WEBPACK_IMPORTED_MODULE_0__core_three__["AdditiveBlending"]
  });
  return material;
}
function MeshLineMaterial(options) {
  var material = new __WEBPACK_IMPORTED_MODULE_1__material__["a" /* default */]({
    uniforms: {
      u_opacity: {
        value: options.u_opacity || 1.0
      },
      u_time: {
        value: options.u_time || 0
      },
      u_zoom: {
        value: options.u_zoom
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_6__shader_meshline_vert_glsl___default.a,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_7__shader_meshline_frag_glsl___default.a,
    transparent: true
  });
  return material;
}
function DashLineMaterial(options) {
  var material = new __WEBPACK_IMPORTED_MODULE_1__material__["a" /* default */]({
    uniforms: {
      u_opacity: {
        value: options.u_opacity || 1.0
      },
      u_time: {
        value: options.u_time || 0
      },
      u_zoom: {
        value: options.u_zoom
      },
      u_dashSteps: {
        value: options.u_dashSteps || 12
      },
      u_dashSmooth: {
        value: options.u_dashSmooth || 0.01
      },
      u_dashDistance: {
        value: options.u_dashDistance || 0.2
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_9__shader_dashline_vert_glsl___default.a,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_8__shader_dashline_frag_glsl___default.a,
    transparent: true
  });
  return material;
}

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PointBuffer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bufferBase__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shape_index__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var PointBuffer =
/*#__PURE__*/
function (_BufferBase) {
  _inherits(PointBuffer, _BufferBase);

  function PointBuffer() {
    _classCallCheck(this, PointBuffer);

    return _possibleConstructorReturn(this, _getPrototypeOf(PointBuffer).apply(this, arguments));
  }

  _createClass(PointBuffer, [{
    key: "geometryBuffer",
    value: function geometryBuffer() {
      var type = this.get('type');

      switch (type) {
        case 'image':
          this._imageBuffer();

          break;

        case '2d':
          this._3dRegularBuffer();

          break;

        case '3d':
          this._3dRegularBuffer();

          break;

        case 'Model':
          this._ModelBuffer();

          break;

        default:
          this._sdfRegularBuffer();

      }
    }
  }, {
    key: "_imageBuffer",
    value: function _imageBuffer() {
      var coordinates = this.get('coordinates');
      var properties = this.get('properties');
      var imagePos = this.get('imagePos');
      var uv = new Float32Array(properties.length * 2);

      for (var i = 0; i < properties.length; i++) {
        var _imagePos$properties$ = imagePos[properties[i].shape],
            x = _imagePos$properties$.x,
            y = _imagePos$properties$.y;
        uv[i * 2] = x;
        uv[i * 2 + 1] = y;
      }

      this.bufferStruct.position = coordinates;
      this.bufferStruct.uv = uv;
      this.bufferStruct.style = properties;
      this.attributes = this._toPointsAttributes(this.bufferStruct);
      this.attributes.uvs = uv;
    }
  }, {
    key: "_sdfRegularBuffer",
    value: function _sdfRegularBuffer() {
      var coordinates = this.get('coordinates');
      var properties = this.get('properties');
      this.bufferStruct.position = coordinates;
      this.bufferStruct.style = properties;
      this.attributes = this._toPointsAttributes(this.bufferStruct);
    }
  }, {
    key: "_3dRegularBuffer",
    value: function _3dRegularBuffer() {
      var coordinates = this.get('coordinates');
      var properties = this.get('properties');
      var type = this.get('type');
      var positions = [];
      var shapes = [];
      var sizes = [];
      var uvs = [];
      var positionsIndex = [];
      var indexCount = 0;
      this.bufferStruct.style = properties;
      coordinates.forEach(function (geo, index) {
        var _properties$index = properties[index],
            size = _properties$index.size,
            shape = _properties$index.shape;
        var shapeType = 'extrude';

        if (type === '2d' || type === '3d' && size[2] === 0) {
          shapeType = 'fill';
          __WEBPACK_IMPORTED_MODULE_2__util___default.a.isArray(size) || (size = [size, size, 0]);
        } else {
          __WEBPACK_IMPORTED_MODULE_2__util___default.a.isArray(size) || (size = [size, size, size]);
        }

        if (__WEBPACK_IMPORTED_MODULE_1__shape_index__["c" /* regularShape */][shape] == null) {
          uvs.push(0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0);
          shape = 'square';
        }

        var vert = __WEBPACK_IMPORTED_MODULE_1__shape_index__["c" /* regularShape */][shape](shapeType);
        shapes.push(vert.positions);
        positions.push(geo);
        sizes.push(size);
        positionsIndex.push(vert.positionsIndex);
        indexCount += vert.positionsIndex.length;
      });
      this.bufferStruct.indices = positionsIndex;
      this.bufferStruct.position = positions;
      this.bufferStruct.indexCount = indexCount;
      this.bufferStruct.shapes = shapes;
      this.bufferStruct.sizes = sizes;
      this.bufferStruct.faceUv = uvs;
      this.attributes = this._toPointShapeAttributes(this.bufferStruct);
    }
  }]);

  return PointBuffer;
}(__WEBPACK_IMPORTED_MODULE_0__bufferBase__["a" /* default */]);



/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_scene__ = __webpack_require__(78);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return __WEBPACK_IMPORTED_MODULE_0__core_scene__["a"]; });
// import Util from './util';

var version = '0.0.1';


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Scene; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__engine__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__layer__ = __webpack_require__(252);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__base__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__image__ = __webpack_require__(333);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__map_provider__ = __webpack_require__(334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__map_gaodeMap__ = __webpack_require__(338);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__global__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__global___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__global__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }










var Scene =
/*#__PURE__*/
function (_Base) {
  _inherits(Scene, _Base);

  _createClass(Scene, [{
    key: "getDefaultCfg",
    value: function getDefaultCfg() {
      return __WEBPACK_IMPORTED_MODULE_7__global___default.a.scene;
    }
  }]);

  function Scene(cfg) {
    var _this;

    _classCallCheck(this, Scene);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this, cfg));

    _this._initMap();

    _this._initAttribution();

    _this.addImage();

    _this._layers = [];
    return _this;
  }

  _createClass(Scene, [{
    key: "_initEngine",
    value: function _initEngine(mapContainer) {
      this._engine = new __WEBPACK_IMPORTED_MODULE_0__engine__["a" /* default */](mapContainer, this);

      this._engine.run();
    } // 为pickup场景添加 object 对象

  }, {
    key: "addPickMesh",
    value: function addPickMesh(object) {
      this._engine._picking.add(object);
    }
  }, {
    key: "_initMap",
    value: function _initMap() {
      var _this2 = this;

      this.mapContainer = this.get('id');
      this._container = document.getElementById(this.mapContainer);
      var Map = new __WEBPACK_IMPORTED_MODULE_5__map_provider__["a" /* MapProvider */](this.mapContainer, this._attrs);
      Map.on('mapLoad', function () {
        _this2._initEngine(Map.renderDom);

        var sceneMap = new __WEBPACK_IMPORTED_MODULE_6__map_gaodeMap__["a" /* default */](Map.map); // eslint-disable-next-line

        Object.getOwnPropertyNames(sceneMap.__proto__).forEach(function (key) {
          // eslint-disable-next-line
          if (true) {
            _this2.__proto__[key] = sceneMap.__proto__[key];
          }
        });
        _this2.map = Map.map;
        Map.asyncCamera(_this2._engine);

        _this2.initLayer();

        _this2.emit('loaded');
      });
    }
  }, {
    key: "initLayer",
    value: function initLayer() {
      var _this3 = this;

      var _loop = function _loop(methodName) {
        _this3[methodName] = function (cfg) {
          cfg ? cfg.mapType = _this3.mapType : cfg = {
            mapType: _this3.mapType
          };
          var layer = new __WEBPACK_IMPORTED_MODULE_2__layer__[methodName](_this3, cfg);

          _this3._layers.push(layer);

          return layer;
        };
      };

      for (var methodName in __WEBPACK_IMPORTED_MODULE_2__layer__) {
        _loop(methodName);
      }
    }
  }, {
    key: "on",
    value: function on(type, hander) {
      if (this.map) {
        this.map.on(type, hander);
      }

      _get(_getPrototypeOf(Scene.prototype), "on", this).call(this, type, hander);
    }
  }, {
    key: "_initAttribution",
    value: function _initAttribution() {
      var message = '<a href="http://antv.alipay.com/zh-cn/index.html title="Large-scale WebGL-powered Geospatial Data Visualization">AntV | L7  </a>';
      var element = document.createElement('div');
      element.innerHTML = message;
      element.style.cssText += 'position: absolute; pointer-events:none;background: rgba(255, 255, 255, 0.7);font-size: 11px;z-index:100; padding:4px;bottom: 0;right:0px;';

      this._container.appendChild(element);
    }
  }, {
    key: "addImage",
    value: function addImage() {
      this.image = new __WEBPACK_IMPORTED_MODULE_4__image__["a" /* default */]();
    }
  }, {
    key: "_initEvent",
    value: function _initEvent() {}
  }, {
    key: "getLayers",
    value: function getLayers() {
      return this._layers;
    }
  }, {
    key: "_addLight",
    value: function _addLight() {
      var scene = this._engine._scene;
      var ambientLight = new __WEBPACK_IMPORTED_MODULE_1__three__["AmbientLight"](0xaaaaaa);
      scene.add(ambientLight);
      var directionalLight = new __WEBPACK_IMPORTED_MODULE_1__three__["DirectionalLight"](0xffffff, 0.5);
      scene.add(directionalLight);
    }
  }, {
    key: "_addLayer",
    value: function _addLayer() {}
  }, {
    key: "removeLayer",
    value: function removeLayer(layer) {
      var layerIndex = this._layers.indexOf(layer);

      if (layerIndex > -1) {
        this._layers.splice(layerIndex, 1);
      }

      layer.destroy();
    }
  }]);

  return Scene;
}(__WEBPACK_IMPORTED_MODULE_3__base__["a" /* default */]);



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Engine; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_wolfy87_eventemitter__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_wolfy87_eventemitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_wolfy87_eventemitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__scene__ = __webpack_require__(247);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__camera__ = __webpack_require__(248);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__renderer__ = __webpack_require__(249);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__picking_picking__ = __webpack_require__(250);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }








var Engine =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Engine, _EventEmitter);

  function Engine(container, world) {
    var _this;

    _classCallCheck(this, Engine);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Engine).call(this));
    _this._scene = __WEBPACK_IMPORTED_MODULE_2__scene__["a" /* default */];
    _this._camera = new __WEBPACK_IMPORTED_MODULE_3__camera__["a" /* default */](container).camera;
    _this._renderer = new __WEBPACK_IMPORTED_MODULE_4__renderer__["a" /* default */](container).renderer;
    _this._world = world;
    _this._picking = Object(__WEBPACK_IMPORTED_MODULE_5__picking_picking__["a" /* default */])(_this._world, _this._renderer, _this._camera, _this._scene);
    _this.clock = new __WEBPACK_IMPORTED_MODULE_1__three__["Clock"]();
    return _this;
  }

  _createClass(Engine, [{
    key: "_initPostProcessing",
    value: function _initPostProcessing() {}
  }, {
    key: "update",
    value: function update() {
      this._renderer.render(this._scene, this._camera);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }, {
    key: "run",
    value: function run() {
      this.update();
      this.engineID = requestAnimationFrame(this.run.bind(this));
    }
  }, {
    key: "stop",
    value: function stop() {
      cancelAnimationFrame(this.engineID);
    }
  }]);

  return Engine;
}(__WEBPACK_IMPORTED_MODULE_0_wolfy87_eventemitter___default.a);



/***/ }),
/* 80 */
/***/ (function(module, exports) {

// Polyfills
if (Number.EPSILON === undefined) {
  Number.EPSILON = Math.pow(2, -52);
}

if (Number.isInteger === undefined) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
  Number.isInteger = function (value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
  };
} //


if (Math.sign === undefined) {
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
  Math.sign = function (x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x;
  };
}

if ('name' in Function.prototype === false) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
  Object.defineProperty(Function.prototype, 'name', {
    get: function () {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  });
}

if (Object.assign === undefined) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
  (function () {
    Object.assign = function (target) {
      'use strict';

      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];

        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }

      return output;
    };
  })();
}

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Scene; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__ = __webpack_require__(5);

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene() {
  __WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__["a" /* Object3D */].call(this);
  this.type = 'Scene';
  this.background = null;
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true; // checked by the renderer
}

Scene.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__["a" /* Object3D */].prototype), {
  constructor: Scene,
  copy: function (source, recursive) {
    __WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__["a" /* Object3D */].prototype.copy.call(this, source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  },
  toJSON: function (meta) {
    var data = __WEBPACK_IMPORTED_MODULE_0__core_Object3D_js__["a" /* Object3D */].prototype.toJSON.call(this, meta);
    if (this.background !== null) data.object.background = this.background.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    return data;
  }
});


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Euler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Quaternion_js__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Math_js__ = __webpack_require__(6);




/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Euler(x, y, z, order) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || Euler.DefaultOrder;
}

Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
Euler.DefaultOrder = 'XYZ';
Object.defineProperties(Euler.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (value) {
      this._x = value;
      this.onChangeCallback();
    }
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (value) {
      this._y = value;
      this.onChangeCallback();
    }
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (value) {
      this._z = value;
      this.onChangeCallback();
    }
  },
  order: {
    get: function () {
      return this._order;
    },
    set: function (value) {
      this._order = value;
      this.onChangeCallback();
    }
  }
});
Object.assign(Euler.prototype, {
  isEuler: true,
  set: function (x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;
    this.onChangeCallback();
    return this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function (euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function (m, order, update) {
    var clamp = __WEBPACK_IMPORTED_MODULE_3__Math_js__["a" /* _Math */].clamp; // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements;
    var m11 = te[0],
        m12 = te[4],
        m13 = te[8];
    var m21 = te[1],
        m22 = te[5],
        m23 = te[9];
    var m31 = te[2],
        m32 = te[6],
        m33 = te[10];
    order = order || this._order;

    if (order === 'XYZ') {
      this._y = Math.asin(clamp(m13, -1, 1));

      if (Math.abs(m13) < 0.99999) {
        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
      } else {
        this._x = Math.atan2(m32, m22);
        this._z = 0;
      }
    } else if (order === 'YXZ') {
      this._x = Math.asin(-clamp(m23, -1, 1));

      if (Math.abs(m23) < 0.99999) {
        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
      } else {
        this._y = Math.atan2(-m31, m11);
        this._z = 0;
      }
    } else if (order === 'ZXY') {
      this._x = Math.asin(clamp(m32, -1, 1));

      if (Math.abs(m32) < 0.99999) {
        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
      } else {
        this._y = 0;
        this._z = Math.atan2(m21, m11);
      }
    } else if (order === 'ZYX') {
      this._y = Math.asin(-clamp(m31, -1, 1));

      if (Math.abs(m31) < 0.99999) {
        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
      } else {
        this._x = 0;
        this._z = Math.atan2(-m12, m22);
      }
    } else if (order === 'YZX') {
      this._z = Math.asin(clamp(m21, -1, 1));

      if (Math.abs(m21) < 0.99999) {
        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
      } else {
        this._x = 0;
        this._y = Math.atan2(m13, m33);
      }
    } else if (order === 'XZY') {
      this._z = Math.asin(-clamp(m12, -1, 1));

      if (Math.abs(m12) < 0.99999) {
        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
      } else {
        this._x = Math.atan2(-m23, m33);
        this._y = 0;
      }
    } else {
      console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
    }

    this._order = order;
    if (update !== false) this.onChangeCallback();
    return this;
  },
  setFromQuaternion: function () {
    var matrix = new __WEBPACK_IMPORTED_MODULE_2__Matrix4_js__["a" /* Matrix4 */]();
    return function setFromQuaternion(q, order, update) {
      matrix.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(matrix, order, update);
    };
  }(),
  setFromVector3: function (v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  },
  reorder: function () {
    // WARNING: this discards revolution information -bhouston
    var q = new __WEBPACK_IMPORTED_MODULE_0__Quaternion_js__["a" /* Quaternion */]();
    return function reorder(newOrder) {
      q.setFromEuler(this);
      return this.setFromQuaternion(q, newOrder);
    };
  }(),
  equals: function (euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },
  fromArray: function (array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];
    this.onChangeCallback();
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  },
  toVector3: function (optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](this._x, this._y, this._z);
    }
  },
  onChange: function (callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function () {}
});


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Layers; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function Layers() {
  this.mask = 1 | 0;
}

Object.assign(Layers.prototype, {
  set: function (channel) {
    this.mask = 1 << channel | 0;
  },
  enable: function (channel) {
    this.mask |= 1 << channel | 0;
  },
  toggle: function (channel) {
    this.mask ^= 1 << channel | 0;
  },
  disable: function (channel) {
    this.mask &= ~(1 << channel | 0);
  },
  test: function (layers) {
    return (this.mask & layers.mask) !== 0;
  }
});


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLRenderer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Math_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__textures_DataTexture_js__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Frustum_js__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shaders_ShaderLib_js__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__shaders_UniformsLib_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__shaders_UniformsUtils_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__math_Vector4_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__webgl_WebGLAnimation_js__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__webgl_WebGLAttributes_js__ = __webpack_require__(201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__webgl_WebGLBackground_js__ = __webpack_require__(202);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__webgl_WebGLBufferRenderer_js__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__webgl_WebGLCapabilities_js__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__webgl_WebGLClipping_js__ = __webpack_require__(209);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__webgl_WebGLExtensions_js__ = __webpack_require__(210);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__webgl_WebGLGeometries_js__ = __webpack_require__(211);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__webgl_WebGLIndexedBufferRenderer_js__ = __webpack_require__(212);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__webgl_WebGLInfo_js__ = __webpack_require__(213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__webgl_WebGLMorphtargets_js__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__webgl_WebGLObjects_js__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__webgl_WebGLPrograms_js__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__webgl_WebGLProperties_js__ = __webpack_require__(220);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__webgl_WebGLRenderLists_js__ = __webpack_require__(221);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__webgl_WebGLRenderStates_js__ = __webpack_require__(222);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__webgl_WebGLShadowMap_js__ = __webpack_require__(224);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__webgl_WebGLState_js__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__webgl_WebGLTextures_js__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__webgl_WebGLUniforms_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__webgl_WebGLUtils_js__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__webvr_WebVRManager_js__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__webvr_WebXRManager_js__ = __webpack_require__(231);

































/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

function WebGLRenderer(parameters) {
  console.log('THREE.WebGLRenderer', __WEBPACK_IMPORTED_MODULE_0__constants_js__["_27" /* REVISION */]);
  parameters = parameters || {};

  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
      _context = parameters.context !== undefined ? parameters.context : null,
      _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
      _depth = parameters.depth !== undefined ? parameters.depth : true,
      _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
      _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
      _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
      _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
      _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

  var currentRenderList = null;
  var currentRenderState = null; // public properties

  this.domElement = _canvas;
  this.context = null; // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true; // scene graph

  this.sortObjects = true; // user-defined clipping

  this.clippingPlanes = [];
  this.localClippingEnabled = false; // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility

  this.gammaInput = false;
  this.gammaOutput = false; // physical lights

  this.physicallyCorrectLights = false; // tone mapping

  this.toneMapping = __WEBPACK_IMPORTED_MODULE_0__constants_js__["W" /* LinearToneMapping */];
  this.toneMappingExposure = 1.0;
  this.toneMappingWhitePoint = 1.0; // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4; // internal properties

  var _this = this,
      _isContextLost = false,
      // internal state cache
  _framebuffer = null,
      _currentRenderTarget = null,
      _currentFramebuffer = null,
      _currentMaterialId = -1,
      // geometry and program caching
  _currentGeometryProgram = {
    geometry: null,
    program: null,
    wireframe: false
  },
      _currentCamera = null,
      _currentArrayCamera = null,
      _currentViewport = new __WEBPACK_IMPORTED_MODULE_9__math_Vector4_js__["a" /* Vector4 */](),
      _currentScissor = new __WEBPACK_IMPORTED_MODULE_9__math_Vector4_js__["a" /* Vector4 */](),
      _currentScissorTest = null,
      //
  _usedTextureUnits = 0,
      //
  _width = _canvas.width,
      _height = _canvas.height,
      _pixelRatio = 1,
      _viewport = new __WEBPACK_IMPORTED_MODULE_9__math_Vector4_js__["a" /* Vector4 */](0, 0, _width, _height),
      _scissor = new __WEBPACK_IMPORTED_MODULE_9__math_Vector4_js__["a" /* Vector4 */](0, 0, _width, _height),
      _scissorTest = false,
      // frustum
  _frustum = new __WEBPACK_IMPORTED_MODULE_3__math_Frustum_js__["a" /* Frustum */](),
      // clipping
  _clipping = new __WEBPACK_IMPORTED_MODULE_15__webgl_WebGLClipping_js__["a" /* WebGLClipping */](),
      _clippingEnabled = false,
      _localClippingEnabled = false,
      // camera matrices cache
  _projScreenMatrix = new __WEBPACK_IMPORTED_MODULE_4__math_Matrix4_js__["a" /* Matrix4 */](),
      _vector3 = new __WEBPACK_IMPORTED_MODULE_8__math_Vector3_js__["a" /* Vector3 */]();

  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  } // initialize


  var _gl;

  try {
    var contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference
    }; // event listeners must be registered before WebGL context is created, see #12753

    _canvas.addEventListener('webglcontextlost', onContextLost, false);

    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

    _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);

    if (_gl === null) {
      if (_canvas.getContext('webgl') !== null) {
        throw new Error('Error creating WebGL context with your selected attributes.');
      } else {
        throw new Error('Error creating WebGL context.');
      }
    } // Some experimental-webgl implementations do not have getShaderPrecisionFormat


    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
  } catch (error) {
    console.error('THREE.WebGLRenderer: ' + error.message);
  }

  var extensions, capabilities, state, info;
  var properties, textures, attributes, geometries, objects;
  var programCache, renderLists, renderStates;
  var background, morphtargets, bufferRenderer, indexedBufferRenderer;
  var utils;

  function initGLContext() {
    extensions = new __WEBPACK_IMPORTED_MODULE_16__webgl_WebGLExtensions_js__["a" /* WebGLExtensions */](_gl);
    capabilities = new __WEBPACK_IMPORTED_MODULE_14__webgl_WebGLCapabilities_js__["a" /* WebGLCapabilities */](_gl, extensions, parameters);

    if (!capabilities.isWebGL2) {
      extensions.get('WEBGL_depth_texture');
      extensions.get('OES_texture_float');
      extensions.get('OES_texture_half_float');
      extensions.get('OES_texture_half_float_linear');
      extensions.get('OES_standard_derivatives');
      extensions.get('OES_element_index_uint');
      extensions.get('ANGLE_instanced_arrays');
    }

    extensions.get('OES_texture_float_linear');
    utils = new __WEBPACK_IMPORTED_MODULE_30__webgl_WebGLUtils_js__["a" /* WebGLUtils */](_gl, extensions, capabilities);
    state = new __WEBPACK_IMPORTED_MODULE_27__webgl_WebGLState_js__["a" /* WebGLState */](_gl, extensions, utils, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
    info = new __WEBPACK_IMPORTED_MODULE_19__webgl_WebGLInfo_js__["a" /* WebGLInfo */](_gl);
    properties = new __WEBPACK_IMPORTED_MODULE_23__webgl_WebGLProperties_js__["a" /* WebGLProperties */]();
    textures = new __WEBPACK_IMPORTED_MODULE_28__webgl_WebGLTextures_js__["a" /* WebGLTextures */](_gl, extensions, state, properties, capabilities, utils, info);
    attributes = new __WEBPACK_IMPORTED_MODULE_11__webgl_WebGLAttributes_js__["a" /* WebGLAttributes */](_gl);
    geometries = new __WEBPACK_IMPORTED_MODULE_17__webgl_WebGLGeometries_js__["a" /* WebGLGeometries */](_gl, attributes, info);
    objects = new __WEBPACK_IMPORTED_MODULE_21__webgl_WebGLObjects_js__["a" /* WebGLObjects */](geometries, info);
    morphtargets = new __WEBPACK_IMPORTED_MODULE_20__webgl_WebGLMorphtargets_js__["a" /* WebGLMorphtargets */](_gl);
    programCache = new __WEBPACK_IMPORTED_MODULE_22__webgl_WebGLPrograms_js__["a" /* WebGLPrograms */](_this, extensions, capabilities);
    renderLists = new __WEBPACK_IMPORTED_MODULE_24__webgl_WebGLRenderLists_js__["a" /* WebGLRenderLists */]();
    renderStates = new __WEBPACK_IMPORTED_MODULE_25__webgl_WebGLRenderStates_js__["a" /* WebGLRenderStates */]();
    background = new __WEBPACK_IMPORTED_MODULE_12__webgl_WebGLBackground_js__["a" /* WebGLBackground */](_this, state, objects, _premultipliedAlpha);
    bufferRenderer = new __WEBPACK_IMPORTED_MODULE_13__webgl_WebGLBufferRenderer_js__["a" /* WebGLBufferRenderer */](_gl, extensions, info, capabilities);
    indexedBufferRenderer = new __WEBPACK_IMPORTED_MODULE_18__webgl_WebGLIndexedBufferRenderer_js__["a" /* WebGLIndexedBufferRenderer */](_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.context = _gl;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }

  initGLContext(); // vr

  var vr = 'xr' in navigator ? new __WEBPACK_IMPORTED_MODULE_32__webvr_WebXRManager_js__["a" /* WebXRManager */](_this) : new __WEBPACK_IMPORTED_MODULE_31__webvr_WebVRManager_js__["a" /* WebVRManager */](_this);
  this.vr = vr; // shadow map

  var shadowMap = new __WEBPACK_IMPORTED_MODULE_26__webgl_WebGLShadowMap_js__["a" /* WebGLShadowMap */](_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap; // API

  this.getContext = function () {
    return _gl;
  };

  this.getContextAttributes = function () {
    return _gl.getContextAttributes();
  };

  this.forceContextLoss = function () {
    var extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.loseContext();
  };

  this.forceContextRestore = function () {
    var extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.restoreContext();
  };

  this.getPixelRatio = function () {
    return _pixelRatio;
  };

  this.setPixelRatio = function (value) {
    if (value === undefined) return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };

  this.getSize = function () {
    return {
      width: _width,
      height: _height
    };
  };

  this.setSize = function (width, height, updateStyle) {
    if (vr.isPresenting()) {
      console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
      return;
    }

    _width = width;
    _height = height;
    _canvas.width = width * _pixelRatio;
    _canvas.height = height * _pixelRatio;

    if (updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }

    this.setViewport(0, 0, width, height);
  };

  this.getDrawingBufferSize = function () {
    return {
      width: _width * _pixelRatio,
      height: _height * _pixelRatio
    };
  };

  this.setDrawingBufferSize = function (width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas.width = width * pixelRatio;
    _canvas.height = height * pixelRatio;
    this.setViewport(0, 0, width, height);
  };

  this.getCurrentViewport = function () {
    return _currentViewport;
  };

  this.setViewport = function (x, y, width, height) {
    _viewport.set(x, _height - y - height, width, height);

    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
  };

  this.setScissor = function (x, y, width, height) {
    _scissor.set(x, _height - y - height, width, height);

    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
  };

  this.setScissorTest = function (boolean) {
    state.setScissorTest(_scissorTest = boolean);
  }; // Clearing


  this.getClearColor = function () {
    return background.getClearColor();
  };

  this.setClearColor = function () {
    background.setClearColor.apply(background, arguments);
  };

  this.getClearAlpha = function () {
    return background.getClearAlpha();
  };

  this.setClearAlpha = function () {
    background.setClearAlpha.apply(background, arguments);
  };

  this.clear = function (color, depth, stencil) {
    var bits = 0;
    if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
    if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
    if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

    _gl.clear(bits);
  };

  this.clearColor = function () {
    this.clear(true, false, false);
  };

  this.clearDepth = function () {
    this.clear(false, true, false);
  };

  this.clearStencil = function () {
    this.clear(false, false, true);
  };

  this.clearTarget = function (renderTarget, color, depth, stencil) {
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  }; //


  this.dispose = function () {
    _canvas.removeEventListener('webglcontextlost', onContextLost, false);

    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    objects.dispose();
    vr.dispose();
    animation.stop();
  }; // Events


  function onContextLost(event) {
    event.preventDefault();
    console.log('THREE.WebGLRenderer: Context Lost.');
    _isContextLost = true;
  }

  function onContextRestore()
  /* event */
  {
    console.log('THREE.WebGLRenderer: Context Restored.');
    _isContextLost = false;
    initGLContext();
  }

  function onMaterialDispose(event) {
    var material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  } // Buffer deallocation


  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }

  function releaseMaterialProgramReference(material) {
    var programInfo = properties.get(material).program;
    material.program = undefined;

    if (programInfo !== undefined) {
      programCache.releaseProgram(programInfo);
    }
  } // Buffer rendering


  function renderObjectImmediate(object, program) {
    object.render(function (object) {
      _this.renderBufferImmediate(object, program);
    });
  }

  this.renderBufferImmediate = function (object, program) {
    state.initAttributes();
    var buffers = properties.get(object);
    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
    var programAttributes = program.getAttributes();

    if (object.hasPositions) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);

      _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

      state.enableAttribute(programAttributes.position);

      _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
    }

    if (object.hasNormals) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);

      _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

      state.enableAttribute(programAttributes.normal);

      _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
    }

    if (object.hasUvs) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);

      _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

      state.enableAttribute(programAttributes.uv);

      _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
    }

    if (object.hasColors) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);

      _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

      state.enableAttribute(programAttributes.color);

      _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
    }

    state.disableUnusedAttributes();

    _gl.drawArrays(_gl.TRIANGLES, 0, object.count);

    object.count = 0;
  };

  this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
    var frontFaceCW = object.isMesh && object.normalMatrix.determinant() < 0;
    state.setMaterial(material, frontFaceCW);
    var program = setProgram(camera, fog, material, object);
    var updateBuffers = false;

    if (_currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
      _currentGeometryProgram.geometry = geometry.id;
      _currentGeometryProgram.program = program.id;
      _currentGeometryProgram.wireframe = material.wireframe === true;
      updateBuffers = true;
    }

    if (object.morphTargetInfluences) {
      morphtargets.update(object, geometry, material, program);
      updateBuffers = true;
    } //


    var index = geometry.index;
    var position = geometry.attributes.position;
    var rangeFactor = 1;

    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }

    var attribute;
    var renderer = bufferRenderer;

    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }

    if (updateBuffers) {
      setupVertexAttributes(material, program, geometry);

      if (index !== null) {
        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer);
      }
    } //


    var dataCount = Infinity;

    if (index !== null) {
      dataCount = index.count;
    } else if (position !== undefined) {
      dataCount = position.count;
    }

    var rangeStart = geometry.drawRange.start * rangeFactor;
    var rangeCount = geometry.drawRange.count * rangeFactor;
    var groupStart = group !== null ? group.start * rangeFactor : 0;
    var groupCount = group !== null ? group.count * rangeFactor : Infinity;
    var drawStart = Math.max(rangeStart, groupStart);
    var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    var drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) return; //

    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(_gl.LINES);
      } else {
        switch (object.drawMode) {
          case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_73" /* TrianglesDrawMode */]:
            renderer.setMode(_gl.TRIANGLES);
            break;

          case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_72" /* TriangleStripDrawMode */]:
            renderer.setMode(_gl.TRIANGLE_STRIP);
            break;

          case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_71" /* TriangleFanDrawMode */]:
            renderer.setMode(_gl.TRIANGLE_FAN);
            break;
        }
      }
    } else if (object.isLine) {
      var lineWidth = material.linewidth;
      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

      state.setLineWidth(lineWidth * getTargetPixelRatio());

      if (object.isLineSegments) {
        renderer.setMode(_gl.LINES);
      } else if (object.isLineLoop) {
        renderer.setMode(_gl.LINE_LOOP);
      } else {
        renderer.setMode(_gl.LINE_STRIP);
      }
    } else if (object.isPoints) {
      renderer.setMode(_gl.POINTS);
    } else if (object.isSprite) {
      renderer.setMode(_gl.TRIANGLES);
    }

    if (geometry && geometry.isInstancedBufferGeometry) {
      if (geometry.maxInstancedCount > 0) {
        renderer.renderInstances(geometry, drawStart, drawCount);
      }
    } else {
      renderer.render(drawStart, drawCount);
    }
  };

  function setupVertexAttributes(material, program, geometry) {
    if (geometry && geometry.isInstancedBufferGeometry & !capabilities.isWebGL2) {
      if (extensions.get('ANGLE_instanced_arrays') === null) {
        console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    state.initAttributes();
    var geometryAttributes = geometry.attributes;
    var programAttributes = program.getAttributes();
    var materialDefaultAttributeValues = material.defaultAttributeValues;

    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];

      if (programAttribute >= 0) {
        var geometryAttribute = geometryAttributes[name];

        if (geometryAttribute !== undefined) {
          var normalized = geometryAttribute.normalized;
          var size = geometryAttribute.itemSize;
          var attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          var buffer = attribute.buffer;
          var type = attribute.type;
          var bytesPerElement = attribute.bytesPerElement;

          if (geometryAttribute.isInterleavedBufferAttribute) {
            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;

            if (data && data.isInstancedInterleavedBuffer) {
              state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

              if (geometry.maxInstancedCount === undefined) {
                geometry.maxInstancedCount = data.meshPerAttribute * data.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }

            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);

            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

              if (geometry.maxInstancedCount === undefined) {
                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }

            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);

            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (materialDefaultAttributeValues !== undefined) {
          var value = materialDefaultAttributeValues[name];

          if (value !== undefined) {
            switch (value.length) {
              case 2:
                _gl.vertexAttrib2fv(programAttribute, value);

                break;

              case 3:
                _gl.vertexAttrib3fv(programAttribute, value);

                break;

              case 4:
                _gl.vertexAttrib4fv(programAttribute, value);

                break;

              default:
                _gl.vertexAttrib1fv(programAttribute, value);

            }
          }
        }
      }
    }

    state.disableUnusedAttributes();
  } // Compile


  this.compile = function (scene, camera) {
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.traverse(function (object) {
      if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(camera);
    scene.traverse(function (object) {
      if (object.material) {
        if (Array.isArray(object.material)) {
          for (var i = 0; i < object.material.length; i++) {
            initMaterial(object.material[i], scene.fog, object);
          }
        } else {
          initMaterial(object.material, scene.fog, object);
        }
      }
    });
  }; // Animation Loop


  var onAnimationFrameCallback = null;

  function onAnimationFrame(time) {
    if (vr.isPresenting()) return;
    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }

  var animation = new __WEBPACK_IMPORTED_MODULE_10__webgl_WebGLAnimation_js__["a" /* WebGLAnimation */]();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== 'undefined') animation.setContext(window);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
    vr.setAnimationLoop(callback);
    animation.start();
  }; // Rendering


  this.render = function (scene, camera, renderTarget, forceClear) {
    if (!(camera && camera.isCamera)) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }

    if (_isContextLost) return; // reset caching for this frame

    _currentGeometryProgram.geometry = null;
    _currentGeometryProgram.program = null;
    _currentGeometryProgram.wireframe = false;
    _currentMaterialId = -1;
    _currentCamera = null; // update scene graph

    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

    if (camera.parent === null) camera.updateMatrixWorld();

    if (vr.enabled) {
      camera = vr.getCamera(camera);
    } //


    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.onBeforeRender(_this, scene, camera, renderTarget);

    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    _frustum.setFromMatrix(_projScreenMatrix);

    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, camera);
    currentRenderList.init();
    projectObject(scene, camera, _this.sortObjects);

    if (_this.sortObjects === true) {
      currentRenderList.sort();
    } //


    if (_clippingEnabled) _clipping.beginShadows();
    var shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights(camera);
    if (_clippingEnabled) _clipping.endShadows(); //

    if (this.info.autoReset) this.info.reset();

    if (renderTarget === undefined) {
      renderTarget = null;
    }

    this.setRenderTarget(renderTarget); //

    background.render(currentRenderList, scene, camera, forceClear); // render scene

    var opaqueObjects = currentRenderList.opaque;
    var transparentObjects = currentRenderList.transparent;

    if (scene.overrideMaterial) {
      var overrideMaterial = scene.overrideMaterial;
      if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
      if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
    } else {
      // opaque pass (front-to-back order)
      if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera); // transparent pass (back-to-front order)

      if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
    } // Generate mipmap if we're using any kind of mipmap filtering


    if (renderTarget) {
      textures.updateRenderTargetMipmap(renderTarget);
    } // Ensure depth buffer writing is enabled so it can be cleared on next render


    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    scene.onAfterRender(_this, scene, camera);

    if (vr.enabled) {
      vr.submitFrame();
    } // _gl.finish();


    currentRenderList = null;
    currentRenderState = null;
  };
  /*
  // TODO Duplicated code (Frustum)
  	var _sphere = new Sphere();
  	function isObjectViewable( object ) {
  		var geometry = object.geometry;
  		if ( geometry.boundingSphere === null )
  		geometry.computeBoundingSphere();
  		_sphere.copy( geometry.boundingSphere ).
  	applyMatrix4( object.matrixWorld );
  		return isSphereViewable( _sphere );
  	}
  	function isSpriteViewable( sprite ) {
  		_sphere.center.set( 0, 0, 0 );
  	_sphere.radius = 0.7071067811865476;
  	_sphere.applyMatrix4( sprite.matrixWorld );
  		return isSphereViewable( _sphere );
  	}
  	function isSphereViewable( sphere ) {
  		if ( ! _frustum.intersectsSphere( sphere ) ) return false;
  		var numPlanes = _clipping.numPlanes;
  		if ( numPlanes === 0 ) return true;
  		var planes = _this.clippingPlanes,
  			center = sphere.center,
  		negRad = - sphere.radius,
  		i = 0;
  		do {
  			// out when deeper than radius in the negative halfspace
  		if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;
  		} while ( ++ i !== numPlanes );
  		return true;
  	}
  */


  function projectObject(object, camera, sortObjects) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);

    if (visible) {
      if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          var geometry = objects.update(object);
          var material = object.material;
          currentRenderList.push(object, geometry, material, _vector3.z, null);
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }

        currentRenderList.push(object, null, object.material, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          object.skeleton.update();
        }

        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          var geometry = objects.update(object);
          var material = object.material;

          if (Array.isArray(material)) {
            var groups = geometry.groups;

            for (var i = 0, l = groups.length; i < l; i++) {
              var group = groups[i];
              var groupMaterial = material[group.materialIndex];

              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, _vector3.z, null);
          }
        }
      }
    }

    var children = object.children;

    for (var i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, sortObjects);
    }
  }

  function renderObjects(renderList, scene, camera, overrideMaterial) {
    for (var i = 0, l = renderList.length; i < l; i++) {
      var renderItem = renderList[i];
      var object = renderItem.object;
      var geometry = renderItem.geometry;
      var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
      var group = renderItem.group;

      if (camera.isArrayCamera) {
        _currentArrayCamera = camera;
        var cameras = camera.cameras;

        for (var j = 0, jl = cameras.length; j < jl; j++) {
          var camera2 = cameras[j];

          if (object.layers.test(camera2.layers)) {
            if ('viewport' in camera2) {
              // XR
              state.viewport(_currentViewport.copy(camera2.viewport));
            } else {
              var bounds = camera2.bounds;
              var x = bounds.x * _width;
              var y = bounds.y * _height;
              var width = bounds.z * _width;
              var height = bounds.w * _height;
              state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio));
            }

            currentRenderState.setupLights(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        _currentArrayCamera = null;
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }

  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

    if (object.isImmediateRenderObject) {
      state.setMaterial(material);
      var program = setProgram(camera, scene.fog, material, object);
      _currentGeometryProgram.geometry = null;
      _currentGeometryProgram.program = null;
      _currentGeometryProgram.wireframe = false;
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
    }

    object.onAfterRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
  }

  function initMaterial(material, fog, object) {
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;
    var shadowsArray = currentRenderState.state.shadowsArray;
    var lightsHash = materialProperties.lightsHash;
    var lightsStateHash = lights.state.hash;
    var parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);
    var code = programCache.getProgramCode(material, parameters);
    var program = materialProperties.program;
    var programChange = true;

    if (program === undefined) {
      // new material
      material.addEventListener('dispose', onMaterialDispose);
    } else if (program.code !== code) {
      // changed glsl or parameters
      releaseMaterialProgramReference(material);
    } else if (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength) {
      lightsHash.stateID = lightsStateHash.stateID;
      lightsHash.directionalLength = lightsStateHash.directionalLength;
      lightsHash.pointLength = lightsStateHash.pointLength;
      lightsHash.spotLength = lightsStateHash.spotLength;
      lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
      lightsHash.hemiLength = lightsStateHash.hemiLength;
      lightsHash.shadowsLength = lightsStateHash.shadowsLength;
      programChange = false;
    } else if (parameters.shaderID !== undefined) {
      // same glsl and uniform list
      return;
    } else {
      // only rebuild uniform list
      programChange = false;
    }

    if (programChange) {
      if (parameters.shaderID) {
        var shader = __WEBPACK_IMPORTED_MODULE_5__shaders_ShaderLib_js__["a" /* ShaderLib */][parameters.shaderID];
        materialProperties.shader = {
          name: material.type,
          uniforms: __WEBPACK_IMPORTED_MODULE_7__shaders_UniformsUtils_js__["a" /* UniformsUtils */].clone(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader
        };
      } else {
        materialProperties.shader = {
          name: material.type,
          uniforms: material.uniforms,
          vertexShader: material.vertexShader,
          fragmentShader: material.fragmentShader
        };
      }

      material.onBeforeCompile(materialProperties.shader, _this); // Computing code again as onBeforeCompile may have changed the shaders

      code = programCache.getProgramCode(material, parameters);
      program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);
      materialProperties.program = program;
      material.program = program;
    }

    var programAttributes = program.getAttributes();

    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;

      for (var i = 0; i < _this.maxMorphTargets; i++) {
        if (programAttributes['morphTarget' + i] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }

    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;

      for (var i = 0; i < _this.maxMorphNormals; i++) {
        if (programAttributes['morphNormal' + i] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }

    var uniforms = materialProperties.shader.uniforms;

    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = _clipping.numPlanes;
      materialProperties.numIntersection = _clipping.numIntersection;
      uniforms.clippingPlanes = _clipping.uniform;
    }

    materialProperties.fog = fog; // store the light setup it was created for

    if (lightsHash === undefined) {
      materialProperties.lightsHash = lightsHash = {};
    }

    lightsHash.stateID = lightsStateHash.stateID;
    lightsHash.directionalLength = lightsStateHash.directionalLength;
    lightsHash.pointLength = lightsStateHash.pointLength;
    lightsHash.spotLength = lightsStateHash.spotLength;
    lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
    lightsHash.hemiLength = lightsStateHash.hemiLength;
    lightsHash.shadowsLength = lightsStateHash.shadowsLength;

    if (material.lights) {
      // wire up the material to this renderer's lighting state
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.pointLights.value = lights.state.point;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
    }

    var progUniforms = materialProperties.program.getUniforms(),
        uniformsList = __WEBPACK_IMPORTED_MODULE_29__webgl_WebGLUniforms_js__["a" /* WebGLUniforms */].seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }

  function setProgram(camera, fog, material, object) {
    _usedTextureUnits = 0;
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;
    var lightsHash = materialProperties.lightsHash;
    var lightsStateHash = lights.state.hash;

    if (_clippingEnabled) {
      if (_localClippingEnabled || camera !== _currentCamera) {
        var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
        // object instead of the material, once it becomes feasible
        // (#8465, #8379)

        _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
      }
    }

    if (material.needsUpdate === false) {
      if (materialProperties.program === undefined) {
        material.needsUpdate = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        material.needsUpdate = true;
      } else if (material.lights && (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength)) {
        material.needsUpdate = true;
      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
        material.needsUpdate = true;
      }
    }

    if (material.needsUpdate) {
      initMaterial(material, fog, object);
      material.needsUpdate = false;
    }

    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;
    var program = materialProperties.program,
        p_uniforms = program.getUniforms(),
        m_uniforms = materialProperties.shader.uniforms;

    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }

    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }

    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
      }

      if (_currentCamera !== camera) {
        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
        // now, in case this material supports lights - or later, when
        // the next material that does gets activated:

        refreshMaterial = true; // set to true on material change

        refreshLights = true; // remains set until update done
      } // load material specific uniforms
      // (shader material also gets them for the sake of genericity)


      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
        var uCamPos = p_uniforms.map.cameraPosition;

        if (uCamPos !== undefined) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }

      if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
      }
    } // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // not sure why, but otherwise weird things happen


    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, 'bindMatrix');
      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
      var skeleton = object.skeleton;

      if (skeleton) {
        var bones = skeleton.bones;

        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === undefined) {
            // layout (1 matrix = 4 pixels)
            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
            var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix

            size = __WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

            boneMatrices.set(skeleton.boneMatrices); // copy current values

            var boneTexture = new __WEBPACK_IMPORTED_MODULE_2__textures_DataTexture_js__["a" /* DataTexture */](boneMatrices, size, size, __WEBPACK_IMPORTED_MODULE_0__constants_js__["_29" /* RGBAFormat */], __WEBPACK_IMPORTED_MODULE_0__constants_js__["E" /* FloatType */]);
            boneTexture.needsUpdate = true;
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }

          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture);
          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
        }
      }
    }

    if (refreshMaterial) {
      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
      p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);

      if (material.lights) {
        // the current material requires lighting info
        // note: all lighting uniforms are always set correctly
        // they simply reference the renderer's state for their
        // values
        //
        // use the current material's .needsUpdate flags to set
        // the GL state when required
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      } // refresh uniforms common to several materials


      if (fog && material.fog) {
        refreshUniformsFog(m_uniforms, fog);
      }

      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(m_uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsLambert(m_uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(m_uniforms, material);

        if (material.isMeshToonMaterial) {
          refreshUniformsToon(m_uniforms, material);
        } else {
          refreshUniformsPhong(m_uniforms, material);
        }
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(m_uniforms, material);

        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(m_uniforms, material);
        } else {
          refreshUniformsStandard(m_uniforms, material);
        }
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsDepth(m_uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsDistance(m_uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsNormal(m_uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(m_uniforms, material);

        if (material.isLineDashedMaterial) {
          refreshUniformsDash(m_uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(m_uniforms, material);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(m_uniforms, material);
      } else if (material.isShadowMaterial) {
        m_uniforms.color.value = material.color;
        m_uniforms.opacity.value = material.opacity;
      } // RectAreaLight Texture
      // TODO (mrdoob): Find a nicer implementation


      if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = __WEBPACK_IMPORTED_MODULE_6__shaders_UniformsLib_js__["a" /* UniformsLib */].LTC_1;
      if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = __WEBPACK_IMPORTED_MODULE_6__shaders_UniformsLib_js__["a" /* UniformsLib */].LTC_2;
      __WEBPACK_IMPORTED_MODULE_29__webgl_WebGLUniforms_js__["a" /* WebGLUniforms */].upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
    }

    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      __WEBPACK_IMPORTED_MODULE_29__webgl_WebGLUniforms_js__["a" /* WebGLUniforms */].upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
      material.uniformsNeedUpdate = false;
    }

    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, 'center', object.center);
    } // common matrices


    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
    return program;
  } // Uniforms (refresh uniforms objects)


  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;

    if (material.color) {
      uniforms.diffuse.value = material.color;
    }

    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }

    if (material.envMap) {
      uniforms.envMap.value = material.envMap; // don't flip CubeTexture envMaps, flip everything else:
      //  WebGLRenderTargetCube will be flipped for backwards compatibility
      //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
      // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future

      uniforms.flipEnvMap.value = !(material.envMap && material.envMap.isCubeTexture) ? 1 : -1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;
    }

    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }

    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. normal map
    // 4. bump map
    // 5. alpha map
    // 6. emissive map


    var uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    }

    if (uvScaleMap !== undefined) {
      // backwards compatibility
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }

      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
  }

  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }

  function refreshUniformsPoints(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * _pixelRatio;
    uniforms.scale.value = _height * 0.5;
    uniforms.map.value = material.map;

    if (material.map !== null) {
      if (material.map.matrixAutoUpdate === true) {
        material.map.updateMatrix();
      }

      uniforms.uvTransform.value.copy(material.map.matrix);
    }
  }

  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    uniforms.map.value = material.map;

    if (material.map !== null) {
      if (material.map.matrixAutoUpdate === true) {
        material.map.updateMatrix();
      }

      uniforms.uvTransform.value.copy(material.map.matrix);
    }
  }

  function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value = fog.color;

    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }

  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }

  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value = material.specular;
    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["f" /* BackSide */]) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["f" /* BackSide */]) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsToon(uniforms, material) {
    refreshUniformsPhong(uniforms, material);

    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }

  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;

    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }

    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["f" /* BackSide */]) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["f" /* BackSide */]) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    if (material.envMap) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }

  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

    uniforms.clearCoat.value = material.clearCoat;
    uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
  }

  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }

  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["f" /* BackSide */]) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["f" /* BackSide */]) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  } // If uniforms are marked as clean, they don't need to be loaded to the GPU.


  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  } // Textures


  function allocTextureUnit() {
    var textureUnit = _usedTextureUnits;

    if (textureUnit >= capabilities.maxTextures) {
      console.warn('THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
    }

    _usedTextureUnits += 1;
    return textureUnit;
  }

  this.allocTextureUnit = allocTextureUnit; // this.setTexture2D = setTexture2D;

  this.setTexture2D = function () {
    var warned = false; // backwards compatibility: peel texture.texture

    return function setTexture2D(texture, slot) {
      if (texture && texture.isWebGLRenderTarget) {
        if (!warned) {
          console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
          warned = true;
        }

        texture = texture.texture;
      }

      textures.setTexture2D(texture, slot);
    };
  }();

  this.setTexture = function () {
    var warned = false;
    return function setTexture(texture, slot) {
      if (!warned) {
        console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
        warned = true;
      }

      textures.setTexture2D(texture, slot);
    };
  }();

  this.setTextureCube = function () {
    var warned = false;
    return function setTextureCube(texture, slot) {
      // backwards compatibility: peel texture.texture
      if (texture && texture.isWebGLRenderTargetCube) {
        if (!warned) {
          console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
          warned = true;
        }

        texture = texture.texture;
      } // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
      // TODO: unify these code paths


      if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
        // CompressedTexture can have Array in image :/
        // this function alone should take care of cube textures
        textures.setTextureCube(texture, slot);
      } else {
        // assumed: texture property of THREE.WebGLRenderTargetCube
        textures.setTextureCubeDynamic(texture, slot);
      }
    };
  }(); //


  this.setFramebuffer = function (value) {
    _framebuffer = value;
  };

  this.getRenderTarget = function () {
    return _currentRenderTarget;
  };

  this.setRenderTarget = function (renderTarget) {
    _currentRenderTarget = renderTarget;

    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
      textures.setupRenderTarget(renderTarget);
    }

    var framebuffer = _framebuffer;
    var isCube = false;

    if (renderTarget) {
      var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

      if (renderTarget.isWebGLRenderTargetCube) {
        framebuffer = __webglFramebuffer[renderTarget.activeCubeFace];
        isCube = true;
      } else {
        framebuffer = __webglFramebuffer;
      }

      _currentViewport.copy(renderTarget.viewport);

      _currentScissor.copy(renderTarget.scissor);

      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);

      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);

      _currentScissorTest = _scissorTest;
    }

    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

      _currentFramebuffer = framebuffer;
    }

    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);

    if (isCube) {
      var textureProperties = properties.get(renderTarget.texture);

      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
    }
  };

  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
      return;
    }

    var framebuffer = properties.get(renderTarget).__webglFramebuffer;

    if (framebuffer) {
      var restore = false;

      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

        restore = true;
      }

      try {
        var texture = renderTarget.texture;
        var textureFormat = texture.format;
        var textureType = texture.type;

        if (textureFormat !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_29" /* RGBAFormat */] && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
          return;
        }

        if (textureType !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_76" /* UnsignedByteType */] && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(textureType === __WEBPACK_IMPORTED_MODULE_0__constants_js__["E" /* FloatType */] && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
        !(textureType === __WEBPACK_IMPORTED_MODULE_0__constants_js__["L" /* HalfFloatType */] && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
          return;
        }

        if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
          if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
        }
      }
    }
  };

  this.copyFramebufferToTexture = function (position, texture, level) {
    var width = texture.image.width;
    var height = texture.image.height;
    var glFormat = utils.convert(texture.format);
    this.setTexture2D(texture, 0);

    _gl.copyTexImage2D(_gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0);
  };

  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
    var width = srcTexture.image.width;
    var height = srcTexture.image.height;
    var glFormat = utils.convert(dstTexture.format);
    var glType = utils.convert(dstTexture.type);
    this.setTexture2D(dstTexture, 0);

    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      _gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
    }
  };
}



/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ImageUtils; });
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */
var ImageUtils = {
  getDataURL: function (image) {
    var canvas;

    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      var context = canvas.getContext('2d');

      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
    }

    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL('image/jpeg', 0.6);
    } else {
      return canvas.toDataURL('image/png');
    }
  }
};


/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n"

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n"

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = "#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n"

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif"

/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = "\nvec3 transformed = vec3( position );\n"

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = "\nvec3 objectNormal = vec3( normal );\n"

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\tif( decayExponent > 0.0 ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t// this is intended to be used on spot and point lights who are represented as luminous intensity\n\t\t// but who must be converted to luminous irradiance for surface lighting calculation\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n\n#else\n\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n#endif\n\n\t}\n\n\treturn 1.0;\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\t// geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n\t// also see #12151\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n\treturn 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n\treturn specularColor * AB.x + AB.y;\n\n} // validated\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n"

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n"

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = "#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = "#if NUM_CLIPPING_PLANES > 0\n\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n"

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n"

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n\n"

/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif"

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n"

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif"

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_COLOR\n\n\tvColor.xyz = color.xyz;\n\n#endif"

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\n\treturn - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n\treturn dot( weights, color.rgb );\n\n}\n"

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = "#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_textureSize (1024.0)\n\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\n\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\t// Clamp the value to the max mip level counts. hard coded to 6 mips\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\n\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\t// float powScale = exp2(roughnessLevel + mipLevel);\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\t// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\t// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\n\tfloat rcpPowScale = 1.0 / powScale;\n\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\n\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\n\t// round to nearest mipmap if we are not interpolating.\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\n\t// Tri linear interpolation.\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\n\tvec4 result = mix(color10, color20, t);\n\n\treturn vec4(result.rgb, 1.0);\n}\n\n#endif\n"

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = "vec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n"

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n"

/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n"

/***/ }),
/* 108 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n"

/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n"

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n"

/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = "// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n"

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\tvec2 sampleUV;\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n\t#else\n\n\t\tvec4 envColor = vec4( 0.0 );\n\n\t#endif\n\n\tenvColor = envMapTexelToLinear( envColor );\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 113 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n\n#ifdef USE_ENVMAP\n\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n"

/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_FOG\n\n\tfogDepth = -mvPosition.z;\n\n#endif\n"

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_FOG\n\n\tvarying float fogDepth;\n\n#endif\n"

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n"

/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = "#ifdef TOON\n\n\tuniform sampler2D gradientMap;\n\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n\t\t// dotNL will be from -1.0 to 1.0\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n\t\t#ifdef USE_GRADIENTMAP\n\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\n\t\t#else\n\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n\t\t#endif\n\n\n\t}\n\n#endif\n"

/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_LIGHTMAP\n\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n"

/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif"

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = "vec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\t// TODO (abelnation): implement\n\n\t}\n\n#endif\n*/\n\n#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n\t\t#endif\n\n\t}\n\n#endif\n"

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = "uniform vec3 ambientLightColor;\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI;\n\n\t#endif\n\n\treturn irradiance;\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( angleCos > spotLight.coneCos ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tirradiance *= PI;\n\n\t\t#endif\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n"

/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n\tvec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#else\n\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\n\t\t#else\n\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\n\t\t#endif\n\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t}\n\n\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t//float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n\t\t//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n\t\t// clamp to allowable LOD ranges.\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t}\n\n\tvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n\t\t#endif\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#endif\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t}\n\n#endif\n"

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n"

/***/ }),
/* 127 */
/***/ (function(module, exports) {

module.exports = "varying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t#ifdef TOON\n\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n\t#else\n\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\n\t#endif\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n"

/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat ); // Burley clearcoat model\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n"

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = "struct PhysicalMaterial {\n\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight; // counterclockwise\n\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\t#ifndef STANDARD\n\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n\t#endif\n\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n\t#ifndef STANDARD\n\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n\t#endif\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n"

/***/ }),
/* 130 */
/***/ (function(module, exports) {

module.exports = "/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t}\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n\n#endif\n"

/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = "#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tirradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n\n#endif\n"

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = "#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n\n#endif\n"

/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif"

/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\n#endif\n"

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n\t#else\n\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\tgl_Position.z *= gl_Position.w;\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\n#endif\n"

/***/ }),
/* 138 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n"

/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_MAP\n\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n"

/***/ }),
/* 140 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_MAP\n\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n\n#endif\n"

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = "float metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n"

/***/ }),
/* 142 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif"

/***/ }),
/* 143 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_MORPHNORMALS\n\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n"

/***/ }),
/* 144 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif"

/***/ }),
/* 145 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_MORPHTARGETS\n\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 146 */
/***/ (function(module, exports) {

module.exports = "#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 147 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_NORMALMAP\n\n\t#ifdef OBJECTSPACE_NORMALMAP\n\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t\t#ifdef FLIP_SIDED\n\n\t\t\tnormal = - normal;\n\n\t\t#endif\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\tnormal = normalize( normalMatrix * normal );\n\n\t#else // tangent-space normal map\n\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n\t#endif\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n"

/***/ }),
/* 148 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t#ifdef OBJECTSPACE_NORMALMAP\n\n\t\tuniform mat3 normalMatrix;\n\n\t#else\n\n\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t\treturn normalize( tsn * mapN );\n\n\t\t}\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n"

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = "#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n"

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\ngl_Position = projectionMatrix * mvPosition;\n"

/***/ }),
/* 152 */
/***/ (function(module, exports) {

module.exports = "#if defined( DITHERING )\n\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n"

/***/ }),
/* 153 */
/***/ (function(module, exports) {

module.exports = "#if defined( DITHERING )\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n"

/***/ }),
/* 154 */
/***/ (function(module, exports) {

module.exports = "float roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n"

/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif"

/***/ }),
/* 156 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n\t\tvec2 f = fract( uv * size + 0.5 );\n\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\n\t\treturn c;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n"

/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n"

/***/ }),
/* 158 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n"

/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = "float getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\tDirectionalLight directionalLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\tSpotLight spotLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\tPointLight pointLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update shadow for Area light\n\n\t#endif\n\t*/\n\n\t#endif\n\n\treturn shadow;\n\n}\n"

/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif"

/***/ }),
/* 161 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n"

/***/ }),
/* 162 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n"

/***/ }),
/* 163 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n"

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif"

/***/ }),
/* 165 */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif"

/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = "#if defined( TONE_MAPPING )\n\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n"

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n\treturn toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n"

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvarying vec2 vUv;\n\n#endif"

/***/ }),
/* 169 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n\n#endif\n"

/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif"

/***/ }),
/* 171 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif"

/***/ }),
/* 172 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n#endif"

/***/ }),
/* 173 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = uv2;\n\n#endif"

/***/ }),
/* 174 */
/***/ (function(module, exports) {

module.exports = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n#endif\n"

/***/ }),
/* 175 */
/***/ (function(module, exports) {

module.exports = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\n\nvarying vec3 vWorldPosition;\n\nvoid main() {\n\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n\n}\n"

/***/ }),
/* 176 */
/***/ (function(module, exports) {

module.exports = "varying vec3 vWorldPosition;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n"

/***/ }),
/* 177 */
/***/ (function(module, exports) {

module.exports = "#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\n\t#endif\n\n}\n"

/***/ }),
/* 178 */
/***/ (function(module, exports) {

module.exports = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n}\n"

/***/ }),
/* 179 */
/***/ (function(module, exports) {

module.exports = "#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n"

/***/ }),
/* 180 */
/***/ (function(module, exports) {

module.exports = "#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n"

/***/ }),
/* 181 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D tEquirect;\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n\nvoid main() {\n\n\tvec3 direction = normalize( vWorldPosition );\n\n\tvec2 sampleUV;\n\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n}\n"

/***/ }),
/* 182 */
/***/ (function(module, exports) {

module.exports = "varying vec3 vWorldPosition;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n"

/***/ }),
/* 183 */
/***/ (function(module, exports) {

module.exports = "uniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n"

/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports = "uniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\n\tvLineDistance = scale * lineDistance;\n\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n"

/***/ }),
/* 185 */
/***/ (function(module, exports) {

module.exports = "uniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n"

/***/ }),
/* 186 */
/***/ (function(module, exports) {

module.exports = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_ENVMAP\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\n}\n"

/***/ }),
/* 187 */
/***/ (function(module, exports) {

module.exports = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\n\n#ifdef DOUBLE_SIDED\n\n\tvarying vec3 vLightBack;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n"

/***/ }),
/* 188 */
/***/ (function(module, exports) {

module.exports = "#define LAMBERT\n\nvarying vec3 vLightFront;\n\n#ifdef DOUBLE_SIDED\n\n\tvarying vec3 vLightBack;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n"

/***/ }),
/* 189 */
/***/ (function(module, exports) {

module.exports = "#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n"

/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports = "#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n"

/***/ }),
/* 191 */
/***/ (function(module, exports) {

module.exports = "#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n"

/***/ }),
/* 192 */
/***/ (function(module, exports) {

module.exports = "#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n"

/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = "#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n"

/***/ }),
/* 194 */
/***/ (function(module, exports) {

module.exports = "#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n"

/***/ }),
/* 195 */
/***/ (function(module, exports) {

module.exports = "uniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n"

/***/ }),
/* 196 */
/***/ (function(module, exports) {

module.exports = "uniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n"

/***/ }),
/* 197 */
/***/ (function(module, exports) {

module.exports = "uniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n\t#include <fog_fragment>\n\n}\n"

/***/ }),
/* 198 */
/***/ (function(module, exports) {

module.exports = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n"

/***/ }),
/* 199 */
/***/ (function(module, exports) {

module.exports = "uniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n"

/***/ }),
/* 200 */
/***/ (function(module, exports) {

module.exports = "uniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\tmvPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n"

/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLAttributes; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function WebGLAttributes(gl) {
  var buffers = new WeakMap();

  function createBuffer(attribute, bufferType) {
    var array = attribute.array;
    var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    var type = gl.FLOAT;

    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Float64Array) {
      console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
    } else if (array instanceof Uint16Array) {
      type = gl.UNSIGNED_SHORT;
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    }

    return {
      buffer: buffer,
      type: type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }

  function updateBuffer(buffer, attribute, bufferType) {
    var array = attribute.array;
    var updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);

    if (attribute.dynamic === false) {
      gl.bufferData(bufferType, array, gl.STATIC_DRAW);
    } else if (updateRange.count === -1) {
      // Not using update ranges
      gl.bufferSubData(bufferType, 0, array);
    } else if (updateRange.count === 0) {
      console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
    } else {
      gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      updateRange.count = -1; // reset range
    }
  } //


  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }

  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);

    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }

  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);

    if (data === undefined) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }

  return {
    get: get,
    remove: remove,
    update: update
  };
}



/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLBackground; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cameras_OrthographicCamera_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geometries_BoxGeometry_js__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geometries_PlaneGeometry_js__ = __webpack_require__(205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__materials_MeshBasicMaterial_js__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__materials_ShaderMaterial_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Color_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__objects_Mesh_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__shaders_ShaderLib_js__ = __webpack_require__(42);
/**
 * @author mrdoob / http://mrdoob.com/
 */










function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
  var clearColor = new __WEBPACK_IMPORTED_MODULE_6__math_Color_js__["a" /* Color */](0x000000);
  var clearAlpha = 0;
  var planeCamera, planeMesh;
  var boxMesh;

  function render(renderList, scene, camera, forceClear) {
    var background = scene.background;

    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }

    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }

    if (background && background.isCubeTexture) {
      if (boxMesh === undefined) {
        boxMesh = new __WEBPACK_IMPORTED_MODULE_7__objects_Mesh_js__["a" /* Mesh */](new __WEBPACK_IMPORTED_MODULE_2__geometries_BoxGeometry_js__["a" /* BoxBufferGeometry */](1, 1, 1), new __WEBPACK_IMPORTED_MODULE_5__materials_ShaderMaterial_js__["a" /* ShaderMaterial */]({
          uniforms: __WEBPACK_IMPORTED_MODULE_8__shaders_ShaderLib_js__["a" /* ShaderLib */].cube.uniforms,
          vertexShader: __WEBPACK_IMPORTED_MODULE_8__shaders_ShaderLib_js__["a" /* ShaderLib */].cube.vertexShader,
          fragmentShader: __WEBPACK_IMPORTED_MODULE_8__shaders_ShaderLib_js__["a" /* ShaderLib */].cube.fragmentShader,
          side: __WEBPACK_IMPORTED_MODULE_0__constants_js__["f" /* BackSide */],
          depthTest: true,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.removeAttribute('normal');
        boxMesh.geometry.removeAttribute('uv');

        boxMesh.onBeforeRender = function (renderer, scene, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };

        objects.update(boxMesh);
      }

      boxMesh.material.uniforms.tCube.value = background;
      renderList.push(boxMesh, boxMesh.geometry, boxMesh.material, 0, null);
    } else if (background && background.isTexture) {
      if (planeCamera === undefined) {
        planeCamera = new __WEBPACK_IMPORTED_MODULE_1__cameras_OrthographicCamera_js__["a" /* OrthographicCamera */](-1, 1, 1, -1, 0, 1);
        planeMesh = new __WEBPACK_IMPORTED_MODULE_7__objects_Mesh_js__["a" /* Mesh */](new __WEBPACK_IMPORTED_MODULE_3__geometries_PlaneGeometry_js__["a" /* PlaneBufferGeometry */](2, 2), new __WEBPACK_IMPORTED_MODULE_4__materials_MeshBasicMaterial_js__["a" /* MeshBasicMaterial */]({
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        objects.update(planeMesh);
      }

      planeMesh.material.map = background; // TODO Push this to renderList

      renderer.renderBufferDirect(planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null);
    }
  }

  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }

  return {
    getClearColor: function () {
      return clearColor;
    },
    setClearColor: function (color, alpha) {
      clearColor.set(color);
      clearAlpha = alpha !== undefined ? alpha : 1;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function () {
      return clearAlpha;
    },
    setClearAlpha: function (alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render
  };
}



/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export BoxGeometry */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BoxBufferGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Geometry_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__ = __webpack_require__(0);
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */



 // BoxGeometry

function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  __WEBPACK_IMPORTED_MODULE_0__core_Geometry_js__["a" /* Geometry */].call(this);
  this.type = 'BoxGeometry';
  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };
  this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
  this.mergeVertices();
}

BoxGeometry.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__core_Geometry_js__["a" /* Geometry */].prototype);
BoxGeometry.prototype.constructor = BoxGeometry; // BoxBufferGeometry

function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  __WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__["a" /* BufferGeometry */].call(this);
  this.type = 'BoxBufferGeometry';
  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };
  var scope = this;
  width = width || 1;
  height = height || 1;
  depth = depth || 1; // segments

  widthSegments = Math.floor(widthSegments) || 1;
  heightSegments = Math.floor(heightSegments) || 1;
  depthSegments = Math.floor(depthSegments) || 1; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var numberOfVertices = 0;
  var groupStart = 0; // build each side of the box geometry

  buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

  buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

  buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

  buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

  buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

  buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
  // build geometry

  this.setIndex(indices);
  this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](vertices, 3));
  this.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](normals, 3));
  this.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](uvs, 2));

  function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
    var segmentWidth = width / gridX;
    var segmentHeight = height / gridY;
    var widthHalf = width / 2;
    var heightHalf = height / 2;
    var depthHalf = depth / 2;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var vertexCounter = 0;
    var groupCount = 0;
    var ix, iy;
    var vector = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](); // generate vertices, normals and uvs

    for (iy = 0; iy < gridY1; iy++) {
      var y = iy * segmentHeight - heightHalf;

      for (ix = 0; ix < gridX1; ix++) {
        var x = ix * segmentWidth - widthHalf; // set values to correct vector component

        vector[u] = x * udir;
        vector[v] = y * vdir;
        vector[w] = depthHalf; // now apply vector to vertex buffer

        vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

        vector[u] = 0;
        vector[v] = 0;
        vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

        normals.push(vector.x, vector.y, vector.z); // uvs

        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY); // counters

        vertexCounter += 1;
      }
    } // indices
    // 1. you need three indices to draw a single face
    // 2. a single segment consists of two faces
    // 3. so we need to generate six (2*3) indices per segment


    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a = numberOfVertices + ix + gridX1 * iy;
        var b = numberOfVertices + ix + gridX1 * (iy + 1);
        var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
        var d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

        indices.push(a, b, d);
        indices.push(b, c, d); // increase counter

        groupCount += 6;
      }
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

    groupStart += groupCount; // update total number of vertices

    numberOfVertices += vertexCounter;
  }
}

BoxBufferGeometry.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__["a" /* BufferGeometry */].prototype);
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;


/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DirectGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Vector2_js__ = __webpack_require__(8);
/**
 * @author mrdoob / http://mrdoob.com/
 */


function DirectGeometry() {
  this.vertices = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];
  this.groups = [];
  this.morphTargets = {};
  this.skinWeights = [];
  this.skinIndices = []; // this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null; // update flags

  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.groupsNeedUpdate = false;
}

Object.assign(DirectGeometry.prototype, {
  computeGroups: function (geometry) {
    var group;
    var groups = [];
    var materialIndex = undefined;
    var faces = geometry.faces;

    for (var i = 0; i < faces.length; i++) {
      var face = faces[i]; // materials

      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;

        if (group !== undefined) {
          group.count = i * 3 - group.start;
          groups.push(group);
        }

        group = {
          start: i * 3,
          materialIndex: materialIndex
        };
      }
    }

    if (group !== undefined) {
      group.count = i * 3 - group.start;
      groups.push(group);
    }

    this.groups = groups;
  },
  fromGeometry: function (geometry) {
    var faces = geometry.faces;
    var vertices = geometry.vertices;
    var faceVertexUvs = geometry.faceVertexUvs;
    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs

    var morphTargets = geometry.morphTargets;
    var morphTargetsLength = morphTargets.length;
    var morphTargetsPosition;

    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];

      for (var i = 0; i < morphTargetsLength; i++) {
        morphTargetsPosition[i] = {
          name: morphTargets[i].name,
          data: []
        };
      }

      this.morphTargets.position = morphTargetsPosition;
    }

    var morphNormals = geometry.morphNormals;
    var morphNormalsLength = morphNormals.length;
    var morphTargetsNormal;

    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];

      for (var i = 0; i < morphNormalsLength; i++) {
        morphTargetsNormal[i] = {
          name: morphNormals[i].name,
          data: []
        };
      }

      this.morphTargets.normal = morphTargetsNormal;
    } // skins


    var skinIndices = geometry.skinIndices;
    var skinWeights = geometry.skinWeights;
    var hasSkinIndices = skinIndices.length === vertices.length;
    var hasSkinWeights = skinWeights.length === vertices.length; //

    if (vertices.length > 0 && faces.length === 0) {
      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
    }

    for (var i = 0; i < faces.length; i++) {
      var face = faces[i];
      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      var vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        var normal = face.normal;
        this.normals.push(normal, normal, normal);
      }

      var vertexColors = face.vertexColors;

      if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        var color = face.color;
        this.colors.push(color, color, color);
      }

      if (hasFaceVertexUv === true) {
        var vertexUvs = faceVertexUvs[0][i];

        if (vertexUvs !== undefined) {
          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
          this.uvs.push(new __WEBPACK_IMPORTED_MODULE_0__math_Vector2_js__["a" /* Vector2 */](), new __WEBPACK_IMPORTED_MODULE_0__math_Vector2_js__["a" /* Vector2 */](), new __WEBPACK_IMPORTED_MODULE_0__math_Vector2_js__["a" /* Vector2 */]());
        }
      }

      if (hasFaceVertexUv2 === true) {
        var vertexUvs = faceVertexUvs[1][i];

        if (vertexUvs !== undefined) {
          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
          this.uvs2.push(new __WEBPACK_IMPORTED_MODULE_0__math_Vector2_js__["a" /* Vector2 */](), new __WEBPACK_IMPORTED_MODULE_0__math_Vector2_js__["a" /* Vector2 */](), new __WEBPACK_IMPORTED_MODULE_0__math_Vector2_js__["a" /* Vector2 */]());
        }
      } // morphs


      for (var j = 0; j < morphTargetsLength; j++) {
        var morphTarget = morphTargets[j].vertices;
        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }

      for (var j = 0; j < morphNormalsLength; j++) {
        var morphNormal = morphNormals[j].vertexNormals[i];
        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
      } // skins


      if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }

      if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }

    this.computeGroups(geometry);
    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry.groupsNeedUpdate;
    return this;
  }
});


/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export PlaneGeometry */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PlaneBufferGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Geometry_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__ = __webpack_require__(15);
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */


 // PlaneGeometry

function PlaneGeometry(width, height, widthSegments, heightSegments) {
  __WEBPACK_IMPORTED_MODULE_0__core_Geometry_js__["a" /* Geometry */].call(this);
  this.type = 'PlaneGeometry';
  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };
  this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
  this.mergeVertices();
}

PlaneGeometry.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__core_Geometry_js__["a" /* Geometry */].prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry; // PlaneBufferGeometry

function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
  __WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__["a" /* BufferGeometry */].call(this);
  this.type = 'PlaneBufferGeometry';
  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };
  width = width || 1;
  height = height || 1;
  var width_half = width / 2;
  var height_half = height / 2;
  var gridX = Math.floor(widthSegments) || 1;
  var gridY = Math.floor(heightSegments) || 1;
  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;
  var segment_width = width / gridX;
  var segment_height = height / gridY;
  var ix, iy; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // generate vertices, normals and uvs

  for (iy = 0; iy < gridY1; iy++) {
    var y = iy * segment_height - height_half;

    for (ix = 0; ix < gridX1; ix++) {
      var x = ix * segment_width - width_half;
      vertices.push(x, -y, 0);
      normals.push(0, 0, 1);
      uvs.push(ix / gridX);
      uvs.push(1 - iy / gridY);
    }
  } // indices


  for (iy = 0; iy < gridY; iy++) {
    for (ix = 0; ix < gridX; ix++) {
      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * (iy + 1);
      var c = ix + 1 + gridX1 * (iy + 1);
      var d = ix + 1 + gridX1 * iy; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](vertices, 3));
  this.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](normals, 3));
  this.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](uvs, 2));
}

PlaneBufferGeometry.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__["a" /* BufferGeometry */].prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;


/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Triangle; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector3_js__ = __webpack_require__(0);

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Triangle(a, b, c) {
  this.a = a !== undefined ? a : new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
  this.b = b !== undefined ? b : new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
  this.c = c !== undefined ? c : new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
}

Object.assign(Triangle, {
  getNormal: function () {
    var v0 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function getNormal(a, b, c, target) {
      if (target === undefined) {
        console.warn('THREE.Triangle: .getNormal() target is now required');
        target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
      }

      target.subVectors(c, b);
      v0.subVectors(a, b);
      target.cross(v0);
      var targetLengthSq = target.lengthSq();

      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }

      return target.set(0, 0, 0);
    };
  }(),
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  getBarycoord: function () {
    var v0 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var v2 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function getBarycoord(point, a, b, c, target) {
      v0.subVectors(c, a);
      v1.subVectors(b, a);
      v2.subVectors(point, a);
      var dot00 = v0.dot(v0);
      var dot01 = v0.dot(v1);
      var dot02 = v0.dot(v2);
      var dot11 = v1.dot(v1);
      var dot12 = v1.dot(v2);
      var denom = dot00 * dot11 - dot01 * dot01;

      if (target === undefined) {
        console.warn('THREE.Triangle: .getBarycoord() target is now required');
        target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
      } // collinear or singular triangle


      if (denom === 0) {
        // arbitrary location outside of triangle?
        // not sure if this is the best idea, maybe should be returning undefined
        return target.set(-2, -1, -1);
      }

      var invDenom = 1 / denom;
      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

      return target.set(1 - u - v, v, u);
    };
  }(),
  containsPoint: function () {
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function containsPoint(point, a, b, c) {
      Triangle.getBarycoord(point, a, b, c, v1);
      return v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1;
    };
  }(),
  getUV: function () {
    var barycoord = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, barycoord);
      target.set(0, 0);
      target.addScaledVector(uv1, barycoord.x);
      target.addScaledVector(uv2, barycoord.y);
      target.addScaledVector(uv3, barycoord.z);
      return target;
    };
  }()
});
Object.assign(Triangle.prototype, {
  set: function (a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function (points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  },
  getArea: function () {
    var v0 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var v1 = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function getArea() {
      v0.subVectors(this.c, this.b);
      v1.subVectors(this.a, this.b);
      return v0.cross(v1).length() * 0.5;
    };
  }(),
  getMidpoint: function (target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getMidpoint() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    }

    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function (target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  },
  getPlane: function (target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getPlane() target is now required');
      target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    }

    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function (point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  },
  containsPoint: function (point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  },
  getUV: function (point, uv1, uv2, uv3, result) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, result);
  },
  intersectsBox: function (box) {
    return box.intersectsTriangle(this);
  },
  closestPointToPoint: function () {
    var vab = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var vac = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var vbc = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var vap = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var vbp = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    var vcp = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
    return function closestPointToPoint(p, target) {
      if (target === undefined) {
        console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
        target = new __WEBPACK_IMPORTED_MODULE_0__Vector3_js__["a" /* Vector3 */]();
      }

      var a = this.a,
          b = this.b,
          c = this.c;
      var v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
      // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
      // under the accompanying license; see chapter 5.1.5 for detailed explanation.
      // basically, we're distinguishing which of the voronoi regions of the triangle
      // the point lies in with the minimum amount of redundant computation.

      vab.subVectors(b, a);
      vac.subVectors(c, a);
      vap.subVectors(p, a);
      var d1 = vab.dot(vap);
      var d2 = vac.dot(vap);

      if (d1 <= 0 && d2 <= 0) {
        // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a);
      }

      vbp.subVectors(p, b);
      var d3 = vab.dot(vbp);
      var d4 = vac.dot(vbp);

      if (d3 >= 0 && d4 <= d3) {
        // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b);
      }

      var vc = d1 * d4 - d3 * d2;

      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

        return target.copy(a).addScaledVector(vab, v);
      }

      vcp.subVectors(p, c);
      var d5 = vab.dot(vcp);
      var d6 = vac.dot(vcp);

      if (d6 >= 0 && d5 <= d6) {
        // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c);
      }

      var vb = d5 * d2 - d1 * d6;

      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

        return target.copy(a).addScaledVector(vac, w);
      }

      var va = d3 * d6 - d5 * d4;

      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        vbc.subVectors(c, b);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

        return target.copy(b).addScaledVector(vbc, w); // edge region of BC
      } // face region


      var denom = 1 / (va + vb + vc); // u = va * denom

      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(vab, v).addScaledVector(vac, w);
    };
  }(),
  equals: function (triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
});


/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLBufferRenderer; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  var mode;

  function setMode(value) {
    mode = value;
  }

  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode);
  }

  function renderInstances(geometry, start, count) {
    var extension;

    if (capabilities.isWebGL2) {
      extension = gl;
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');

      if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE'](mode, start, count, geometry.maxInstancedCount);
    info.update(count, mode, geometry.maxInstancedCount);
  } //


  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}



/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLCapabilities; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function WebGLCapabilities(gl, extensions, parameters) {
  var maxAnisotropy;

  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined) return maxAnisotropy;
    var extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }

    return maxAnisotropy;
  }

  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return 'highp';
      }

      precision = 'mediump';
    }

    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return 'mediump';
      }
    }

    return 'lowp';
  }

  var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
  var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  var maxPrecision = getMaxPrecision(precision);

  if (maxPrecision !== precision) {
    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
  }

  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  var vertexTextures = maxVertexTextures > 0;
  var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
  var floatVertexTextures = vertexTextures && floatFragmentTextures;
  return {
    isWebGL2: isWebGL2,
    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    floatFragmentTextures: floatFragmentTextures,
    floatVertexTextures: floatVertexTextures
  };
}



/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLClipping; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Matrix3_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Plane_js__ = __webpack_require__(41);
/**
 * @author tschw
 */



function WebGLClipping() {
  var scope = this,
      globalState = null,
      numGlobalPlanes = 0,
      localClippingEnabled = false,
      renderingShadows = false,
      plane = new __WEBPACK_IMPORTED_MODULE_1__math_Plane_js__["a" /* Plane */](),
      viewNormalMatrix = new __WEBPACK_IMPORTED_MODULE_0__math_Matrix3_js__["a" /* Matrix3 */](),
      uniform = {
    value: null,
    needsUpdate: false
  };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;

  this.init = function (planes, enableLocalClipping, camera) {
    var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };

  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };

  this.endShadows = function () {
    renderingShadows = false;
    resetGlobalState();
  };

  this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      // there's no local clipping
      if (renderingShadows) {
        // there's no global clipping
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
          lGlobal = nGlobal * 4,
          dstArray = cache.clippingState || null;
      uniform.value = dstArray; // ensure unique state

      dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

      for (var i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }

      cache.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };

  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }

    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }

  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    var nPlanes = planes !== null ? planes.length : 0,
        dstArray = null;

    if (nPlanes !== 0) {
      dstArray = uniform.value;

      if (skipTransform !== true || dstArray === null) {
        var flatSize = dstOffset + nPlanes * 4,
            viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);

        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }

        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }

      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }

    scope.numPlanes = nPlanes;
    return dstArray;
  }
}



/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLExtensions; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function WebGLExtensions(gl) {
  var extensions = {};
  return {
    get: function (name) {
      if (extensions[name] !== undefined) {
        return extensions[name];
      }

      var extension;

      switch (name) {
        case 'WEBGL_depth_texture':
          extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
          break;

        case 'EXT_texture_filter_anisotropic':
          extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
          break;

        case 'WEBGL_compressed_texture_s3tc':
          extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
          break;

        case 'WEBGL_compressed_texture_pvrtc':
          extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
          break;

        default:
          extension = gl.getExtension(name);
      }

      if (extension === null) {
        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
      }

      extensions[name] = extension;
      return extension;
    }
  };
}



/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLGeometries; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_BufferAttribute_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_js__ = __webpack_require__(49);
/**
 * @author mrdoob / http://mrdoob.com/
 */




function WebGLGeometries(gl, attributes, info) {
  var geometries = {};
  var wireframeAttributes = {};

  function onGeometryDispose(event) {
    var geometry = event.target;
    var buffergeometry = geometries[geometry.id];

    if (buffergeometry.index !== null) {
      attributes.remove(buffergeometry.index);
    }

    for (var name in buffergeometry.attributes) {
      attributes.remove(buffergeometry.attributes[name]);
    }

    geometry.removeEventListener('dispose', onGeometryDispose);
    delete geometries[geometry.id];
    var attribute = wireframeAttributes[buffergeometry.id];

    if (attribute) {
      attributes.remove(attribute);
      delete wireframeAttributes[buffergeometry.id];
    } //


    info.memory.geometries--;
  }

  function get(object, geometry) {
    var buffergeometry = geometries[geometry.id];
    if (buffergeometry) return buffergeometry;
    geometry.addEventListener('dispose', onGeometryDispose);

    if (geometry.isBufferGeometry) {
      buffergeometry = geometry;
    } else if (geometry.isGeometry) {
      if (geometry._bufferGeometry === undefined) {
        geometry._bufferGeometry = new __WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__["a" /* BufferGeometry */]().setFromObject(object);
      }

      buffergeometry = geometry._bufferGeometry;
    }

    geometries[geometry.id] = buffergeometry;
    info.memory.geometries++;
    return buffergeometry;
  }

  function update(geometry) {
    var index = geometry.index;
    var geometryAttributes = geometry.attributes;

    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }

    for (var name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    } // morph targets


    var morphAttributes = geometry.morphAttributes;

    for (var name in morphAttributes) {
      var array = morphAttributes[name];

      for (var i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], gl.ARRAY_BUFFER);
      }
    }
  }

  function getWireframeAttribute(geometry) {
    var attribute = wireframeAttributes[geometry.id];
    if (attribute) return attribute;
    var indices = [];
    var geometryIndex = geometry.index;
    var geometryAttributes = geometry.attributes; // console.time( 'wireframe' );

    if (geometryIndex !== null) {
      var array = geometryIndex.array;

      for (var i = 0, l = array.length; i < l; i += 3) {
        var a = array[i + 0];
        var b = array[i + 1];
        var c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      var array = geometryAttributes.position.array;

      for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        var a = i + 0;
        var b = i + 1;
        var c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    } // console.timeEnd( 'wireframe' );


    attribute = new (Object(__WEBPACK_IMPORTED_MODULE_2__utils_js__["a" /* arrayMax */])(indices) > 65535 ? __WEBPACK_IMPORTED_MODULE_0__core_BufferAttribute_js__["h" /* Uint32BufferAttribute */] : __WEBPACK_IMPORTED_MODULE_0__core_BufferAttribute_js__["g" /* Uint16BufferAttribute */])(indices, 1);
    attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER);
    wireframeAttributes[geometry.id] = attribute;
    return attribute;
  }

  return {
    get: get,
    update: update,
    getWireframeAttribute: getWireframeAttribute
  };
}



/***/ }),
/* 212 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLIndexedBufferRenderer; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  var mode;

  function setMode(value) {
    mode = value;
  }

  var type, bytesPerElement;

  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }

  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode);
  }

  function renderInstances(geometry, start, count) {
    var extension;

    if (capabilities.isWebGL2) {
      extension = gl;
    } else {
      var extension = extensions.get('ANGLE_instanced_arrays');

      if (extension === null) {
        console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE'](mode, count, type, start * bytesPerElement, geometry.maxInstancedCount);
    info.update(count, mode, geometry.maxInstancedCount);
  } //


  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}



/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLInfo; });
/**
 * @author Mugen87 / https://github.com/Mugen87
 */
function WebGLInfo(gl) {
  var memory = {
    geometries: 0,
    textures: 0
  };
  var render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };

  function update(count, mode, instanceCount) {
    instanceCount = instanceCount || 1;
    render.calls++;

    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;

      case gl.TRIANGLE_STRIP:
      case gl.TRIANGLE_FAN:
        render.triangles += instanceCount * (count - 2);
        break;

      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;

      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;

      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;

      case gl.POINTS:
        render.points += instanceCount * count;
        break;

      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
        break;
    }
  }

  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }

  return {
    memory: memory,
    render: render,
    programs: null,
    autoReset: true,
    reset: reset,
    update: update
  };
}



/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLMorphtargets; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}

function WebGLMorphtargets(gl) {
  var influencesList = {};
  var morphInfluences = new Float32Array(8);

  function update(object, geometry, material, program) {
    var objectInfluences = object.morphTargetInfluences;
    var length = objectInfluences.length;
    var influences = influencesList[geometry.id];

    if (influences === undefined) {
      // initialise list
      influences = [];

      for (var i = 0; i < length; i++) {
        influences[i] = [i, 0];
      }

      influencesList[geometry.id] = influences;
    }

    var morphTargets = material.morphTargets && geometry.morphAttributes.position;
    var morphNormals = material.morphNormals && geometry.morphAttributes.normal; // Remove current morphAttributes

    for (var i = 0; i < length; i++) {
      var influence = influences[i];

      if (influence[1] !== 0) {
        if (morphTargets) geometry.removeAttribute('morphTarget' + i);
        if (morphNormals) geometry.removeAttribute('morphNormal' + i);
      }
    } // Collect influences


    for (var i = 0; i < length; i++) {
      var influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }

    influences.sort(absNumericalSort); // Add morphAttributes

    for (var i = 0; i < 8; i++) {
      var influence = influences[i];

      if (influence) {
        var index = influence[0];
        var value = influence[1];

        if (value) {
          if (morphTargets) geometry.addAttribute('morphTarget' + i, morphTargets[index]);
          if (morphNormals) geometry.addAttribute('morphNormal' + i, morphNormals[index]);
          morphInfluences[i] = value;
          continue;
        }
      }

      morphInfluences[i] = 0;
    }

    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
  }

  return {
    update: update
  };
}



/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLObjects; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function WebGLObjects(geometries, info) {
  var updateList = {};

  function update(object) {
    var frame = info.render.frame;
    var geometry = object.geometry;
    var buffergeometry = geometries.get(object, geometry); // Update once per frame

    if (updateList[buffergeometry.id] !== frame) {
      if (geometry.isGeometry) {
        buffergeometry.updateFromObject(object);
      }

      geometries.update(buffergeometry);
      updateList[buffergeometry.id] = frame;
    }

    return buffergeometry;
  }

  function dispose() {
    updateList = {};
  }

  return {
    update: update,
    dispose: dispose
  };
}



/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLPrograms; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__WebGLProgram_js__ = __webpack_require__(217);
/**
 * @author mrdoob / http://mrdoob.com/
 */



function WebGLPrograms(renderer, extensions, capabilities) {
  var programs = [];
  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'phong',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };
  var parameterNames = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

  function allocateBones(object) {
    var skeleton = object.skeleton;
    var bones = skeleton.bones;

    if (capabilities.floatVertexTextures) {
      return 1024;
    } else {
      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)
      var nVertexUniforms = capabilities.maxVertexUniforms;
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = Math.min(nVertexMatrices, bones.length);

      if (maxBones < bones.length) {
        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
        return 0;
      }

      return maxBones;
    }
  }

  function getTextureEncodingFromMap(map, gammaOverrideLinear) {
    var encoding;

    if (!map) {
      encoding = __WEBPACK_IMPORTED_MODULE_0__constants_js__["S" /* LinearEncoding */];
    } else if (map.isTexture) {
      encoding = map.encoding;
    } else if (map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.


    if (encoding === __WEBPACK_IMPORTED_MODULE_0__constants_js__["S" /* LinearEncoding */] && gammaOverrideLinear) {
      encoding = __WEBPACK_IMPORTED_MODULE_0__constants_js__["I" /* GammaEncoding */];
    }

    return encoding;
  }

  this.getParameters = function (material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
    var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
    var precision = capabilities.precision;

    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);

      if (precision !== material.precision) {
        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    }

    var currentRenderTarget = renderer.getRenderTarget();
    var parameters = {
      shaderID: shaderID,
      precision: precision,
      supportsVertexTextures: capabilities.vertexTextures,
      outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
      envMap: !!material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
      envMapCubeUV: !!material.envMap && (material.envMap.mapping === __WEBPACK_IMPORTED_MODULE_0__constants_js__["n" /* CubeUVReflectionMapping */] || material.envMap.mapping === __WEBPACK_IMPORTED_MODULE_0__constants_js__["o" /* CubeUVRefractionMapping */]),
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_19" /* ObjectSpaceNormalMap */],
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      combine: material.combine,
      vertexColors: material.vertexColors,
      fog: !!fog,
      useFog: material.fog,
      fogExp: fog && fog.isFogExp2,
      flatShading: material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones: maxBones,
      useVertexTexture: capabilities.floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numClippingPlanes: nClipPlanes,
      numClipIntersection: nClipIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: renderer.toneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["w" /* DoubleSide */],
      flipSided: material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["f" /* BackSide */],
      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false
    };
    return parameters;
  };

  this.getProgramCode = function (material, parameters) {
    var array = [];

    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(material.fragmentShader);
      array.push(material.vertexShader);
    }

    if (material.defines !== undefined) {
      for (var name in material.defines) {
        array.push(name);
        array.push(material.defines[name]);
      }
    }

    for (var i = 0; i < parameterNames.length; i++) {
      array.push(parameters[parameterNames[i]]);
    }

    array.push(material.onBeforeCompile.toString());
    array.push(renderer.gammaOutput);
    return array.join();
  };

  this.acquireProgram = function (material, shader, parameters, code) {
    var program; // Check if code has been already compiled

    for (var p = 0, pl = programs.length; p < pl; p++) {
      var programInfo = programs[p];

      if (programInfo.code === code) {
        program = programInfo;
        ++program.usedTimes;
        break;
      }
    }

    if (program === undefined) {
      program = new __WEBPACK_IMPORTED_MODULE_1__WebGLProgram_js__["a" /* WebGLProgram */](renderer, extensions, code, material, shader, parameters, capabilities);
      programs.push(program);
    }

    return program;
  };

  this.releaseProgram = function (program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      var i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop(); // Free WebGL resources

      program.destroy();
    }
  }; // Exposed for resource monitoring & error feedback via renderer.info:


  this.programs = programs;
}



/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLProgram; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__WebGLUniforms_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__WebGLShader_js__ = __webpack_require__(219);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_ShaderChunk_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constants_js__ = __webpack_require__(3);
/**
 * @author mrdoob / http://mrdoob.com/
 */




var programIdCount = 0;

function getEncodingComponents(encoding) {
  switch (encoding) {
    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["S" /* LinearEncoding */]:
      return ['Linear', '( value )'];

    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_88" /* sRGBEncoding */]:
      return ['sRGB', '( value )'];

    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_50" /* RGBEEncoding */]:
      return ['RGBE', '( value )'];

    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_54" /* RGBM7Encoding */]:
      return ['RGBM', '( value, 7.0 )'];

    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_53" /* RGBM16Encoding */]:
      return ['RGBM', '( value, 16.0 )'];

    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_49" /* RGBDEncoding */]:
      return ['RGBD', '( value, 256.0 )'];

    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["I" /* GammaEncoding */]:
      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

    default:
      throw new Error('unsupported encoding: ' + encoding);
  }
}

function getTexelDecodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}

function getTexelEncodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}

function getToneMappingFunction(functionName, toneMapping) {
  var toneMappingName;

  switch (toneMapping) {
    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["W" /* LinearToneMapping */]:
      toneMappingName = 'Linear';
      break;

    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_59" /* ReinhardToneMapping */]:
      toneMappingName = 'Reinhard';
      break;

    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_75" /* Uncharted2ToneMapping */]:
      toneMappingName = 'Uncharted2';
      break;

    case __WEBPACK_IMPORTED_MODULE_3__constants_js__["j" /* CineonToneMapping */]:
      toneMappingName = 'OptimizedCineon';
      break;

    default:
      throw new Error('unsupported toneMapping: ' + toneMapping);
  }

  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}

function generateExtensions(extensions, parameters, rendererExtensions) {
  extensions = extensions || {};
  var chunks = [extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap && !parameters.objectSpaceNormalMap || parameters.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '', (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', extensions.drawBuffers && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '', (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
  return chunks.filter(filterEmptyLine).join('\n');
}

function generateDefines(defines) {
  var chunks = [];

  for (var name in defines) {
    var value = defines[name];
    if (value === false) continue;
    chunks.push('#define ' + name + ' ' + value);
  }

  return chunks.join('\n');
}

function fetchAttributeLocations(gl, program) {
  var attributes = {};
  var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

  for (var i = 0; i < n; i++) {
    var info = gl.getActiveAttrib(program, i);
    var name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

    attributes[name] = gl.getAttribLocation(program, name);
  }

  return attributes;
}

function filterEmptyLine(string) {
  return string !== '';
}

function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
}

function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}

function parseIncludes(string) {
  var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  function replace(match, include) {
    var replace = __WEBPACK_IMPORTED_MODULE_2__shaders_ShaderChunk_js__["a" /* ShaderChunk */][include];

    if (replace === undefined) {
      throw new Error('Can not resolve #include <' + include + '>');
    }

    return parseIncludes(replace);
  }

  return string.replace(pattern, replace);
}

function unrollLoops(string) {
  var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

  function replace(match, start, end, snippet) {
    var unroll = '';

    for (var i = parseInt(start); i < parseInt(end); i++) {
      unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
    }

    return unroll;
  }

  return string.replace(pattern, replace);
}

function WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities) {
  var gl = renderer.context;
  var defines = material.defines;
  var vertexShader = shader.vertexShader;
  var fragmentShader = shader.fragmentShader;
  var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  if (parameters.shadowMapType === __WEBPACK_IMPORTED_MODULE_3__constants_js__["_25" /* PCFShadowMap */]) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
  } else if (parameters.shadowMapType === __WEBPACK_IMPORTED_MODULE_3__constants_js__["_26" /* PCFSoftShadowMap */]) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
  }

  var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
  var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

  if (parameters.envMap) {
    switch (material.envMap.mapping) {
      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["l" /* CubeReflectionMapping */]:
      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["m" /* CubeRefractionMapping */]:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;

      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["n" /* CubeUVReflectionMapping */]:
      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["o" /* CubeUVRefractionMapping */]:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;

      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["A" /* EquirectangularReflectionMapping */]:
      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["B" /* EquirectangularRefractionMapping */]:
        envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
        break;

      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_64" /* SphericalReflectionMapping */]:
        envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
        break;
    }

    switch (material.envMap.mapping) {
      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["m" /* CubeRefractionMapping */]:
      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["B" /* EquirectangularRefractionMapping */]:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }

    switch (material.combine) {
      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_9" /* MultiplyOperation */]:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;

      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_7" /* MixOperation */]:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;

      case __WEBPACK_IMPORTED_MODULE_3__constants_js__["b" /* AddOperation */]:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
  }

  var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0; // console.log( 'building new program ' );
  //

  var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions(material.extensions, parameters, extensions);
  var customDefines = generateDefines(defines); //

  var program = gl.createProgram();
  var prefixVertex, prefixFragment;

  if (material.isRawShaderMaterial) {
    prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

    if (prefixVertex.length > 0) {
      prefixVertex += '\n';
    }

    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

    if (prefixFragment.length > 0) {
      prefixFragment += '\n';
    }
  } else {
    prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + shader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
    prefixFragment = [customExtensions, 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + shader.name, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
    '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '', parameters.envMap && (capabilities.isWebGL2 || extensions.get('EXT_shader_texture_lod')) ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', parameters.toneMapping !== __WEBPACK_IMPORTED_MODULE_3__constants_js__["_16" /* NoToneMapping */] ? '#define TONE_MAPPING' : '', parameters.toneMapping !== __WEBPACK_IMPORTED_MODULE_3__constants_js__["_16" /* NoToneMapping */] ? __WEBPACK_IMPORTED_MODULE_2__shaders_ShaderChunk_js__["a" /* ShaderChunk */]['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
    parameters.toneMapping !== __WEBPACK_IMPORTED_MODULE_3__constants_js__["_16" /* NoToneMapping */] ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? __WEBPACK_IMPORTED_MODULE_2__shaders_ShaderChunk_js__["a" /* ShaderChunk */]['encodings_pars_fragment'] : '', // this code is required here because it is used by the various encoding/decoding function defined below
    parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '', parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
  }

  vertexShader = parseIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = parseIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);

  if (capabilities.isWebGL2 && !material.isRawShaderMaterial) {
    var isGLSL3ShaderMaterial = false;
    var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

    if (material.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
      isGLSL3ShaderMaterial = true;
      vertexShader = vertexShader.replace(versionRegex, '');
      fragmentShader = fragmentShader.replace(versionRegex, '');
    } // GLSL 3.0 conversion


    prefixVertex = ['#version 300 es\n', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
    prefixFragment = ['#version 300 es\n', '#define varying in', isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;', isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
  }

  var vertexGlsl = prefixVertex + vertexShader;
  var fragmentGlsl = prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );

  var glVertexShader = Object(__WEBPACK_IMPORTED_MODULE_1__WebGLShader_js__["a" /* WebGLShader */])(gl, gl.VERTEX_SHADER, vertexGlsl);
  var glFragmentShader = Object(__WEBPACK_IMPORTED_MODULE_1__WebGLShader_js__["a" /* WebGLShader */])(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

  if (material.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, material.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
  }

  gl.linkProgram(program);
  var programLog = gl.getProgramInfoLog(program).trim();
  var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
  var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
  var runnable = true;
  var haveDiagnostics = true; // console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
  // console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
    runnable = false;
    console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
  } else if (programLog !== '') {
    console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
  } else if (vertexLog === '' || fragmentLog === '') {
    haveDiagnostics = false;
  }

  if (haveDiagnostics) {
    this.diagnostics = {
      runnable: runnable,
      material: material,
      programLog: programLog,
      vertexShader: {
        log: vertexLog,
        prefix: prefixVertex
      },
      fragmentShader: {
        log: fragmentLog,
        prefix: prefixFragment
      }
    };
  } // clean up


  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader); // set up caching for uniform locations

  var cachedUniforms;

  this.getUniforms = function () {
    if (cachedUniforms === undefined) {
      cachedUniforms = new __WEBPACK_IMPORTED_MODULE_0__WebGLUniforms_js__["a" /* WebGLUniforms */](gl, program, renderer);
    }

    return cachedUniforms;
  }; // set up caching for attribute locations


  var cachedAttributes;

  this.getAttributes = function () {
    if (cachedAttributes === undefined) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }

    return cachedAttributes;
  }; // free resource


  this.destroy = function () {
    gl.deleteProgram(program);
    this.program = undefined;
  }; // DEPRECATED


  Object.defineProperties(this, {
    uniforms: {
      get: function () {
        console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
        return this.getUniforms();
      }
    },
    attributes: {
      get: function () {
        console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
        return this.getAttributes();
      }
    }
  }); //

  this.name = shader.name;
  this.id = programIdCount++;
  this.code = code;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}



/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CubeTexture; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Texture_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_js__ = __webpack_require__(3);
/**
 * @author mrdoob / http://mrdoob.com/
 */



function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  images = images !== undefined ? images : [];
  mapping = mapping !== undefined ? mapping : __WEBPACK_IMPORTED_MODULE_1__constants_js__["l" /* CubeReflectionMapping */];
  __WEBPACK_IMPORTED_MODULE_0__Texture_js__["a" /* Texture */].call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.flipY = false;
}

CubeTexture.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__Texture_js__["a" /* Texture */].prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, 'images', {
  get: function () {
    return this.image;
  },
  set: function (value) {
    this.image = value;
  }
});


/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLShader; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function addLineNumbers(string) {
  var lines = string.split('\n');

  for (var i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ': ' + lines[i];
  }

  return lines.join('\n');
}

function WebGLShader(gl, type, string) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);

  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
    console.error('THREE.WebGLShader: Shader couldn\'t compile.');
  }

  if (gl.getShaderInfoLog(shader) !== '') {
    console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
  } // --enable-privileged-webgl-extension
  // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );


  return shader;
}



/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLProperties; });
/**
 * @author fordacious / fordacious.github.io
 */
function WebGLProperties() {
  var properties = new WeakMap();

  function get(object) {
    var map = properties.get(object);

    if (map === undefined) {
      map = {};
      properties.set(object, map);
    }

    return map;
  }

  function remove(object) {
    properties.delete(object);
  }

  function update(object, key, value) {
    properties.get(object)[key] = value;
  }

  function dispose() {
    properties = new WeakMap();
  }

  return {
    get: get,
    remove: remove,
    update: update,
    dispose: dispose
  };
}



/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLRenderLists; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
function painterSortStable(a, b) {
  if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program && b.program && a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}

function reversePainterSortStable(a, b) {
  if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  }

  if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}

function WebGLRenderList() {
  var renderItems = [];
  var renderItemsIndex = 0;
  var opaque = [];
  var transparent = [];

  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }

  function push(object, geometry, material, z, group) {
    var renderItem = renderItems[renderItemsIndex];

    if (renderItem === undefined) {
      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        program: material.program,
        renderOrder: object.renderOrder,
        z: z,
        group: group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = material.program;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }

    (material.transparent === true ? transparent : opaque).push(renderItem);
    renderItemsIndex++;
  }

  function sort() {
    if (opaque.length > 1) opaque.sort(painterSortStable);
    if (transparent.length > 1) transparent.sort(reversePainterSortStable);
  }

  return {
    opaque: opaque,
    transparent: transparent,
    init: init,
    push: push,
    sort: sort
  };
}

function WebGLRenderLists() {
  var lists = {};

  function get(scene, camera) {
    var hash = scene.id + ',' + camera.id;
    var list = lists[hash];

    if (list === undefined) {
      // console.log( 'THREE.WebGLRenderLists:', hash );
      list = new WebGLRenderList();
      lists[hash] = list;
    }

    return list;
  }

  function dispose() {
    lists = {};
  }

  return {
    get: get,
    dispose: dispose
  };
}



/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLRenderStates; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__WebGLLights_js__ = __webpack_require__(223);
/**
 * @author Mugen87 / https://github.com/Mugen87
 */


function WebGLRenderState() {
  var lights = new __WEBPACK_IMPORTED_MODULE_0__WebGLLights_js__["a" /* WebGLLights */]();
  var lightsArray = [];
  var shadowsArray = [];

  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }

  function pushLight(light) {
    lightsArray.push(light);
  }

  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }

  function setupLights(camera) {
    lights.setup(lightsArray, shadowsArray, camera);
  }

  var state = {
    lightsArray: lightsArray,
    shadowsArray: shadowsArray,
    lights: lights
  };
  return {
    init: init,
    state: state,
    setupLights: setupLights,
    pushLight: pushLight,
    pushShadow: pushShadow
  };
}

function WebGLRenderStates() {
  var renderStates = {};

  function get(scene, camera) {
    var renderState;

    if (renderStates[scene.id] === undefined) {
      renderState = new WebGLRenderState();
      renderStates[scene.id] = {};
      renderStates[scene.id][camera.id] = renderState;
    } else {
      if (renderStates[scene.id][camera.id] === undefined) {
        renderState = new WebGLRenderState();
        renderStates[scene.id][camera.id] = renderState;
      } else {
        renderState = renderStates[scene.id][camera.id];
      }
    }

    return renderState;
  }

  function dispose() {
    renderStates = {};
  }

  return {
    get: get,
    dispose: dispose
  };
}



/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLLights; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Color_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__ = __webpack_require__(0);
/**
 * @author mrdoob / http://mrdoob.com/
 */





function UniformsCache() {
  var lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      var uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
            color: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](),
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */]()
          };
          break;

        case 'SpotLight':
          uniforms = {
            position: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
            direction: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
            color: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */]()
          };
          break;

        case 'PointLight':
          uniforms = {
            position: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
            color: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](),
            distance: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */](),
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;

        case 'HemisphereLight':
          uniforms = {
            direction: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
            skyColor: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](),
            groundColor: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */]()
          };
          break;

        case 'RectAreaLight':
          uniforms = {
            color: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](),
            position: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
            halfWidth: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
            halfHeight: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]() // TODO (abelnation): set RectAreaLight shadow uniforms

          };
          break;
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

var count = 0;

function WebGLLights() {
  var cache = new UniformsCache();
  var state = {
    id: count++,
    hash: {
      stateID: -1,
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      shadowsLength: -1
    },
    ambient: [0, 0, 0],
    directional: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  var vector3 = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
  var matrix4 = new __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__["a" /* Matrix4 */]();
  var matrix42 = new __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__["a" /* Matrix4 */]();

  function setup(lights, shadows, camera) {
    var r = 0,
        g = 0,
        b = 0;
    var directionalLength = 0;
    var pointLength = 0;
    var spotLength = 0;
    var rectAreaLength = 0;
    var hemiLength = 0;
    var viewMatrix = camera.matrixWorldInverse;

    for (var i = 0, l = lights.length; i < l; i++) {
      var light = lights[i];
      var color = light.color;
      var intensity = light.intensity;
      var distance = light.distance;
      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isDirectionalLight) {
        var uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }

        state.directionalShadowMap[directionalLength] = shadowMap;
        state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        var uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.distance === 0 ? 0.0 : light.decay;
        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }

        state.spotShadowMap[spotLength] = shadowMap;
        state.spotShadowMatrix[spotLength] = light.shadow.matrix;
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        var uniforms = cache.get(light); // (a) intensity is the total visible light emitted
        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
        // (b) intensity is the brightness of the light

        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42); // TODO (abelnation): RectAreaLight distance?
        // uniforms.distance = distance;

        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        var uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.distance === 0 ? 0.0 : light.decay;
        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
          uniforms.shadowCameraNear = shadow.camera.near;
          uniforms.shadowCameraFar = shadow.camera.far;
        }

        state.pointShadowMap[pointLength] = shadowMap;
        state.pointShadowMatrix[pointLength] = light.shadow.matrix;
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        var uniforms = cache.get(light);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }

    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    state.directional.length = directionalLength;
    state.spot.length = spotLength;
    state.rectArea.length = rectAreaLength;
    state.point.length = pointLength;
    state.hemi.length = hemiLength;
    state.hash.stateID = state.id;
    state.hash.directionalLength = directionalLength;
    state.hash.pointLength = pointLength;
    state.hash.spotLength = spotLength;
    state.hash.rectAreaLength = rectAreaLength;
    state.hash.hemiLength = hemiLength;
    state.hash.shadowsLength = shadows.length;
  }

  return {
    setup: setup,
    state: state
  };
}



/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLShadowMap; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__WebGLRenderTarget_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__materials_MeshDepthMaterial_js__ = __webpack_require__(225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__materials_MeshDistanceMaterial_js__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Frustum_js__ = __webpack_require__(40);
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */










function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  var _frustum = new __WEBPACK_IMPORTED_MODULE_8__math_Frustum_js__["a" /* Frustum */](),
      _projScreenMatrix = new __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__["a" /* Matrix4 */](),
      _shadowMapSize = new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](),
      _maxShadowMapSize = new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](maxTextureSize, maxTextureSize),
      _lookTarget = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](),
      _lightPositionWorld = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](),
      _MorphingFlag = 1,
      _SkinningFlag = 2,
      _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,
      _depthMaterials = new Array(_NumberOfMaterialVariants),
      _distanceMaterials = new Array(_NumberOfMaterialVariants),
      _materialCache = {};

  var shadowSide = {
    0: __WEBPACK_IMPORTED_MODULE_0__constants_js__["f" /* BackSide */],
    1: __WEBPACK_IMPORTED_MODULE_0__constants_js__["H" /* FrontSide */],
    2: __WEBPACK_IMPORTED_MODULE_0__constants_js__["w" /* DoubleSide */]
  };
  var cubeDirections = [new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](1, 0, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](-1, 0, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 0, 1), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 0, -1), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, -1, 0)];
  var cubeUps = [new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 0, 1), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 0, -1)];
  var cube2DViewPorts = [new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */](), new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */](), new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */](), new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */](), new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */](), new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */]()]; // init

  for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
    var useMorphing = (i & _MorphingFlag) !== 0;
    var useSkinning = (i & _SkinningFlag) !== 0;
    var depthMaterial = new __WEBPACK_IMPORTED_MODULE_2__materials_MeshDepthMaterial_js__["a" /* MeshDepthMaterial */]({
      depthPacking: __WEBPACK_IMPORTED_MODULE_0__constants_js__["_28" /* RGBADepthPacking */],
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _depthMaterials[i] = depthMaterial; //

    var distanceMaterial = new __WEBPACK_IMPORTED_MODULE_3__materials_MeshDistanceMaterial_js__["a" /* MeshDistanceMaterial */]({
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _distanceMaterials[i] = distanceMaterial;
  } //


  var scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["_25" /* PCFShadowMap */];

  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return; // TODO Clean up (needed in case of contextlost)

    var _gl = _renderer.context;
    var _state = _renderer.state; // Set GL state for depth map.

    _state.disable(_gl.BLEND);

    _state.buffers.color.setClear(1, 1, 1, 1);

    _state.buffers.depth.setTest(true);

    _state.setScissorTest(false); // render depth map


    var faceCount;

    for (var i = 0, il = lights.length; i < il; i++) {
      var light = lights[i];
      var shadow = light.shadow;
      var isPointLight = light && light.isPointLight;

      if (shadow === undefined) {
        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
        continue;
      }

      var shadowCamera = shadow.camera;

      _shadowMapSize.copy(shadow.mapSize);

      _shadowMapSize.min(_maxShadowMapSize);

      if (isPointLight) {
        var vpWidth = _shadowMapSize.x;
        var vpHeight = _shadowMapSize.y; // These viewports map a cube-map onto a 2D texture with the
        // following orientation:
        //
        //  xzXZ
        //   y Y
        //
        // X - Positive x direction
        // x - Negative x direction
        // Y - Positive y direction
        // y - Negative y direction
        // Z - Positive z direction
        // z - Negative z direction
        // positive X

        cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight); // negative X

        cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight); // positive Z

        cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight); // negative Z

        cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight); // positive Y

        cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight); // negative Y

        cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
        _shadowMapSize.x *= 4.0;
        _shadowMapSize.y *= 2.0;
      }

      if (shadow.map === null) {
        var pars = {
          minFilter: __WEBPACK_IMPORTED_MODULE_0__constants_js__["_10" /* NearestFilter */],
          magFilter: __WEBPACK_IMPORTED_MODULE_0__constants_js__["_10" /* NearestFilter */],
          format: __WEBPACK_IMPORTED_MODULE_0__constants_js__["_29" /* RGBAFormat */]
        };
        shadow.map = new __WEBPACK_IMPORTED_MODULE_1__WebGLRenderTarget_js__["a" /* WebGLRenderTarget */](_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadowCamera.updateProjectionMatrix();
      }

      if (shadow.isSpotLightShadow) {
        shadow.update(light);
      }

      var shadowMap = shadow.map;
      var shadowMatrix = shadow.matrix;

      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);

      shadowCamera.position.copy(_lightPositionWorld);

      if (isPointLight) {
        faceCount = 6; // for point lights we set the shadow matrix to be a translation-only matrix
        // equal to inverse of the light's position

        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      } else {
        faceCount = 1;

        _lookTarget.setFromMatrixPosition(light.target.matrixWorld);

        shadowCamera.lookAt(_lookTarget);
        shadowCamera.updateMatrixWorld(); // compute shadow matrix

        shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      }

      _renderer.setRenderTarget(shadowMap);

      _renderer.clear(); // render shadow map for each cube face (if omni-directional) or
      // run a single pass if not


      for (var face = 0; face < faceCount; face++) {
        if (isPointLight) {
          _lookTarget.copy(shadowCamera.position);

          _lookTarget.add(cubeDirections[face]);

          shadowCamera.up.copy(cubeUps[face]);
          shadowCamera.lookAt(_lookTarget);
          shadowCamera.updateMatrixWorld();
          var vpDimensions = cube2DViewPorts[face];

          _state.viewport(vpDimensions);
        } // update camera matrices and frustum


        _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

        _frustum.setFromMatrix(_projScreenMatrix); // set object matrices & frustum culling


        renderObject(scene, camera, shadowCamera, isPointLight);
      }
    }

    scope.needsUpdate = false;
  };

  function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
    var geometry = object.geometry;
    var result = null;
    var materialVariants = _depthMaterials;
    var customMaterial = object.customDepthMaterial;

    if (isPointLight) {
      materialVariants = _distanceMaterials;
      customMaterial = object.customDistanceMaterial;
    }

    if (!customMaterial) {
      var useMorphing = false;

      if (material.morphTargets) {
        if (geometry && geometry.isBufferGeometry) {
          useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
        } else if (geometry && geometry.isGeometry) {
          useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
        }
      }

      if (object.isSkinnedMesh && material.skinning === false) {
        console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
      }

      var useSkinning = object.isSkinnedMesh && material.skinning;
      var variantIndex = 0;
      if (useMorphing) variantIndex |= _MorphingFlag;
      if (useSkinning) variantIndex |= _SkinningFlag;
      result = materialVariants[variantIndex];
    } else {
      result = customMaterial;
    }

    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      // in this case we need a unique material instance reflecting the
      // appropriate state
      var keyA = result.uuid,
          keyB = material.uuid;
      var materialsForVariant = _materialCache[keyA];

      if (materialsForVariant === undefined) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }

      var cachedMaterial = materialsForVariant[keyB];

      if (cachedMaterial === undefined) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }

      result = cachedMaterial;
    }

    result.visible = material.visible;
    result.wireframe = material.wireframe;
    result.side = material.shadowSide != null ? material.shadowSide : shadowSide[material.side];
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;

    if (isPointLight && result.isMeshDistanceMaterial) {
      result.referencePosition.copy(lightPositionWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }

    return result;
  }

  function renderObject(object, camera, shadowCamera, isPointLight) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);

    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

        var geometry = _objects.update(object);

        var material = object.material;

        if (Array.isArray(material)) {
          var groups = geometry.groups;

          for (var k = 0, kl = groups.length; k < kl; k++) {
            var group = groups[k];
            var groupMaterial = material[group.materialIndex];

            if (groupMaterial && groupMaterial.visible) {
              var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);

              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);

          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }

    var children = object.children;

    for (var i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, isPointLight);
    }
  }
}



/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MeshDepthMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Material_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_js__ = __webpack_require__(3);


/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

function MeshDepthMaterial(parameters) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].call(this);
  this.type = 'MeshDepthMaterial';
  this.depthPacking = __WEBPACK_IMPORTED_MODULE_1__constants_js__["g" /* BasicDepthPacking */];
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshDepthMaterial.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function (source) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype.copy.call(this, source);
  this.depthPacking = source.depthPacking;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};



/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MeshDistanceMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Material_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__ = __webpack_require__(0);


/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

function MeshDistanceMaterial(parameters) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].call(this);
  this.type = 'MeshDistanceMaterial';
  this.referencePosition = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
  this.nearDistance = 1;
  this.farDistance = 1000;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshDistanceMaterial.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

MeshDistanceMaterial.prototype.copy = function (source) {
  __WEBPACK_IMPORTED_MODULE_0__Material_js__["a" /* Material */].prototype.copy.call(this, source);
  this.referencePosition.copy(source.referencePosition);
  this.nearDistance = source.nearDistance;
  this.farDistance = source.farDistance;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  return this;
};



/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLState; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__ = __webpack_require__(11);
/**
 * @author mrdoob / http://mrdoob.com/
 */



function WebGLState(gl, extensions, utils, capabilities) {
  function ColorBuffer() {
    var locked = false;
    var color = new __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__["a" /* Vector4 */]();
    var currentColorMask = null;
    var currentColorClear = new __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__["a" /* Vector4 */](0, 0, 0, 0);
    return {
      setMask: function (colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }

        color.set(r, g, b, a);

        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function () {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0); // set to invalid state
      }
    };
  }

  function DepthBuffer() {
    var locked = false;
    var currentDepthMask = null;
    var currentDepthFunc = null;
    var currentDepthClear = null;
    return {
      setTest: function (depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function (depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function (depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_13" /* NeverDepth */]:
                gl.depthFunc(gl.NEVER);
                break;

              case __WEBPACK_IMPORTED_MODULE_0__constants_js__["e" /* AlwaysDepth */]:
                gl.depthFunc(gl.ALWAYS);
                break;

              case __WEBPACK_IMPORTED_MODULE_0__constants_js__["Q" /* LessDepth */]:
                gl.depthFunc(gl.LESS);
                break;

              case __WEBPACK_IMPORTED_MODULE_0__constants_js__["R" /* LessEqualDepth */]:
                gl.depthFunc(gl.LEQUAL);
                break;

              case __WEBPACK_IMPORTED_MODULE_0__constants_js__["z" /* EqualDepth */]:
                gl.depthFunc(gl.EQUAL);
                break;

              case __WEBPACK_IMPORTED_MODULE_0__constants_js__["K" /* GreaterEqualDepth */]:
                gl.depthFunc(gl.GEQUAL);
                break;

              case __WEBPACK_IMPORTED_MODULE_0__constants_js__["J" /* GreaterDepth */]:
                gl.depthFunc(gl.GREATER);
                break;

              case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_18" /* NotEqualDepth */]:
                gl.depthFunc(gl.NOTEQUAL);
                break;

              default:
                gl.depthFunc(gl.LEQUAL);
            }
          } else {
            gl.depthFunc(gl.LEQUAL);
          }

          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function () {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }

  function StencilBuffer() {
    var locked = false;
    var currentStencilMask = null;
    var currentStencilFunc = null;
    var currentStencilRef = null;
    var currentStencilFuncMask = null;
    var currentStencilFail = null;
    var currentStencilZFail = null;
    var currentStencilZPass = null;
    var currentStencilClear = null;
    return {
      setTest: function (stencilTest) {
        if (stencilTest) {
          enable(gl.STENCIL_TEST);
        } else {
          disable(gl.STENCIL_TEST);
        }
      },
      setMask: function (stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function (stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function (stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function () {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  } //


  var colorBuffer = new ColorBuffer();
  var depthBuffer = new DepthBuffer();
  var stencilBuffer = new StencilBuffer();
  var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  var newAttributes = new Uint8Array(maxVertexAttributes);
  var enabledAttributes = new Uint8Array(maxVertexAttributes);
  var attributeDivisors = new Uint8Array(maxVertexAttributes);
  var enabledCapabilities = {};
  var compressedTextureFormats = null;
  var currentProgram = null;
  var currentBlendingEnabled = null;
  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;
  var currentPremultipledAlpha = false;
  var currentFlipSided = null;
  var currentCullFace = null;
  var currentLineWidth = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;
  var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  var lineWidthAvailable = false;
  var version = 0;
  var glVersion = gl.getParameter(gl.VERSION);

  if (glVersion.indexOf('WebGL') !== -1) {
    version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1.0;
  } else if (glVersion.indexOf('OpenGL ES') !== -1) {
    version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2.0;
  }

  var currentTextureSlot = null;
  var currentBoundTextures = {};
  var currentScissor = new __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__["a" /* Vector4 */]();
  var currentViewport = new __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__["a" /* Vector4 */]();

  function createTexture(type, target, count) {
    var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

    var texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    for (var i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
    }

    return texture;
  }

  var emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6); // init

  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(__WEBPACK_IMPORTED_MODULE_0__constants_js__["R" /* LessEqualDepth */]);
  setFlipSided(false);
  setCullFace(__WEBPACK_IMPORTED_MODULE_0__constants_js__["p" /* CullFaceBack */]);
  enable(gl.CULL_FACE);
  setBlending(__WEBPACK_IMPORTED_MODULE_0__constants_js__["_14" /* NoBlending */]); //

  function initAttributes() {
    for (var i = 0, l = newAttributes.length; i < l; i++) {
      newAttributes[i] = 0;
    }
  }

  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }

  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    newAttributes[attribute] = 1;

    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }

    if (attributeDivisors[attribute] !== meshPerAttribute) {
      var extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
      extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }

  function disableUnusedAttributes() {
    for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }

  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }

  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }

  function getCompressedTextureFormats() {
    if (compressedTextureFormats === null) {
      compressedTextureFormats = [];

      if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc') || extensions.get('WEBGL_compressed_texture_etc1') || extensions.get('WEBGL_compressed_texture_astc')) {
        var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);

        for (var i = 0; i < formats.length; i++) {
          compressedTextureFormats.push(formats[i]);
        }
      }
    }

    return compressedTextureFormats;
  }

  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }

    return false;
  }

  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_14" /* NoBlending */]) {
      if (currentBlendingEnabled) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }

      return;
    }

    if (!currentBlendingEnabled) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }

    if (blending !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["t" /* CustomBlending */]) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* AddEquation */] || currentBlendEquationAlpha !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* AddEquation */]) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* AddEquation */];
          currentBlendEquationAlpha = __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* AddEquation */];
        }

        if (premultipliedAlpha) {
          switch (blending) {
            case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_17" /* NormalBlending */]:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;

            case __WEBPACK_IMPORTED_MODULE_0__constants_js__["c" /* AdditiveBlending */]:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;

            case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_69" /* SubtractiveBlending */]:
              gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
              break;

            case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_8" /* MultiplyBlending */]:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        } else {
          switch (blending) {
            case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_17" /* NormalBlending */]:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;

            case __WEBPACK_IMPORTED_MODULE_0__constants_js__["c" /* AdditiveBlending */]:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;

            case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_69" /* SubtractiveBlending */]:
              gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
              break;

            case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_8" /* MultiplyBlending */]:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        }

        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }

      return;
    } // custom blending


    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;

    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }

    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }

    currentBlending = blending;
    currentPremultipledAlpha = null;
  }

  function setMaterial(material, frontFaceCW) {
    material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["w" /* DoubleSide */] ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    var flipSided = material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["f" /* BackSide */];
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_17" /* NormalBlending */] && material.transparent === false ? setBlending(__WEBPACK_IMPORTED_MODULE_0__constants_js__["_14" /* NoBlending */]) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  } //


  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }

      currentFlipSided = flipSided;
    }
  }

  function setCullFace(cullFace) {
    if (cullFace !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["s" /* CullFaceNone */]) {
      enable(gl.CULL_FACE);

      if (cullFace !== currentCullFace) {
        if (cullFace === __WEBPACK_IMPORTED_MODULE_0__constants_js__["p" /* CullFaceBack */]) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === __WEBPACK_IMPORTED_MODULE_0__constants_js__["q" /* CullFaceFront */]) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }

    currentCullFace = cullFace;
  }

  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }

  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);

      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }

  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  } // texture


  function activeTexture(webglSlot) {
    if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }

  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }

    var boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture === undefined) {
      boundTexture = {
        type: undefined,
        texture: undefined
      };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }

    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }

  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  } //


  function scissor(scissor) {
    if (currentScissor.equals(scissor) === false) {
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      currentScissor.copy(scissor);
    }
  }

  function viewport(viewport) {
    if (currentViewport.equals(viewport) === false) {
      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
      currentViewport.copy(viewport);
    }
  } //


  function reset() {
    for (var i = 0; i < enabledAttributes.length; i++) {
      if (enabledAttributes[i] === 1) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }

    enabledCapabilities = {};
    compressedTextureFormats = null;
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlending = null;
    currentFlipSided = null;
    currentCullFace = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }

  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    initAttributes: initAttributes,
    enableAttribute: enableAttribute,
    enableAttributeAndDivisor: enableAttributeAndDivisor,
    disableUnusedAttributes: disableUnusedAttributes,
    enable: enable,
    disable: disable,
    getCompressedTextureFormats: getCompressedTextureFormats,
    useProgram: useProgram,
    setBlending: setBlending,
    setMaterial: setMaterial,
    setFlipSided: setFlipSided,
    setCullFace: setCullFace,
    setLineWidth: setLineWidth,
    setPolygonOffset: setPolygonOffset,
    setScissorTest: setScissorTest,
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    compressedTexImage2D: compressedTexImage2D,
    texImage2D: texImage2D,
    scissor: scissor,
    viewport: viewport,
    reset: reset
  };
}



/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLTextures; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Math_js__ = __webpack_require__(6);
/**
 * @author mrdoob / http://mrdoob.com/
 */



function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  var _videoTextures = {};

  var _canvas; //


  function clampToMaxSize(image, maxSize) {
    if (image.width > maxSize || image.height > maxSize) {
      if ('data' in image) {
        console.warn('THREE.WebGLRenderer: image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
        return;
      } // Warning: Scaling through the canvas will only work with images that use
      // premultiplied alpha.


      var scale = maxSize / Math.max(image.width, image.height);
      var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
      canvas.width = Math.floor(image.width * scale);
      canvas.height = Math.floor(image.height * scale);
      var context = canvas.getContext('2d');
      context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
      console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height);
      return canvas;
    }

    return image;
  }

  function isPowerOfTwo(image) {
    return __WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].isPowerOfTwo(image.width) && __WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].isPowerOfTwo(image.height);
  }

  function makePowerOfTwo(image) {
    if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap) {
      if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
      _canvas.width = __WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].floorPowerOfTwo(image.width);
      _canvas.height = __WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].floorPowerOfTwo(image.height);

      var context = _canvas.getContext('2d');

      context.drawImage(image, 0, 0, _canvas.width, _canvas.height);
      console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + _canvas.width + 'x' + _canvas.height);
      return _canvas;
    }

    return image;
  }

  function textureNeedsPowerOfTwo(texture) {
    if (capabilities.isWebGL2) return false;
    return texture.wrapS !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["k" /* ClampToEdgeWrapping */] || texture.wrapT !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["k" /* ClampToEdgeWrapping */] || texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_10" /* NearestFilter */] && texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["T" /* LinearFilter */];
  }

  function textureNeedsGenerateMipmaps(texture, isPowerOfTwo) {
    return texture.generateMipmaps && isPowerOfTwo && texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_10" /* NearestFilter */] && texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["T" /* LinearFilter */];
  }

  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);

    var textureProperties = properties.get(texture); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11

    textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
  }

  function getInternalFormat(glFormat, glType) {
    if (!capabilities.isWebGL2) return glFormat;

    if (glFormat === _gl.RGB) {
      if (glType === _gl.FLOAT) return _gl.RGB32F;
      if (glType === _gl.HALF_FLOAT) return _gl.RGB16F;
      if (glType === _gl.UNSIGNED_BYTE) return _gl.RGB8;
    }

    if (glFormat === _gl.RGBA) {
      if (glType === _gl.FLOAT) return _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) return _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE) return _gl.RGBA8;
    }

    return glFormat;
  } // Fallback filters for non-power-of-2 textures


  function filterFallback(f) {
    if (f === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_10" /* NearestFilter */] || f === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_12" /* NearestMipMapNearestFilter */] || f === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_11" /* NearestMipMapLinearFilter */]) {
      return _gl.NEAREST;
    }

    return _gl.LINEAR;
  } //


  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);

    if (texture.isVideoTexture) {
      delete _videoTextures[texture.id];
    }

    info.memory.textures--;
  }

  function onRenderTargetDispose(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  } //


  function deallocateTexture(texture) {
    var textureProperties = properties.get(texture);

    if (texture.image && textureProperties.__image__webglTextureCube) {
      // cube texture
      _gl.deleteTexture(textureProperties.__image__webglTextureCube);
    } else {
      // 2D texture
      if (textureProperties.__webglInit === undefined) return;

      _gl.deleteTexture(textureProperties.__webglTexture);
    } // remove all webgl properties


    properties.remove(texture);
  }

  function deallocateRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget) return;

    if (textureProperties.__webglTexture !== undefined) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }

    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }

    if (renderTarget.isWebGLRenderTargetCube) {
      for (var i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
    }

    properties.remove(renderTarget.texture);
    properties.remove(renderTarget);
  } //


  function setTexture2D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      var image = texture.image;

      if (image === undefined) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
      } else if (image.complete === false) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }

    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
  }

  function setTextureCube(texture, slot) {
    var textureProperties = properties.get(texture);

    if (texture.image.length === 6) {
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        if (!textureProperties.__image__webglTextureCube) {
          texture.addEventListener('dispose', onTextureDispose);
          textureProperties.__image__webglTextureCube = _gl.createTexture();
          info.memory.textures++;
        }

        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);

        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

        var isCompressed = texture && texture.isCompressedTexture;
        var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        var cubeImage = [];

        for (var i = 0; i < 6; i++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
          } else {
            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
          }
        }

        var image = cubeImage[0],
            isPowerOfTwoImage = isPowerOfTwo(image),
            glFormat = utils.convert(texture.format),
            glType = utils.convert(texture.type),
            glInternalFormat = getInternalFormat(glFormat, glType);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);

        for (var i = 0; i < 6; i++) {
          if (!isCompressed) {
            if (isDataTexture) {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            }
          } else {
            var mipmap,
                mipmaps = cubeImage[i].mipmaps;

            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
              mipmap = mipmaps[j];

              if (texture.format !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_29" /* RGBAFormat */] && texture.format !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_52" /* RGBFormat */]) {
                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }

        if (!isCompressed) {
          textureProperties.__maxMipLevel = 0;
        } else {
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        }

        if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
          // We assume images for cube map have the same size.
          generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
        }

        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
      } else {
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
      }
    }
  }

  function setTextureCubeDynamic(texture, slot) {
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
  }

  function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
    var extension;

    if (isPowerOfTwoImage) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, utils.convert(texture.wrapS));

      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, utils.convert(texture.wrapT));

      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, utils.convert(texture.magFilter));

      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, utils.convert(texture.minFilter));
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);

      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

      if (texture.wrapS !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["k" /* ClampToEdgeWrapping */] || texture.wrapT !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["k" /* ClampToEdgeWrapping */]) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
      }

      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));

      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));

      if (texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_10" /* NearestFilter */] && texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["T" /* LinearFilter */]) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
      }
    }

    extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension) {
      if (texture.type === __WEBPACK_IMPORTED_MODULE_0__constants_js__["E" /* FloatType */] && extensions.get('OES_texture_float_linear') === null) return;
      if (texture.type === __WEBPACK_IMPORTED_MODULE_0__constants_js__["L" /* HalfFloatType */] && (capabilities.isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }

  function uploadTexture(textureProperties, texture, slot) {
    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture.addEventListener('dispose', onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }

    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);

    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

    var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);

    if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
      image = makePowerOfTwo(image);
    }

    var isPowerOfTwoImage = isPowerOfTwo(image),
        glFormat = utils.convert(texture.format),
        glType = utils.convert(texture.type),
        glInternalFormat = getInternalFormat(glFormat, glType);
    setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
    var mipmap,
        mipmaps = texture.mipmaps;

    if (texture.isDepthTexture) {
      // populate depth texture with dummy data
      glInternalFormat = _gl.DEPTH_COMPONENT;

      if (texture.type === __WEBPACK_IMPORTED_MODULE_0__constants_js__["E" /* FloatType */]) {
        if (!capabilities.isWebGL2) throw new Error('Float Depth Texture only supported in WebGL2.0');
        glInternalFormat = _gl.DEPTH_COMPONENT32F;
      } else if (capabilities.isWebGL2) {
        // WebGL 2.0 requires signed internalformat for glTexImage2D
        glInternalFormat = _gl.DEPTH_COMPONENT16;
      }

      if (texture.format === __WEBPACK_IMPORTED_MODULE_0__constants_js__["u" /* DepthFormat */] && glInternalFormat === _gl.DEPTH_COMPONENT) {
        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        if (texture.type !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_82" /* UnsignedShortType */] && texture.type !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_78" /* UnsignedIntType */]) {
          console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
          texture.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["_82" /* UnsignedShortType */];
          glType = utils.convert(texture.type);
        }
      } // Depth stencil textures need the DEPTH_STENCIL internal format
      // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)


      if (texture.format === __WEBPACK_IMPORTED_MODULE_0__constants_js__["v" /* DepthStencilFormat */]) {
        glInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

        if (texture.type !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_77" /* UnsignedInt248Type */]) {
          console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
          texture.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["_77" /* UnsignedInt248Type */];
          glType = utils.convert(texture.type);
        }
      }

      state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && isPowerOfTwoImage) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (var i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];

        if (texture.format !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_29" /* RGBAFormat */] && texture.format !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_52" /* RGBFormat */]) {
          if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
            state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
          }
        } else {
          state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }

      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      // regular Texture (image, video, canvas)
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && isPowerOfTwoImage) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }

    if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
      generateMipmap(_gl.TEXTURE_2D, texture, image.width, image.height);
    }

    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  } // Render targets
  // Setup storage for target texture and bind it to correct framebuffer


  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    var glFormat = utils.convert(renderTarget.texture.format);
    var glType = utils.convert(renderTarget.texture.type);
    var glInternalFormat = getInternalFormat(glFormat, glType);
    state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);

    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
  } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


  function setupRenderBufferStorage(renderbuffer, renderTarget) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);

      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);

      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      // FIXME: We don't support !depth !stencil
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
    }

    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  } // Setup resources for a Depth Texture for a FBO (needs an extension)


  function setupDepthTexture(framebuffer, renderTarget) {
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    } // upload an empty depth texture with framebuffer size


    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }

    setTexture2D(renderTarget.depthTexture, 0);

    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

    if (renderTarget.depthTexture.format === __WEBPACK_IMPORTED_MODULE_0__constants_js__["u" /* DepthFormat */]) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === __WEBPACK_IMPORTED_MODULE_0__constants_js__["v" /* DepthStencilFormat */]) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
    } else {
      throw new Error('Unknown depthTexture format');
    }
  } // Setup GL resources for a non-texture depth buffer


  function setupDepthRenderbuffer(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var isCube = renderTarget.isWebGLRenderTargetCube === true;

    if (renderTarget.depthTexture) {
      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];

        for (var i = 0; i < 6; i++) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);

          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
        }
      } else {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);

        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
      }
    }

    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
  } // Set up GL resources for the render target


  function setupRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    var isCube = renderTarget.isWebGLRenderTargetCube === true;
    var isTargetPowerOfTwo = isPowerOfTwo(renderTarget); // Setup framebuffer

    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];

      for (var i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
    } // Setup color buffer


    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);

      for (var i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
      }

      if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
    } else {
      state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);

      if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
        generateMipmap(_gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(_gl.TEXTURE_2D, null);
    } // Setup depth and stencil buffers


    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }

  function updateRenderTargetMipmap(renderTarget) {
    var texture = renderTarget.texture;
    var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);

    if (textureNeedsGenerateMipmaps(texture, isTargetPowerOfTwo)) {
      var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;

      var webglTexture = properties.get(texture).__webglTexture;

      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }

  function updateVideoTexture(texture) {
    var id = texture.id;
    var frame = info.render.frame; // Check the last frame we updated the VideoTexture

    if (_videoTextures[id] !== frame) {
      _videoTextures[id] = frame;
      texture.update();
    }
  }

  this.setTexture2D = setTexture2D;
  this.setTextureCube = setTextureCube;
  this.setTextureCubeDynamic = setTextureCubeDynamic;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
}



/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLUtils; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/**
 * @author thespite / http://www.twitter.com/thespite
 */


function WebGLUtils(gl, extensions, capabilities) {
  function convert(p) {
    var extension;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_60" /* RepeatWrapping */]) return gl.REPEAT;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["k" /* ClampToEdgeWrapping */]) return gl.CLAMP_TO_EDGE;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_6" /* MirroredRepeatWrapping */]) return gl.MIRRORED_REPEAT;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_10" /* NearestFilter */]) return gl.NEAREST;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_12" /* NearestMipMapNearestFilter */]) return gl.NEAREST_MIPMAP_NEAREST;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_11" /* NearestMipMapLinearFilter */]) return gl.NEAREST_MIPMAP_LINEAR;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["T" /* LinearFilter */]) return gl.LINEAR;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["V" /* LinearMipMapNearestFilter */]) return gl.LINEAR_MIPMAP_NEAREST;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["U" /* LinearMipMapLinearFilter */]) return gl.LINEAR_MIPMAP_LINEAR;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_76" /* UnsignedByteType */]) return gl.UNSIGNED_BYTE;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_79" /* UnsignedShort4444Type */]) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_80" /* UnsignedShort5551Type */]) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_81" /* UnsignedShort565Type */]) return gl.UNSIGNED_SHORT_5_6_5;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["i" /* ByteType */]) return gl.BYTE;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_62" /* ShortType */]) return gl.SHORT;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_82" /* UnsignedShortType */]) return gl.UNSIGNED_SHORT;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["M" /* IntType */]) return gl.INT;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_78" /* UnsignedIntType */]) return gl.UNSIGNED_INT;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["E" /* FloatType */]) return gl.FLOAT;

    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["L" /* HalfFloatType */]) {
      if (capabilities.isWebGL2) return gl.HALF_FLOAT;
      extension = extensions.get('OES_texture_half_float');
      if (extension !== null) return extension.HALF_FLOAT_OES;
    }

    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["d" /* AlphaFormat */]) return gl.ALPHA;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_52" /* RGBFormat */]) return gl.RGB;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_29" /* RGBAFormat */]) return gl.RGBA;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_2" /* LuminanceFormat */]) return gl.LUMINANCE;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_1" /* LuminanceAlphaFormat */]) return gl.LUMINANCE_ALPHA;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["u" /* DepthFormat */]) return gl.DEPTH_COMPONENT;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["v" /* DepthStencilFormat */]) return gl.DEPTH_STENCIL;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* AddEquation */]) return gl.FUNC_ADD;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_68" /* SubtractEquation */]) return gl.FUNC_SUBTRACT;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_61" /* ReverseSubtractEquation */]) return gl.FUNC_REVERSE_SUBTRACT;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_86" /* ZeroFactor */]) return gl.ZERO;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_20" /* OneFactor */]) return gl.ONE;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_67" /* SrcColorFactor */]) return gl.SRC_COLOR;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_24" /* OneMinusSrcColorFactor */]) return gl.ONE_MINUS_SRC_COLOR;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_65" /* SrcAlphaFactor */]) return gl.SRC_ALPHA;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_23" /* OneMinusSrcAlphaFactor */]) return gl.ONE_MINUS_SRC_ALPHA;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["x" /* DstAlphaFactor */]) return gl.DST_ALPHA;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_21" /* OneMinusDstAlphaFactor */]) return gl.ONE_MINUS_DST_ALPHA;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["y" /* DstColorFactor */]) return gl.DST_COLOR;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_22" /* OneMinusDstColorFactor */]) return gl.ONE_MINUS_DST_COLOR;
    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_66" /* SrcAlphaSaturateFactor */]) return gl.SRC_ALPHA_SATURATE;

    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_58" /* RGB_S3TC_DXT1_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_46" /* RGBA_S3TC_DXT1_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_47" /* RGBA_S3TC_DXT3_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_48" /* RGBA_S3TC_DXT5_Format */]) {
      extension = extensions.get('WEBGL_compressed_texture_s3tc');

      if (extension !== null) {
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_58" /* RGB_S3TC_DXT1_Format */]) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_46" /* RGBA_S3TC_DXT1_Format */]) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_47" /* RGBA_S3TC_DXT3_Format */]) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_48" /* RGBA_S3TC_DXT5_Format */]) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
    }

    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_57" /* RGB_PVRTC_4BPPV1_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_56" /* RGB_PVRTC_2BPPV1_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_45" /* RGBA_PVRTC_4BPPV1_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_44" /* RGBA_PVRTC_2BPPV1_Format */]) {
      extension = extensions.get('WEBGL_compressed_texture_pvrtc');

      if (extension !== null) {
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_57" /* RGB_PVRTC_4BPPV1_Format */]) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_56" /* RGB_PVRTC_2BPPV1_Format */]) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_45" /* RGBA_PVRTC_4BPPV1_Format */]) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_44" /* RGBA_PVRTC_2BPPV1_Format */]) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
    }

    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_55" /* RGB_ETC1_Format */]) {
      extension = extensions.get('WEBGL_compressed_texture_etc1');
      if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
    }

    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_36" /* RGBA_ASTC_4x4_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_37" /* RGBA_ASTC_5x4_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_38" /* RGBA_ASTC_5x5_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_39" /* RGBA_ASTC_6x5_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_40" /* RGBA_ASTC_6x6_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_41" /* RGBA_ASTC_8x5_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_42" /* RGBA_ASTC_8x6_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_43" /* RGBA_ASTC_8x8_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_31" /* RGBA_ASTC_10x5_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_32" /* RGBA_ASTC_10x6_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_33" /* RGBA_ASTC_10x8_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_30" /* RGBA_ASTC_10x10_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_34" /* RGBA_ASTC_12x10_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_35" /* RGBA_ASTC_12x12_Format */]) {
      extension = extensions.get('WEBGL_compressed_texture_astc');

      if (extension !== null) {
        return p;
      }
    }

    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_5" /* MinEquation */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_4" /* MaxEquation */]) {
      if (capabilities.isWebGL2) {
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_5" /* MinEquation */]) return gl.MIN;
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_4" /* MaxEquation */]) return gl.MAX;
      }

      extension = extensions.get('EXT_blend_minmax');

      if (extension !== null) {
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_5" /* MinEquation */]) return extension.MIN_EXT;
        if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_4" /* MaxEquation */]) return extension.MAX_EXT;
      }
    }

    if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_77" /* UnsignedInt248Type */]) {
      if (capabilities.isWebGL2) return gl.UNSIGNED_INT_24_8;
      extension = extensions.get('WEBGL_depth_texture');
      if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
    }

    return 0;
  }

  return {
    convert: convert
  };
}



/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebVRManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__objects_Group_js__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector4_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Quaternion_js__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__cameras_ArrayCamera_js__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__cameras_PerspectiveCamera_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__webgl_WebGLAnimation_js__ = __webpack_require__(33);
/**
 * @author mrdoob / http://mrdoob.com/
 */









function WebVRManager(renderer) {
  var scope = this;
  var device = null;
  var frameData = null;
  var poseTarget = null;
  var controllers = [];
  var standingMatrix = new __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__["a" /* Matrix4 */]();
  var standingMatrixInverse = new __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__["a" /* Matrix4 */]();
  var frameOfReferenceType = 'stage';

  if (typeof window !== 'undefined' && 'VRFrameData' in window) {
    frameData = new window.VRFrameData();
    window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);
  }

  var matrixWorldInverse = new __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__["a" /* Matrix4 */]();
  var tempQuaternion = new __WEBPACK_IMPORTED_MODULE_4__math_Quaternion_js__["a" /* Quaternion */]();
  var tempPosition = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]();
  var cameraL = new __WEBPACK_IMPORTED_MODULE_6__cameras_PerspectiveCamera_js__["a" /* PerspectiveCamera */]();
  cameraL.bounds = new __WEBPACK_IMPORTED_MODULE_3__math_Vector4_js__["a" /* Vector4 */](0.0, 0.0, 0.5, 1.0);
  cameraL.layers.enable(1);
  var cameraR = new __WEBPACK_IMPORTED_MODULE_6__cameras_PerspectiveCamera_js__["a" /* PerspectiveCamera */]();
  cameraR.bounds = new __WEBPACK_IMPORTED_MODULE_3__math_Vector4_js__["a" /* Vector4 */](0.5, 0.0, 0.5, 1.0);
  cameraR.layers.enable(2);
  var cameraVR = new __WEBPACK_IMPORTED_MODULE_5__cameras_ArrayCamera_js__["a" /* ArrayCamera */]([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2); //

  function isPresenting() {
    return device !== null && device.isPresenting === true;
  }

  var currentSize, currentPixelRatio;

  function onVRDisplayPresentChange() {
    if (isPresenting()) {
      var eyeParameters = device.getEyeParameters('left');
      var renderWidth = eyeParameters.renderWidth;
      var renderHeight = eyeParameters.renderHeight;
      currentPixelRatio = renderer.getPixelRatio();
      currentSize = renderer.getSize();
      renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);
      animation.start();
    } else {
      if (scope.enabled) {
        renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
      }

      animation.stop();
    }
  } //


  var triggers = [];

  function findGamepad(id) {
    var gamepads = navigator.getGamepads && navigator.getGamepads();

    for (var i = 0, j = 0, l = gamepads.length; i < l; i++) {
      var gamepad = gamepads[i];

      if (gamepad && (gamepad.id === 'Daydream Controller' || gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' || gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith('Oculus Touch') || gamepad.id.startsWith('Spatial Controller'))) {
        if (j === id) return gamepad;
        j++;
      }
    }
  }

  function updateControllers() {
    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      var gamepad = findGamepad(i);

      if (gamepad !== undefined && gamepad.pose !== undefined) {
        if (gamepad.pose === null) return; //  Pose

        var pose = gamepad.pose;
        if (pose.hasPosition === false) controller.position.set(0.2, -0.6, -0.05);
        if (pose.position !== null) controller.position.fromArray(pose.position);
        if (pose.orientation !== null) controller.quaternion.fromArray(pose.orientation);
        controller.matrix.compose(controller.position, controller.quaternion, controller.scale);
        controller.matrix.premultiply(standingMatrix);
        controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
        controller.matrixWorldNeedsUpdate = true;
        controller.visible = true; //  Trigger

        var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

        if (triggers[i] !== gamepad.buttons[buttonId].pressed) {
          triggers[i] = gamepad.buttons[buttonId].pressed;

          if (triggers[i] === true) {
            controller.dispatchEvent({
              type: 'selectstart'
            });
          } else {
            controller.dispatchEvent({
              type: 'selectend'
            });
            controller.dispatchEvent({
              type: 'select'
            });
          }
        }
      } else {
        controller.visible = false;
      }
    }
  } //


  this.enabled = false;

  this.getController = function (id) {
    var controller = controllers[id];

    if (controller === undefined) {
      controller = new __WEBPACK_IMPORTED_MODULE_0__objects_Group_js__["a" /* Group */]();
      controller.matrixAutoUpdate = false;
      controller.visible = false;
      controllers[id] = controller;
    }

    return controller;
  };

  this.getDevice = function () {
    return device;
  };

  this.setDevice = function (value) {
    if (value !== undefined) device = value;
    animation.setContext(value);
  };

  this.setFrameOfReferenceType = function (value) {
    frameOfReferenceType = value;
  };

  this.setPoseTarget = function (object) {
    if (object !== undefined) poseTarget = object;
  };

  this.getCamera = function (camera) {
    var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;

    if (device === null) {
      camera.position.set(0, userHeight, 0);
      return camera;
    }

    device.depthNear = camera.near;
    device.depthFar = camera.far;
    device.getFrameData(frameData); //

    if (frameOfReferenceType === 'stage') {
      var stageParameters = device.stageParameters;

      if (stageParameters) {
        standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
      } else {
        standingMatrix.makeTranslation(0, userHeight, 0);
      }
    }

    var pose = frameData.pose;
    var poseObject = poseTarget !== null ? poseTarget : camera; // We want to manipulate poseObject by its position and quaternion components since users may rely on them.

    poseObject.matrix.copy(standingMatrix);
    poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);

    if (pose.orientation !== null) {
      tempQuaternion.fromArray(pose.orientation);
      poseObject.quaternion.multiply(tempQuaternion);
    }

    if (pose.position !== null) {
      tempQuaternion.setFromRotationMatrix(standingMatrix);
      tempPosition.fromArray(pose.position);
      tempPosition.applyQuaternion(tempQuaternion);
      poseObject.position.add(tempPosition);
    }

    poseObject.updateMatrixWorld();
    if (device.isPresenting === false) return camera; //

    cameraL.near = camera.near;
    cameraR.near = camera.near;
    cameraL.far = camera.far;
    cameraR.far = camera.far;
    cameraVR.matrixWorld.copy(camera.matrixWorld);
    cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse);
    cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
    cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix); // TODO (mrdoob) Double check this code

    standingMatrixInverse.getInverse(standingMatrix);

    if (frameOfReferenceType === 'stage') {
      cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
      cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
    }

    var parent = poseObject.parent;

    if (parent !== null) {
      matrixWorldInverse.getInverse(parent.matrixWorld);
      cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
      cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
    } // envMap and Mirror needs camera.matrixWorld


    cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
    cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
    cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
    cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix); // HACK (mrdoob)
    // https://github.com/w3c/webvr/issues/203

    cameraVR.projectionMatrix.copy(cameraL.projectionMatrix); //

    var layers = device.getLayers();

    if (layers.length) {
      var layer = layers[0];

      if (layer.leftBounds !== null && layer.leftBounds.length === 4) {
        cameraL.bounds.fromArray(layer.leftBounds);
      }

      if (layer.rightBounds !== null && layer.rightBounds.length === 4) {
        cameraR.bounds.fromArray(layer.rightBounds);
      }
    }

    updateControllers();
    return cameraVR;
  };

  this.getStandingMatrix = function () {
    return standingMatrix;
  };

  this.isPresenting = isPresenting; // Animation Loop

  var animation = new __WEBPACK_IMPORTED_MODULE_7__webgl_WebGLAnimation_js__["a" /* WebGLAnimation */]();

  this.setAnimationLoop = function (callback) {
    animation.setAnimationLoop(callback);
  };

  this.submitFrame = function () {
    if (isPresenting()) device.submitFrame();
  };

  this.dispose = function () {
    if (typeof window !== 'undefined') {
      window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);
    }
  };
}



/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebXRManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__objects_Group_js__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cameras_ArrayCamera_js__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__cameras_PerspectiveCamera_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__webgl_WebGLAnimation_js__ = __webpack_require__(33);
/**
 * @author mrdoob / http://mrdoob.com/
 */






function WebXRManager(renderer) {
  var gl = renderer.context;
  var device = null;
  var session = null;
  var frameOfReference = null;
  var frameOfReferenceType = 'stage';
  var pose = null;
  var controllers = [];
  var inputSources = [];

  function isPresenting() {
    return session !== null && frameOfReference !== null;
  } //


  var cameraL = new __WEBPACK_IMPORTED_MODULE_3__cameras_PerspectiveCamera_js__["a" /* PerspectiveCamera */]();
  cameraL.layers.enable(1);
  cameraL.viewport = new __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__["a" /* Vector4 */]();
  var cameraR = new __WEBPACK_IMPORTED_MODULE_3__cameras_PerspectiveCamera_js__["a" /* PerspectiveCamera */]();
  cameraR.layers.enable(2);
  cameraR.viewport = new __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__["a" /* Vector4 */]();
  var cameraVR = new __WEBPACK_IMPORTED_MODULE_2__cameras_ArrayCamera_js__["a" /* ArrayCamera */]([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2); //

  this.enabled = false;

  this.getController = function (id) {
    var controller = controllers[id];

    if (controller === undefined) {
      controller = new __WEBPACK_IMPORTED_MODULE_0__objects_Group_js__["a" /* Group */]();
      controller.matrixAutoUpdate = false;
      controller.visible = false;
      controllers[id] = controller;
    }

    return controller;
  };

  this.getDevice = function () {
    return device;
  };

  this.setDevice = function (value) {
    if (value !== undefined) device = value;
    if (value instanceof XRDevice) gl.setCompatibleXRDevice(value);
  }; //


  function onSessionEvent(event) {
    var controller = controllers[inputSources.indexOf(event.inputSource)];
    if (controller) controller.dispatchEvent({
      type: event.type
    });
  }

  function onSessionEnd() {
    renderer.setFramebuffer(null);
    animation.stop();
  }

  this.setFrameOfReferenceType = function (value) {
    frameOfReferenceType = value;
  };

  this.setSession = function (value) {
    session = value;

    if (session !== null) {
      session.addEventListener('select', onSessionEvent);
      session.addEventListener('selectstart', onSessionEvent);
      session.addEventListener('selectend', onSessionEvent);
      session.addEventListener('end', onSessionEnd);
      session.baseLayer = new XRWebGLLayer(session, gl);
      session.requestFrameOfReference(frameOfReferenceType).then(function (value) {
        frameOfReference = value;
        renderer.setFramebuffer(session.baseLayer.framebuffer);
        animation.setContext(session);
        animation.start();
      }); //

      inputSources = session.getInputSources();
      session.addEventListener('inputsourceschange', function () {
        inputSources = session.getInputSources();
        console.log(inputSources);
      });
    }
  };

  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }

    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  }

  this.getCamera = function (camera) {
    if (isPresenting()) {
      var parent = camera.parent;
      var cameras = cameraVR.cameras; // apply camera.parent to cameraVR

      updateCamera(cameraVR, parent);

      for (var i = 0; i < cameras.length; i++) {
        updateCamera(cameras[i], parent);
      } // update camera and its children


      camera.matrixWorld.copy(cameraVR.matrixWorld);
      var children = camera.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(true);
      }

      return cameraVR;
    }

    return camera;
  };

  this.isPresenting = isPresenting; // Animation Loop

  var onAnimationFrameCallback = null;

  function onAnimationFrame(time, frame) {
    pose = frame.getDevicePose(frameOfReference);

    if (pose !== null) {
      var layer = session.baseLayer;
      var views = frame.views;

      for (var i = 0; i < views.length; i++) {
        var view = views[i];
        var viewport = layer.getViewport(view);
        var viewMatrix = pose.getViewMatrix(view);
        var camera = cameraVR.cameras[i];
        camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

        if (i === 0) {
          cameraVR.matrix.copy(camera.matrix); // HACK (mrdoob)
          // https://github.com/w3c/webvr/issues/203

          cameraVR.projectionMatrix.copy(camera.projectionMatrix);
        }
      }
    } //


    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      var inputSource = inputSources[i];

      if (inputSource) {
        var inputPose = frame.getInputPose(inputSource, frameOfReference);

        if (inputPose !== null) {
          if ('targetRay' in inputPose) {
            controller.matrix.elements = inputPose.targetRay.transformMatrix;
          } else if ('pointerMatrix' in inputPose) {
            // DEPRECATED
            controller.matrix.elements = inputPose.pointerMatrix;
          }

          controller.matrix.decompose(controller.position, controller.rotation, controller.scale);
          controller.visible = true;
          continue;
        }
      }

      controller.visible = false;
    }

    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }

  var animation = new __WEBPACK_IMPORTED_MODULE_4__webgl_WebGLAnimation_js__["a" /* WebGLAnimation */]();
  animation.setAnimationLoop(onAnimationFrame);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
  };

  this.dispose = function () {}; // DEPRECATED


  this.getStandingMatrix = function () {
    console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.');
    return new THREE.Matrix4();
  };

  this.submitFrame = function () {};
}



/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CanvasTexture; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Texture_js__ = __webpack_require__(10);
/**
 * @author mrdoob / http://mrdoob.com/
 */


function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  __WEBPACK_IMPORTED_MODULE_0__Texture_js__["a" /* Texture */].call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.needsUpdate = true;
}

CanvasTexture.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__Texture_js__["a" /* Texture */].prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;


/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Clock; });
/**
 * @author alteredq / http://alteredqualia.com/
 */
function Clock(autoStart) {
  this.autoStart = autoStart !== undefined ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
}

Object.assign(Clock.prototype, {
  start: function () {
    this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  },
  stop: function () {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  },
  getElapsedTime: function () {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function () {
    var diff = 0;

    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }

    if (this.running) {
      var newTime = (typeof performance === 'undefined' ? Date : performance).now();
      diff = (newTime - this.oldTime) / 1000;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }

    return diff;
  }
});


/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Points; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Sphere_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Ray_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__materials_PointsMaterial_js__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_BufferGeometry_js__ = __webpack_require__(14);







/**
 * @author alteredq / http://alteredqualia.com/
 */

function Points(geometry, material) {
  __WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__["a" /* Object3D */].call(this);
  this.type = 'Points';
  this.geometry = geometry !== undefined ? geometry : new __WEBPACK_IMPORTED_MODULE_6__core_BufferGeometry_js__["a" /* BufferGeometry */]();
  this.material = material !== undefined ? material : new __WEBPACK_IMPORTED_MODULE_5__materials_PointsMaterial_js__["a" /* PointsMaterial */]({
    color: Math.random() * 0xffffff
  });
}

Points.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__["a" /* Object3D */].prototype), {
  constructor: Points,
  isPoints: true,
  raycast: function () {
    var inverseMatrix = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__["a" /* Matrix4 */]();
    var ray = new __WEBPACK_IMPORTED_MODULE_1__math_Ray_js__["a" /* Ray */]();
    var sphere = new __WEBPACK_IMPORTED_MODULE_0__math_Sphere_js__["a" /* Sphere */]();
    return function raycast(raycaster, intersects) {
      var object = this;
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;
      var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      sphere.radius += threshold;
      if (raycaster.ray.intersectsSphere(sphere) === false) return; //

      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;
      var position = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();
      var intersectPoint = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();

      function testPoint(point, index) {
        var rayPointDistanceSq = ray.distanceSqToPoint(point);

        if (rayPointDistanceSq < localThresholdSq) {
          ray.closestPointToPoint(point, intersectPoint);
          intersectPoint.applyMatrix4(matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far) return;
          intersects.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint.clone(),
            index: index,
            face: null,
            object: object
          });
        }
      }

      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;

        if (index !== null) {
          var indices = index.array;

          for (var i = 0, il = indices.length; i < il; i++) {
            var a = indices[i];
            position.fromArray(positions, a * 3);
            testPoint(position, a);
          }
        } else {
          for (var i = 0, l = positions.length / 3; i < l; i++) {
            position.fromArray(positions, i * 3);
            testPoint(position, i);
          }
        }
      } else {
        var vertices = geometry.vertices;

        for (var i = 0, l = vertices.length; i < l; i++) {
          testPoint(vertices[i], i);
        }
      }
    };
  }(),
  clone: function () {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});


/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineSegments; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Line_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__ = __webpack_require__(15);



/**
 * @author mrdoob / http://mrdoob.com/
 */

function LineSegments(geometry, material) {
  __WEBPACK_IMPORTED_MODULE_0__Line_js__["a" /* Line */].call(this, geometry, material);
  this.type = 'LineSegments';
}

LineSegments.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__Line_js__["a" /* Line */].prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function () {
    var start = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
    var end = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
    return function computeLineDistances() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        // we assume non-indexed geometry
        if (geometry.index === null) {
          var positionAttribute = geometry.attributes.position;
          var lineDistances = [];

          for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
            start.fromBufferAttribute(positionAttribute, i);
            end.fromBufferAttribute(positionAttribute, i + 1);
            lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
            lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
          }

          geometry.addAttribute('lineDistance', new __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](lineDistances, 1));
        } else {
          console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
      } else if (geometry.isGeometry) {
        var vertices = geometry.vertices;
        var lineDistances = geometry.lineDistances;

        for (var i = 0, l = vertices.length; i < l; i += 2) {
          start.copy(vertices[i]);
          end.copy(vertices[i + 1]);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
        }
      }

      return this;
    };
  }()
});


/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DirectionalLight; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Light_js__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__DirectionalLightShadow_js__ = __webpack_require__(237);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__ = __webpack_require__(5);



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function DirectionalLight(color, intensity) {
  __WEBPACK_IMPORTED_MODULE_0__Light_js__["a" /* Light */].call(this, color, intensity);
  this.type = 'DirectionalLight';
  this.position.copy(__WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].DefaultUp);
  this.updateMatrix();
  this.target = new __WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */]();
  this.shadow = new __WEBPACK_IMPORTED_MODULE_1__DirectionalLightShadow_js__["a" /* DirectionalLightShadow */]();
}

DirectionalLight.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__Light_js__["a" /* Light */].prototype), {
  constructor: DirectionalLight,
  isDirectionalLight: true,
  copy: function (source) {
    __WEBPACK_IMPORTED_MODULE_0__Light_js__["a" /* Light */].prototype.copy.call(this, source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});


/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DirectionalLightShadow; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LightShadow_js__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cameras_OrthographicCamera_js__ = __webpack_require__(45);


/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectionalLightShadow() {
  __WEBPACK_IMPORTED_MODULE_0__LightShadow_js__["a" /* LightShadow */].call(this, new __WEBPACK_IMPORTED_MODULE_1__cameras_OrthographicCamera_js__["a" /* OrthographicCamera */](-5, 5, 5, -5, 0.5, 500));
}

DirectionalLightShadow.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__LightShadow_js__["a" /* LightShadow */].prototype), {
  constructor: DirectionalLightShadow
});


/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LightShadow; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Matrix4_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__ = __webpack_require__(8);


/**
 * @author mrdoob / http://mrdoob.com/
 */

function LightShadow(camera) {
  this.camera = camera;
  this.bias = 0;
  this.radius = 1;
  this.mapSize = new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */](512, 512);
  this.map = null;
  this.matrix = new __WEBPACK_IMPORTED_MODULE_0__math_Matrix4_js__["a" /* Matrix4 */]();
}

Object.assign(LightShadow.prototype, {
  copy: function (source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    var object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
});


/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AmbientLight; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Light_js__ = __webpack_require__(59);

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AmbientLight(color, intensity) {
  __WEBPACK_IMPORTED_MODULE_0__Light_js__["a" /* Light */].call(this, color, intensity);
  this.type = 'AmbientLight';
  this.castShadow = undefined;
}

AmbientLight.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__Light_js__["a" /* Light */].prototype), {
  constructor: AmbientLight,
  isAmbientLight: true
});


/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Raycaster; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Ray_js__ = __webpack_require__(25);

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster(origin, direction, near, far) {
  this.ray = new __WEBPACK_IMPORTED_MODULE_0__math_Ray_js__["a" /* Ray */](origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

  this.near = near || 0;
  this.far = far || Infinity;
  this.params = {
    Mesh: {},
    Line: {},
    LOD: {},
    Points: {
      threshold: 1
    },
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function () {
        console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
        return this.Points;
      }
    }
  });
}

function ascSort(a, b) {
  return a.distance - b.distance;
}

function intersectObject(object, raycaster, intersects, recursive) {
  if (object.visible === false) return;
  object.raycast(raycaster, intersects);

  if (recursive === true) {
    var children = object.children;

    for (var i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects, true);
    }
  }
}

Object.assign(Raycaster.prototype, {
  linePrecision: 1,
  set: function (origin, direction) {
    // direction is assumed to be normalized (for accurate distance calculations)
    this.ray.set(origin, direction);
  },
  setFromCamera: function (coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
    } else {
      console.error('THREE.Raycaster: Unsupported camera type.');
    }
  },
  intersectObject: function (object, recursive, optionalTarget) {
    var intersects = optionalTarget || [];
    intersectObject(object, this, intersects, recursive);
    intersects.sort(ascSort);
    return intersects;
  },
  intersectObjects: function (objects, recursive, optionalTarget) {
    var intersects = optionalTarget || [];

    if (Array.isArray(objects) === false) {
      console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
      return intersects;
    }

    for (var i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects, recursive);
    }

    intersects.sort(ascSort);
    return intersects;
  }
});


/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineLoop; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Line_js__ = __webpack_require__(34);

/**
 * @author mgreter / http://github.com/mgreter
 */

function LineLoop(geometry, material) {
  __WEBPACK_IMPORTED_MODULE_0__Line_js__["a" /* Line */].call(this, geometry, material);
  this.type = 'LineLoop';
}

LineLoop.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__Line_js__["a" /* Line */].prototype), {
  constructor: LineLoop,
  isLineLoop: true
});


/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TextureLoader; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ImageLoader_js__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__textures_Texture_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__LoadingManager_js__ = __webpack_require__(60);
/**
 * @author mrdoob / http://mrdoob.com/
 */





function TextureLoader(manager) {
  this.manager = manager !== undefined ? manager : __WEBPACK_IMPORTED_MODULE_3__LoadingManager_js__["a" /* DefaultLoadingManager */];
}

Object.assign(TextureLoader.prototype, {
  crossOrigin: 'anonymous',
  load: function (url, onLoad, onProgress, onError) {
    var texture = new __WEBPACK_IMPORTED_MODULE_2__textures_Texture_js__["a" /* Texture */]();
    var loader = new __WEBPACK_IMPORTED_MODULE_1__ImageLoader_js__["a" /* ImageLoader */](this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function (image) {
      texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

      var isJPEG = url.search(/\.jpe?g$/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? __WEBPACK_IMPORTED_MODULE_0__constants_js__["_52" /* RGBFormat */] : __WEBPACK_IMPORTED_MODULE_0__constants_js__["_29" /* RGBAFormat */];
      texture.needsUpdate = true;

      if (onLoad !== undefined) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});


/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ImageLoader; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Cache_js__ = __webpack_require__(244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__LoadingManager_js__ = __webpack_require__(60);
/**
 * @author mrdoob / http://mrdoob.com/
 */



function ImageLoader(manager) {
  this.manager = manager !== undefined ? manager : __WEBPACK_IMPORTED_MODULE_1__LoadingManager_js__["a" /* DefaultLoadingManager */];
}

Object.assign(ImageLoader.prototype, {
  crossOrigin: 'anonymous',
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = __WEBPACK_IMPORTED_MODULE_0__Cache_js__["a" /* Cache */].get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

    function onImageLoad() {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      __WEBPACK_IMPORTED_MODULE_0__Cache_js__["a" /* Cache */].add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }

    function onImageError(event) {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      if (onError) onError(event);
      scope.manager.itemEnd(url);
      scope.manager.itemError(url);
    }

    image.addEventListener('load', onImageLoad, false);
    image.addEventListener('error', onImageError, false);

    if (url.substr(0, 5) !== 'data:') {
      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
    }

    scope.manager.itemStart(url);
    image.src = url;
    return image;
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function (value) {
    this.path = value;
    return this;
  }
});


/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Cache; });
/**
 * @author mrdoob / http://mrdoob.com/
 */
var Cache = {
  enabled: false,
  files: {},
  add: function (key, file) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[key] = file;
  },
  get: function (key) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[key];
  },
  remove: function (key) {
    delete this.files[key];
  },
  clear: function () {
    this.files = {};
  }
};


/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineDashedMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LineBasicMaterial_js__ = __webpack_require__(58);
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */


function LineDashedMaterial(parameters) {
  __WEBPACK_IMPORTED_MODULE_0__LineBasicMaterial_js__["a" /* LineBasicMaterial */].call(this);
  this.type = 'LineDashedMaterial';
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.setValues(parameters);
}

LineDashedMaterial.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__LineBasicMaterial_js__["a" /* LineBasicMaterial */].prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function (source) {
  __WEBPACK_IMPORTED_MODULE_0__LineBasicMaterial_js__["a" /* LineBasicMaterial */].prototype.copy.call(this, source);
  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;
  return this;
};



/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VideoTexture; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Texture_js__ = __webpack_require__(10);
/**
 * @author mrdoob / http://mrdoob.com/
 */


function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  __WEBPACK_IMPORTED_MODULE_0__Texture_js__["a" /* Texture */].call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.generateMipmaps = false;
}

VideoTexture.prototype = Object.assign(Object.create(__WEBPACK_IMPORTED_MODULE_0__Texture_js__["a" /* Texture */].prototype), {
  constructor: VideoTexture,
  isVideoTexture: true,
  update: function () {
    var video = this.image;

    if (video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
});


/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__three__ = __webpack_require__(2);

/* harmony default export */ __webpack_exports__["a"] = ((function () {
  var scene = new __WEBPACK_IMPORTED_MODULE_0__three__["Scene"]();
  return scene;
})());

/***/ }),
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Camera; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__three__ = __webpack_require__(2);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var Camera =
/*#__PURE__*/
function () {
  function Camera(container) {
    _classCallCheck(this, Camera);

    this.container = container;
    var camera = new __WEBPACK_IMPORTED_MODULE_0__three__["PerspectiveCamera"](45, 1, 1, 2000000);
    this.camera = camera;
    this.updateSize();
    window.addEventListener('resize', this.updateSize.bind(this));
  }

  _createClass(Camera, [{
    key: "updateSize",
    value: function updateSize() {
      var container = this.container;
      this.camera.aspect = container.clientWidth / container.clientHeight;
      this.camera.updateProjectionMatrix();
    }
  }]);

  return Camera;
}();



/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Renderer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__three__ = __webpack_require__(2);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var Renderer =
/*#__PURE__*/
function () {
  function Renderer(container) {
    _classCallCheck(this, Renderer);

    this.container = container;
    this.initRender();
    this.updateSize();
    window.addEventListener('resize', this.updateSize.bind(this), false);
  }

  _createClass(Renderer, [{
    key: "initRender",
    value: function initRender() {
      this.renderer = new __WEBPACK_IMPORTED_MODULE_0__three__["WebGLRenderer"]({
        antialias: true,
        alpha: true
      });
      this.renderer.setClearColor(0xff0000, 0.0);
      this.pixelRatio = window.devicePixelRatio;
      this.renderer.setPixelRatio(this.pixelRatio);
      this.renderer.gammaInput = true;
      this.renderer.gammaOutput = true;
      this.renderer.shadowMap.enabled = true;
      this.container.appendChild(this.renderer.domElement);
    }
  }, {
    key: "updateSize",
    value: function updateSize() {
      this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    }
  }]);

  return Renderer;
}();



/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pickingScene__ = __webpack_require__(251);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__three__ = __webpack_require__(2);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var nextId = 1;

var Picking =
/*#__PURE__*/
function () {
  function Picking(world, renderer, camera, scene) {
    _classCallCheck(this, Picking);

    this._world = world;
    this._renderer = renderer;
    this._camera = camera;
    this._raycaster = new __WEBPACK_IMPORTED_MODULE_1__three__["Raycaster"]();
    this.scene = scene;
    this._envents = []; // TODO: Match this with the line width used in the picking layers

    this._raycaster.linePrecision = 3;
    this._pickingScene = __WEBPACK_IMPORTED_MODULE_0__pickingScene__["a" /* default */];

    var size = this._renderer.getSize();

    this._width = size.width;
    this._height = size.height;
    var parameters = {
      minFilter: __WEBPACK_IMPORTED_MODULE_1__three__["LinearFilter"],
      magFilter: __WEBPACK_IMPORTED_MODULE_1__three__["LinearFilter"],
      format: __WEBPACK_IMPORTED_MODULE_1__three__["RGBAFormat"],
      stencilBuffer: false,
      depthBuffer: false
    };
    this._pickingTexture = new __WEBPACK_IMPORTED_MODULE_1__three__["WebGLRenderTarget"](this._width, this._height, parameters);
    this._nextId = 1;

    this._resizeTexture();

    this._initEvents();
  }

  _createClass(Picking, [{
    key: "_initEvents",
    value: function _initEvents() {
      this._resizeHandler = this._resizeTexture.bind(this);
      window.addEventListener('resize', this._resizeHandler, false);
      this._mouseUpHandler = this._onMouseUp.bind(this);

      this._world._container.addEventListener('mouseup', this._mouseUpHandler, false);

      this._world._container.addEventListener('mousemove', this._mouseUpHandler, false);

      this._world._container.addEventListener('mousemove', this._onWorldMove.bind(this), false);
    }
  }, {
    key: "_onMouseUp",
    value: function _onMouseUp(event) {
      // Only react to main button click
      // if (event.button !== 0) {
      //   return;
      // }
      var point = {
        x: event.clientX,
        y: event.clientY
      };
      var normalisedPoint = {
        x: 0,
        y: 0
      };
      normalisedPoint.x = point.x / this._width * 2 - 1;
      normalisedPoint.y = -(point.y / this._height) * 2 + 1;

      this._pick(point, normalisedPoint);
    }
  }, {
    key: "_onWorldMove",
    value: function _onWorldMove() {
      this._needUpdate = true;
    } // TODO: Ensure this doesn't get out of sync issue with the renderer resize

  }, {
    key: "_resizeTexture",
    value: function _resizeTexture() {
      var size = this._renderer.getSize();

      this._width = size.width;
      this._height = size.height;

      this._pickingTexture.setSize(this._width, this._height);

      this._pixelBuffer = new Uint8Array(4 * this._width * this._height);
      this._needUpdate = true;
    }
  }, {
    key: "_update",
    value: function _update(point) {
      var texture = this._pickingTexture;

      if (this._needUpdate) {
        this._renderer.render(this._pickingScene, this._camera, this._pickingTexture);

        this._needUpdate = false;
      }

      this.pixelBuffer = new Uint8Array(4);

      this._renderer.readRenderTargetPixels(texture, point.x, this._height - point.y, 1, 1, this.pixelBuffer);
    } // 添加dom事件 支持 mousedown ,mouseenter mouseleave mousemove mouseover mouseout mouse up

  }, {
    key: "on",
    value: function on(type) {
      this._mouseUpHandler = this._onMouseUp.bind(this);

      this._world._container.addEventListener(type, this._mouseUpHandler, false);

      this._envents.push([type, this._mouseUpHandler]);
    }
  }, {
    key: "off",
    value: function off(type, hander) {
      this._world._container.removeEventListener(type, this._mouseUpHandler, false);

      this._envents = this._envents.filter(function (item) {
        return item[0] === 'type' && hander === item[1];
      });
    }
  }, {
    key: "_updateRender",
    value: function _updateRender() {
      this._renderer.render(this._pickingScene, this._camera, this._pickingTexture);
    }
  }, {
    key: "_pick",
    value: function _pick(point, normalisedPoint) {
      this._update(point); // Interpret the pixel as an ID


      var id = this.pixelBuffer[2] * 255 * 255 + this.pixelBuffer[1] * 255 + this.pixelBuffer[0]; // Skip if ID is 16646655 (white) as the background returns this

      if (id === 16646655 || this.pixelBuffer[3] === 0) {
        return;
      }

      this._raycaster.setFromCamera(normalisedPoint, this._camera); // Perform ray intersection on picking scene
      //
      // TODO: Only perform intersection test on the relevant picking mesh


      var intersects = this._raycaster.intersectObjects(this._pickingScene.children, true);

      var _point2d = {
        x: point.x,
        y: point.y
      };

      var _point3d;

      if (intersects.length > 0) {
        _point3d = intersects[0].point;
      } // Pass along as much data as possible for now until we know more about how
      // people use the picking API and what the returned data should be
      //
      // TODO: Look into the leak potential for passing so much by reference here


      var item = {
        featureId: id - 1,
        point2d: _point2d,
        point3d: _point3d,
        intersects: intersects
      };

      this._world.emit('pick', item); // this._world.emit('pick-' + id, _point2d, _point3d, intersects);

    } // Add mesh to picking scene
    //
    // Picking ID should already be added as an attribute

  }, {
    key: "add",
    value: function add(mesh) {
      this._pickingScene.add(mesh);

      this._needUpdate = true;
    } // Remove mesh from picking scene

  }, {
    key: "remove",
    value: function remove(mesh) {
      this._pickingScene.remove(mesh);

      this._needUpdate = true;
    } // Returns next ID to use for picking

  }, {
    key: "getNextId",
    value: function getNextId() {
      return nextId++;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this = this;

      // TODO: Find a way to properly remove these listeners as they stay
      // active at the moment
      window.removeEventListener('resize', this._resizeHandler, false);

      this._envents.forEach(function (event) {
        _this._world._container.removeEventListener(event[0], event[1], false);
      });

      this._world.off('move', this._onWorldMove);

      if (this._pickingScene.children) {
        // Remove everything else in the layer
        var child;

        for (var i = this._pickingScene.children.length - 1; i >= 0; i--) {
          child = this._pickingScene.children[i];

          if (!child) {
            continue;
          }

          this._pickingScene.remove(child); // Probably not a good idea to dispose of geometry due to it being
          // shared with the non-picking scene
          // if (child.geometry) {
          //   // Dispose of mesh and materials
          //   child.geometry.dispose();
          //   child.geometry = null;
          // }


          if (child.material) {
            if (child.material.map) {
              child.material.map.dispose();
              child.material.map = null;
            }

            child.material.dispose();
            child.material = null;
          }
        }
      }

      this._pickingScene = null;
      this._pickingTexture = null;
      this._pixelBuffer = null;
      this._world = null;
      this._renderer = null;
      this._camera = null;
    }
  }]);

  return Picking;
}(); // Initialise without requiring new keyword


/* harmony default export */ __webpack_exports__["a"] = (function (world, renderer, camera, scene) {
  return new Picking(world, renderer, camera, scene);
});

/***/ }),
/* 251 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__three__ = __webpack_require__(2);
 // This can be imported from anywhere and will still reference the same scene,
// though there is a helper reference in Engine.pickingScene

/* harmony default export */ __webpack_exports__["a"] = ((function () {
  var scene = new __WEBPACK_IMPORTED_MODULE_0__three__["Scene"]();
  return scene;
})());

/***/ }),
/* 252 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygonLayer__ = __webpack_require__(253);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonLayer", function() { return __WEBPACK_IMPORTED_MODULE_0__polygonLayer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pointLayer__ = __webpack_require__(307);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PointLayer", function() { return __WEBPACK_IMPORTED_MODULE_1__pointLayer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lineLayer__ = __webpack_require__(317);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "LineLayer", function() { return __WEBPACK_IMPORTED_MODULE_2__lineLayer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__imageLayer__ = __webpack_require__(321);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLayer", function() { return __WEBPACK_IMPORTED_MODULE_3__imageLayer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__rasterLayer__ = __webpack_require__(326);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "RasterLayer", function() { return __WEBPACK_IMPORTED_MODULE_4__rasterLayer__["a"]; });






/***/ }),
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PolygonLayer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_layer__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_buffer_polygon__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_material_polygonMaterial__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_material_lineMaterial__ = __webpack_require__(75);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }







var PolygonLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(PolygonLayer, _Layer);

  function PolygonLayer() {
    _classCallCheck(this, PolygonLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(PolygonLayer).apply(this, arguments));
  }

  _createClass(PolygonLayer, [{
    key: "shape",
    value: function shape(type) {
      this.shape = type;
      return this;
    }
  }, {
    key: "render",
    value: function render() {
      if (!this._hasRender) {
        // 首次渲染
        this._hasRender = true;

        this._prepareRender();
      } else {
        this._initAttrs();

        this._needUpdateFilter || this._needUpdateColor ? this._updateFilter() : null;

        var _this$get = this.get('styleOptions'),
            opacity = _this$get.opacity,
            baseColor = _this$get.baseColor,
            brightColor = _this$get.brightColor,
            windowColor = _this$get.windowColor;

        this.layerMesh.material.upDateUninform({
          u_opacity: opacity,
          u_baseColor: baseColor,
          u_brightColor: brightColor,
          u_windowColor: windowColor
        });
      }

      return this;
    }
  }, {
    key: "_prepareRender",
    value: function _prepareRender() {
      this.init();
      this.type = 'polygon';
      var source = this.layerSource;
      this._buffer = new __WEBPACK_IMPORTED_MODULE_2__geom_buffer_polygon__["a" /* default */]({
        shape: this.shape,
        coordinates: source.geoData,
        properties: this.StyleData
      });
      var attributes = this._buffer.attributes;
      this.geometry = new __WEBPACK_IMPORTED_MODULE_0__core_three__["BufferGeometry"]();
      this.geometry.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_0__core_three__["Float32BufferAttribute"](attributes.vertices, 3));
      this.geometry.addAttribute('a_color', new __WEBPACK_IMPORTED_MODULE_0__core_three__["Float32BufferAttribute"](attributes.colors, 4));
      this.geometry.addAttribute('pickingId', new __WEBPACK_IMPORTED_MODULE_0__core_three__["Float32BufferAttribute"](attributes.pickingIds, 1));

      if (this.shape === 'line') {
        this._renderLine();
      } else {
        this._renderPolygon();
      }
    }
  }, {
    key: "_renderLine",
    value: function _renderLine() {
      var _this$get2 = this.get('styleOptions'),
          opacity = _this$get2.opacity;

      var lineMaterial = new __WEBPACK_IMPORTED_MODULE_4__geom_material_lineMaterial__["c" /* LineMaterial */]({
        u_opacity: opacity
      });
      var polygonLine = new __WEBPACK_IMPORTED_MODULE_0__core_three__["LineSegments"](this.geometry, lineMaterial);
      this.add(polygonLine);
    }
  }, {
    key: "_renderPolygon",
    value: function _renderPolygon() {
      var animateOptions = this.get('animateOptions');

      var _this$get3 = this.get('styleOptions'),
          opacity = _this$get3.opacity,
          baseColor = _this$get3.baseColor,
          brightColor = _this$get3.brightColor,
          windowColor = _this$get3.windowColor;

      var camera = this.map.getCameraState();
      var material = new __WEBPACK_IMPORTED_MODULE_3__geom_material_polygonMaterial__["a" /* default */]({
        u_opacity: opacity,
        u_baseColor: baseColor,
        u_brightColor: brightColor,
        u_windowColor: windowColor,
        u_near: camera.near,
        u_far: camera.far
      });
      var attributes = this._buffer.attributes;
      this.geometry.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_0__core_three__["Float32BufferAttribute"](attributes.normals, 3));

      if (animateOptions.enable) {
        material.setDefinesvalue('ANIMATE', true);
        this.geometry.addAttribute('faceUv', new __WEBPACK_IMPORTED_MODULE_0__core_three__["Float32BufferAttribute"](attributes.faceUv, 2));
        this.geometry.addAttribute('a_size', new __WEBPACK_IMPORTED_MODULE_0__core_three__["Float32BufferAttribute"](attributes.sizes, 1));
      } // const pickmaterial = new PickingMaterial();


      var polygonMesh = new __WEBPACK_IMPORTED_MODULE_0__core_three__["Mesh"](this.geometry, material);
      this.add(polygonMesh);
    }
  }, {
    key: "update",
    value: function update() {
      this.updateFilter(this.StyleData); // 动态更新相关属性
    }
  }]);

  return PolygonLayer;
}(__WEBPACK_IMPORTED_MODULE_1__core_layer__["a" /* default */]);



/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports["Util"] = factory();else root["Util"] = factory();
})(this, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 40);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, exports, __webpack_require__) {
      var isObject = __webpack_require__(16);

      var isArray = __webpack_require__(1);

      var each = function each(elements, func) {
        if (!elements) {
          return;
        }

        var rst = void 0;

        if (isArray(elements)) {
          for (var i = 0, len = elements.length; i < len; i++) {
            rst = func(elements[i], i);

            if (rst === false) {
              break;
            }
          }
        } else if (isObject(elements)) {
          for (var k in elements) {
            if (elements.hasOwnProperty(k)) {
              rst = func(elements[k], k);

              if (rst === false) {
                break;
              }
            }
          }
        }
      };

      module.exports = each;
      /***/
    },
    /* 1 */

    /***/
    function (module, exports, __webpack_require__) {
      var isType = __webpack_require__(4);

      var isArray = Array.isArray ? Array.isArray : function (value) {
        return isType(value, 'Array');
      };
      module.exports = isArray;
      /***/
    },
    /* 2 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * 是否为函数
       * @param  {*} fn 对象
       * @return {Boolean}  是否函数
       */
      var isType = __webpack_require__(4);

      var isFunction = function isFunction(value) {
        return isType(value, 'Function');
      };

      module.exports = isFunction;
      /***/
    },
    /* 3 */

    /***/
    function (module, exports) {
      var isArrayLike = function isArrayLike(value) {
        /**
         * isArrayLike([1, 2, 3]) => true
         * isArrayLike(document.body.children) => true
         * isArrayLike('abc') => true
         * isArrayLike(Function) => false
         */
        return value !== null && typeof value !== 'function' && isFinite(value.length);
      };

      module.exports = isArrayLike;
      /***/
    },
    /* 4 */

    /***/
    function (module, exports) {
      var toString = {}.toString;

      var isType = function isType(value, type) {
        return toString.call(value) === '[object ' + type + ']';
      };

      module.exports = isType;
      /***/
    },
    /* 5 */

    /***/
    function (module, exports) {
      // isFinite,
      var isNil = function isNil(value) {
        /**
         * isNil(null) => true
         * isNil() => true
         */
        return value === null || value === undefined;
      };

      module.exports = isNil;
      /***/
    },
    /* 6 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * 判断是否数字
       * @return {Boolean} 是否数字
       */
      var isType = __webpack_require__(4);

      var isNumber = function isNumber(value) {
        return isType(value, 'Number');
      };

      module.exports = isNumber;
      /***/
    },
    /* 7 */

    /***/
    function (module, exports, __webpack_require__) {
      var isObjectLike = __webpack_require__(13);

      var isType = __webpack_require__(4);

      var isPlainObject = function isPlainObject(value) {
        /**
         * isObjectLike(new Foo) => false
         * isObjectLike([1, 2, 3]) => false
         * isObjectLike({ x: 0, y: 0 }) => true
         * isObjectLike(Object.create(null)) => true
         */
        if (!isObjectLike(value) || !isType(value, 'Object')) {
          return false;
        }

        if (Object.getPrototypeOf(value) === null) {
          return true;
        }

        var proto = value;

        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
        }

        return Object.getPrototypeOf(value) === proto;
      };

      module.exports = isPlainObject;
      /***/
    },
    /* 8 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNil = __webpack_require__(5);

      function toString(value) {
        if (isNil(value)) return '';
        return value.toString();
      }

      module.exports = toString;
      /***/
    },
    /* 9 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(3);

      var indexOf = Array.prototype.indexOf;

      var contains = function contains(arr, value) {
        if (!isArrayLike(arr)) {
          return false;
        }

        return indexOf.call(arr, value) > -1;
      };

      module.exports = contains;
      /***/
    },
    /* 10 */

    /***/
    function (module, exports, __webpack_require__) {
      var isType = __webpack_require__(4);

      var isString = function isString(str) {
        return isType(str, 'String');
      };

      module.exports = isString;
      /***/
    },
    /* 11 */

    /***/
    function (module, exports) {
      function _mix(dist, obj) {
        for (var key in obj) {
          if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {
            dist[key] = obj[key];
          }
        }
      }

      var mix = function mix(dist, src1, src2, src3) {
        if (src1) _mix(dist, src1);
        if (src2) _mix(dist, src2);
        if (src3) _mix(dist, src3);
        return dist;
      };

      module.exports = mix;
      /***/
    },
    /* 12 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(0);

      var isArrayLike = __webpack_require__(3);

      var filter = function filter(arr, func) {
        if (!isArrayLike(arr)) {
          return arr;
        }

        var result = [];
        each(arr, function (value, index) {
          if (func(value, index)) {
            result.push(value);
          }
        });
        return result;
      };

      module.exports = filter;
      /***/
    },
    /* 13 */

    /***/
    function (module, exports) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      var isObjectLike = function isObjectLike(value) {
        /**
         * isObjectLike({}) => true
         * isObjectLike([1, 2, 3]) => true
         * isObjectLike(Function) => false
         * isObjectLike(null) => false
         */
        return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
      };

      module.exports = isObjectLike;
      /***/
    },
    /* 14 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(3);

      function toArray(value) {
        return isArrayLike(value) ? Array.prototype.slice.call(value) : [];
      }

      module.exports = toArray;
      /***/
    },
    /* 15 */

    /***/
    function (module, exports) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setMatrixArrayType = setMatrixArrayType;
      exports.toRadian = toRadian;
      exports.equals = equals;
      /**
       * Common utilities
       * @module glMatrix
       */
      // Configuration Constants

      var EPSILON = exports.EPSILON = 0.000001;
      var ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
      var RANDOM = exports.RANDOM = Math.random;
      /**
       * Sets the type of array used when creating new vectors and matrices
       *
       * @param {Type} type Array type, such as Float32Array or Array
       */

      function setMatrixArrayType(type) {
        exports.ARRAY_TYPE = ARRAY_TYPE = type;
      }

      var degree = Math.PI / 180;
      /**
       * Convert Degree To Radian
       *
       * @param {Number} a Angle in Degrees
       */

      function toRadian(a) {
        return a * degree;
      }
      /**
       * Tests whether or not the arguments have approximately the same value, within an absolute
       * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
       * than or equal to 1.0, and a relative tolerance is used for larger values)
       *
       * @param {Number} a The first number to test.
       * @param {Number} b The second number to test.
       * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
       */


      function equals(a, b) {
        return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
      }
      /***/

    },
    /* 16 */

    /***/
    function (module, exports) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      var isObject = function isObject(value) {
        /**
         * isObject({}) => true
         * isObject([1, 2, 3]) => true
         * isObject(Function) => true
         * isObject(null) => false
         */
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
        return value !== null && type === 'object' || type === 'function';
      };

      module.exports = isObject;
      /***/
    },
    /* 17 */

    /***/
    function (module, exports, __webpack_require__) {
      var keys = __webpack_require__(18);

      var isNil = __webpack_require__(5);

      function isMatch(obj, attrs) {
        var _keys = keys(attrs);

        var length = _keys.length;
        if (isNil(obj)) return !length;

        for (var i = 0; i < length; i += 1) {
          var key = _keys[i];

          if (attrs[key] !== obj[key] || !(key in obj)) {
            return false;
          }
        }

        return true;
      }

      module.exports = isMatch;
      /***/
    },
    /* 18 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(0);

      var isFunction = __webpack_require__(2);

      var keys = Object.keys ? function (obj) {
        return Object.keys(obj);
      } : function (obj) {
        var result = [];
        each(obj, function (value, key) {
          if (!(isFunction(obj) && key === 'prototype')) {
            result.push(key);
          }
        });
        return result;
      };
      module.exports = keys;
      /***/
    },
    /* 19 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(3);

      var splice = Array.prototype.splice;

      var pullAt = function pullAt(arr, indexes) {
        if (!isArrayLike(arr)) {
          return [];
        }

        var length = arr ? indexes.length : 0;
        var last = length - 1;

        while (length--) {
          var previous = void 0;
          var index = indexes[length];

          if (length === last || index !== previous) {
            previous = index;
            splice.call(arr, index, 1);
          }
        }

        return arr;
      };

      module.exports = pullAt;
      /***/
    },
    /* 20 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(0);

      var contains = __webpack_require__(9);

      var uniq = function uniq(arr) {
        var resultArr = [];
        each(arr, function (item) {
          if (!contains(resultArr, item)) {
            resultArr.push(item);
          }
        });
        return resultArr;
      };

      module.exports = uniq;
      /***/
    },
    /* 21 */

    /***/
    function (module, exports) {
      var clamp = function clamp(a, min, max) {
        if (a < min) {
          return min;
        } else if (a > max) {
          return max;
        }

        return a;
      };

      module.exports = clamp;
      /***/
    },
    /* 22 */

    /***/
    function (module, exports) {
      module.exports = parseInt;
      /***/
    },
    /* 23 */

    /***/
    function (module, exports, __webpack_require__) {
      var mat3 = __webpack_require__(89);

      mat3.translate = function (out, a, v) {
        var transMat = new Array(9);
        mat3.fromTranslation(transMat, v);
        return mat3.multiply(out, transMat, a);
      };

      mat3.rotate = function (out, a, rad) {
        var rotateMat = new Array(9);
        mat3.fromRotation(rotateMat, rad);
        return mat3.multiply(out, rotateMat, a);
      };

      mat3.scale = function (out, a, v) {
        var scaleMat = new Array(9);
        mat3.fromScaling(scaleMat, v);
        return mat3.multiply(out, scaleMat, a);
      };

      module.exports = mat3;
      /***/
    },
    /* 24 */

    /***/
    function (module, exports, __webpack_require__) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      var isArray = __webpack_require__(1);

      var clone = function clone(obj) {
        if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
          return obj;
        }

        var rst = void 0;

        if (isArray(obj)) {
          rst = [];

          for (var i = 0, l = obj.length; i < l; i++) {
            if (_typeof(obj[i]) === 'object' && obj[i] != null) {
              rst[i] = clone(obj[i]);
            } else {
              rst[i] = obj[i];
            }
          }
        } else {
          rst = {};

          for (var k in obj) {
            if (_typeof(obj[k]) === 'object' && obj[k] != null) {
              rst[k] = clone(obj[k]);
            } else {
              rst[k] = obj[k];
            }
          }
        }

        return rst;
      };

      module.exports = clone;
      /***/
    },
    /* 25 */

    /***/
    function (module, exports) {
      module.exports = function (obj, key) {
        return obj.hasOwnProperty(key);
      };
      /***/

    },
    /* 26 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(0);

      var isFunction = __webpack_require__(2);

      var values = Object.values ? function (obj) {
        return Object.values(obj);
      } : function (obj) {
        var result = [];
        each(obj, function (value, key) {
          if (!(isFunction(obj) && key === 'prototype')) {
            result.push(value);
          }
        });
        return result;
      };
      module.exports = values;
      /***/
    },
    /* 27 */

    /***/
    function (module, exports, __webpack_require__) {
      var parsePathArray = __webpack_require__(28);

      module.exports = function rectPath(x, y, w, h, r) {
        if (r) {
          return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
        }

        var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
        res.parsePathArray = parsePathArray;
        return res;
      };
      /***/

    },
    /* 28 */

    /***/
    function (module, exports) {
      var p2s = /,?([a-z]),?/gi;

      module.exports = function parsePathArray(path) {
        return path.join(',').replace(p2s, '$1');
      };
      /***/

    },
    /* 29 */

    /***/
    function (module, exports, __webpack_require__) {
      var pathToAbsolute = __webpack_require__(30);

      var a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        if (rx === ry) {
          rx += 1;
        }

        var _120 = Math.PI * 120 / 180;

        var rad = Math.PI / 180 * (+angle || 0);
        var res = [];
        var xy = void 0;
        var f1 = void 0;
        var f2 = void 0;
        var cx = void 0;
        var cy = void 0;

        var rotate = function rotate(x, y, rad) {
          var X = x * Math.cos(rad) - y * Math.sin(rad);
          var Y = x * Math.sin(rad) + y * Math.cos(rad);
          return {
            x: X,
            y: Y
          };
        };

        if (!recursive) {
          xy = rotate(x1, y1, -rad);
          x1 = xy.x;
          y1 = xy.y;
          xy = rotate(x2, y2, -rad);
          x2 = xy.x;
          y2 = xy.y;

          if (x1 === x2 && y1 === y2) {
            // 若弧的起始点和终点重叠则错开一点
            x2 += 1;
            y2 += 1;
          } // const cos = Math.cos(Math.PI / 180 * angle);
          // const sin = Math.sin(Math.PI / 180 * angle);


          var x = (x1 - x2) / 2;
          var y = (y1 - y2) / 2;
          var h = x * x / (rx * rx) + y * y / (ry * ry);

          if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx;
            ry = h * ry;
          }

          var rx2 = rx * rx;
          var ry2 = ry * ry;
          var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
          cx = k * rx * y / ry + (x1 + x2) / 2;
          cy = k * -ry * x / rx + (y1 + y2) / 2;
          f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
          f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
          f1 = x1 < cx ? Math.PI - f1 : f1;
          f2 = x2 < cx ? Math.PI - f2 : f2;
          f1 < 0 && (f1 = Math.PI * 2 + f1);
          f2 < 0 && (f2 = Math.PI * 2 + f2);

          if (sweep_flag && f1 > f2) {
            f1 = f1 - Math.PI * 2;
          }

          if (!sweep_flag && f2 > f1) {
            f2 = f2 - Math.PI * 2;
          }
        } else {
          f1 = recursive[0];
          f2 = recursive[1];
          cx = recursive[2];
          cy = recursive[3];
        }

        var df = f2 - f1;

        if (Math.abs(df) > _120) {
          var f2old = f2;
          var x2old = x2;
          var y2old = y2;
          f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
          x2 = cx + rx * Math.cos(f2);
          y2 = cy + ry * Math.sin(f2);
          res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }

        df = f2 - f1;
        var c1 = Math.cos(f1);
        var s1 = Math.sin(f1);
        var c2 = Math.cos(f2);
        var s2 = Math.sin(f2);
        var t = Math.tan(df / 4);
        var hx = 4 / 3 * rx * t;
        var hy = 4 / 3 * ry * t;
        var m1 = [x1, y1];
        var m2 = [x1 + hx * s1, y1 - hy * c1];
        var m3 = [x2 + hx * s2, y2 - hy * c2];
        var m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];

        if (recursive) {
          return [m2, m3, m4].concat(res);
        }

        res = [m2, m3, m4].concat(res).join().split(',');
        var newres = [];

        for (var i = 0, ii = res.length; i < ii; i++) {
          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
        }

        return newres;
      };

      var l2c = function l2c(x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
      };

      var q2c = function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3;

        var _23 = 2 / 3;

        return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
      };

      module.exports = function pathTocurve(path, path2) {
        var p = pathToAbsolute(path);
        var p2 = path2 && pathToAbsolute(path2);
        var attrs = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        };
        var attrs2 = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        };
        var pcoms1 = []; // path commands of original path p

        var pcoms2 = []; // path commands of original path p2

        var pfirst = ''; // temporary holder for original path command

        var pcom = ''; // holder for previous path command of original path

        var ii = void 0;

        var processPath = function processPath(path, d, pcom) {
          var nx = void 0,
              ny = void 0;

          if (!path) {
            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
          }

          !(path[0] in {
            T: 1,
            Q: 1
          }) && (d.qx = d.qy = null);

          switch (path[0]) {
            case 'M':
              d.X = path[1];
              d.Y = path[2];
              break;

            case 'A':
              path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
              break;

            case 'S':
              if (pcom === 'C' || pcom === 'S') {
                // In "S" case we have to take into account, if the previous command is C/S.
                nx = d.x * 2 - d.bx; // And reflect the previous

                ny = d.y * 2 - d.by; // command's control point relative to the current point.
              } else {
                // or some else or nothing
                nx = d.x;
                ny = d.y;
              }

              path = ['C', nx, ny].concat(path.slice(1));
              break;

            case 'T':
              if (pcom === 'Q' || pcom === 'T') {
                // In "T" case we have to take into account, if the previous command is Q/T.
                d.qx = d.x * 2 - d.qx; // And make a reflection similar

                d.qy = d.y * 2 - d.qy; // to case "S".
              } else {
                // or something else or nothing
                d.qx = d.x;
                d.qy = d.y;
              }

              path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
              break;

            case 'Q':
              d.qx = path[1];
              d.qy = path[2];
              path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
              break;

            case 'L':
              path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
              break;

            case 'H':
              path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
              break;

            case 'V':
              path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
              break;

            case 'Z':
              path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
              break;

            default:
              break;
          }

          return path;
        };

        var fixArc = function fixArc(pp, i) {
          if (pp[i].length > 7) {
            pp[i].shift();
            var pi = pp[i];

            while (pi.length) {
              pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved

              p2 && (pcoms2[i] = 'A'); // the same as above

              pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
            }

            pp.splice(i, 1);
            ii = Math.max(p.length, p2 && p2.length || 0);
          }
        };

        var fixM = function fixM(path1, path2, a1, a2, i) {
          if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {
            path2.splice(i, 0, ['M', a2.x, a2.y]);
            a1.bx = 0;
            a1.by = 0;
            a1.x = path1[i][1];
            a1.y = path1[i][2];
            ii = Math.max(p.length, p2 && p2.length || 0);
          }
        };

        ii = Math.max(p.length, p2 && p2.length || 0);

        for (var i = 0; i < ii; i++) {
          p[i] && (pfirst = p[i][0]); // save current path command

          if (pfirst !== 'C') {
            // C is not saved yet, because it may be result of conversion
            pcoms1[i] = pfirst; // Save current path command

            i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
          }

          p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

          if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; // A is the only command
          // which may produce multiple C:s
          // so we have to make sure that C is also C in original path

          fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

          if (p2) {
            // the same procedures is done to p2
            p2[i] && (pfirst = p2[i][0]);

            if (pfirst !== 'C') {
              pcoms2[i] = pfirst;
              i && (pcom = pcoms2[i - 1]);
            }

            p2[i] = processPath(p2[i], attrs2, pcom);

            if (pcoms2[i] !== 'A' && pfirst === 'C') {
              pcoms2[i] = 'C';
            }

            fixArc(p2, i);
          }

          fixM(p, p2, attrs, attrs2, i);
          fixM(p2, p, attrs2, attrs, i);
          var seg = p[i];
          var seg2 = p2 && p2[i];
          var seglen = seg.length;
          var seg2len = p2 && seg2.length;
          attrs.x = seg[seglen - 2];
          attrs.y = seg[seglen - 1];
          attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
          attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
          attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
          attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
          attrs2.x = p2 && seg2[seg2len - 2];
          attrs2.y = p2 && seg2[seg2len - 1];
        }

        return p2 ? [p, p2] : p;
      };
      /***/

    },
    /* 30 */

    /***/
    function (module, exports, __webpack_require__) {
      var parsePathString = __webpack_require__(31);

      var catmullRom2bezier = __webpack_require__(32);

      function ellipsePath(x, y, rx, ry, a) {
        var res = [];

        if (a === null && ry === null) {
          ry = rx;
        }

        x = +x;
        y = +y;
        rx = +rx;
        ry = +ry;

        if (a !== null) {
          var rad = Math.PI / 180;
          var x1 = x + rx * Math.cos(-ry * rad);
          var x2 = x + rx * Math.cos(-a * rad);
          var y1 = y + rx * Math.sin(-ry * rad);
          var y2 = y + rx * Math.sin(-a * rad);
          res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
        } else {
          res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
        }

        return res;
      }

      module.exports = function pathToAbsolute(pathArray) {
        pathArray = parsePathString(pathArray);

        if (!pathArray || !pathArray.length) {
          return [['M', 0, 0]];
        }

        var res = [];
        var x = 0;
        var y = 0;
        var mx = 0;
        var my = 0;
        var start = 0;
        var pa0 = void 0;
        var dots = void 0;

        if (pathArray[0][0] === 'M') {
          x = +pathArray[0][1];
          y = +pathArray[0][2];
          mx = x;
          my = y;
          start++;
          res[0] = ['M', x, y];
        }

        var crz = pathArray.length === 3 && pathArray[0][0] === 'M' && pathArray[1][0].toUpperCase() === 'R' && pathArray[2][0].toUpperCase() === 'Z';

        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
          res.push(r = []);
          pa = pathArray[i];
          pa0 = pa[0];

          if (pa0 !== pa0.toUpperCase()) {
            r[0] = pa0.toUpperCase();

            switch (r[0]) {
              case 'A':
                r[1] = pa[1];
                r[2] = pa[2];
                r[3] = pa[3];
                r[4] = pa[4];
                r[5] = pa[5];
                r[6] = +pa[6] + x;
                r[7] = +pa[7] + y;
                break;

              case 'V':
                r[1] = +pa[1] + y;
                break;

              case 'H':
                r[1] = +pa[1] + x;
                break;

              case 'R':
                dots = [x, y].concat(pa.slice(1));

                for (var j = 2, jj = dots.length; j < jj; j++) {
                  dots[j] = +dots[j] + x;
                  dots[++j] = +dots[j] + y;
                }

                res.pop();
                res = res.concat(catmullRom2bezier(dots, crz));
                break;

              case 'O':
                res.pop();
                dots = ellipsePath(x, y, pa[1], pa[2]);
                dots.push(dots[0]);
                res = res.concat(dots);
                break;

              case 'U':
                res.pop();
                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                r = ['U'].concat(res[res.length - 1].slice(-2));
                break;

              case 'M':
                mx = +pa[1] + x;
                my = +pa[2] + y;
                break;
              // for lint

              default:
                for (var _j = 1, _jj = pa.length; _j < _jj; _j++) {
                  r[_j] = +pa[_j] + (_j % 2 ? x : y);
                }

            }
          } else if (pa0 === 'R') {
            dots = [x, y].concat(pa.slice(1));
            res.pop();
            res = res.concat(catmullRom2bezier(dots, crz));
            r = ['R'].concat(pa.slice(-2));
          } else if (pa0 === 'O') {
            res.pop();
            dots = ellipsePath(x, y, pa[1], pa[2]);
            dots.push(dots[0]);
            res = res.concat(dots);
          } else if (pa0 === 'U') {
            res.pop();
            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
            r = ['U'].concat(res[res.length - 1].slice(-2));
          } else {
            for (var k = 0, kk = pa.length; k < kk; k++) {
              r[k] = pa[k];
            }
          }

          pa0 = pa0.toUpperCase();

          if (pa0 !== 'O') {
            switch (r[0]) {
              case 'Z':
                x = +mx;
                y = +my;
                break;

              case 'H':
                x = r[1];
                break;

              case 'V':
                y = r[1];
                break;

              case 'M':
                mx = r[r.length - 2];
                my = r[r.length - 1];
                break;
              // for lint

              default:
                x = r[r.length - 2];
                y = r[r.length - 1];
            }
          }
        }

        return res;
      };
      /***/

    },
    /* 31 */

    /***/
    function (module, exports) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      var SPACES = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029';
      var PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');
      var PATH_VALUES = new RegExp('(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig'); // Parses given path string into an array of arrays of path segments

      module.exports = function parsePathString(pathString) {
        if (!pathString) {
          return null;
        }

        if ((typeof pathString === 'undefined' ? 'undefined' : _typeof(pathString)) === _typeof([])) {
          return pathString;
        }

        var paramCounts = {
          a: 7,
          c: 6,
          o: 2,
          h: 1,
          l: 2,
          m: 2,
          r: 4,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          u: 3,
          z: 0
        };
        var data = [];
        String(pathString).replace(PATH_COMMAND, function (a, b, c) {
          var params = [];
          var name = b.toLowerCase();
          c.replace(PATH_VALUES, function (a, b) {
            b && params.push(+b);
          });

          if (name === 'm' && params.length > 2) {
            data.push([b].concat(params.splice(0, 2)));
            name = 'l';
            b = b === 'm' ? 'l' : 'L';
          }

          if (name === 'o' && params.length === 1) {
            data.push([b, params[0]]);
          }

          if (name === 'r') {
            data.push([b].concat(params));
          } else {
            while (params.length >= paramCounts[name]) {
              data.push([b].concat(params.splice(0, paramCounts[name])));

              if (!paramCounts[name]) {
                break;
              }
            }
          }
        });
        return data;
      };
      /***/

    },
    /* 32 */

    /***/
    function (module, exports) {
      // http://schepers.cc/getting-to-the-point
      module.exports = function catmullRom2bezier(crp, z) {
        var d = [];

        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
          var p = [{
            x: +crp[i - 2],
            y: +crp[i - 1]
          }, {
            x: +crp[i],
            y: +crp[i + 1]
          }, {
            x: +crp[i + 2],
            y: +crp[i + 3]
          }, {
            x: +crp[i + 4],
            y: +crp[i + 5]
          }];

          if (z) {
            if (!i) {
              p[0] = {
                x: +crp[iLen - 2],
                y: +crp[iLen - 1]
              };
            } else if (iLen - 4 === i) {
              p[3] = {
                x: +crp[0],
                y: +crp[1]
              };
            } else if (iLen - 2 === i) {
              p[2] = {
                x: +crp[0],
                y: +crp[1]
              };
              p[3] = {
                x: +crp[2],
                y: +crp[3]
              };
            }
          } else {
            if (iLen - 4 === i) {
              p[3] = p[2];
            } else if (!i) {
              p[0] = {
                x: +crp[i],
                y: +crp[i + 1]
              };
            }
          }

          d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
        }

        return d;
      };
      /***/

    },
    /* 33 */

    /***/
    function (module, exports, __webpack_require__) {
      var toString = __webpack_require__(8);

      var lowerCase = function lowerCase(str) {
        return toString(str).toLowerCase();
      };

      module.exports = lowerCase;
      /***/
    },
    /* 34 */

    /***/
    function (module, exports, __webpack_require__) {
      var toString = __webpack_require__(8);

      var upperCase = function upperCase(str) {
        return toString(str).toUpperCase();
      };

      module.exports = upperCase;
      /***/
    },
    /* 35 */

    /***/
    function (module, exports) {
      var toString = {}.toString;

      var getType = function getType(value) {
        return toString.call(value).replace(/^\[object /, '').replace(/\]$/, '');
      };

      module.exports = getType;
      /***/
    },
    /* 36 */

    /***/
    function (module, exports) {
      var objectProto = Object.prototype;

      var isPrototype = function isPrototype(value) {
        var Ctor = value && value.constructor;
        var proto = typeof Ctor === 'function' && Ctor.prototype || objectProto;
        return value === proto;
      };

      module.exports = isPrototype;
      /***/
    },
    /* 37 */

    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(2);

      var isArray = __webpack_require__(1);

      var groupBy = __webpack_require__(38);

      var groupToMap = function groupToMap(data, condition) {
        if (!condition) {
          return {
            0: data
          };
        }

        if (!isFunction(condition)) {
          var paramsCondition = isArray(condition) ? condition : condition.replace(/\s+/g, '').split('*');

          condition = function condition(row) {
            var unique = '_'; // 避免出现数字作为Key的情况，会进行按照数字的排序

            for (var i = 0, l = paramsCondition.length; i < l; i++) {
              unique += row[paramsCondition[i]] && row[paramsCondition[i]].toString();
            }

            return unique;
          };
        }

        var groups = groupBy(data, condition);
        return groups;
      };

      module.exports = groupToMap;
      /***/
    },
    /* 38 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(0);

      var isArray = __webpack_require__(1);

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      var groupBy = function groupBy(data, condition) {
        if (!condition || !isArray(data)) {
          return data;
        }

        var result = {};
        var key = null;
        each(data, function (item) {
          key = condition(item);

          if (hasOwnProperty.call(result, key)) {
            result[key].push(item);
          } else {
            result[key] = [item];
          }
        });
        return result;
      };

      module.exports = groupBy;
      /***/
    },
    /* 39 */

    /***/
    function (module, exports, __webpack_require__) {
      var isObjectLike = __webpack_require__(13);

      var isArrayLike = __webpack_require__(3);

      var isString = __webpack_require__(10);

      var isEqual = function isEqual(value, other) {
        if (value === other) {
          return true;
        }

        if (!value || !other) {
          return false;
        }

        if (isString(value) || isString(other)) {
          return false;
        }

        if (isArrayLike(value) || isArrayLike(other)) {
          if (value.length !== other.length) {
            return false;
          }

          var rst = true;

          for (var i = 0; i < value.length; i++) {
            rst = isEqual(value[i], other[i]);

            if (!rst) {
              break;
            }
          }

          return rst;
        }

        if (isObjectLike(value) || isObjectLike(other)) {
          var valueKeys = Object.keys(value);
          var otherKeys = Object.keys(other);

          if (valueKeys.length !== otherKeys.length) {
            return false;
          }

          var _rst = true;

          for (var _i = 0; _i < valueKeys.length; _i++) {
            _rst = isEqual(value[valueKeys[_i]], other[valueKeys[_i]]);

            if (!_rst) {
              break;
            }
          }

          return _rst;
        }

        return false;
      };

      module.exports = isEqual;
      /***/
    },
    /* 40 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(0);

      var mix = __webpack_require__(11); // collections


      var DOMUtil = __webpack_require__(41);

      var arrayUtil = __webpack_require__(53);

      var eventUtil = __webpack_require__(67);

      var formatUtil = __webpack_require__(70);

      var mathUtil = __webpack_require__(74);

      var matrixUtil = __webpack_require__(88);

      var objectUtil = __webpack_require__(95);

      var pathUtil = __webpack_require__(99);

      var stringUtil = __webpack_require__(105);

      var typeUtil = __webpack_require__(111);

      var util = {
        // collections
        DOMUtil: DOMUtil,
        DomUtil: DOMUtil,
        MatrixUtil: matrixUtil,
        PathUtil: pathUtil,
        arrayUtil: arrayUtil,
        domUtil: DOMUtil,
        eventUtil: eventUtil,
        formatUtil: formatUtil,
        mathUtil: mathUtil,
        matrixUtil: matrixUtil,
        objectUtil: objectUtil,
        stringUtil: stringUtil,
        pathUtil: pathUtil,
        typeUtil: typeUtil,
        // others
        augment: __webpack_require__(116),
        clone: __webpack_require__(24),
        deepMix: __webpack_require__(117),
        each: each,
        extend: __webpack_require__(118),
        filter: __webpack_require__(12),
        group: __webpack_require__(119),
        groupBy: __webpack_require__(38),
        groupToMap: __webpack_require__(37),
        indexOf: __webpack_require__(120),
        isEmpty: __webpack_require__(121),
        isEqual: __webpack_require__(39),
        isEqualWith: __webpack_require__(122),
        map: __webpack_require__(123),
        mix: mix,
        pick: __webpack_require__(124),
        toArray: __webpack_require__(14),
        toString: __webpack_require__(8),
        uniqueId: __webpack_require__(125)
      };
      each([DOMUtil, arrayUtil, eventUtil, formatUtil, mathUtil, matrixUtil, objectUtil, pathUtil, stringUtil, typeUtil], function (collection) {
        mix(util, collection);
      });
      module.exports = util;
      /***/
    },
    /* 41 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        addEventListener: __webpack_require__(42),
        createDom: __webpack_require__(43),
        getBoundingClientRect: __webpack_require__(44),
        getHeight: __webpack_require__(45),
        getOuterHeight: __webpack_require__(46),
        getOuterWidth: __webpack_require__(47),
        getRatio: __webpack_require__(48),
        getStyle: __webpack_require__(49),
        getWidth: __webpack_require__(50),
        modifyCSS: __webpack_require__(51),
        requestAnimationFrame: __webpack_require__(52)
      };
      /***/
    },
    /* 42 */

    /***/
    function (module, exports) {
      /**
       * 添加事件监听器
       * @param  {Object} target DOM对象
       * @param  {String} eventType 事件名
       * @param  {Funtion} callback 回调函数
       * @return {Object} 返回对象
       */
      module.exports = function addEventListener(target, eventType, callback) {
        if (target) {
          if (target.addEventListener) {
            target.addEventListener(eventType, callback, false);
            return {
              remove: function remove() {
                target.removeEventListener(eventType, callback, false);
              }
            };
          } else if (target.attachEvent) {
            target.attachEvent('on' + eventType, callback);
            return {
              remove: function remove() {
                target.detachEvent('on' + eventType, callback);
              }
            };
          }
        }
      };
      /***/

    },
    /* 43 */

    /***/
    function (module, exports) {
      /**
       * 创建DOM 节点
       * @param  {String} str Dom 字符串
       * @return {HTMLElement}  DOM 节点
       */
      var TABLE = document.createElement('table');
      var TABLE_TR = document.createElement('tr');
      var FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
      var CONTAINERS = {
        tr: document.createElement('tbody'),
        tbody: TABLE,
        thead: TABLE,
        tfoot: TABLE,
        td: TABLE_TR,
        th: TABLE_TR,
        '*': document.createElement('div')
      };

      module.exports = function createDom(str) {
        var name = FRAGMENT_REG.test(str) && RegExp.$1;

        if (!(name in CONTAINERS)) {
          name = '*';
        }

        var container = CONTAINERS[name];
        str = str.replace(/(^\s*)|(\s*$)/g, '');
        container.innerHTML = '' + str;
        var dom = container.childNodes[0];
        container.removeChild(dom);
        return dom;
      };
      /***/

    },
    /* 44 */

    /***/
    function (module, exports) {
      module.exports = function getBoundingClientRect(node, defaultValue) {
        if (node && node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          var top = document.documentElement.clientTop;
          var left = document.documentElement.clientLeft;
          return {
            top: rect.top - top,
            bottom: rect.bottom - top,
            left: rect.left - left,
            right: rect.right - left
          };
        }

        return defaultValue || null;
      };
      /***/

    },
    /* 45 */

    /***/
    function (module, exports) {
      /**
       * 获取高度
       * @param  {HTMLElement} el dom节点
       * @param  {Number} defaultValue 默认值
       * @return {Number} 高度
       */
      module.exports = function getHeight(el, defaultValue) {
        var height = this.getStyle(el, 'height', defaultValue);

        if (height === 'auto') {
          height = el.offsetHeight;
        }

        return parseFloat(height);
      };
      /***/

    },
    /* 46 */

    /***/
    function (module, exports) {
      /**
       * 获取外层高度
       * @param  {HTMLElement} el dom节点
       * @param  {Number} defaultValue 默认值
       * @return {Number} 高度
       */
      module.exports = function getOuterHeight(el, defaultValue) {
        var height = this.getHeight(el, defaultValue);
        var bTop = parseFloat(this.getStyle(el, 'borderTopWidth')) || 0;
        var pTop = parseFloat(this.getStyle(el, 'paddingTop')) || 0;
        var pBottom = parseFloat(this.getStyle(el, 'paddingBottom')) || 0;
        var bBottom = parseFloat(this.getStyle(el, 'borderBottomWidth')) || 0;
        return height + bTop + bBottom + pTop + pBottom;
      };
      /***/

    },
    /* 47 */

    /***/
    function (module, exports) {
      /**
       * 获取外层宽度
       * @param  {HTMLElement} el dom节点
       * @param  {Number} defaultValue 默认值
       * @return {Number} 宽度
       */
      module.exports = function getOuterWidth(el, defaultValue) {
        var width = this.getWidth(el, defaultValue);
        var bLeft = parseFloat(this.getStyle(el, 'borderLeftWidth')) || 0;
        var pLeft = parseFloat(this.getStyle(el, 'paddingLeft')) || 0;
        var pRight = parseFloat(this.getStyle(el, 'paddingRight')) || 0;
        var bRight = parseFloat(this.getStyle(el, 'borderRightWidth')) || 0;
        return width + bLeft + bRight + pLeft + pRight;
      };
      /***/

    },
    /* 48 */

    /***/
    function (module, exports) {
      module.exports = function getRatio() {
        return window.devicePixelRatio ? window.devicePixelRatio : 2;
      };
      /***/

    },
    /* 49 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNil = __webpack_require__(5);
      /**
       * 获取样式
       * @param  {Object} dom DOM节点
       * @param  {String} name 样式名
       * @param  {Any} defaultValue 默认值
       * @return {String} 属性值
       */


      module.exports = function getStyle(dom, name, defaultValue) {
        try {
          if (window.getComputedStyle) {
            return window.getComputedStyle(dom, null)[name];
          }

          return dom.currentStyle[name];
        } catch (e) {
          if (!isNil(defaultValue)) {
            return defaultValue;
          }

          return null;
        }
      };
      /***/

    },
    /* 50 */

    /***/
    function (module, exports) {
      /**
       * 获取宽度
       * @param  {HTMLElement} el  dom节点
       * @param  {Number} defaultValue 默认值
       * @return {Number} 宽度
       */
      module.exports = function getWidth(el, defaultValue) {
        var width = this.getStyle(el, 'width', defaultValue);

        if (width === 'auto') {
          width = el.offsetWidth;
        }

        return parseFloat(width);
      };
      /***/

    },
    /* 51 */

    /***/
    function (module, exports) {
      module.exports = function modifyCSS(dom, css) {
        if (dom) {
          for (var key in css) {
            if (css.hasOwnProperty(key)) {
              dom.style[key] = css[key];
            }
          }
        }

        return dom;
      };
      /***/

    },
    /* 52 */

    /***/
    function (module, exports) {
      module.exports = function requestAnimationFrame(fn) {
        var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
          return setTimeout(fn, 16);
        };

        return method(fn);
      };
      /***/

    },
    /* 53 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        contains: __webpack_require__(9),
        difference: __webpack_require__(54),
        find: __webpack_require__(55),
        firstValue: __webpack_require__(56),
        flatten: __webpack_require__(57),
        flattenDeep: __webpack_require__(58),
        getRange: __webpack_require__(59),
        merge: __webpack_require__(60),
        pull: __webpack_require__(61),
        pullAt: __webpack_require__(19),
        reduce: __webpack_require__(62),
        remove: __webpack_require__(63),
        sortBy: __webpack_require__(64),
        union: __webpack_require__(65),
        uniq: __webpack_require__(20),
        valuesOfKey: __webpack_require__(66)
      };
      /***/
    },
    /* 54 */

    /***/
    function (module, exports, __webpack_require__) {
      var filter = __webpack_require__(12);

      var contains = __webpack_require__(9);
      /**
       * Flattens `array` a single level deep.
       *
       * @param {Array} arr The array to inspect.
       * @param {Array} values The values to exclude.
       * @return {Array} Returns the new array of filtered values.
       * @example
       * difference([2, 1], [2, 3]);  // => [1]
       */


      var difference = function difference(arr) {
        var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        return filter(arr, function (value) {
          return !contains(values, value);
        });
      };

      module.exports = difference;
      /***/
    },
    /* 55 */

    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(2);

      var isPlainObject = __webpack_require__(7);

      var isMatch = __webpack_require__(17);

      function find(arr, predicate) {
        var _predicate = void 0;

        if (isFunction(predicate)) {
          _predicate = predicate;
        }

        if (isPlainObject(predicate)) {
          _predicate = function _predicate(a) {
            return isMatch(a, predicate);
          };
        }

        if (_predicate) {
          for (var i = 0; i < arr.length; i += 1) {
            if (_predicate(arr[i])) {
              return arr[i];
            }
          }
        }

        return null;
      }

      module.exports = find;
      /***/
    },
    /* 56 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNil = __webpack_require__(5);

      var isArray = __webpack_require__(1);

      var firstValue = function firstValue(data, name) {
        var rst = null;

        for (var i = 0; i < data.length; i++) {
          var obj = data[i];
          var value = obj[name];

          if (!isNil(value)) {
            if (isArray(value)) {
              rst = value[0];
            } else {
              rst = value;
            }

            break;
          }
        }

        return rst;
      };

      module.exports = firstValue;
      /***/
    },
    /* 57 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(1);

      var each = __webpack_require__(0);
      /**
       * Flattens `array` a single level deep.
       *
       * @param {Array} arr The array to flatten.
       * @return {Array} Returns the new flattened array.
       * @example
       *
       * flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]
       */


      var flatten = function flatten(arr) {
        if (!isArray(arr)) {
          return arr;
        }

        var result = [];
        each(arr, function (item) {
          if (isArray(item)) {
            each(item, function (subItem) {
              result.push(subItem);
            });
          } else {
            result.push(item);
          }
        });
        return result;
      };

      module.exports = flatten;
      /***/
    },
    /* 58 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(1);
      /**
       * Flattens `array` a single level deep.
       *
       * @param {Array} arr The array to flatten.
       * @param {Array} result The array to return.
       * @return {Array} Returns the new flattened array.
       * @example
       *
       * flattenDeep([1, [2, [3, [4]], 5]]);  // => [1, 2, 3, 4, 5]
       */


      var flattenDeep = function flattenDeep(arr) {
        var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        if (!isArray(arr)) {
          result.push(arr);
        } else {
          for (var i = 0; i < arr.length; i += 1) {
            flattenDeep(arr[i], result);
          }
        }

        return result;
      };

      module.exports = flattenDeep;
      /***/
    },
    /* 59 */

    /***/
    function (module, exports, __webpack_require__) {
      var filter = __webpack_require__(12);

      var isArray = __webpack_require__(1);

      var getRange = function getRange(values) {
        // 存在 NaN 时，min,max 判定会出问题
        values = filter(values, function (v) {
          return !isNaN(v);
        });

        if (!values.length) {
          // 如果没有数值则直接返回0
          return {
            min: 0,
            max: 0
          };
        }

        if (isArray(values[0])) {
          var tmp = [];

          for (var i = 0; i < values.length; i++) {
            tmp = tmp.concat(values[i]);
          }

          values = tmp;
        }

        var max = Math.max.apply(null, values);
        var min = Math.min.apply(null, values);
        return {
          min: min,
          max: max
        };
      };

      module.exports = getRange;
      /***/
    },
    /* 60 */

    /***/
    function (module, exports) {
      var merge = function merge(dataArray) {
        var rst = [];

        for (var i = 0; i < dataArray.length; i++) {
          rst = rst.concat(dataArray[i]);
        }

        return rst;
      };

      module.exports = merge;
      /***/
    },
    /* 61 */

    /***/
    function (module, exports) {
      var arrPrototype = Array.prototype;
      var splice = arrPrototype.splice;
      var indexOf = arrPrototype.indexOf;
      var slice = arrPrototype.slice;

      var pull = function pull(arr) {
        var values = slice.call(arguments, 1);

        for (var i = 0; i < values.length; i++) {
          var value = values[i];
          var fromIndex = -1;

          while ((fromIndex = indexOf.call(arr, value)) > -1) {
            splice.call(arr, fromIndex, 1);
          }
        }

        return arr;
      };

      module.exports = pull;
      /***/
    },
    /* 62 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(1);

      var isPlainObject = __webpack_require__(7);

      var each = __webpack_require__(0);

      var reduce = function reduce(arr, fn, init) {
        if (!isArray(arr) && !isPlainObject(arr)) {
          return arr;
        }

        var result = init;
        each(arr, function (data, i) {
          result = fn(result, data, i);
        });
        return result;
      };

      module.exports = reduce;
      /***/
    },
    /* 63 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(3);

      var pullAt = __webpack_require__(19);

      var remove = function remove(arr, predicate) {
        /**
         * const arr = [1, 2, 3, 4]
         * const evens = remove(arr, n => n % 2 == 0)
         * console.log(arr) // => [1, 3]
         * console.log(evens) // => [2, 4]
         */
        var result = [];

        if (!isArrayLike(arr)) {
          return result;
        }

        var i = -1;
        var indexes = [];
        var length = arr.length;

        while (++i < length) {
          var value = arr[i];

          if (predicate(value, i, arr)) {
            result.push(value);
            indexes.push(i);
          }
        }

        pullAt(arr, indexes);
        return result;
      };

      module.exports = remove;
      /***/
    },
    /* 64 */

    /***/
    function (module, exports, __webpack_require__) {
      var isString = __webpack_require__(10);

      var isFunction = __webpack_require__(2);

      var isArray = __webpack_require__(1);

      function sortBy(arr, key) {
        var comparer = void 0;

        if (isFunction(key)) {
          comparer = function comparer(a, b) {
            return key(a) - key(b);
          };
        } else {
          var keys = [];

          if (isString(key)) {
            keys.push(key);
          } else if (isArray(key)) {
            keys = key;
          }

          comparer = function comparer(a, b) {
            for (var i = 0; i < keys.length; i += 1) {
              var prop = keys[i];

              if (a[prop] > b[prop]) {
                return 1;
              }

              if (a[prop] < b[prop]) {
                return -1;
              }
            }

            return 0;
          };
        }

        arr.sort(comparer);
        return arr;
      }

      module.exports = sortBy;
      /***/
    },
    /* 65 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(0);

      var toArray = __webpack_require__(14);

      var uniq = __webpack_require__(20);

      var union = function union() {
        var result = [];
        var sources = toArray(arguments);
        each(sources, function (arr) {
          result = result.concat(arr);
        });
        return uniq(result);
      };

      module.exports = union;
      /***/
    },
    /* 66 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNil = __webpack_require__(5);

      var isArray = __webpack_require__(1);

      var each = __webpack_require__(0);

      module.exports = function valuesOfKey(data, name) {
        var rst = [];
        var tmpMap = {};

        for (var i = 0; i < data.length; i++) {
          var obj = data[i];
          var value = obj[name];

          if (!isNil(value)) {
            if (!isArray(value)) {
              value = [value];
            }

            each(value, function (val) {
              if (!tmpMap[val]) {
                rst.push(val);
                tmpMap[val] = true;
              }
            });
          }
        }

        return rst;
      };
      /***/

    },
    /* 67 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        getWrapBehavior: __webpack_require__(68),
        wrapBehavior: __webpack_require__(69)
      };
      /***/
    },
    /* 68 */

    /***/
    function (module, exports) {
      /**
       * 获取封装的事件
       * @protected
       * @param  {Object} obj   对象
       * @param  {String} action 事件名称
       * @return {Function}        返回事件处理函数
       */
      function getWrapBehavior(obj, action) {
        return obj['_wrap_' + action];
      }

      module.exports = getWrapBehavior;
      /***/
    },
    /* 69 */

    /***/
    function (module, exports) {
      /**
       * 封装事件，便于使用上下文this,和便于解除事件时使用
       * @protected
       * @param  {Object} obj   对象
       * @param  {String} action 事件名称
       * @return {Function}        返回事件处理函数
       */
      function wrapBehavior(obj, action) {
        if (obj['_wrap_' + action]) {
          return obj['_wrap_' + action];
        }

        var method = function method(e) {
          obj[action](e);
        };

        obj['_wrap_' + action] = method;
        return method;
      }

      module.exports = wrapBehavior;
      /***/
    },
    /* 70 */

    /***/
    function (module, exports, __webpack_require__) {
      var number2color = __webpack_require__(71);

      module.exports = {
        number2color: number2color,
        numberToColor: number2color,
        parsePath: __webpack_require__(72),
        parseRadius: __webpack_require__(73)
      };
      /***/
    },
    /* 71 */

    /***/
    function (module, exports) {
      var numColorCache = {};

      module.exports = function numberToColor(num) {
        // 增加缓存
        var color = numColorCache[num];

        if (!color) {
          var str = num.toString(16);

          for (var i = str.length; i < 6; i++) {
            str = '0' + str;
          }

          color = '#' + str;
          numColorCache[num] = color;
        }

        return color;
      };
      /***/

    },
    /* 72 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(1);

      var isString = __webpack_require__(10);

      var each = __webpack_require__(0);

      var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
      var regexDot = /[^\s\,]+/ig;

      module.exports = function parsePath(path) {
        path = path || [];

        if (isArray(path)) {
          return path;
        }

        if (isString(path)) {
          path = path.match(regexTags);
          each(path, function (item, index) {
            item = item.match(regexDot);

            if (item[0].length > 1) {
              var tag = item[0].charAt(0);
              item.splice(1, 0, item[0].substr(1));
              item[0] = tag;
            }

            each(item, function (sub, i) {
              if (!isNaN(sub)) {
                item[i] = +sub;
              }
            });
            path[index] = item;
          });
          return path;
        }
      };
      /***/

    },
    /* 73 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(1);

      module.exports = function parseRadius(radius) {
        var r1 = 0,
            r2 = 0,
            r3 = 0,
            r4 = 0;

        if (isArray(radius)) {
          if (radius.length === 1) {
            r1 = r2 = r3 = r4 = radius[0];
          } else if (radius.length === 2) {
            r1 = r3 = radius[0];
            r2 = r4 = radius[1];
          } else if (radius.length === 3) {
            r1 = radius[0];
            r2 = r4 = radius[1];
            r3 = radius[2];
          } else {
            r1 = radius[0];
            r2 = radius[1];
            r3 = radius[2];
            r4 = radius[3];
          }
        } else {
          r1 = r2 = r3 = r4 = radius;
        }

        return {
          r1: r1,
          r2: r2,
          r3: r3,
          r4: r4
        };
      };
      /***/

    },
    /* 74 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumberEqual = __webpack_require__(75);

      module.exports = {
        clamp: __webpack_require__(21),
        fixedBase: __webpack_require__(76),
        isDecimal: __webpack_require__(77),
        isEven: __webpack_require__(78),
        isInteger: __webpack_require__(79),
        isNegative: __webpack_require__(80),
        isNumberEqual: isNumberEqual,
        isOdd: __webpack_require__(81),
        isPositive: __webpack_require__(82),
        maxBy: __webpack_require__(83),
        minBy: __webpack_require__(84),
        mod: __webpack_require__(85),
        snapEqual: isNumberEqual,
        toDegree: __webpack_require__(86),
        toInt: __webpack_require__(22),
        toInteger: __webpack_require__(22),
        toRadian: __webpack_require__(87)
      };
      /***/
    },
    /* 75 */

    /***/
    function (module, exports) {
      var PRECISION = 0.00001; // numbers less than this is considered as 0

      module.exports = function isNumberEqual(a, b) {
        var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PRECISION;
        return Math.abs(a - b) < precision;
      };
      /***/

    },
    /* 76 */

    /***/
    function (module, exports) {
      var fixedBase = function fixedBase(v, base) {
        var str = base.toString();
        var index = str.indexOf('.');

        if (index === -1) {
          return Math.round(v);
        }

        var length = str.substr(index + 1).length;

        if (length > 20) {
          length = 20;
        }

        return parseFloat(v.toFixed(length));
      };

      module.exports = fixedBase;
      /***/
    },
    /* 77 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(6);

      var isDecimal = function isDecimal(num) {
        return isNumber(num) && num % 1 !== 0;
      };

      module.exports = isDecimal;
      /***/
    },
    /* 78 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(6);

      var isEven = function isEven(num) {
        return isNumber(num) && num % 2 === 0;
      };

      module.exports = isEven;
      /***/
    },
    /* 79 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(6);

      var isInteger = Number.isInteger ? Number.isInteger : function (num) {
        return isNumber(num) && num % 1 === 0;
      };
      module.exports = isInteger;
      /***/
    },
    /* 80 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(6);

      var isNagative = function isNagative(num) {
        return isNumber(num) && num < 0;
      };

      module.exports = isNagative;
      /***/
    },
    /* 81 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(6);

      var isOdd = function isOdd(num) {
        return isNumber(num) && num % 2 !== 0;
      };

      module.exports = isOdd;
      /***/
    },
    /* 82 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNumber = __webpack_require__(6);

      var isPositive = function isPositive(num) {
        return isNumber(num) && num > 0;
      };

      module.exports = isPositive;
      /***/
    },
    /* 83 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(1);

      var isFunction = __webpack_require__(2);

      var each = __webpack_require__(0);
      /**
       * @param {Array} arr The array to iterate over.
       * @param {Function} [fn] The iteratee invoked per element.
       * @return {*} Returns the maximum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * maxBy(objects, function(o) { return o.n; });
       * // => { 'n': 2 }
       *
       * maxBy(objects, 'n');
       * // => { 'n': 2 }
       */


      var maxBy = function maxBy(arr, fn) {
        if (!isArray(arr)) {
          return undefined;
        }

        var max = arr[0];
        var maxData = void 0;

        if (isFunction(fn)) {
          maxData = fn(arr[0]);
        } else {
          maxData = arr[0][fn];
        }

        var data = void 0;
        each(arr, function (val) {
          if (isFunction(fn)) {
            data = fn(val);
          } else {
            data = val[fn];
          }

          if (data > maxData) {
            max = val;
            maxData = data;
          }
        });
        return max;
      };

      module.exports = maxBy;
      /***/
    },
    /* 84 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(1);

      var isFunction = __webpack_require__(2);

      var each = __webpack_require__(0);
      /**
       * @param {Array} arr The array to iterate over.
       * @param {Function} [fn] The iteratee invoked per element.
       * @return {*} Returns the minimum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * minBy(objects, function(o) { return o.n; });
       * // => { 'n': 1 }
       *
       * minBy(objects, 'n');
       * // => { 'n': 1 }
       */


      var minBy = function minBy(arr, fn) {
        if (!isArray(arr)) {
          return undefined;
        }

        var min = arr[0];
        var minData = void 0;

        if (isFunction(fn)) {
          minData = fn(arr[0]);
        } else {
          minData = arr[0][fn];
        }

        var data = void 0;
        each(arr, function (val) {
          if (isFunction(fn)) {
            data = fn(val);
          } else {
            data = val[fn];
          }

          if (data < minData) {
            min = val;
            minData = data;
          }
        });
        return min;
      };

      module.exports = minBy;
      /***/
    },
    /* 85 */

    /***/
    function (module, exports) {
      var mod = function mod(n, m) {
        return (n % m + m) % m;
      };

      module.exports = mod;
      /***/
    },
    /* 86 */

    /***/
    function (module, exports) {
      var DEGREE = 180 / Math.PI;

      var toDegree = function toDegree(radian) {
        return DEGREE * radian;
      };

      module.exports = toDegree;
      /***/
    },
    /* 87 */

    /***/
    function (module, exports) {
      var RADIAN = Math.PI / 180;

      var toRadian = function toRadian(degree) {
        return RADIAN * degree;
      };

      module.exports = toRadian;
      /***/
    },
    /* 88 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        mat3: __webpack_require__(23),
        vec2: __webpack_require__(90),
        vec3: __webpack_require__(92),
        transform: __webpack_require__(94)
      };
      /***/
    },
    /* 89 */

    /***/
    function (module, exports, __webpack_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sub = exports.mul = undefined;
      exports.create = create;
      exports.fromMat4 = fromMat4;
      exports.clone = clone;
      exports.copy = copy;
      exports.fromValues = fromValues;
      exports.set = set;
      exports.identity = identity;
      exports.transpose = transpose;
      exports.invert = invert;
      exports.adjoint = adjoint;
      exports.determinant = determinant;
      exports.multiply = multiply;
      exports.translate = translate;
      exports.rotate = rotate;
      exports.scale = scale;
      exports.fromTranslation = fromTranslation;
      exports.fromRotation = fromRotation;
      exports.fromScaling = fromScaling;
      exports.fromMat2d = fromMat2d;
      exports.fromQuat = fromQuat;
      exports.normalFromMat4 = normalFromMat4;
      exports.projection = projection;
      exports.str = str;
      exports.frob = frob;
      exports.add = add;
      exports.subtract = subtract;
      exports.multiplyScalar = multiplyScalar;
      exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
      exports.exactEquals = exactEquals;
      exports.equals = equals;

      var _common = __webpack_require__(15);

      var glMatrix = _interopRequireWildcard(_common);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }
      /**
       * 3x3 Matrix
       * @module mat3
       */

      /**
       * Creates a new identity mat3
       *
       * @returns {mat3} a new 3x3 matrix
       */


      function create() {
        var out = new glMatrix.ARRAY_TYPE(9);

        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[5] = 0;
          out[6] = 0;
          out[7] = 0;
        }

        out[0] = 1;
        out[4] = 1;
        out[8] = 1;
        return out;
      }
      /**
       * Copies the upper-left 3x3 values into the given mat3.
       *
       * @param {mat3} out the receiving 3x3 matrix
       * @param {mat4} a   the source 4x4 matrix
       * @returns {mat3} out
       */


      function fromMat4(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[4];
        out[4] = a[5];
        out[5] = a[6];
        out[6] = a[8];
        out[7] = a[9];
        out[8] = a[10];
        return out;
      }
      /**
       * Creates a new mat3 initialized with values from an existing matrix
       *
       * @param {mat3} a matrix to clone
       * @returns {mat3} a new 3x3 matrix
       */


      function clone(a) {
        var out = new glMatrix.ARRAY_TYPE(9);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        return out;
      }
      /**
       * Copy the values from one mat3 to another
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the source matrix
       * @returns {mat3} out
       */


      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        return out;
      }
      /**
       * Create a new mat3 with the given values
       *
       * @param {Number} m00 Component in column 0, row 0 position (index 0)
       * @param {Number} m01 Component in column 0, row 1 position (index 1)
       * @param {Number} m02 Component in column 0, row 2 position (index 2)
       * @param {Number} m10 Component in column 1, row 0 position (index 3)
       * @param {Number} m11 Component in column 1, row 1 position (index 4)
       * @param {Number} m12 Component in column 1, row 2 position (index 5)
       * @param {Number} m20 Component in column 2, row 0 position (index 6)
       * @param {Number} m21 Component in column 2, row 1 position (index 7)
       * @param {Number} m22 Component in column 2, row 2 position (index 8)
       * @returns {mat3} A new mat3
       */


      function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        var out = new glMatrix.ARRAY_TYPE(9);
        out[0] = m00;
        out[1] = m01;
        out[2] = m02;
        out[3] = m10;
        out[4] = m11;
        out[5] = m12;
        out[6] = m20;
        out[7] = m21;
        out[8] = m22;
        return out;
      }
      /**
       * Set the components of a mat3 to the given values
       *
       * @param {mat3} out the receiving matrix
       * @param {Number} m00 Component in column 0, row 0 position (index 0)
       * @param {Number} m01 Component in column 0, row 1 position (index 1)
       * @param {Number} m02 Component in column 0, row 2 position (index 2)
       * @param {Number} m10 Component in column 1, row 0 position (index 3)
       * @param {Number} m11 Component in column 1, row 1 position (index 4)
       * @param {Number} m12 Component in column 1, row 2 position (index 5)
       * @param {Number} m20 Component in column 2, row 0 position (index 6)
       * @param {Number} m21 Component in column 2, row 1 position (index 7)
       * @param {Number} m22 Component in column 2, row 2 position (index 8)
       * @returns {mat3} out
       */


      function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        out[0] = m00;
        out[1] = m01;
        out[2] = m02;
        out[3] = m10;
        out[4] = m11;
        out[5] = m12;
        out[6] = m20;
        out[7] = m21;
        out[8] = m22;
        return out;
      }
      /**
       * Set a mat3 to the identity matrix
       *
       * @param {mat3} out the receiving matrix
       * @returns {mat3} out
       */


      function identity(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 1;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
      }
      /**
       * Transpose the values of a mat3
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the source matrix
       * @returns {mat3} out
       */


      function transpose(out, a) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (out === a) {
          var a01 = a[1],
              a02 = a[2],
              a12 = a[5];
          out[1] = a[3];
          out[2] = a[6];
          out[3] = a01;
          out[5] = a[7];
          out[6] = a02;
          out[7] = a12;
        } else {
          out[0] = a[0];
          out[1] = a[3];
          out[2] = a[6];
          out[3] = a[1];
          out[4] = a[4];
          out[5] = a[7];
          out[6] = a[2];
          out[7] = a[5];
          out[8] = a[8];
        }

        return out;
      }
      /**
       * Inverts a mat3
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the source matrix
       * @returns {mat3} out
       */


      function invert(out, a) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2];
        var a10 = a[3],
            a11 = a[4],
            a12 = a[5];
        var a20 = a[6],
            a21 = a[7],
            a22 = a[8];
        var b01 = a22 * a11 - a12 * a21;
        var b11 = -a22 * a10 + a12 * a20;
        var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

        var det = a00 * b01 + a01 * b11 + a02 * b21;

        if (!det) {
          return null;
        }

        det = 1.0 / det;
        out[0] = b01 * det;
        out[1] = (-a22 * a01 + a02 * a21) * det;
        out[2] = (a12 * a01 - a02 * a11) * det;
        out[3] = b11 * det;
        out[4] = (a22 * a00 - a02 * a20) * det;
        out[5] = (-a12 * a00 + a02 * a10) * det;
        out[6] = b21 * det;
        out[7] = (-a21 * a00 + a01 * a20) * det;
        out[8] = (a11 * a00 - a01 * a10) * det;
        return out;
      }
      /**
       * Calculates the adjugate of a mat3
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the source matrix
       * @returns {mat3} out
       */


      function adjoint(out, a) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2];
        var a10 = a[3],
            a11 = a[4],
            a12 = a[5];
        var a20 = a[6],
            a21 = a[7],
            a22 = a[8];
        out[0] = a11 * a22 - a12 * a21;
        out[1] = a02 * a21 - a01 * a22;
        out[2] = a01 * a12 - a02 * a11;
        out[3] = a12 * a20 - a10 * a22;
        out[4] = a00 * a22 - a02 * a20;
        out[5] = a02 * a10 - a00 * a12;
        out[6] = a10 * a21 - a11 * a20;
        out[7] = a01 * a20 - a00 * a21;
        out[8] = a00 * a11 - a01 * a10;
        return out;
      }
      /**
       * Calculates the determinant of a mat3
       *
       * @param {mat3} a the source matrix
       * @returns {Number} determinant of a
       */


      function determinant(a) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2];
        var a10 = a[3],
            a11 = a[4],
            a12 = a[5];
        var a20 = a[6],
            a21 = a[7],
            a22 = a[8];
        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
      }
      /**
       * Multiplies two mat3's
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the first operand
       * @param {mat3} b the second operand
       * @returns {mat3} out
       */


      function multiply(out, a, b) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2];
        var a10 = a[3],
            a11 = a[4],
            a12 = a[5];
        var a20 = a[6],
            a21 = a[7],
            a22 = a[8];
        var b00 = b[0],
            b01 = b[1],
            b02 = b[2];
        var b10 = b[3],
            b11 = b[4],
            b12 = b[5];
        var b20 = b[6],
            b21 = b[7],
            b22 = b[8];
        out[0] = b00 * a00 + b01 * a10 + b02 * a20;
        out[1] = b00 * a01 + b01 * a11 + b02 * a21;
        out[2] = b00 * a02 + b01 * a12 + b02 * a22;
        out[3] = b10 * a00 + b11 * a10 + b12 * a20;
        out[4] = b10 * a01 + b11 * a11 + b12 * a21;
        out[5] = b10 * a02 + b11 * a12 + b12 * a22;
        out[6] = b20 * a00 + b21 * a10 + b22 * a20;
        out[7] = b20 * a01 + b21 * a11 + b22 * a21;
        out[8] = b20 * a02 + b21 * a12 + b22 * a22;
        return out;
      }
      /**
       * Translate a mat3 by the given vector
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the matrix to translate
       * @param {vec2} v vector to translate by
       * @returns {mat3} out
       */


      function translate(out, a, v) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a10 = a[3],
            a11 = a[4],
            a12 = a[5],
            a20 = a[6],
            a21 = a[7],
            a22 = a[8],
            x = v[0],
            y = v[1];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a10;
        out[4] = a11;
        out[5] = a12;
        out[6] = x * a00 + y * a10 + a20;
        out[7] = x * a01 + y * a11 + a21;
        out[8] = x * a02 + y * a12 + a22;
        return out;
      }
      /**
       * Rotates a mat3 by the given angle
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the matrix to rotate
       * @param {Number} rad the angle to rotate the matrix by
       * @returns {mat3} out
       */


      function rotate(out, a, rad) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a10 = a[3],
            a11 = a[4],
            a12 = a[5],
            a20 = a[6],
            a21 = a[7],
            a22 = a[8],
            s = Math.sin(rad),
            c = Math.cos(rad);
        out[0] = c * a00 + s * a10;
        out[1] = c * a01 + s * a11;
        out[2] = c * a02 + s * a12;
        out[3] = c * a10 - s * a00;
        out[4] = c * a11 - s * a01;
        out[5] = c * a12 - s * a02;
        out[6] = a20;
        out[7] = a21;
        out[8] = a22;
        return out;
      }

      ;
      /**
       * Scales the mat3 by the dimensions in the given vec2
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the matrix to rotate
       * @param {vec2} v the vec2 to scale the matrix by
       * @returns {mat3} out
       **/

      function scale(out, a, v) {
        var x = v[0],
            y = v[1];
        out[0] = x * a[0];
        out[1] = x * a[1];
        out[2] = x * a[2];
        out[3] = y * a[3];
        out[4] = y * a[4];
        out[5] = y * a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        return out;
      }
      /**
       * Creates a matrix from a vector translation
       * This is equivalent to (but much faster than):
       *
       *     mat3.identity(dest);
       *     mat3.translate(dest, dest, vec);
       *
       * @param {mat3} out mat3 receiving operation result
       * @param {vec2} v Translation vector
       * @returns {mat3} out
       */


      function fromTranslation(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 1;
        out[5] = 0;
        out[6] = v[0];
        out[7] = v[1];
        out[8] = 1;
        return out;
      }
      /**
       * Creates a matrix from a given angle
       * This is equivalent to (but much faster than):
       *
       *     mat3.identity(dest);
       *     mat3.rotate(dest, dest, rad);
       *
       * @param {mat3} out mat3 receiving operation result
       * @param {Number} rad the angle to rotate the matrix by
       * @returns {mat3} out
       */


      function fromRotation(out, rad) {
        var s = Math.sin(rad),
            c = Math.cos(rad);
        out[0] = c;
        out[1] = s;
        out[2] = 0;
        out[3] = -s;
        out[4] = c;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
      }
      /**
       * Creates a matrix from a vector scaling
       * This is equivalent to (but much faster than):
       *
       *     mat3.identity(dest);
       *     mat3.scale(dest, dest, vec);
       *
       * @param {mat3} out mat3 receiving operation result
       * @param {vec2} v Scaling vector
       * @returns {mat3} out
       */


      function fromScaling(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = v[1];
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
      }
      /**
       * Copies the values from a mat2d into a mat3
       *
       * @param {mat3} out the receiving matrix
       * @param {mat2d} a the matrix to copy
       * @returns {mat3} out
       **/


      function fromMat2d(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = 0;
        out[3] = a[2];
        out[4] = a[3];
        out[5] = 0;
        out[6] = a[4];
        out[7] = a[5];
        out[8] = 1;
        return out;
      }
      /**
      * Calculates a 3x3 matrix from the given quaternion
      *
      * @param {mat3} out mat3 receiving operation result
      * @param {quat} q Quaternion to create matrix from
      *
      * @returns {mat3} out
      */


      function fromQuat(out, q) {
        var x = q[0],
            y = q[1],
            z = q[2],
            w = q[3];
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        out[0] = 1 - yy - zz;
        out[3] = yx - wz;
        out[6] = zx + wy;
        out[1] = yx + wz;
        out[4] = 1 - xx - zz;
        out[7] = zy - wx;
        out[2] = zx - wy;
        out[5] = zy + wx;
        out[8] = 1 - xx - yy;
        return out;
      }
      /**
      * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
      *
      * @param {mat3} out mat3 receiving operation result
      * @param {mat4} a Mat4 to derive the normal matrix from
      *
      * @returns {mat3} out
      */


      function normalFromMat4(out, a) {
        var a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3];
        var a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7];
        var a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];
        var a30 = a[12],
            a31 = a[13],
            a32 = a[14],
            a33 = a[15];
        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det) {
          return null;
        }

        det = 1.0 / det;
        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        return out;
      }
      /**
       * Generates a 2D projection matrix with the given bounds
       *
       * @param {mat3} out mat3 frustum matrix will be written into
       * @param {number} width Width of your gl context
       * @param {number} height Height of gl context
       * @returns {mat3} out
       */


      function projection(out, width, height) {
        out[0] = 2 / width;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = -2 / height;
        out[5] = 0;
        out[6] = -1;
        out[7] = 1;
        out[8] = 1;
        return out;
      }
      /**
       * Returns a string representation of a mat3
       *
       * @param {mat3} a matrix to represent as a string
       * @returns {String} string representation of the matrix
       */


      function str(a) {
        return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
      }
      /**
       * Returns Frobenius norm of a mat3
       *
       * @param {mat3} a the matrix to calculate Frobenius norm of
       * @returns {Number} Frobenius norm
       */


      function frob(a) {
        return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
      }
      /**
       * Adds two mat3's
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the first operand
       * @param {mat3} b the second operand
       * @returns {mat3} out
       */


      function add(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        out[2] = a[2] + b[2];
        out[3] = a[3] + b[3];
        out[4] = a[4] + b[4];
        out[5] = a[5] + b[5];
        out[6] = a[6] + b[6];
        out[7] = a[7] + b[7];
        out[8] = a[8] + b[8];
        return out;
      }
      /**
       * Subtracts matrix b from matrix a
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the first operand
       * @param {mat3} b the second operand
       * @returns {mat3} out
       */


      function subtract(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        out[2] = a[2] - b[2];
        out[3] = a[3] - b[3];
        out[4] = a[4] - b[4];
        out[5] = a[5] - b[5];
        out[6] = a[6] - b[6];
        out[7] = a[7] - b[7];
        out[8] = a[8] - b[8];
        return out;
      }
      /**
       * Multiply each element of the matrix by a scalar.
       *
       * @param {mat3} out the receiving matrix
       * @param {mat3} a the matrix to scale
       * @param {Number} b amount to scale the matrix's elements by
       * @returns {mat3} out
       */


      function multiplyScalar(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        out[2] = a[2] * b;
        out[3] = a[3] * b;
        out[4] = a[4] * b;
        out[5] = a[5] * b;
        out[6] = a[6] * b;
        out[7] = a[7] * b;
        out[8] = a[8] * b;
        return out;
      }
      /**
       * Adds two mat3's after multiplying each element of the second operand by a scalar value.
       *
       * @param {mat3} out the receiving vector
       * @param {mat3} a the first operand
       * @param {mat3} b the second operand
       * @param {Number} scale the amount to scale b's elements by before adding
       * @returns {mat3} out
       */


      function multiplyScalarAndAdd(out, a, b, scale) {
        out[0] = a[0] + b[0] * scale;
        out[1] = a[1] + b[1] * scale;
        out[2] = a[2] + b[2] * scale;
        out[3] = a[3] + b[3] * scale;
        out[4] = a[4] + b[4] * scale;
        out[5] = a[5] + b[5] * scale;
        out[6] = a[6] + b[6] * scale;
        out[7] = a[7] + b[7] * scale;
        out[8] = a[8] + b[8] * scale;
        return out;
      }
      /**
       * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
       *
       * @param {mat3} a The first matrix.
       * @param {mat3} b The second matrix.
       * @returns {Boolean} True if the matrices are equal, false otherwise.
       */


      function exactEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
      }
      /**
       * Returns whether or not the matrices have approximately the same elements in the same position.
       *
       * @param {mat3} a The first matrix.
       * @param {mat3} b The second matrix.
       * @returns {Boolean} True if the matrices are equal, false otherwise.
       */


      function equals(a, b) {
        var a0 = a[0],
            a1 = a[1],
            a2 = a[2],
            a3 = a[3],
            a4 = a[4],
            a5 = a[5],
            a6 = a[6],
            a7 = a[7],
            a8 = a[8];
        var b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3],
            b4 = b[4],
            b5 = b[5],
            b6 = b[6],
            b7 = b[7],
            b8 = b[8];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
      }
      /**
       * Alias for {@link mat3.multiply}
       * @function
       */


      var mul = exports.mul = multiply;
      /**
       * Alias for {@link mat3.subtract}
       * @function
       */

      var sub = exports.sub = subtract;
      /***/
    },
    /* 90 */

    /***/
    function (module, exports, __webpack_require__) {
      var vec2 = __webpack_require__(91);

      var clamp = __webpack_require__(21);

      vec2.angle = function (v1, v2) {
        var theta = vec2.dot(v1, v2) / (vec2.length(v1) * vec2.length(v2));
        return Math.acos(clamp(theta, -1, 1));
      };
      /**
       * 向量 v1 到 向量 v2 夹角的方向
       * @param  {Array} v1 向量
       * @param  {Array} v2 向量
       * @return {Boolean} >= 0 顺时针 < 0 逆时针
       */


      vec2.direction = function (v1, v2) {
        return v1[0] * v2[1] - v2[0] * v1[1];
      };

      vec2.angleTo = function (v1, v2, direct) {
        var angle = vec2.angle(v1, v2);
        var angleLargeThanPI = vec2.direction(v1, v2) >= 0;

        if (direct) {
          if (angleLargeThanPI) {
            return Math.PI * 2 - angle;
          }

          return angle;
        }

        if (angleLargeThanPI) {
          return angle;
        }

        return Math.PI * 2 - angle;
      };

      vec2.vertical = function (out, v, flag) {
        if (flag) {
          out[0] = v[1];
          out[1] = -1 * v[0];
        } else {
          out[0] = -1 * v[1];
          out[1] = v[0];
        }

        return out;
      };

      module.exports = vec2;
      /***/
    },
    /* 91 */

    /***/
    function (module, exports, __webpack_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = undefined;
      exports.create = create;
      exports.clone = clone;
      exports.fromValues = fromValues;
      exports.copy = copy;
      exports.set = set;
      exports.add = add;
      exports.subtract = subtract;
      exports.multiply = multiply;
      exports.divide = divide;
      exports.ceil = ceil;
      exports.floor = floor;
      exports.min = min;
      exports.max = max;
      exports.round = round;
      exports.scale = scale;
      exports.scaleAndAdd = scaleAndAdd;
      exports.distance = distance;
      exports.squaredDistance = squaredDistance;
      exports.length = length;
      exports.squaredLength = squaredLength;
      exports.negate = negate;
      exports.inverse = inverse;
      exports.normalize = normalize;
      exports.dot = dot;
      exports.cross = cross;
      exports.lerp = lerp;
      exports.random = random;
      exports.transformMat2 = transformMat2;
      exports.transformMat2d = transformMat2d;
      exports.transformMat3 = transformMat3;
      exports.transformMat4 = transformMat4;
      exports.rotate = rotate;
      exports.angle = angle;
      exports.str = str;
      exports.exactEquals = exactEquals;
      exports.equals = equals;

      var _common = __webpack_require__(15);

      var glMatrix = _interopRequireWildcard(_common);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }
      /**
       * 2 Dimensional Vector
       * @module vec2
       */

      /**
       * Creates a new, empty vec2
       *
       * @returns {vec2} a new 2D vector
       */


      function create() {
        var out = new glMatrix.ARRAY_TYPE(2);

        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[0] = 0;
          out[1] = 0;
        }

        return out;
      }
      /**
       * Creates a new vec2 initialized with values from an existing vector
       *
       * @param {vec2} a vector to clone
       * @returns {vec2} a new 2D vector
       */


      function clone(a) {
        var out = new glMatrix.ARRAY_TYPE(2);
        out[0] = a[0];
        out[1] = a[1];
        return out;
      }
      /**
       * Creates a new vec2 initialized with the given values
       *
       * @param {Number} x X component
       * @param {Number} y Y component
       * @returns {vec2} a new 2D vector
       */


      function fromValues(x, y) {
        var out = new glMatrix.ARRAY_TYPE(2);
        out[0] = x;
        out[1] = y;
        return out;
      }
      /**
       * Copy the values from one vec2 to another
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the source vector
       * @returns {vec2} out
       */


      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        return out;
      }
      /**
       * Set the components of a vec2 to the given values
       *
       * @param {vec2} out the receiving vector
       * @param {Number} x X component
       * @param {Number} y Y component
       * @returns {vec2} out
       */


      function set(out, x, y) {
        out[0] = x;
        out[1] = y;
        return out;
      }
      /**
       * Adds two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function add(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        return out;
      }
      /**
       * Subtracts vector b from vector a
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function subtract(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        return out;
      }
      /**
       * Multiplies two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function multiply(out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        return out;
      }
      /**
       * Divides two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function divide(out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        return out;
      }
      /**
       * Math.ceil the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to ceil
       * @returns {vec2} out
       */


      function ceil(out, a) {
        out[0] = Math.ceil(a[0]);
        out[1] = Math.ceil(a[1]);
        return out;
      }
      /**
       * Math.floor the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to floor
       * @returns {vec2} out
       */


      function floor(out, a) {
        out[0] = Math.floor(a[0]);
        out[1] = Math.floor(a[1]);
        return out;
      }
      /**
       * Returns the minimum of two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function min(out, a, b) {
        out[0] = Math.min(a[0], b[0]);
        out[1] = Math.min(a[1], b[1]);
        return out;
      }
      /**
       * Returns the maximum of two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec2} out
       */


      function max(out, a, b) {
        out[0] = Math.max(a[0], b[0]);
        out[1] = Math.max(a[1], b[1]);
        return out;
      }
      /**
       * Math.round the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to round
       * @returns {vec2} out
       */


      function round(out, a) {
        out[0] = Math.round(a[0]);
        out[1] = Math.round(a[1]);
        return out;
      }
      /**
       * Scales a vec2 by a scalar number
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to scale
       * @param {Number} b amount to scale the vector by
       * @returns {vec2} out
       */


      function scale(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        return out;
      }
      /**
       * Adds two vec2's after scaling the second operand by a scalar value
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @param {Number} scale the amount to scale b by before adding
       * @returns {vec2} out
       */


      function scaleAndAdd(out, a, b, scale) {
        out[0] = a[0] + b[0] * scale;
        out[1] = a[1] + b[1] * scale;
        return out;
      }
      /**
       * Calculates the euclidian distance between two vec2's
       *
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {Number} distance between a and b
       */


      function distance(a, b) {
        var x = b[0] - a[0],
            y = b[1] - a[1];
        return Math.sqrt(x * x + y * y);
      }
      /**
       * Calculates the squared euclidian distance between two vec2's
       *
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {Number} squared distance between a and b
       */


      function squaredDistance(a, b) {
        var x = b[0] - a[0],
            y = b[1] - a[1];
        return x * x + y * y;
      }
      /**
       * Calculates the length of a vec2
       *
       * @param {vec2} a vector to calculate length of
       * @returns {Number} length of a
       */


      function length(a) {
        var x = a[0],
            y = a[1];
        return Math.sqrt(x * x + y * y);
      }
      /**
       * Calculates the squared length of a vec2
       *
       * @param {vec2} a vector to calculate squared length of
       * @returns {Number} squared length of a
       */


      function squaredLength(a) {
        var x = a[0],
            y = a[1];
        return x * x + y * y;
      }
      /**
       * Negates the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to negate
       * @returns {vec2} out
       */


      function negate(out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        return out;
      }
      /**
       * Returns the inverse of the components of a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to invert
       * @returns {vec2} out
       */


      function inverse(out, a) {
        out[0] = 1.0 / a[0];
        out[1] = 1.0 / a[1];
        return out;
      }
      /**
       * Normalize a vec2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a vector to normalize
       * @returns {vec2} out
       */


      function normalize(out, a) {
        var x = a[0],
            y = a[1];
        var len = x * x + y * y;

        if (len > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          out[0] = a[0] * len;
          out[1] = a[1] * len;
        }

        return out;
      }
      /**
       * Calculates the dot product of two vec2's
       *
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {Number} dot product of a and b
       */


      function dot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      }
      /**
       * Computes the cross product of two vec2's
       * Note that the cross product must by definition produce a 3D vector
       *
       * @param {vec3} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @returns {vec3} out
       */


      function cross(out, a, b) {
        var z = a[0] * b[1] - a[1] * b[0];
        out[0] = out[1] = 0;
        out[2] = z;
        return out;
      }
      /**
       * Performs a linear interpolation between two vec2's
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the first operand
       * @param {vec2} b the second operand
       * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
       * @returns {vec2} out
       */


      function lerp(out, a, b, t) {
        var ax = a[0],
            ay = a[1];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        return out;
      }
      /**
       * Generates a random vector with the given scale
       *
       * @param {vec2} out the receiving vector
       * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
       * @returns {vec2} out
       */


      function random(out, scale) {
        scale = scale || 1.0;
        var r = glMatrix.RANDOM() * 2.0 * Math.PI;
        out[0] = Math.cos(r) * scale;
        out[1] = Math.sin(r) * scale;
        return out;
      }
      /**
       * Transforms the vec2 with a mat2
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat2} m matrix to transform with
       * @returns {vec2} out
       */


      function transformMat2(out, a, m) {
        var x = a[0],
            y = a[1];
        out[0] = m[0] * x + m[2] * y;
        out[1] = m[1] * x + m[3] * y;
        return out;
      }
      /**
       * Transforms the vec2 with a mat2d
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat2d} m matrix to transform with
       * @returns {vec2} out
       */


      function transformMat2d(out, a, m) {
        var x = a[0],
            y = a[1];
        out[0] = m[0] * x + m[2] * y + m[4];
        out[1] = m[1] * x + m[3] * y + m[5];
        return out;
      }
      /**
       * Transforms the vec2 with a mat3
       * 3rd vector component is implicitly '1'
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat3} m matrix to transform with
       * @returns {vec2} out
       */


      function transformMat3(out, a, m) {
        var x = a[0],
            y = a[1];
        out[0] = m[0] * x + m[3] * y + m[6];
        out[1] = m[1] * x + m[4] * y + m[7];
        return out;
      }
      /**
       * Transforms the vec2 with a mat4
       * 3rd vector component is implicitly '0'
       * 4th vector component is implicitly '1'
       *
       * @param {vec2} out the receiving vector
       * @param {vec2} a the vector to transform
       * @param {mat4} m matrix to transform with
       * @returns {vec2} out
       */


      function transformMat4(out, a, m) {
        var x = a[0];
        var y = a[1];
        out[0] = m[0] * x + m[4] * y + m[12];
        out[1] = m[1] * x + m[5] * y + m[13];
        return out;
      }
      /**
       * Rotate a 2D vector
       * @param {vec2} out The receiving vec2
       * @param {vec2} a The vec2 point to rotate
       * @param {vec2} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec2} out
       */


      function rotate(out, a, b, c) {
        //Translate point to the origin
        var p0 = a[0] - b[0],
            p1 = a[1] - b[1],
            sinC = Math.sin(c),
            cosC = Math.cos(c); //perform rotation and translate to correct position

        out[0] = p0 * cosC - p1 * sinC + b[0];
        out[1] = p0 * sinC + p1 * cosC + b[1];
        return out;
      }
      /**
       * Get the angle between two 2D vectors
       * @param {vec2} a The first operand
       * @param {vec2} b The second operand
       * @returns {Number} The angle in radians
       */


      function angle(a, b) {
        var x1 = a[0],
            y1 = a[1],
            x2 = b[0],
            y2 = b[1];
        var len1 = x1 * x1 + y1 * y1;

        if (len1 > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len1 = 1 / Math.sqrt(len1);
        }

        var len2 = x2 * x2 + y2 * y2;

        if (len2 > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len2 = 1 / Math.sqrt(len2);
        }

        var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

        if (cosine > 1.0) {
          return 0;
        } else if (cosine < -1.0) {
          return Math.PI;
        } else {
          return Math.acos(cosine);
        }
      }
      /**
       * Returns a string representation of a vector
       *
       * @param {vec2} a vector to represent as a string
       * @returns {String} string representation of the vector
       */


      function str(a) {
        return 'vec2(' + a[0] + ', ' + a[1] + ')';
      }
      /**
       * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
       *
       * @param {vec2} a The first vector.
       * @param {vec2} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */


      function exactEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1];
      }
      /**
       * Returns whether or not the vectors have approximately the same elements in the same position.
       *
       * @param {vec2} a The first vector.
       * @param {vec2} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */


      function equals(a, b) {
        var a0 = a[0],
            a1 = a[1];
        var b0 = b[0],
            b1 = b[1];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
      }
      /**
       * Alias for {@link vec2.length}
       * @function
       */


      var len = exports.len = length;
      /**
       * Alias for {@link vec2.subtract}
       * @function
       */

      var sub = exports.sub = subtract;
      /**
       * Alias for {@link vec2.multiply}
       * @function
       */

      var mul = exports.mul = multiply;
      /**
       * Alias for {@link vec2.divide}
       * @function
       */

      var div = exports.div = divide;
      /**
       * Alias for {@link vec2.distance}
       * @function
       */

      var dist = exports.dist = distance;
      /**
       * Alias for {@link vec2.squaredDistance}
       * @function
       */

      var sqrDist = exports.sqrDist = squaredDistance;
      /**
       * Alias for {@link vec2.squaredLength}
       * @function
       */

      var sqrLen = exports.sqrLen = squaredLength;
      /**
       * Perform some operation over an array of vec2s.
       *
       * @param {Array} a the array of vectors to iterate over
       * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
       * @param {Number} offset Number of elements to skip at the beginning of the array
       * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
       * @param {Function} fn Function to call for each vector in the array
       * @param {Object} [arg] additional argument to pass to fn
       * @returns {Array} a
       * @function
       */

      var forEach = exports.forEach = function () {
        var vec = create();
        return function (a, stride, offset, count, fn, arg) {
          var i = void 0,
              l = void 0;

          if (!stride) {
            stride = 2;
          }

          if (!offset) {
            offset = 0;
          }

          if (count) {
            l = Math.min(count * stride + offset, a.length);
          } else {
            l = a.length;
          }

          for (i = offset; i < l; i += stride) {
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
          }

          return a;
        };
      }();
      /***/

    },
    /* 92 */

    /***/
    function (module, exports, __webpack_require__) {
      var vec3 = __webpack_require__(93);

      module.exports = vec3;
      /***/
    },
    /* 93 */

    /***/
    function (module, exports, __webpack_require__) {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;
      exports.create = create;
      exports.clone = clone;
      exports.length = length;
      exports.fromValues = fromValues;
      exports.copy = copy;
      exports.set = set;
      exports.add = add;
      exports.subtract = subtract;
      exports.multiply = multiply;
      exports.divide = divide;
      exports.ceil = ceil;
      exports.floor = floor;
      exports.min = min;
      exports.max = max;
      exports.round = round;
      exports.scale = scale;
      exports.scaleAndAdd = scaleAndAdd;
      exports.distance = distance;
      exports.squaredDistance = squaredDistance;
      exports.squaredLength = squaredLength;
      exports.negate = negate;
      exports.inverse = inverse;
      exports.normalize = normalize;
      exports.dot = dot;
      exports.cross = cross;
      exports.lerp = lerp;
      exports.hermite = hermite;
      exports.bezier = bezier;
      exports.random = random;
      exports.transformMat4 = transformMat4;
      exports.transformMat3 = transformMat3;
      exports.transformQuat = transformQuat;
      exports.rotateX = rotateX;
      exports.rotateY = rotateY;
      exports.rotateZ = rotateZ;
      exports.angle = angle;
      exports.str = str;
      exports.exactEquals = exactEquals;
      exports.equals = equals;

      var _common = __webpack_require__(15);

      var glMatrix = _interopRequireWildcard(_common);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }
      /**
       * 3 Dimensional Vector
       * @module vec3
       */

      /**
       * Creates a new, empty vec3
       *
       * @returns {vec3} a new 3D vector
       */


      function create() {
        var out = new glMatrix.ARRAY_TYPE(3);

        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
        }

        return out;
      }
      /**
       * Creates a new vec3 initialized with values from an existing vector
       *
       * @param {vec3} a vector to clone
       * @returns {vec3} a new 3D vector
       */


      function clone(a) {
        var out = new glMatrix.ARRAY_TYPE(3);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        return out;
      }
      /**
       * Calculates the length of a vec3
       *
       * @param {vec3} a vector to calculate length of
       * @returns {Number} length of a
       */


      function length(a) {
        var x = a[0];
        var y = a[1];
        var z = a[2];
        return Math.sqrt(x * x + y * y + z * z);
      }
      /**
       * Creates a new vec3 initialized with the given values
       *
       * @param {Number} x X component
       * @param {Number} y Y component
       * @param {Number} z Z component
       * @returns {vec3} a new 3D vector
       */


      function fromValues(x, y, z) {
        var out = new glMatrix.ARRAY_TYPE(3);
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return out;
      }
      /**
       * Copy the values from one vec3 to another
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the source vector
       * @returns {vec3} out
       */


      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        return out;
      }
      /**
       * Set the components of a vec3 to the given values
       *
       * @param {vec3} out the receiving vector
       * @param {Number} x X component
       * @param {Number} y Y component
       * @param {Number} z Z component
       * @returns {vec3} out
       */


      function set(out, x, y, z) {
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return out;
      }
      /**
       * Adds two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function add(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        out[2] = a[2] + b[2];
        return out;
      }
      /**
       * Subtracts vector b from vector a
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function subtract(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        out[2] = a[2] - b[2];
        return out;
      }
      /**
       * Multiplies two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function multiply(out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        out[2] = a[2] * b[2];
        return out;
      }
      /**
       * Divides two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function divide(out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        out[2] = a[2] / b[2];
        return out;
      }
      /**
       * Math.ceil the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to ceil
       * @returns {vec3} out
       */


      function ceil(out, a) {
        out[0] = Math.ceil(a[0]);
        out[1] = Math.ceil(a[1]);
        out[2] = Math.ceil(a[2]);
        return out;
      }
      /**
       * Math.floor the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to floor
       * @returns {vec3} out
       */


      function floor(out, a) {
        out[0] = Math.floor(a[0]);
        out[1] = Math.floor(a[1]);
        out[2] = Math.floor(a[2]);
        return out;
      }
      /**
       * Returns the minimum of two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function min(out, a, b) {
        out[0] = Math.min(a[0], b[0]);
        out[1] = Math.min(a[1], b[1]);
        out[2] = Math.min(a[2], b[2]);
        return out;
      }
      /**
       * Returns the maximum of two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function max(out, a, b) {
        out[0] = Math.max(a[0], b[0]);
        out[1] = Math.max(a[1], b[1]);
        out[2] = Math.max(a[2], b[2]);
        return out;
      }
      /**
       * Math.round the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to round
       * @returns {vec3} out
       */


      function round(out, a) {
        out[0] = Math.round(a[0]);
        out[1] = Math.round(a[1]);
        out[2] = Math.round(a[2]);
        return out;
      }
      /**
       * Scales a vec3 by a scalar number
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to scale
       * @param {Number} b amount to scale the vector by
       * @returns {vec3} out
       */


      function scale(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        out[2] = a[2] * b;
        return out;
      }
      /**
       * Adds two vec3's after scaling the second operand by a scalar value
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @param {Number} scale the amount to scale b by before adding
       * @returns {vec3} out
       */


      function scaleAndAdd(out, a, b, scale) {
        out[0] = a[0] + b[0] * scale;
        out[1] = a[1] + b[1] * scale;
        out[2] = a[2] + b[2] * scale;
        return out;
      }
      /**
       * Calculates the euclidian distance between two vec3's
       *
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {Number} distance between a and b
       */


      function distance(a, b) {
        var x = b[0] - a[0];
        var y = b[1] - a[1];
        var z = b[2] - a[2];
        return Math.sqrt(x * x + y * y + z * z);
      }
      /**
       * Calculates the squared euclidian distance between two vec3's
       *
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {Number} squared distance between a and b
       */


      function squaredDistance(a, b) {
        var x = b[0] - a[0];
        var y = b[1] - a[1];
        var z = b[2] - a[2];
        return x * x + y * y + z * z;
      }
      /**
       * Calculates the squared length of a vec3
       *
       * @param {vec3} a vector to calculate squared length of
       * @returns {Number} squared length of a
       */


      function squaredLength(a) {
        var x = a[0];
        var y = a[1];
        var z = a[2];
        return x * x + y * y + z * z;
      }
      /**
       * Negates the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to negate
       * @returns {vec3} out
       */


      function negate(out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        out[2] = -a[2];
        return out;
      }
      /**
       * Returns the inverse of the components of a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to invert
       * @returns {vec3} out
       */


      function inverse(out, a) {
        out[0] = 1.0 / a[0];
        out[1] = 1.0 / a[1];
        out[2] = 1.0 / a[2];
        return out;
      }
      /**
       * Normalize a vec3
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a vector to normalize
       * @returns {vec3} out
       */


      function normalize(out, a) {
        var x = a[0];
        var y = a[1];
        var z = a[2];
        var len = x * x + y * y + z * z;

        if (len > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          out[0] = a[0] * len;
          out[1] = a[1] * len;
          out[2] = a[2] * len;
        }

        return out;
      }
      /**
       * Calculates the dot product of two vec3's
       *
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {Number} dot product of a and b
       */


      function dot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      /**
       * Computes the cross product of two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @returns {vec3} out
       */


      function cross(out, a, b) {
        var ax = a[0],
            ay = a[1],
            az = a[2];
        var bx = b[0],
            by = b[1],
            bz = b[2];
        out[0] = ay * bz - az * by;
        out[1] = az * bx - ax * bz;
        out[2] = ax * by - ay * bx;
        return out;
      }
      /**
       * Performs a linear interpolation between two vec3's
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
       * @returns {vec3} out
       */


      function lerp(out, a, b, t) {
        var ax = a[0];
        var ay = a[1];
        var az = a[2];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        out[2] = az + t * (b[2] - az);
        return out;
      }
      /**
       * Performs a hermite interpolation with two control points
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @param {vec3} c the third operand
       * @param {vec3} d the fourth operand
       * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
       * @returns {vec3} out
       */


      function hermite(out, a, b, c, d, t) {
        var factorTimes2 = t * t;
        var factor1 = factorTimes2 * (2 * t - 3) + 1;
        var factor2 = factorTimes2 * (t - 2) + t;
        var factor3 = factorTimes2 * (t - 1);
        var factor4 = factorTimes2 * (3 - 2 * t);
        out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
        out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
        out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
        return out;
      }
      /**
       * Performs a bezier interpolation with two control points
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the first operand
       * @param {vec3} b the second operand
       * @param {vec3} c the third operand
       * @param {vec3} d the fourth operand
       * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
       * @returns {vec3} out
       */


      function bezier(out, a, b, c, d, t) {
        var inverseFactor = 1 - t;
        var inverseFactorTimesTwo = inverseFactor * inverseFactor;
        var factorTimes2 = t * t;
        var factor1 = inverseFactorTimesTwo * inverseFactor;
        var factor2 = 3 * t * inverseFactorTimesTwo;
        var factor3 = 3 * factorTimes2 * inverseFactor;
        var factor4 = factorTimes2 * t;
        out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
        out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
        out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
        return out;
      }
      /**
       * Generates a random vector with the given scale
       *
       * @param {vec3} out the receiving vector
       * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
       * @returns {vec3} out
       */


      function random(out, scale) {
        scale = scale || 1.0;
        var r = glMatrix.RANDOM() * 2.0 * Math.PI;
        var z = glMatrix.RANDOM() * 2.0 - 1.0;
        var zScale = Math.sqrt(1.0 - z * z) * scale;
        out[0] = Math.cos(r) * zScale;
        out[1] = Math.sin(r) * zScale;
        out[2] = z * scale;
        return out;
      }
      /**
       * Transforms the vec3 with a mat4.
       * 4th vector component is implicitly '1'
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to transform
       * @param {mat4} m matrix to transform with
       * @returns {vec3} out
       */


      function transformMat4(out, a, m) {
        var x = a[0],
            y = a[1],
            z = a[2];
        var w = m[3] * x + m[7] * y + m[11] * z + m[15];
        w = w || 1.0;
        out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
        out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
        out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
        return out;
      }
      /**
       * Transforms the vec3 with a mat3.
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to transform
       * @param {mat3} m the 3x3 matrix to transform with
       * @returns {vec3} out
       */


      function transformMat3(out, a, m) {
        var x = a[0],
            y = a[1],
            z = a[2];
        out[0] = x * m[0] + y * m[3] + z * m[6];
        out[1] = x * m[1] + y * m[4] + z * m[7];
        out[2] = x * m[2] + y * m[5] + z * m[8];
        return out;
      }
      /**
       * Transforms the vec3 with a quat
       * Can also be used for dual quaternions. (Multiply it with the real part)
       *
       * @param {vec3} out the receiving vector
       * @param {vec3} a the vector to transform
       * @param {quat} q quaternion to transform with
       * @returns {vec3} out
       */


      function transformQuat(out, a, q) {
        // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
        var qx = q[0],
            qy = q[1],
            qz = q[2],
            qw = q[3];
        var x = a[0],
            y = a[1],
            z = a[2]; // var qvec = [qx, qy, qz];
        // var uv = vec3.cross([], qvec, a);

        var uvx = qy * z - qz * y,
            uvy = qz * x - qx * z,
            uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

        var uuvx = qy * uvz - qz * uvy,
            uuvy = qz * uvx - qx * uvz,
            uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

        var w2 = qw * 2;
        uvx *= w2;
        uvy *= w2;
        uvz *= w2; // vec3.scale(uuv, uuv, 2);

        uuvx *= 2;
        uuvy *= 2;
        uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

        out[0] = x + uvx + uuvx;
        out[1] = y + uvy + uuvy;
        out[2] = z + uvz + uuvz;
        return out;
      }
      /**
       * Rotate a 3D vector around the x-axis
       * @param {vec3} out The receiving vec3
       * @param {vec3} a The vec3 point to rotate
       * @param {vec3} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec3} out
       */


      function rotateX(out, a, b, c) {
        var p = [],
            r = []; //Translate point to the origin

        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2]; //perform rotation

        r[0] = p[0];
        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      }
      /**
       * Rotate a 3D vector around the y-axis
       * @param {vec3} out The receiving vec3
       * @param {vec3} a The vec3 point to rotate
       * @param {vec3} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec3} out
       */


      function rotateY(out, a, b, c) {
        var p = [],
            r = []; //Translate point to the origin

        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2]; //perform rotation

        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
        r[1] = p[1];
        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      }
      /**
       * Rotate a 3D vector around the z-axis
       * @param {vec3} out The receiving vec3
       * @param {vec3} a The vec3 point to rotate
       * @param {vec3} b The origin of the rotation
       * @param {Number} c The angle of rotation
       * @returns {vec3} out
       */


      function rotateZ(out, a, b, c) {
        var p = [],
            r = []; //Translate point to the origin

        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2]; //perform rotation

        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
        r[2] = p[2]; //translate to correct position

        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      }
      /**
       * Get the angle between two 3D vectors
       * @param {vec3} a The first operand
       * @param {vec3} b The second operand
       * @returns {Number} The angle in radians
       */


      function angle(a, b) {
        var tempA = fromValues(a[0], a[1], a[2]);
        var tempB = fromValues(b[0], b[1], b[2]);
        normalize(tempA, tempA);
        normalize(tempB, tempB);
        var cosine = dot(tempA, tempB);

        if (cosine > 1.0) {
          return 0;
        } else if (cosine < -1.0) {
          return Math.PI;
        } else {
          return Math.acos(cosine);
        }
      }
      /**
       * Returns a string representation of a vector
       *
       * @param {vec3} a vector to represent as a string
       * @returns {String} string representation of the vector
       */


      function str(a) {
        return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
      }
      /**
       * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
       *
       * @param {vec3} a The first vector.
       * @param {vec3} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */


      function exactEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
      }
      /**
       * Returns whether or not the vectors have approximately the same elements in the same position.
       *
       * @param {vec3} a The first vector.
       * @param {vec3} b The second vector.
       * @returns {Boolean} True if the vectors are equal, false otherwise.
       */


      function equals(a, b) {
        var a0 = a[0],
            a1 = a[1],
            a2 = a[2];
        var b0 = b[0],
            b1 = b[1],
            b2 = b[2];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
      }
      /**
       * Alias for {@link vec3.subtract}
       * @function
       */


      var sub = exports.sub = subtract;
      /**
       * Alias for {@link vec3.multiply}
       * @function
       */

      var mul = exports.mul = multiply;
      /**
       * Alias for {@link vec3.divide}
       * @function
       */

      var div = exports.div = divide;
      /**
       * Alias for {@link vec3.distance}
       * @function
       */

      var dist = exports.dist = distance;
      /**
       * Alias for {@link vec3.squaredDistance}
       * @function
       */

      var sqrDist = exports.sqrDist = squaredDistance;
      /**
       * Alias for {@link vec3.length}
       * @function
       */

      var len = exports.len = length;
      /**
       * Alias for {@link vec3.squaredLength}
       * @function
       */

      var sqrLen = exports.sqrLen = squaredLength;
      /**
       * Perform some operation over an array of vec3s.
       *
       * @param {Array} a the array of vectors to iterate over
       * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
       * @param {Number} offset Number of elements to skip at the beginning of the array
       * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
       * @param {Function} fn Function to call for each vector in the array
       * @param {Object} [arg] additional argument to pass to fn
       * @returns {Array} a
       * @function
       */

      var forEach = exports.forEach = function () {
        var vec = create();
        return function (a, stride, offset, count, fn, arg) {
          var i = void 0,
              l = void 0;

          if (!stride) {
            stride = 3;
          }

          if (!offset) {
            offset = 0;
          }

          if (count) {
            l = Math.min(count * stride + offset, a.length);
          } else {
            l = a.length;
          }

          for (i = offset; i < l; i += stride) {
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
          }

          return a;
        };
      }();
      /***/

    },
    /* 94 */

    /***/
    function (module, exports, __webpack_require__) {
      var clone = __webpack_require__(24);

      var each = __webpack_require__(0);

      var mat3 = __webpack_require__(23);

      module.exports = function transform(m, ts) {
        m = clone(m);
        each(ts, function (t) {
          switch (t[0]) {
            case 't':
              mat3.translate(m, m, [t[1], t[2]]);
              break;

            case 's':
              mat3.scale(m, m, [t[1], t[2]]);
              break;

            case 'r':
              mat3.rotate(m, m, t[1]);
              break;

            case 'm':
              mat3.multiply(m, m, t[1]);
              break;

            default:
              return false;
          }
        });
        return m;
      };
      /***/

    },
    /* 95 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = {
        forIn: __webpack_require__(96),
        has: __webpack_require__(25),
        hasKey: __webpack_require__(97),
        hasValue: __webpack_require__(98),
        keys: __webpack_require__(18),
        isMatch: __webpack_require__(17),
        values: __webpack_require__(26)
      };
      /***/
    },
    /* 96 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(0);
      /***/
    },
    /* 97 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(25);
      /***/
    },
    /* 98 */

    /***/
    function (module, exports, __webpack_require__) {
      var contains = __webpack_require__(9);

      var values = __webpack_require__(26);

      module.exports = function (obj, value) {
        return contains(values(obj), value);
      };
      /***/

    },
    /* 99 */

    /***/
    function (module, exports, __webpack_require__) {
      var pathIntersection = __webpack_require__(100);

      var path2absolute = __webpack_require__(30);

      var path2curve = __webpack_require__(29);

      var catmullRom2Bezier = __webpack_require__(32);

      module.exports = {
        catmullRom2Bezier: catmullRom2Bezier,
        catmullRomToBezier: catmullRom2Bezier,
        fillPath: __webpack_require__(101),
        fillPathByDiff: __webpack_require__(102),
        formatPath: __webpack_require__(104),
        intersection: pathIntersection,
        pathIntersection: pathIntersection,
        parsePathArray: __webpack_require__(28),
        parsePathString: __webpack_require__(31),
        pathToAbsolute: path2absolute,
        path2absolute: path2absolute,
        pathTocurve: path2curve,
        path2curve: path2curve,
        rectPath: __webpack_require__(27)
      };
      /***/
    },
    /* 100 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(1);

      var rectPath = __webpack_require__(27);

      var pathTocurve = __webpack_require__(29);

      var base3 = function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
        var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
      };

      var bezlen = function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z === null) {
          z = 1;
        }

        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2;
        var n = 12;
        var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
        var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
        var sum = 0;

        for (var i = 0; i < n; i++) {
          var ct = z2 * Tvalues[i] + z2;
          var xbase = base3(ct, x1, x2, x3, x4);
          var ybase = base3(ct, y1, y2, y3, y4);
          var comb = xbase * xbase + ybase * ybase;
          sum += Cvalues[i] * Math.sqrt(comb);
        }

        return z2 * sum;
      };

      var curveDim = function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
        var tvalues = [];
        var bounds = [[], []];
        var a = void 0;
        var b = void 0;
        var c = void 0;
        var t = void 0;

        for (var i = 0; i < 2; ++i) {
          if (i === 0) {
            b = 6 * x0 - 12 * x1 + 6 * x2;
            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
            c = 3 * x1 - 3 * x0;
          } else {
            b = 6 * y0 - 12 * y1 + 6 * y2;
            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
            c = 3 * y1 - 3 * y0;
          }

          if (Math.abs(a) < 1e-12) {
            if (Math.abs(b) < 1e-12) {
              continue;
            }

            t = -c / b;

            if (t > 0 && t < 1) {
              tvalues.push(t);
            }

            continue;
          }

          var b2ac = b * b - 4 * c * a;
          var sqrtb2ac = Math.sqrt(b2ac);

          if (b2ac < 0) {
            continue;
          }

          var t1 = (-b + sqrtb2ac) / (2 * a);

          if (t1 > 0 && t1 < 1) {
            tvalues.push(t1);
          }

          var t2 = (-b - sqrtb2ac) / (2 * a);

          if (t2 > 0 && t2 < 1) {
            tvalues.push(t2);
          }
        }

        var j = tvalues.length;
        var jlen = j;
        var mt = void 0;

        while (j--) {
          t = tvalues[j];
          mt = 1 - t;
          bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
          bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
        }

        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        bounds[0].length = bounds[1].length = jlen + 2;
        return {
          min: {
            x: Math.min.apply(0, bounds[0]),
            y: Math.min.apply(0, bounds[1])
          },
          max: {
            x: Math.max.apply(0, bounds[0]),
            y: Math.max.apply(0, bounds[1])
          }
        };
      };

      var intersect = function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
          return;
        }

        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
        var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
        var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
          return;
        }

        var px = nx / denominator;
        var py = ny / denominator;
        var px2 = +px.toFixed(2);
        var py2 = +py.toFixed(2);

        if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
          return;
        }

        return {
          x: px,
          y: py
        };
      };

      var isPointInsideBBox = function isPointInsideBBox(bbox, x, y) {
        return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
      };

      var box = function box(x, y, width, height) {
        if (x === null) {
          x = y = width = height = 0;
        }

        if (y === null) {
          y = x.y;
          width = x.width;
          height = x.height;
          x = x.x;
        }

        return {
          x: x,
          y: y,
          width: width,
          w: width,
          height: height,
          h: height,
          x2: x + width,
          y2: y + height,
          cx: x + width / 2,
          cy: y + height / 2,
          r1: Math.min(width, height) / 2,
          r2: Math.max(width, height) / 2,
          r0: Math.sqrt(width * width + height * height) / 2,
          path: rectPath(x, y, width, height),
          vb: [x, y, width, height].join(' ')
        };
      };

      var isBBoxIntersect = function isBBoxIntersect(bbox1, bbox2) {
        bbox1 = box(bbox1);
        bbox2 = box(bbox2);
        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
      };

      var bezierBBox = function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!isArray(p1x)) {
          p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }

        var bbox = curveDim.apply(null, p1x);
        return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
      };

      var findDotsAtSegment = function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t;
        var t13 = Math.pow(t1, 3);
        var t12 = Math.pow(t1, 2);
        var t2 = t * t;
        var t3 = t2 * t;
        var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
        var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
        var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
        var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
        var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
        var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
        var ax = t1 * p1x + t * c1x;
        var ay = t1 * p1y + t * c1y;
        var cx = t1 * c2x + t * p2x;
        var cy = t1 * c2y + t * p2y;
        var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI; // (mx > nx || my < ny) && (alpha += 180);

        return {
          x: x,
          y: y,
          m: {
            x: mx,
            y: my
          },
          n: {
            x: nx,
            y: ny
          },
          start: {
            x: ax,
            y: ay
          },
          end: {
            x: cx,
            y: cy
          },
          alpha: alpha
        };
      };

      var interHelper = function interHelper(bez1, bez2, justCount) {
        var bbox1 = bezierBBox(bez1);
        var bbox2 = bezierBBox(bez2);

        if (!isBBoxIntersect(bbox1, bbox2)) {
          return justCount ? 0 : [];
        }

        var l1 = bezlen.apply(0, bez1);
        var l2 = bezlen.apply(0, bez2);
        var n1 = ~~(l1 / 8);
        var n2 = ~~(l2 / 8);
        var dots1 = [];
        var dots2 = [];
        var xy = {};
        var res = justCount ? 0 : [];

        for (var i = 0; i < n1 + 1; i++) {
          var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
          dots1.push({
            x: d.x,
            y: d.y,
            t: i / n1
          });
        }

        for (var _i = 0; _i < n2 + 1; _i++) {
          var _d = findDotsAtSegment.apply(0, bez2.concat(_i / n2));

          dots2.push({
            x: _d.x,
            y: _d.y,
            t: _i / n2
          });
        }

        for (var _i2 = 0; _i2 < n1; _i2++) {
          for (var j = 0; j < n2; j++) {
            var di = dots1[_i2];
            var di1 = dots1[_i2 + 1];
            var dj = dots2[j];
            var dj1 = dots2[j + 1];
            var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
            var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
            var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);

            if (is) {
              if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
                continue;
              }

              xy[is.x.toFixed(4)] = is.y.toFixed(4);
              var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
              var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

              if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                if (justCount) {
                  res++;
                } else {
                  res.push({
                    x: is.x,
                    y: is.y,
                    t1: t1,
                    t2: t2
                  });
                }
              }
            }
          }
        }

        return res;
      };

      var interPathHelper = function interPathHelper(path1, path2, justCount) {
        path1 = pathTocurve(path1);
        path2 = pathTocurve(path2);
        var x1 = void 0;
        var y1 = void 0;
        var x2 = void 0;
        var y2 = void 0;
        var x1m = void 0;
        var y1m = void 0;
        var x2m = void 0;
        var y2m = void 0;
        var bez1 = void 0;
        var bez2 = void 0;
        var res = justCount ? 0 : [];

        for (var i = 0, ii = path1.length; i < ii; i++) {
          var pi = path1[i];

          if (pi[0] === 'M') {
            x1 = x1m = pi[1];
            y1 = y1m = pi[2];
          } else {
            if (pi[0] === 'C') {
              bez1 = [x1, y1].concat(pi.slice(1));
              x1 = bez1[6];
              y1 = bez1[7];
            } else {
              bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
              x1 = x1m;
              y1 = y1m;
            }

            for (var j = 0, jj = path2.length; j < jj; j++) {
              var pj = path2[j];

              if (pj[0] === 'M') {
                x2 = x2m = pj[1];
                y2 = y2m = pj[2];
              } else {
                if (pj[0] === 'C') {
                  bez2 = [x2, y2].concat(pj.slice(1));
                  x2 = bez2[6];
                  y2 = bez2[7];
                } else {
                  bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                  x2 = x2m;
                  y2 = y2m;
                }

                var intr = interHelper(bez1, bez2, justCount);

                if (justCount) {
                  res += intr;
                } else {
                  for (var k = 0, kk = intr.length; k < kk; k++) {
                    intr[k].segment1 = i;
                    intr[k].segment2 = j;
                    intr[k].bez1 = bez1;
                    intr[k].bez2 = bez2;
                  }

                  res = res.concat(intr);
                }
              }
            }
          }
        }

        return res;
      };

      module.exports = function pathIntersection(path1, path2) {
        return interPathHelper(path1, path2);
      };
      /***/

    },
    /* 101 */

    /***/
    function (module, exports) {
      function decasteljau(points, t) {
        var left = [];
        var right = [];

        function recurse(points, t) {
          if (points.length === 1) {
            left.push(points[0]);
            right.push(points[0]);
          } else {
            var middlePoints = [];

            for (var i = 0; i < points.length - 1; i++) {
              if (i === 0) {
                left.push(points[0]);
              }

              if (i === points.length - 2) {
                right.push(points[i + 1]);
              }

              middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];
            }

            recurse(middlePoints, t);
          }
        }

        if (points.length) {
          recurse(points, t);
        }

        return {
          left: left,
          right: right.reverse()
        };
      }

      function splitCurve(start, end, count) {
        var points = [[start[1], start[2]]];
        count = count || 2;
        var segments = [];

        if (end[0] === 'A') {
          points.push(end[6]);
          points.push(end[7]);
        } else if (end[0] === 'C') {
          points.push([end[1], end[2]]);
          points.push([end[3], end[4]]);
          points.push([end[5], end[6]]);
        } else if (end[0] === 'S' || end[0] === 'Q') {
          points.push([end[1], end[2]]);
          points.push([end[3], end[4]]);
        } else {
          points.push([end[1], end[2]]);
        }

        var leftSegments = points;
        var t = 1 / count;

        for (var i = 0; i < count - 1; i++) {
          var rt = t / (1 - t * i);
          var split = decasteljau(leftSegments, rt);
          segments.push(split.left);
          leftSegments = split.right;
        }

        segments.push(leftSegments);
        var result = segments.map(function (segment) {
          var cmd = [];

          if (segment.length === 4) {
            cmd.push('C');
            cmd = cmd.concat(segment[2]);
          }

          if (segment.length >= 3) {
            if (segment.length === 3) {
              cmd.push('Q');
            }

            cmd = cmd.concat(segment[1]);
          }

          if (segment.length === 2) {
            cmd.push('L');
          }

          cmd = cmd.concat(segment[segment.length - 1]);
          return cmd;
        });
        return result;
      }

      function splitSegment(start, end, count) {
        if (count === 1) {
          return [[].concat(start)];
        }

        var segments = [];

        if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {
          segments = segments.concat(splitCurve(start, end, count));
        } else {
          var temp = [].concat(start);

          if (temp[0] === 'M') {
            temp[0] = 'L';
          }

          for (var i = 0; i <= count - 1; i++) {
            segments.push(temp);
          }
        }

        return segments;
      }

      module.exports = function fillPath(source, target) {
        if (source.length === 1) {
          return source;
        }

        var sourceLen = source.length - 1;
        var targetLen = target.length - 1;
        var ratio = sourceLen / targetLen;
        var segmentsToFill = [];

        if (source.length === 1 && source[0][0] === 'M') {
          for (var i = 0; i < targetLen - sourceLen; i++) {
            source.push(source[0]);
          }

          return source;
        }

        for (var _i = 0; _i < targetLen; _i++) {
          var index = Math.floor(ratio * _i);
          segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
        }

        var filled = segmentsToFill.reduce(function (filled, count, i) {
          if (i === sourceLen) {
            return filled.concat(source[sourceLen]);
          }

          return filled.concat(splitSegment(source[i], source[i + 1], count));
        }, []);
        filled.unshift(source[0]);

        if (target[targetLen] === 'Z' || target[targetLen] === 'z') {
          filled.push('Z');
        }

        return filled;
      };
      /***/

    },
    /* 102 */

    /***/
    function (module, exports, __webpack_require__) {
      var isEqual = __webpack_require__(103);

      function getMinDiff(del, add, modify) {
        var type = null;
        var min = modify;

        if (add < min) {
          min = add;
          type = 'add';
        }

        if (del < min) {
          min = del;
          type = 'del';
        }

        return {
          type: type,
          min: min
        };
      }
      /*
       * https://en.wikipedia.org/wiki/Levenshtein_distance
       * 计算两条path的编辑距离
       */


      var levenshteinDistance = function levenshteinDistance(source, target) {
        var sourceLen = source.length;
        var targetLen = target.length;
        var sourceSegment = void 0,
            targetSegment = void 0;
        var temp = 0;

        if (sourceLen === 0 || targetLen === 0) {
          return null;
        }

        var dist = [];

        for (var i = 0; i <= sourceLen; i++) {
          dist[i] = [];
          dist[i][0] = {
            min: i
          };
        }

        for (var j = 0; j <= targetLen; j++) {
          dist[0][j] = {
            min: j
          };
        }

        for (var _i = 1; _i <= sourceLen; _i++) {
          sourceSegment = source[_i - 1];

          for (var _j = 1; _j <= targetLen; _j++) {
            targetSegment = target[_j - 1];

            if (isEqual(sourceSegment, targetSegment)) {
              temp = 0;
            } else {
              temp = 1;
            }

            var del = dist[_i - 1][_j].min + 1;
            var add = dist[_i][_j - 1].min + 1;
            var modify = dist[_i - 1][_j - 1].min + temp;
            dist[_i][_j] = getMinDiff(del, add, modify);
          }
        }

        return dist;
      };

      module.exports = function fillPathByDiff(source, target) {
        var diffMatrix = levenshteinDistance(source, target);
        var sourceLen = source.length;
        var targetLen = target.length;
        var changes = [];
        var index = 1;
        var minPos = 1; // 如果source和target不是完全不相等

        if (diffMatrix[sourceLen][targetLen] !== sourceLen) {
          // 获取从source到target所需改动
          for (var i = 1; i <= sourceLen; i++) {
            var min = diffMatrix[i][i].min;
            minPos = i;

            for (var j = index; j <= targetLen; j++) {
              if (diffMatrix[i][j].min < min) {
                min = diffMatrix[i][j].min;
                minPos = j;
              }
            }

            index = minPos;

            if (diffMatrix[i][index].type) {
              changes.push({
                index: i - 1,
                type: diffMatrix[i][index].type
              });
            }
          } // 对source进行增删path


          for (var _i2 = changes.length - 1; _i2 >= 0; _i2--) {
            index = changes[_i2].index;

            if (changes[_i2].type === 'add') {
              source.splice(index, 0, [].concat(source[index]));
            } else {
              source.splice(index, 1);
            }
          }
        } // source尾部补齐


        sourceLen = source.length;

        if (sourceLen < targetLen) {
          for (var _i3 = 0; _i3 < targetLen - sourceLen; _i3++) {
            if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {
              source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
            } else {
              source.push(source[sourceLen - 1]);
            }
          }
        }

        return source;
      };
      /***/

    },
    /* 103 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(0);

      module.exports = function isEqual(obj1, obj2) {
        if (obj1.length !== obj2.length) {
          return false;
        }

        var result = true;
        each(obj1, function (item, i) {
          if (item !== obj2[i]) {
            result = false;
            return false;
          }
        });
        return result;
      };
      /***/

    },
    /* 104 */

    /***/
    function (module, exports) {
      /*
       * 抽取pathSegment中的关键点
       * M,L,A,Q,H,V一个端点
       * Q, S抽取一个端点，一个控制点
       * C抽取一个端点，两个控制点
       */
      function _getSegmentPoints(segment) {
        var points = [];

        switch (segment[0]) {
          case 'M':
            points.push([segment[1], segment[2]]);
            break;

          case 'L':
            points.push([segment[1], segment[2]]);
            break;

          case 'A':
            points.push([segment[6], segment[7]]);
            break;

          case 'Q':
            points.push([segment[3], segment[4]]);
            points.push([segment[1], segment[2]]);
            break;

          case 'T':
            points.push([segment[1], segment[2]]);
            break;

          case 'C':
            points.push([segment[5], segment[6]]);
            points.push([segment[1], segment[2]]);
            points.push([segment[3], segment[4]]);
            break;

          case 'S':
            points.push([segment[3], segment[4]]);
            points.push([segment[1], segment[2]]);
            break;

          case 'H':
            points.push([segment[1], segment[1]]);
            break;

          case 'V':
            points.push([segment[1], segment[1]]);
            break;

          default:
        }

        return points;
      } // 将两个点均分成count个点


      function _splitPoints(points, former, count) {
        var result = [].concat(points);
        var index = void 0;
        var t = 1 / (count + 1);

        var formerEnd = _getSegmentPoints(former)[0];

        for (var i = 1; i <= count; i++) {
          t *= i;
          index = Math.floor(points.length * t);

          if (index === 0) {
            result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
          } else {
            result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
          }
        }

        return result;
      }

      module.exports = function formatPath(fromPath, toPath) {
        if (fromPath.length <= 1) {
          return fromPath;
        }

        var points = void 0;

        for (var i = 0; i < toPath.length; i++) {
          if (fromPath[i][0] !== toPath[i][0]) {
            // 获取fromPath的pathSegment的端点，根据toPath的指令对其改造
            points = _getSegmentPoints(fromPath[i]);

            switch (toPath[i][0]) {
              case 'M':
                fromPath[i] = ['M'].concat(points[0]);
                break;

              case 'L':
                fromPath[i] = ['L'].concat(points[0]);
                break;

              case 'A':
                fromPath[i] = [].concat(toPath[i]);
                fromPath[i][6] = points[0][0];
                fromPath[i][7] = points[0][1];
                break;

              case 'Q':
                if (points.length < 2) {
                  if (i > 0) {
                    points = _splitPoints(points, fromPath[i - 1], 1);
                  } else {
                    fromPath[i] = toPath[i];
                    break;
                  }
                }

                fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {
                  return arr.concat(i);
                }, []));
                break;

              case 'T':
                fromPath[i] = ['T'].concat(points[0]);
                break;

              case 'C':
                if (points.length < 3) {
                  if (i > 0) {
                    points = _splitPoints(points, fromPath[i - 1], 2);
                  } else {
                    fromPath[i] = toPath[i];
                    break;
                  }
                }

                fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {
                  return arr.concat(i);
                }, []));
                break;

              case 'S':
                if (points.length < 2) {
                  if (i > 0) {
                    points = _splitPoints(points, fromPath[i - 1], 1);
                  } else {
                    fromPath[i] = toPath[i];
                    break;
                  }
                }

                fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {
                  return arr.concat(i);
                }, []));
                break;

              default:
                fromPath[i] = toPath[i];
            }
          }
        }

        return fromPath;
      };
      /***/

    },
    /* 105 */

    /***/
    function (module, exports, __webpack_require__) {
      var strUtil = {
        lc: __webpack_require__(106),
        lowerCase: __webpack_require__(33),
        lowerFirst: __webpack_require__(107),
        substitute: __webpack_require__(108),
        uc: __webpack_require__(109),
        upperCase: __webpack_require__(34),
        upperFirst: __webpack_require__(110)
      };
      module.exports = strUtil;
      /***/
    },
    /* 106 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(33);
      /***/
    },
    /* 107 */

    /***/
    function (module, exports, __webpack_require__) {
      var toString = __webpack_require__(8);

      var lowerFirst = function lowerFirst(value) {
        var str = toString(value);
        return str.charAt(0).toLowerCase() + str.substring(1);
      };

      module.exports = lowerFirst;
      /***/
    },
    /* 108 */

    /***/
    function (module, exports) {
      var substitute = function substitute(str, o) {
        if (!str || !o) {
          return str;
        }

        return str.replace(/\\?\{([^{}]+)\}/g, function (match, name) {
          if (match.charAt(0) === '\\') {
            return match.slice(1);
          }

          return o[name] === undefined ? '' : o[name];
        });
      };

      module.exports = substitute;
      /***/
    },
    /* 109 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(34);
      /***/
    },
    /* 110 */

    /***/
    function (module, exports, __webpack_require__) {
      var toString = __webpack_require__(8);

      var upperFirst = function upperFirst(value) {
        var str = toString(value);
        return str.charAt(0).toUpperCase() + str.substring(1);
      };

      module.exports = upperFirst;
      /***/
    },
    /* 111 */

    /***/
    function (module, exports, __webpack_require__) {
      var isType = __webpack_require__(4);

      var checkType = {
        getType: __webpack_require__(35),
        isArray: __webpack_require__(1),
        isArrayLike: __webpack_require__(3),
        isBoolean: __webpack_require__(112),
        isFunction: __webpack_require__(2),
        isNil: __webpack_require__(5),
        isNull: __webpack_require__(113),
        isNumber: __webpack_require__(6),
        isObject: __webpack_require__(16),
        isObjectLike: __webpack_require__(13),
        isPlainObject: __webpack_require__(7),
        isPrototype: __webpack_require__(36),
        isType: isType,
        isUndefined: __webpack_require__(114),
        isString: __webpack_require__(10),
        isRegExp: __webpack_require__(115)
      };
      ['Arguments', 'Date', 'Error'].forEach(function (type) {
        checkType['is' + type] = function (value) {
          return isType(value, type);
        };
      });
      module.exports = checkType;
      /***/
    },
    /* 112 */

    /***/
    function (module, exports, __webpack_require__) {
      /**
       * 是否是布尔类型
       *
       * @param {Object} value 测试的值
       * @return {Boolean}
       */
      var isType = __webpack_require__(4);

      var isBoolean = function isBoolean(value) {
        return isType(value, 'Boolean');
      };

      module.exports = isBoolean;
      /***/
    },
    /* 113 */

    /***/
    function (module, exports) {
      var isNull = function isNull(value) {
        return value === null;
      };

      module.exports = isNull;
      /***/
    },
    /* 114 */

    /***/
    function (module, exports) {
      var isUndefined = function isUndefined(value) {
        return value === undefined;
      };

      module.exports = isUndefined;
      /***/
    },
    /* 115 */

    /***/
    function (module, exports, __webpack_require__) {
      var isType = __webpack_require__(4);

      var isRegExp = function isRegExp(str) {
        return isType(str, 'RegExp');
      };

      module.exports = isRegExp;
      /***/
    },
    /* 116 */

    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(2);

      var toArray = __webpack_require__(14);

      var mix = __webpack_require__(11);

      var augment = function augment(c) {
        var args = toArray(arguments);

        for (var i = 1; i < args.length; i++) {
          var obj = args[i];

          if (isFunction(obj)) {
            obj = obj.prototype;
          }

          mix(c.prototype, obj);
        }
      };

      module.exports = augment;
      /***/
    },
    /* 117 */

    /***/
    function (module, exports, __webpack_require__) {
      var isPlainObject = __webpack_require__(7);

      var isArray = __webpack_require__(1);

      var MAX_MIX_LEVEL = 5;

      function _deepMix(dist, src, level, maxLevel) {
        level = level || 0;
        maxLevel = maxLevel || MAX_MIX_LEVEL;

        for (var key in src) {
          if (src.hasOwnProperty(key)) {
            var value = src[key];

            if (value !== null && isPlainObject(value)) {
              if (!isPlainObject(dist[key])) {
                dist[key] = {};
              }

              if (level < maxLevel) {
                _deepMix(dist[key], value, level + 1, maxLevel);
              } else {
                dist[key] = src[key];
              }
            } else if (isArray(value)) {
              dist[key] = [];
              dist[key] = dist[key].concat(value);
            } else if (value !== undefined) {
              dist[key] = value;
            }
          }
        }
      }

      var deepMix = function deepMix() {
        var args = new Array(arguments.length);
        var length = args.length;

        for (var i = 0; i < length; i++) {
          args[i] = arguments[i];
        }

        var rst = args[0];

        for (var _i = 1; _i < length; _i++) {
          _deepMix(rst, args[_i]);
        }

        return rst;
      };

      module.exports = deepMix;
      /***/
    },
    /* 118 */

    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(2);

      var mix = __webpack_require__(11);

      var extend = function extend(subclass, superclass, overrides, staticOverrides) {
        // 如果只提供父类构造函数，则自动生成子类构造函数
        if (!isFunction(superclass)) {
          overrides = superclass;
          superclass = subclass;

          subclass = function subclass() {};
        }

        var create = Object.create ? function (proto, c) {
          return Object.create(proto, {
            constructor: {
              value: c
            }
          });
        } : function (proto, c) {
          function Tmp() {}

          Tmp.prototype = proto;
          var o = new Tmp();
          o.constructor = c;
          return o;
        };
        var superObj = create(superclass.prototype, subclass); // new superclass(),//实例化父类作为子类的prototype

        subclass.prototype = mix(superObj, subclass.prototype); // 指定子类的prototype

        subclass.superclass = create(superclass.prototype, superclass);
        mix(superObj, overrides);
        mix(subclass, staticOverrides);
        return subclass;
      };

      module.exports = extend;
      /***/
    },
    /* 119 */

    /***/
    function (module, exports, __webpack_require__) {
      var groupToMap = __webpack_require__(37);

      var group = function group(data, condition) {
        if (!condition) {
          return [data];
        }

        var groups = groupToMap(data, condition);
        var array = [];

        for (var i in groups) {
          array.push(groups[i]);
        }

        return array;
      };

      module.exports = group;
      /***/
    },
    /* 120 */

    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(3);

      var indexOf = function indexOf(arr, obj) {
        if (!isArrayLike(arr)) {
          return -1;
        }

        var m = Array.prototype.indexOf;

        if (m) {
          return m.call(arr, obj);
        }

        var index = -1;

        for (var i = 0; i < arr.length; i++) {
          if (arr[i] === obj) {
            index = i;
            break;
          }
        }

        return index;
      };

      module.exports = indexOf;
      /***/
    },
    /* 121 */

    /***/
    function (module, exports, __webpack_require__) {
      var isNil = __webpack_require__(5);

      var isArrayLike = __webpack_require__(3);

      var getType = __webpack_require__(35);

      var isPrototype = __webpack_require__(36);

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      function isEmpty(value) {
        /**
         * isEmpty(null) => true
         * isEmpty() => true
         * isEmpty(true) => true
         * isEmpty(1) => true
         * isEmpty([1, 2, 3]) => false
         * isEmpty('abc') => false
         * isEmpty({ a: 1 }) => false
         */
        if (isNil(value)) {
          return true;
        }

        if (isArrayLike(value)) {
          return !value.length;
        }

        var type = getType(value);

        if (type === 'Map' || type === 'Set') {
          return !value.size;
        }

        if (isPrototype(value)) {
          return !Object.keys(value).length;
        }

        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }

        return true;
      }

      module.exports = isEmpty;
      /***/
    },
    /* 122 */

    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(2);

      var isEqual = __webpack_require__(39);
      /**
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {Function} [fn] The function to customize comparisons.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, othValue) {
       *   if (isGreeting(objValue) && isGreeting(othValue)) {
       *     return true;
       *   }
       * }
       *
       * var array = ['hello', 'goodbye'];
       * var other = ['hi', 'goodbye'];
       *
       * isEqualWith(array, other, customizer);  // => true
       */


      var isEqualWith = function isEqualWith(value, other, fn) {
        if (!isFunction(fn)) {
          return isEqual(value, other);
        }

        return !!fn(value, other);
      };

      module.exports = isEqualWith;
      /***/
    },
    /* 123 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(0);

      var isArrayLike = __webpack_require__(3);

      var map = function map(arr, func) {
        if (!isArrayLike(arr)) {
          return arr;
        }

        var result = [];
        each(arr, function (value, index) {
          result.push(func(value, index));
        });
        return result;
      };

      module.exports = map;
      /***/
    },
    /* 124 */

    /***/
    function (module, exports, __webpack_require__) {
      var each = __webpack_require__(0);

      var isPlaineObject = __webpack_require__(7);

      var hasOwnProperty = Object.prototype.hasOwnProperty;
      /**
       * Creates an object composed of the picked `object` properties.
       *
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       * pick(object, ['a', 'c']);  // => { 'a': 1, 'c': 3 }
       */

      var pick = function pick(object, keys) {
        if (object === null || !isPlaineObject(object)) {
          return {};
        }

        var result = {};
        each(keys, function (key) {
          if (hasOwnProperty.call(object, key)) {
            result[key] = object[key];
          }
        });
        return result;
      };

      module.exports = pick;
      /***/
    },
    /* 125 */

    /***/
    function (module, exports) {
      var uniqueId = function () {
        var map = {};
        return function (prefix) {
          prefix = prefix || 'g';

          if (!map[prefix]) {
            map[prefix] = 1;
          } else {
            map[prefix] += 1;
          }

          return prefix + map[prefix];
        };
      }();

      module.exports = uniqueId;
      /***/
    }])
  );
});

/***/ }),
/* 255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geojsonSource__ = __webpack_require__(256);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "geojson", function() { return __WEBPACK_IMPORTED_MODULE_0__geojsonSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__csvSource__ = __webpack_require__(69);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return __WEBPACK_IMPORTED_MODULE_1__csvSource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "array", function() { return __WEBPACK_IMPORTED_MODULE_1__csvSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_source__ = __webpack_require__(23);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "basic", function() { return __WEBPACK_IMPORTED_MODULE_2__core_source__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__imageSource__ = __webpack_require__(70);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "imageSource", function() { return __WEBPACK_IMPORTED_MODULE_3__imageSource__["a"]; });






/***/ }),
/* 256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GeojsonSource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_source__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_meta__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_meta___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__turf_meta__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__turf_clean_coords__ = __webpack_require__(268);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__turf_clean_coords___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__turf_clean_coords__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__turf_invariant__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__turf_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__turf_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geo_featureIndex__ = __webpack_require__(68);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }







var GeojsonSource =
/*#__PURE__*/
function (_Source) {
  _inherits(GeojsonSource, _Source);

  function GeojsonSource() {
    _classCallCheck(this, GeojsonSource);

    return _possibleConstructorReturn(this, _getPrototypeOf(GeojsonSource).apply(this, arguments));
  }

  _createClass(GeojsonSource, [{
    key: "prepareData",
    value: function prepareData() {
      var _this = this;

      this.type = 'geojson';
      var data = this.get('data');
      this.propertiesData = [];
      this.geoData = [];
      __WEBPACK_IMPORTED_MODULE_1__turf_meta__["flattenEach"](data, function (currentFeature, featureIndex) {
        var coord = Object(__WEBPACK_IMPORTED_MODULE_3__turf_invariant__["getCoords"])(__WEBPACK_IMPORTED_MODULE_2__turf_clean_coords___default()(currentFeature));

        _this.geoData.push(_this._coordProject(coord));

        currentFeature.properties._id = featureIndex + 1;

        _this.propertiesData.push(currentFeature.properties);
      });
    }
  }, {
    key: "featureIndex",
    value: function featureIndex() {
      var data = this.get('data');
      this.featureIndex = new __WEBPACK_IMPORTED_MODULE_4__geo_featureIndex__["a" /* default */](data);
    }
  }, {
    key: "getSelectFeatureId",
    value: function getSelectFeatureId(featureId) {
      var data = this.get('data');
      var selectFeatureIds = [];
      var featureStyleId = 0;
      __WEBPACK_IMPORTED_MODULE_1__turf_meta__["flattenEach"](data, function (currentFeature, featureIndex
      /* , multiFeatureIndex*/
      ) {
        if (featureIndex === featureId) {
          selectFeatureIds.push(featureStyleId);
        }

        featureStyleId++;

        if (featureIndex > featureId) {
          return;
        }
      });
      return selectFeatureIds;
    }
  }]);

  return GeojsonSource;
}(__WEBPACK_IMPORTED_MODULE_0__core_source__["a" /* default */]);



/***/ }),
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scale__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scale___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__scale__);
/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, "Scale", function() { return __WEBPACK_IMPORTED_MODULE_0__scale___default.a; });



/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileOverview 度量的控制器
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(1);

var Global = __webpack_require__(20);

var Scale = __webpack_require__(259);

var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
var TYPES = {
  LINEAR: 'linear',
  CAT: 'cat',
  TIME: 'time'
};

var ScaleController =
/*#__PURE__*/
function () {
  function ScaleController(cfg) {
    _classCallCheck(this, ScaleController);

    // defs 列定义
    this.defs = {};
    Util.assign(this, cfg);
  }

  _createClass(ScaleController, [{
    key: "_getDef",
    value: function _getDef(field) {
      var defs = this.defs;
      var def = null;

      if (Global.scales[field] || defs[field]) {
        def = Util.mix({}, Global.scales[field]); // 处理覆盖属性的问题

        Util.each(defs[field], function (v, k) {
          if (Util.isNil(v)) {
            delete def[k];
          } else {
            def[k] = v;
          }
        });
      }

      return def;
    }
  }, {
    key: "_getDefaultType",
    value: function _getDefaultType(field, data) {
      var type = TYPES.LINEAR;
      var value = Util.Array.firstValue(data, field);

      if (Util.isArray(value)) {
        value = value[0];
      }

      if (dateRegex.test(value)) {
        type = TYPES.TIME;
      } else if (Util.isString(value)) {
        type = TYPES.CAT;
      }

      return type;
    }
  }, {
    key: "_getScaleCfg",
    value: function _getScaleCfg(type, field, data) {
      var cfg = {
        field: field
      };
      var values = Util.Array.values(data, field);
      cfg.values = values;

      if (!Scale.isCategory(type) && type !== 'time') {
        var range = Util.Array.getRange(values);
        cfg.min = range.min;
        cfg.max = range.max;
        cfg.nice = true;
      }

      if (type === 'time') {
        cfg.nice = false;
      }

      return cfg;
    }
  }, {
    key: "createScale",
    value: function createScale(field, data) {
      var self = this;

      var def = self._getDef(field);

      var scale; // 如果数据为空直接返回常量度量

      if (!data || !data.length) {
        if (def && def.type) {
          scale = Scale[def.type](def);
        } else {
          scale = Scale.identity({
            value: field,
            field: field.toString(),
            values: [field]
          });
        }

        return scale;
      }

      var firstValue = Util.Array.firstValue(data, field);

      if (Util.isNumber(field) || Util.isNil(firstValue) && !def) {
        scale = Scale.identity({
          value: field,
          field: field.toString(),
          values: [field]
        });
      } else {
        // 如果已经定义过这个度量
        var type;

        if (def) {
          type = def.type;
        }

        type = type || self._getDefaultType(field, data);

        var cfg = self._getScaleCfg(type, field, data);

        if (def) {
          Util.mix(cfg, def);
        }

        scale = Scale[type](cfg);
      }

      return scale;
    }
  }]);

  return ScaleController;
}();

module.exports = ScaleController;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview Scale entry, used to reference all the scales
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(1);

var Base = __webpack_require__(27);

Base.Linear = __webpack_require__(28);
Base.Identity = __webpack_require__(261);
Base.Cat = __webpack_require__(62);
Base.Time = __webpack_require__(262);
Base.TimeCat = __webpack_require__(264);
Base.Log = __webpack_require__(265);
Base.Pow = __webpack_require__(266);

var _loop = function _loop(k) {
  if (Base.hasOwnProperty(k)) {
    var methodName = Util.lowerFirst(k);

    Base[methodName] = function (cfg) {
      return new Base[k](cfg);
    };
  }
};

for (var k in Base) {
  _loop(k);
}

var CAT_ARR = ['cat', 'timeCat'];

Base.isCategory = function (type) {
  return CAT_ARR.indexOf(type) >= 0;
};

module.exports = Base;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 自动计算数字坐标轴
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(1);

var AutoUtil = __webpack_require__(61);

var MIN_COUNT = 5;
var MAX_COUNT = 7;

var Global = __webpack_require__(20);

module.exports = function (info) {
  var min = info.min;
  var max = info.max;
  var interval = info.interval;
  var ticks = [];
  var minCount = info.minCount || MIN_COUNT;
  var maxCount = info.maxCount || MAX_COUNT;
  var isFixedCount = minCount === maxCount; // 是否限定死了个数

  var minLimit = Util.isNil(info.minLimit) ? -Infinity : info.minLimit; // 限定的最小值

  var maxLimit = Util.isNil(info.maxLimit) ? Infinity : info.maxLimit; // 限定最大值

  var avgCount = (minCount + maxCount) / 2;
  var count = avgCount; // 用户传入的逼近数组

  var snapArray = info.snapArray ? info.snapArray : isFixedCount ? Global.snapCountArray : Global.snapArray; // 如果限定大小范围，同时大小范围等于用户传入的范围，同时限定了个数，interval 按照个数均分

  if (min === minLimit && max === maxLimit && isFixedCount) {
    interval = (max - min) / (count - 1);
  }

  if (Util.isNil(min)) {
    min = 0;
  }

  if (Util.isNil(max)) {
    max = 0;
  }

  if (max === min) {
    if (min === 0) {
      max = 1;
    } else {
      if (min > 0) {
        min = 0;
      } else {
        max = 0;
      }
    }

    if (max - min < 5 && !interval && max - min >= 1) {
      interval = 1;
    }
  }

  if (Util.isNil(interval)) {
    // 计算间距
    var temp = (max - min) / (avgCount - 1);
    interval = AutoUtil.snapFactorTo(temp, snapArray, 'ceil');

    if (maxCount !== minCount) {
      count = parseInt((max - min) / interval, 10);

      if (count > maxCount) {
        count = maxCount;
      }

      if (count < minCount) {
        count = minCount;
      } // 不确定tick的个数时，使得tick偏小


      interval = AutoUtil.snapFactorTo((max - min) / (count - 1), snapArray, 'floor');
    }
  }

  if (info.interval || maxCount !== minCount) {
    // 校正 max 和 min
    max = Math.min(AutoUtil.snapMultiple(max, interval, 'ceil'), maxLimit); // 向上逼近

    min = Math.max(AutoUtil.snapMultiple(min, interval, 'floor'), minLimit); // 向下逼近

    count = Math.round((max - min) / interval);
    min = Util.fixedBase(min, interval);
    max = Util.fixedBase(max, interval);
  } else {
    avgCount = parseInt(avgCount, 10); // 取整

    var avg = (max + min) / 2;
    var avgTick = AutoUtil.snapMultiple(avg, interval, 'ceil');
    var sideCount = Math.floor((avgCount - 2) / 2);
    var maxTick = avgTick + sideCount * interval;
    var minTick;

    if (avgCount % 2 === 0) {
      minTick = avgTick - sideCount * interval;
    } else {
      minTick = avgTick - (sideCount + 1) * interval;
    }

    if (maxTick < max) {
      maxTick = maxTick + interval;
    }

    if (minTick > min) {
      minTick = minTick - interval;
    }

    max = Util.fixedBase(maxTick, interval);
    min = Util.fixedBase(minTick, interval);
  }

  max = Math.min(max, maxLimit);
  min = Math.max(min, minLimit);
  ticks.push(min);

  for (var i = 1; i < count; i++) {
    var tickValue = Util.fixedBase(interval * i + min, interval);

    if (tickValue < max) {
      ticks.push(tickValue);
    }
  }

  if (ticks[ticks.length - 1] < max) {
    ticks.push(max);
  }

  return {
    min: min,
    max: max,
    interval: interval,
    count: count,
    ticks: ticks
  };
};

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview The data is replaced with constant
 * @author dxq613@gmail.com
 */
var Base = __webpack_require__(27);

var Util = __webpack_require__(1);

var Identity =
/*#__PURE__*/
function (_Base) {
  _inherits(Identity, _Base);

  function Identity() {
    _classCallCheck(this, Identity);

    return _possibleConstructorReturn(this, _getPrototypeOf(Identity).apply(this, arguments));
  }

  _createClass(Identity, [{
    key: "getDefaultCfg",

    /**
     * @override
     */
    value: function getDefaultCfg() {
      var cfg = _get(_getPrototypeOf(Identity.prototype), "getDefaultCfg", this).call(this);

      return Util.mix({}, cfg, {
        isIdentity: true,

        /**
         * @override
         * @type {String}
         */
        type: 'identity',

        /**
         * 常量值
         * @type {*}
         */
        value: null
      });
    }
    /**
     * @override
     */

  }, {
    key: "getText",
    value: function getText() {
      return this.value.toString();
    }
    /**
     * @override
     */

  }, {
    key: "scale",
    value: function scale(value) {
      if (this.value !== value && Util.isNumber(value)) {
        return value;
      }

      return this.range[0];
    }
    /**
     * @override
     */

  }, {
    key: "invert",
    value: function invert() {
      return this.value;
    }
  }]);

  return Identity;
}(Base);

module.exports = Identity;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview The measurement of linear data scale function
 * @author dxq613@gmail.com
 */
var Linear = __webpack_require__(28);

var Util = __webpack_require__(1);

var timeAuto = __webpack_require__(263);

var fecha = __webpack_require__(64);

var TimeUtil = __webpack_require__(65);
/**
 * 时间度量的构造函数
 * @class Scale.Time
 */


var Time =
/*#__PURE__*/
function (_Linear) {
  _inherits(Time, _Linear);

  function Time() {
    _classCallCheck(this, Time);

    return _possibleConstructorReturn(this, _getPrototypeOf(Time).apply(this, arguments));
  }

  _createClass(Time, [{
    key: "getDefaultCfg",

    /**
     * @override
     */
    value: function getDefaultCfg() {
      var cfg = _get(_getPrototypeOf(Time.prototype), "getDefaultCfg", this).call(this);

      return Util.mix({}, cfg, {
        /**
         * @override
         */
        type: 'time',

        /**
         * 格式化符
         * @type {String}
         */
        mask: 'YYYY-MM-DD'
      });
    }
    /**
     * @override
     */

  }, {
    key: "init",
    value: function init() {
      var self = this;
      var values = self.values;

      if (values && values.length) {
        // 重新计算最大最小值
        var timeStamps = [];
        var min = Infinity; // 最小值

        var secondMin = min; // 次小值

        var max = 0; // 使用一个循环，计算min,max,secondMin

        Util.each(values, function (v) {
          var timeStamp = self._toTimeStamp(v);

          if (isNaN(timeStamp)) {
            throw new TypeError("Invalid Time: ".concat(v));
          }

          if (min > timeStamp) {
            secondMin = min;
            min = timeStamp;
          } else if (secondMin > timeStamp) {
            secondMin = timeStamp;
          }

          if (max < timeStamp) {
            max = timeStamp;
          }

          timeStamps.push(timeStamp);
        }); // 存在多个值时，设置最小间距

        if (values.length > 1) {
          self.minTickInterval = secondMin - min;
        }

        if (Util.isNil(self.min) || self._toTimeStamp(self.min) > min) {
          self.min = min;
        }

        if (Util.isNil(self.max) || self._toTimeStamp(self.max) < max) {
          self.max = max;
        }
      }

      _get(_getPrototypeOf(Time.prototype), "init", this).call(this);
    }
  }, {
    key: "calculateTicks",
    value: function calculateTicks() {
      var self = this;
      var min = self.min;
      var max = self.max;
      var count = self.tickCount;
      var interval = self.tickInterval;
      var tmp = timeAuto({
        min: min,
        max: max,
        minCount: count,
        maxCount: count,
        interval: interval,
        minInterval: self.minTickInterval
      });
      return tmp.ticks;
    }
    /**
     * @override
     */

  }, {
    key: "getText",
    value: function getText(value) {
      var formatter = this.formatter;
      value = this.translate(value);
      value = formatter ? formatter(value) : fecha.format(value, this.mask);
      return value;
    }
    /**
     * @override
     */

  }, {
    key: "scale",
    value: function scale(value) {
      if (Util.isString(value)) {
        value = this.translate(value);
      }

      return _get(_getPrototypeOf(Time.prototype), "scale", this).call(this, value);
    }
    /**
     * @override
     */

  }, {
    key: "translate",
    value: function translate(value) {
      return this._toTimeStamp(value);
    } // 将时间转换为时间戳

  }, {
    key: "_toTimeStamp",
    value: function _toTimeStamp(value) {
      return TimeUtil.toTimeStamp(value);
    }
  }]);

  return Time;
}(Linear);

module.exports = Time;

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview 计算时间坐标轴
 * @author dxq613@gmail.com
 */
var Util = __webpack_require__(1);

var AutoUtil = __webpack_require__(61);

var MAX_COUNT = 6;
var SNAP_ARRAY = [1, 2, 4, 6, 8, 12];
var MINUTE_MS = 60 * 1000;
var HOUR_MS = 3600 * 1000;
var DAY_MS = 24 * 3600 * 1000;

function getYear(date) {
  return new Date(date).getFullYear();
}

function createYear(year) {
  return new Date(year, 0, 1).getTime();
}

function getMonth(date) {
  return new Date(date).getMonth();
}

function diffMonth(min, max) {
  var minYear = getYear(min);
  var maxYear = getYear(max);
  var minMonth = getMonth(min);
  var maxMonth = getMonth(max);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}

function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}

function diffDay(min, max) {
  return Math.ceil((max - min) / DAY_MS);
}

function diffHour(min, max) {
  return Math.ceil((max - min) / HOUR_MS);
}

function diffMinus(min, max) {
  return Math.ceil((max - min) / (60 * 1000));
}

module.exports = function (info) {
  var minInterval = info.minInterval;
  var ticks = [];
  var min = info.min;
  var max = info.max;
  var interval = info.interval;
  var count; // 如果最大值和最小值相等，则设置最大值大于最小值一天

  if (max === min) {
    max = min + DAY_MS;
  } // 计算间距


  if (Util.isNil(interval)) {
    var innerTime = max - min;
    var dms = DAY_MS; // 天代表的秒

    var yms = 365 * dms; // 年代表的秒

    interval = parseInt(innerTime / (info.maxCount || MAX_COUNT), 10);

    if (minInterval && minInterval > interval) {
      interval = minInterval;
    }

    var yfactor = interval / yms;
    var minYear = getYear(min); // 大于半年

    if (yfactor > 0.51) {
      var year = Math.ceil(yfactor); // interval = year * yms;

      var maxYear = getYear(max);

      for (var i = minYear; i <= maxYear + year; i = i + year) {
        ticks.push(createYear(i));
      }

      interval = null;
    } else if (yfactor > 0.0834) {
      // 大于一个月
      var month = Math.ceil(yfactor / 0.0834);
      var mmMoth = getMonth(min);
      var dMonths = diffMonth(min, max);

      for (var _i = 0; _i <= dMonths + month; _i = _i + month) {
        ticks.push(creatMonth(minYear, _i + mmMoth));
      }

      interval = null;
    } else if (interval > dms * 0.5) {
      // 大于一天
      var date = new Date(min);

      var _year = date.getFullYear();

      var _month = date.getMonth(min);

      var mday = date.getDate();
      var day = Math.ceil(interval / dms);
      var ddays = diffDay(min, max);
      interval = day * dms;

      for (var _i2 = 0; _i2 < ddays + day; _i2 = _i2 + day) {
        ticks.push(new Date(_year, _month, mday + _i2).getTime());
      }
    } else if (interval > HOUR_MS) {
      // 大于一个小时
      var _date = new Date(min);

      var _year2 = _date.getFullYear();

      var _month2 = _date.getMonth(min);

      var _day = _date.getDate();

      var hour = _date.getHours();

      var hours = AutoUtil.snapTo(SNAP_ARRAY, Math.ceil(interval / HOUR_MS));
      var dHours = diffHour(min, max);
      interval = hours * HOUR_MS;

      for (var _i3 = 0; _i3 <= dHours + hours; _i3 = _i3 + hours) {
        ticks.push(new Date(_year2, _month2, _day, hour + _i3).getTime());
      }
    } else if (interval > MINUTE_MS) {
      // 最小单位是分钟
      var dMinus = diffMinus(min, max);
      var minutes = Math.ceil(interval / MINUTE_MS);
      interval = minutes * MINUTE_MS;

      for (var _i4 = 0; _i4 <= dMinus + minutes; _i4 = _i4 + minutes) {
        ticks.push(min + _i4 * MINUTE_MS);
      }
    } else {
      if (interval < 1000) {
        interval = 1000;
      }

      min = Math.floor(min / 1000) * 1000;
      var dSeconds = Math.ceil((max - min) / 1000);
      var seconds = Math.ceil(interval / 1000);
      interval = seconds * 1000;

      for (var _i5 = 0; _i5 < dSeconds + seconds; _i5 = _i5 + seconds) {
        ticks.push(min + _i5 * 1000);
      }
    }
  }

  if (!ticks.length) {
    min = Math.floor(min / 1000) * 1000;
    max = Math.ceil(max / 1000) * 1000;
    count = (max - min) / interval;

    for (var _i6 = 0; _i6 <= count; _i6++) {
      ticks.push(Util.fixedBase(interval * _i6 + min, interval));
    }
  }

  return {
    max: max,
    min: min,
    interval: interval,
    ticks: ticks,
    count: ticks.length
  };
};

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview 时间数据作为分类类型
 * @author dxq613@gmail.com
 */
var Category = __webpack_require__(62);

var Util = __webpack_require__(1);

var fecha = __webpack_require__(64);

var catAuto = __webpack_require__(63);

var TimeUtil = __webpack_require__(65);
/**
 * 度量的构造函数
 * @class Scale.TimeCategory
 */


var TimeCategory =
/*#__PURE__*/
function (_Category) {
  _inherits(TimeCategory, _Category);

  function TimeCategory() {
    _classCallCheck(this, TimeCategory);

    return _possibleConstructorReturn(this, _getPrototypeOf(TimeCategory).apply(this, arguments));
  }

  _createClass(TimeCategory, [{
    key: "getDefaultCfg",

    /**
     * @override
     */
    value: function getDefaultCfg() {
      var cfg = _get(_getPrototypeOf(TimeCategory.prototype), "getDefaultCfg", this).call(this);

      return Util.mix({}, cfg, {
        /**
         * @override
         */
        type: 'timeCat',

        /**
         * 格式化符
         * @type {String}
         */
        mask: 'YYYY-MM-DD',

        /**
         * @override
         */
        tickCount: 7
      });
    }
  }, {
    key: "init",
    value: function init() {
      var self = this;
      var values = this.values; // 针对时间分类类型，会将时间统一转换为时间戳

      Util.each(values, function (v, i) {
        values[i] = self._toTimeStamp(v);
      });
      values.sort(function (v1, v2) {
        return v1 - v2;
      });

      if (!self.ticks) {
        self.ticks = this.calculateTicks(false);
      }
    }
    /**
     * 计算 ticks
     * @param  {boolean} formated 是否将 ticks 按照指定的 mask 格式化
     * @return {array} 返回 ticks 数组
     */

  }, {
    key: "calculateTicks",
    value: function calculateTicks(formated) {
      var self = this;
      var count = self.tickCount;
      var ticks;

      if (count) {
        var temp = catAuto({
          maxCount: count,
          data: self.values
        });
        ticks = temp.ticks;
      } else {
        ticks = self.values;
      }

      if (formated) {
        Util.each(ticks, function (value, index) {
          ticks[index] = fecha.format(value, self.mask);
        });
      }

      return ticks;
    }
    /**
     * @override
     */

  }, {
    key: "translate",
    value: function translate(value) {
      value = this._toTimeStamp(value);
      var index = this.values.indexOf(value);

      if (index === -1) {
        if (Util.isNumber(value) && value < this.values.length) {
          index = value;
        } else {
          index = NaN;
        }
      }

      return index;
    }
    /**
     * @override
     */

  }, {
    key: "scale",
    value: function scale(value) {
      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      var index = this.translate(value);
      var percent;

      if (this.values.length === 1) {
        percent = index;
      } else if (index > -1) {
        percent = index / (this.values.length - 1);
      } else {
        percent = 0;
      }

      return rangeMin + percent * (rangeMax - rangeMin);
    }
    /**
     * @override
     */

  }, {
    key: "getText",
    value: function getText(value) {
      var result = '';
      var index = this.translate(value);

      if (index > -1) {
        result = this.values[index];
      } else {
        result = value;
      }

      var formatter = this.formatter;
      result = parseInt(result, 10);
      result = formatter ? formatter(result) : fecha.format(result, this.mask);
      return result;
    }
    /**
     * @override
     */

  }, {
    key: "getTicks",
    value: function getTicks() {
      var self = this;
      var ticks = this.ticks;
      var rst = [];
      Util.each(ticks, function (tick) {
        var obj;

        if (Util.isObject(tick)) {
          obj = tick;
        } else {
          obj = {
            text: Util.isString(tick) ? tick : self.getText(tick),
            tickValue: tick,
            // 用于坐标轴上文本动画时确定前后帧的对应关系
            value: self.scale(tick)
          };
        }

        rst.push(obj);
      });
      return rst;
    } // 将时间转换为时间戳

  }, {
    key: "_toTimeStamp",
    value: function _toTimeStamp(value) {
      return TimeUtil.toTimeStamp(value);
    }
  }]);

  return TimeCategory;
}(Category);

module.exports = TimeCategory;

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview 使用度量，进行log转换
 * @author dxq613@gmail.com
 */
var Linear = __webpack_require__(28);

var Util = __webpack_require__(1); // 计算log


function log(a, b) {
  if (a === 1) {
    return 1;
  }

  return Math.log(b) / Math.log(a);
}
/**
 * 度量的log计算
 * @class Scale.Log
 */


var Log =
/*#__PURE__*/
function (_Linear) {
  _inherits(Log, _Linear);

  function Log() {
    _classCallCheck(this, Log);

    return _possibleConstructorReturn(this, _getPrototypeOf(Log).apply(this, arguments));
  }

  _createClass(Log, [{
    key: "getDefaultCfg",

    /**
     * @override
     */
    value: function getDefaultCfg() {
      var cfg = _get(_getPrototypeOf(Log.prototype), "getDefaultCfg", this).call(this);

      return Util.mix({}, cfg, {
        /**
         * @override
         */
        type: 'log',

        /**
         * 进行log计算的基数
         * @type {Number}
         */
        base: 2,

        /**
         * @override
         * log 的坐标点的个数控制在10个以下
         * @type {Number}
         */
        tickCount: 10,
        // 最小的tick，仅内部使用
        _minTick: null
      });
    }
    /**
     * @override
     */

  }, {
    key: "calculateTicks",
    value: function calculateTicks() {
      var self = this;
      var base = self.base;
      var minTick;

      if (self.min < 0) {
        throw new Error('The minimum value must be greater than zero!');
      }

      var maxTick = log(base, self.max);

      if (self.min > 0) {
        minTick = Math.floor(log(base, self.min));
      } else {
        var values = self.values;
        var positiveMin = self.max; // 查找大于0的第一个值, 如果都小于0，默认为1

        Util.each(values, function (value) {
          if (value > 0 && value < positiveMin) {
            positiveMin = value;
          }
        });

        if (positiveMin === self.max) {
          positiveMin = self.max / base;
        }

        if (positiveMin > 1) {
          positiveMin = 1;
        }

        minTick = Math.floor(log(base, positiveMin));
        self._minTick = minTick;
        self.positiveMin = positiveMin;
      }

      var count = maxTick - minTick;
      var tickCount = self.tickCount;
      var avg = Math.ceil(count / tickCount);
      var ticks = [];

      for (var i = minTick; i < maxTick + avg; i = i + avg) {
        ticks.push(Math.pow(base, i));
      }
      /**/


      if (self.min === 0) {
        ticks.unshift(0);
      }

      return ticks;
    } // 获取度量计算时，value占的定义域百分比

  }, {
    key: "_getScalePercent",
    value: function _getScalePercent(value) {
      var max = this.max;
      var min = this.min;

      if (max === min) {
        return 0;
      } // 如果值小于等于0，则按照0处理


      if (value <= 0) {
        return 0;
      }

      var base = this.base;
      var positiveMin = this.positiveMin; // 如果min == 0, 则根据比0大的最小值，计算比例关系。这个最小值作为坐标轴上的第二个tick，第一个是0但是不显示

      if (positiveMin) {
        min = positiveMin * 1 / base;
      }

      var percent; // 如果数值小于次小值，那么就计算 value / 次小值 占整体的比例

      if (value < positiveMin) {
        percent = value / positiveMin / (log(base, max) - log(base, min));
      } else {
        percent = (log(base, value) - log(base, min)) / (log(base, max) - log(base, min));
      }

      return percent;
    }
    /**
     * @override
     */

  }, {
    key: "scale",
    value: function scale(value) {
      var percent = this._getScalePercent(value);

      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      return rangeMin + percent * (rangeMax - rangeMin);
    }
    /**
     * @override
     */

  }, {
    key: "invert",
    value: function invert(value) {
      var base = this.base;
      var max = log(base, this.max);
      var rangeMin = this.rangeMin();
      var range = this.rangeMax() - rangeMin;
      var min;
      var positiveMin = this.positiveMin;

      if (positiveMin) {
        if (value === 0) {
          return 0;
        }

        min = log(base, positiveMin / base);
        var appendPercent = 1 / (max - min) * range; // 0 到 positiveMin的占比

        if (value < appendPercent) {
          // 落到 0 - positiveMin 之间
          return value / appendPercent * positiveMin;
        }
      } else {
        min = log(base, this.min);
      }

      var percent = (value - rangeMin) / range;
      var tmp = percent * (max - min) + min;
      return Math.pow(base, tmp);
    }
  }]);

  return Log;
}(Linear);

module.exports = Log;

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview 使用pow进行度量计算
 * @author dxq613@gmail.com
 */
var Linear = __webpack_require__(28);

var Util = __webpack_require__(1); // 求以a为次幂，结果为b的基数，如 x^^a = b;求x


function calBase(a, b) {
  var e = Math.E;
  var value = Math.pow(e, Math.log(b) / a); // 使用换底公式求底

  return value;
}
/**
 * 度量的Pow计算
 * @class Scale.Log
 */


var Pow =
/*#__PURE__*/
function (_Linear) {
  _inherits(Pow, _Linear);

  function Pow() {
    _classCallCheck(this, Pow);

    return _possibleConstructorReturn(this, _getPrototypeOf(Pow).apply(this, arguments));
  }

  _createClass(Pow, [{
    key: "getDefaultCfg",

    /**
     * @override
     */
    value: function getDefaultCfg() {
      var cfg = _get(_getPrototypeOf(Pow.prototype), "getDefaultCfg", this).call(this);

      return Util.mix({}, cfg, {
        /**
         * @override
         */
        type: 'pow',

        /**
         * 进行pow计算的基数
         * @type {Number}
         */
        exponent: 2,

        /**
         * @override
         * pow 的坐标点的个数控制在10个以下
         * @type {Number}
         */
        tickCount: 10
      });
    }
    /**
     * @override
     */

  }, {
    key: "calculateTicks",
    value: function calculateTicks() {
      var self = this;
      var exponent = self.exponent;
      var min;
      var max = Math.ceil(calBase(exponent, self.max));

      if (self.min >= 0) {
        min = Math.floor(calBase(exponent, self.min));
      } else {
        min = 0;
      }

      if (min > max) {
        var tmp = max;
        max = min;
        min = tmp;
      }

      var count = max - min;
      var tickCount = self.tickCount;
      var avg = Math.ceil(count / tickCount);
      var ticks = [];

      for (var i = min; i < max + avg; i = i + avg) {
        ticks.push(Math.pow(i, exponent));
      }

      return ticks;
    } // 获取度量计算时，value占的定义域百分比

  }, {
    key: "_getScalePercent",
    value: function _getScalePercent(value) {
      var max = this.max;
      var min = this.min;

      if (max === min) {
        return 0;
      }

      var exponent = this.exponent;
      var percent = (calBase(exponent, value) - calBase(exponent, min)) / (calBase(exponent, max) - calBase(exponent, min));
      return percent;
    }
    /**
     * @override
     */

  }, {
    key: "scale",
    value: function scale(value) {
      var percent = this._getScalePercent(value);

      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      return rangeMin + percent * (rangeMax - rangeMin);
    }
    /**
     * @override
     */

  }, {
    key: "invert",
    value: function invert(value) {
      var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
      var exponent = this.exponent;
      var max = calBase(exponent, this.max);
      var min = calBase(exponent, this.min);
      var tmp = percent * (max - min) + min;
      return Math.pow(tmp, exponent);
    }
  }]);

  return Pow;
}(Linear);

module.exports = Pow;

/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = aProjectFlat;
function aProjectFlat(lnglat) {
  var maxs = 85.0511287798;
  var lat = Math.max(Math.min(maxs, lnglat[1]), -maxs);
  var scale = 256 << 20;
  var d = Math.PI / 180;
  var x = lnglat[0] * d;
  var y = lat * d;
  y = Math.log(Math.tan(Math.PI / 4 + y / 2));
  var a = 0.5 / Math.PI,
      b = 0.5,
      c = -0.5 / Math.PI;
  d = 0.5;
  x = scale * (a * x + b) - 215440491;
  y = scale * (c * y + d) - 106744817;
  return {
    x: x,
    y: y
  };
}

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var helpers_1 = __webpack_require__(36);

var invariant_1 = __webpack_require__(67); // To-Do => Improve Typescript GeoJSON handling

/**
 * Removes redundant coordinates from any GeoJSON Geometry.
 *
 * @name cleanCoords
 * @param {Geometry|Feature} geojson Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated
 * @returns {Geometry|Feature} the cleaned input Feature/Geometry
 * @example
 * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);
 * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);
 *
 * turf.cleanCoords(line).geometry.coordinates;
 * //= [[0, 0], [0, 10]]
 *
 * turf.cleanCoords(multiPoint).geometry.coordinates;
 * //= [[0, 0], [2, 2]]
 */


function cleanCoords(geojson, options) {
  if (options === void 0) {
    options = {};
  } // Backwards compatible with v4.0


  var mutate = typeof options === 'object' ? options.mutate : options;
  if (!geojson) throw new Error('geojson is required');
  var type = invariant_1.getType(geojson); // Store new "clean" points in this Array

  var newCoords = [];

  switch (type) {
    case 'LineString':
      newCoords = cleanLine(geojson);
      break;

    case 'MultiLineString':
    case 'Polygon':
      invariant_1.getCoords(geojson).forEach(function (line) {
        newCoords.push(cleanLine(line));
      });
      break;

    case 'MultiPolygon':
      invariant_1.getCoords(geojson).forEach(function (polygons) {
        var polyPoints = [];
        polygons.forEach(function (ring) {
          polyPoints.push(cleanLine(ring));
        });
        newCoords.push(polyPoints);
      });
      break;

    case 'Point':
      return geojson;

    case 'MultiPoint':
      var existing = {};
      invariant_1.getCoords(geojson).forEach(function (coord) {
        var key = coord.join('-');

        if (!existing.hasOwnProperty(key)) {
          newCoords.push(coord);
          existing[key] = true;
        }
      });
      break;

    default:
      throw new Error(type + ' geometry not supported');
  } // Support input mutation


  if (geojson.coordinates) {
    if (mutate === true) {
      geojson.coordinates = newCoords;
      return geojson;
    }

    return {
      type: type,
      coordinates: newCoords
    };
  } else {
    if (mutate === true) {
      geojson.geometry.coordinates = newCoords;
      return geojson;
    }

    return helpers_1.feature({
      type: type,
      coordinates: newCoords
    }, geojson.properties, {
      bbox: geojson.bbox,
      id: geojson.id
    });
  }
}
/**
 * Clean Coords
 *
 * @private
 * @param {Array<number>|LineString} line Line
 * @returns {Array<number>} Cleaned coordinates
 */


function cleanLine(line) {
  var points = invariant_1.getCoords(line); // handle "clean" segment

  if (points.length === 2 && !equals(points[0], points[1])) return points;
  var newPoints = [];
  var secondToLast = points.length - 1;
  var newPointsLength = newPoints.length;
  newPoints.push(points[0]);

  for (var i = 1; i < secondToLast; i++) {
    var prevAddedPoint = newPoints[newPoints.length - 1];
    if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1]) continue;else {
      newPoints.push(points[i]);
      newPointsLength = newPoints.length;

      if (newPointsLength > 2) {
        if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);
      }
    }
  }

  newPoints.push(points[points.length - 1]);
  newPointsLength = newPoints.length;
  if (equals(points[0], points[points.length - 1]) && newPointsLength < 4) throw new Error('invalid polygon');
  if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);
  return newPoints;
}
/**
 * Compares two points and returns if they are equals
 *
 * @private
 * @param {Position} pt1 point
 * @param {Position} pt2 point
 * @returns {boolean} true if they are equals
 */


function equals(pt1, pt2) {
  return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
/**
 * Returns if `point` is on the segment between `start` and `end`.
 * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)
 *
 * @private
 * @param {Position} start coord pair of start of line
 * @param {Position} end coord pair of end of line
 * @param {Position} point coord pair of point to check
 * @returns {boolean} true/false
 */


function isPointOnLineSegment(start, end, point) {
  var x = point[0],
      y = point[1];
  var startX = start[0],
      startY = start[1];
  var endX = end[0],
      endY = end[1];
  var dxc = x - startX;
  var dyc = y - startY;
  var dxl = endX - startX;
  var dyl = endY - startY;
  var cross = dxc * dyl - dyc * dxl;
  if (cross !== 0) return false;else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
}

exports.default = cleanCoords;

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = rbush;
module.exports.default = rbush;

var quickselect = __webpack_require__(270);

function rbush(maxEntries, format) {
  if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance

  this._maxEntries = Math.max(4, maxEntries || 9);
  this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

  if (format) {
    this._initFormat(format);
  }

  this.clear();
}

rbush.prototype = {
  all: function () {
    return this._all(this.data, []);
  },
  search: function (bbox) {
    var node = this.data,
        result = [],
        toBBox = this.toBBox;
    if (!intersects(bbox, node)) return result;
    var nodesToSearch = [],
        i,
        len,
        child,
        childBBox;

    while (node) {
      for (i = 0, len = node.children.length; i < len; i++) {
        child = node.children[i];
        childBBox = node.leaf ? toBBox(child) : child;

        if (intersects(bbox, childBBox)) {
          if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);
        }
      }

      node = nodesToSearch.pop();
    }

    return result;
  },
  collides: function (bbox) {
    var node = this.data,
        toBBox = this.toBBox;
    if (!intersects(bbox, node)) return false;
    var nodesToSearch = [],
        i,
        len,
        child,
        childBBox;

    while (node) {
      for (i = 0, len = node.children.length; i < len; i++) {
        child = node.children[i];
        childBBox = node.leaf ? toBBox(child) : child;

        if (intersects(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox)) return true;
          nodesToSearch.push(child);
        }
      }

      node = nodesToSearch.pop();
    }

    return false;
  },
  load: function (data) {
    if (!(data && data.length)) return this;

    if (data.length < this._minEntries) {
      for (var i = 0, len = data.length; i < len; i++) {
        this.insert(data[i]);
      }

      return this;
    } // recursively build the tree with the given data from scratch using OMT algorithm


    var node = this._build(data.slice(), 0, data.length - 1, 0);

    if (!this.data.children.length) {
      // save as is if tree is empty
      this.data = node;
    } else if (this.data.height === node.height) {
      // split root if trees have the same height
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        // swap trees if inserted one is bigger
        var tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      } // insert the small tree into the large tree at appropriate level


      this._insert(node, this.data.height - node.height - 1, true);
    }

    return this;
  },
  insert: function (item) {
    if (item) this._insert(item, this.data.height - 1);
    return this;
  },
  clear: function () {
    this.data = createNode([]);
    return this;
  },
  remove: function (item, equalsFn) {
    if (!item) return this;
    var node = this.data,
        bbox = this.toBBox(item),
        path = [],
        indexes = [],
        i,
        parent,
        index,
        goingUp; // depth-first iterative tree traversal

    while (node || path.length) {
      if (!node) {
        // go up
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }

      if (node.leaf) {
        // check current node
        index = findItem(item, node.children, equalsFn);

        if (index !== -1) {
          // item found, remove the item and condense tree upwards
          node.children.splice(index, 1);
          path.push(node);

          this._condense(path);

          return this;
        }
      }

      if (!goingUp && !node.leaf && contains(node, bbox)) {
        // go down
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        // go right
        i++;
        node = parent.children[i];
        goingUp = false;
      } else node = null; // nothing found

    }

    return this;
  },
  toBBox: function (item) {
    return item;
  },
  compareMinX: compareNodeMinX,
  compareMinY: compareNodeMinY,
  toJSON: function () {
    return this.data;
  },
  fromJSON: function (data) {
    this.data = data;
    return this;
  },
  _all: function (node, result) {
    var nodesToSearch = [];

    while (node) {
      if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);
      node = nodesToSearch.pop();
    }

    return result;
  },
  _build: function (items, left, right, height) {
    var N = right - left + 1,
        M = this._maxEntries,
        node;

    if (N <= M) {
      // reached leaf level; return leaf
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }

    if (!height) {
      // target height of the bulk-loaded tree
      height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization

      M = Math.ceil(N / Math.pow(M, height - 1));
    }

    node = createNode([]);
    node.leaf = false;
    node.height = height; // split the items into M mostly square tiles

    var N2 = Math.ceil(N / M),
        N1 = N2 * Math.ceil(Math.sqrt(M)),
        i,
        j,
        right2,
        right3;
    multiSelect(items, left, right, N1, this.compareMinX);

    for (i = left; i <= right; i += N1) {
      right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);

      for (j = i; j <= right2; j += N2) {
        right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively

        node.children.push(this._build(items, j, right3, height - 1));
      }
    }

    calcBBox(node, this.toBBox);
    return node;
  },
  _chooseSubtree: function (bbox, node, level, path) {
    var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level) break;
      minArea = minEnlargement = Infinity;

      for (i = 0, len = node.children.length; i < len; i++) {
        child = node.children[i];
        area = bboxArea(child);
        enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement

        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          // otherwise choose one with the smallest area
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }

      node = targetNode || node.children[0];
    }

    return node;
  },
  _insert: function (item, level, isNode) {
    var toBBox = this.toBBox,
        bbox = isNode ? item : toBBox(item),
        insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too

    var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node


    node.children.push(item);
    extend(node, bbox); // split on node overflow; propagate upwards if necessary

    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);

        level--;
      } else break;
    } // adjust bboxes along the insertion path


    this._adjustParentBBoxes(bbox, insertPath, level);
  },
  // split overflowed node into two
  _split: function (insertPath, level) {
    var node = insertPath[level],
        M = node.children.length,
        m = this._minEntries;

    this._chooseSplitAxis(node, m, M);

    var splitIndex = this._chooseSplitIndex(node, m, M);

    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);
  },
  _splitRoot: function (node, newNode) {
    // split root node
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  },
  _chooseSplitIndex: function (node, m, M) {
    var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
    minOverlap = minArea = Infinity;

    for (i = m; i <= M - m; i++) {
      bbox1 = distBBox(node, 0, i, this.toBBox);
      bbox2 = distBBox(node, i, M, this.toBBox);
      overlap = intersectionArea(bbox1, bbox2);
      area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap

      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        // otherwise choose distribution with minimum area
        if (area < minArea) {
          minArea = area;
          index = i;
        }
      }
    }

    return index;
  },
  // sorts node children by the best axis for split
  _chooseSplitAxis: function (node, m, M) {
    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
        compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
        xMargin = this._allDistMargin(node, m, M, compareMinX),
        yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,
    // otherwise it's already sorted by minY


    if (xMargin < yMargin) node.children.sort(compareMinX);
  },
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin: function (node, m, M, compare) {
    node.children.sort(compare);
    var toBBox = this.toBBox,
        leftBBox = distBBox(node, 0, m, toBBox),
        rightBBox = distBBox(node, M - m, M, toBBox),
        margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
        i,
        child;

    for (i = m; i < M - m; i++) {
      child = node.children[i];
      extend(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }

    for (i = M - m - 1; i >= m; i--) {
      child = node.children[i];
      extend(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }

    return margin;
  },
  _adjustParentBBoxes: function (bbox, path, level) {
    // adjust bboxes along the given tree path
    for (var i = level; i >= 0; i--) {
      extend(path[i], bbox);
    }
  },
  _condense: function (path) {
    // go through the path, removing empty nodes and updating bboxes
    for (var i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else this.clear();
      } else calcBBox(path[i], this.toBBox);
    }
  },
  _initFormat: function (format) {
    // data format (minX, minY, maxX, maxY accessors)
    // uses eval-type function compilation instead of just accepting a toBBox function
    // because the algorithms are very sensitive to sorting functions performance,
    // so they should be dead simple and without inner calls
    var compareArr = ['return a', ' - b', ';'];
    this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
    this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
    this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
  }
};

function findItem(item, items, equalsFn) {
  if (!equalsFn) return items.indexOf(item);

  for (var i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i])) return i;
  }

  return -1;
} // calculate node's bbox from bboxes of its children


function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
} // min bounding rectangle of node children from k to p-1


function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode) destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;

  for (var i = k, child; i < p; i++) {
    child = node.children[i];
    extend(destNode, node.leaf ? toBBox(child) : child);
  }

  return destNode;
}

function extend(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}

function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}

function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}

function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}

function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}

function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
  var minX = Math.max(a.minX, b.minX),
      minY = Math.max(a.minY, b.minY),
      maxX = Math.min(a.maxX, b.maxX),
      maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}

function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}

function intersects(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}

function createNode(children) {
  return {
    children: children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
} // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach


function multiSelect(arr, left, right, n, compare) {
  var stack = [left, right],
      mid;

  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n) continue;
    mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.quickselect = factory();
})(this, function () {
  'use strict';

  function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
  }

  function quickselectStep(arr, k, left, right, compare) {
    while (right > left) {
      if (right - left > 600) {
        var n = right - left + 1;
        var m = k - left + 1;
        var z = Math.log(n);
        var s = 0.5 * Math.exp(2 * z / 3);
        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
        quickselectStep(arr, k, newLeft, newRight, compare);
      }

      var t = arr[k];
      var i = left;
      var j = right;
      swap(arr, left, k);
      if (compare(arr[right], t) > 0) swap(arr, left, right);

      while (i < j) {
        swap(arr, i, j);
        i++;
        j--;

        while (compare(arr[i], t) < 0) i++;

        while (compare(arr[j], t) > 0) j--;
      }

      if (compare(arr[left], t) === 0) swap(arr, left, j);else {
        j++;
        swap(arr, j, right);
      }
      if (j <= k) left = j + 1;
      if (k <= j) right = j - 1;
    }
  }

  function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }

  function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }

  return quickselect;
});

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var meta_1 = __webpack_require__(66);
/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @name bbox
 * @param {GeoJSON} geojson any GeoJSON object
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
 * var bbox = turf.bbox(line);
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * //addToMap
 * var addToMap = [line, bboxPolygon]
 */


function bbox(geojson) {
  var result = [Infinity, Infinity, -Infinity, -Infinity];
  meta_1.coordEach(geojson, function (coord) {
    if (result[0] > coord[0]) {
      result[0] = coord[0];
    }

    if (result[1] > coord[1]) {
      result[1] = coord[1];
    }

    if (result[2] < coord[0]) {
      result[2] = coord[0];
    }

    if (result[3] < coord[1]) {
      result[3] = coord[1];
    }
  });
  return result;
}

exports.default = bbox;

/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dsv__ = __webpack_require__(37);
/* unused harmony reexport dsvFormat */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__csv__ = __webpack_require__(273);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_1__csv__["a"]; });
/* unused harmony reexport csvParseRows */
/* unused harmony reexport csvFormat */
/* unused harmony reexport csvFormatRows */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tsv__ = __webpack_require__(274);
/* unused harmony reexport tsvParse */
/* unused harmony reexport tsvParseRows */
/* unused harmony reexport tsvFormat */
/* unused harmony reexport tsvFormatRows */




/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return csvParse; });
/* unused harmony export csvParseRows */
/* unused harmony export csvFormat */
/* unused harmony export csvFormatRows */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dsv__ = __webpack_require__(37);

var csv = Object(__WEBPACK_IMPORTED_MODULE_0__dsv__["a" /* default */])(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;

/***/ }),
/* 274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export tsvParse */
/* unused harmony export tsvParseRows */
/* unused harmony export tsvFormat */
/* unused harmony export tsvFormatRows */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dsv__ = __webpack_require__(37);

var tsv = Object(__WEBPACK_IMPORTED_MODULE_0__dsv__["a" /* default */])("\t");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;

/***/ }),
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PickingMaterial;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_material_material__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__picking_frag_glsl__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__picking_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__picking_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__picking_vert_glsl__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__picking_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__picking_vert_glsl__);



function PickingMaterial(options) {
  var material = new __WEBPACK_IMPORTED_MODULE_0__geom_material_material__["a" /* default */]({
    uniforms: {
      u_zoom: {
        value: options.u_zoom || 1
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_2__picking_vert_glsl___default.a,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_1__picking_frag_glsl___default.a,
    transparent: false
  });
  return material;
}

/***/ }),
/* 276 */
/***/ (function(module, exports) {

module.exports = "\nprecision highp float;\nvarying vec4 worldId;\nvoid main() {\n    if(worldId.x == 0. &&worldId.y == 0. && worldId.z==0.){\n        discard;\n        return;\n    }\n    gl_FragColor = worldId;\n}"

/***/ }),
/* 277 */
/***/ (function(module, exports) {

module.exports = "attribute float pickingId;\n #ifdef polyline\n attribute float a_size;\n attribute float a_miter;\n#endif \n#ifdef point\nattribute vec3 a_size;\nattribute vec3 a_shape;\n#endif\nuniform float u_zoom;\nvarying vec4 worldId;\nvoid main() {\n    mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n    float scale = pow(2.0,(20.0 - u_zoom));\n    vec3 newposition =  position;\n    #ifdef point \n        newposition =position + a_size * scale * a_shape;\n    #endif\n    #ifdef polyline\n      newposition = position.xyz + vec3(normal * a_size * pow(2.0,20.0-u_zoom) / 2.0 * a_miter);\n     #endif \n    float id = step(0.,pickingId) * pickingId;\n    vec3 a = fract(vec3(1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * id);\n    a -= a.xxy * vec3(0.0, 1.0/255.0, 1.0/255.0);\n    worldId = vec4(a,1);\n    //gl_PointSize = a_size;\n    gl_Position = matModelViewProjection * vec4( newposition, 1.0 );\n}"

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

var Base = __webpack_require__(12);

Base.Color = __webpack_require__(279);
Base.Size = __webpack_require__(280);
Base.Opacity = __webpack_require__(281);
Base.Shape = __webpack_require__(282);
Base.Position = __webpack_require__(283);
Base.Symbol = __webpack_require__(284);
Base.Filter = __webpack_require__(285);
module.exports = Base;

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview the color attribute of core
 * @author huangtonger@aliyun.com
 */
var ColorUtil = __webpack_require__(35);

var Base = __webpack_require__(12);

var Util = __webpack_require__(1);
/**
 * 视觉通道 color
 * @class Attr.Color
 */


var Color =
/*#__PURE__*/
function (_Base) {
  _inherits(Color, _Base);

  function Color(cfg) {
    var _this;

    _classCallCheck(this, Color);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Color).call(this, cfg));
    _this.names = ['color'];
    _this.type = 'color';
    _this.gradient = null;

    if (Util.isString(_this.values)) {
      _this.linear = true;
    }

    return _this;
  }
  /**
   * @override
   */


  _createClass(Color, [{
    key: "getLinearValue",
    value: function getLinearValue(percent) {
      var gradient = this.gradient;

      if (!gradient) {
        var values = this.values;
        gradient = ColorUtil.gradient(values);
        this.gradient = gradient;
      }

      var color = gradient(percent);
      return color;
    }
  }]);

  return Color;
}(Base);

module.exports = Color;

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview the size attribute of core
 * @author huangtonger@aliyun.com
 */
var Base = __webpack_require__(12);

var Util = __webpack_require__(1);
/**
 * 视觉通道 size
 * @class Attr.Size
 */


var Size =
/*#__PURE__*/
function (_Base) {
  _inherits(Size, _Base);

  function Size(cfg) {
    var _this;

    _classCallCheck(this, Size);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Size).call(this, cfg));
    _this.names = ['size'];
    _this.type = 'size';
    _this.gradient = null;
    _this.domainIndex = 0;
    return _this;
  }

  _createClass(Size, [{
    key: "mapping",
    value: function mapping() {
      // 重构
      var self = this;
      var outputs = [];
      var scales = self.scales;

      if (self.values.length === 0) {
        var callback = this.callback.bind(this);
        outputs.push(callback.apply(void 0, arguments));
      } else {
        if (!Util.isArray(self.values[0])) {
          self.values = [self.values];
        }

        for (var i = 0; i < scales.length; i++) {
          outputs.push(self._scaling(scales[i], arguments[i]));
        }
      }

      this.domainIndex = 0;
      return outputs;
    }
  }, {
    key: "_scaling",
    value: function _scaling(scale, v) {
      if (scale.type === 'identity') {
        return v;
      } else if (scale.type === 'linear') {
        var percent = scale.scale(v);
        return this.getLinearValue(percent);
      }
    }
  }, {
    key: "getLinearValue",
    value: function getLinearValue(percent) {
      var values = this.values[this.domainIndex];
      var steps = values.length - 1;
      var step = Math.floor(steps * percent);
      var leftPercent = steps * percent - step;
      var start = values[step];
      var end = step === steps ? start : values[step + 1];
      var rstValue = start + (end - start) * leftPercent;
      this.domainIndex += 1;
      return rstValue;
    }
  }]);

  return Size;
}(Base);

module.exports = Size;

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview the opacity attribute of core
 * @author huangtonger@aliyun.com
 */
var Base = __webpack_require__(12);
/**
 * 视觉通道 Opacity
 * @class Attr.Opacity
 */


var Opacity =
/*#__PURE__*/
function (_Base) {
  _inherits(Opacity, _Base);

  function Opacity(cfg) {
    var _this;

    _classCallCheck(this, Opacity);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Opacity).call(this, cfg));
    _this.names = ['opacity'];
    _this.type = 'opacity';
    _this.gradient = null;
    return _this;
  }

  return Opacity;
}(Base);

module.exports = Opacity;

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview the shape attribute of core
 * @author huangtonger@aliyun.com
 */
var Base = __webpack_require__(12);
/**
 * 视觉通道 Shape
 * @class Attr.Shape
 */


var Shape =
/*#__PURE__*/
function (_Base) {
  _inherits(Shape, _Base);

  function Shape(cfg) {
    var _this;

    _classCallCheck(this, Shape);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Shape).call(this, cfg));
    _this.names = ['shape'];
    _this.type = 'shape';
    _this.gradient = null;
    return _this;
  }
  /**
   * @override
   */


  _createClass(Shape, [{
    key: "getLinearValue",
    value: function getLinearValue(percent) {
      var values = this.values;
      var index = Math.round((values.length - 1) * percent);
      return values[index];
    }
    /**
    * @override
    */

  }, {
    key: "_getAttrValue",
    value: function _getAttrValue(scale, value) {
      if (this.values === 'text') {
        return value;
      }

      var values = this.values;

      if (scale.isCategory && !this.linear) {
        var index = scale.translate(value);
        return values[index % values.length];
      }

      var percent = scale.scale(value);
      return this.getLinearValue(percent);
    }
  }]);

  return Shape;
}(Base);

module.exports = Shape;

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * @fileOverview the position attribute of core
 * @author huangtonger@aliyun.com
 */
var Util = __webpack_require__(1);

var Base = __webpack_require__(12);

var Position =
/*#__PURE__*/
function (_Base) {
  _inherits(Position, _Base);

  function Position(cfg) {
    var _this;

    _classCallCheck(this, Position);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Position).call(this, cfg));
    _this.names = ['x', 'y'];
    _this.type = 'position';
    return _this;
  }

  _createClass(Position, [{
    key: "mapping",
    value: function mapping(x, y) {
      var scales = this.scales;
      var coord = this.coord;
      var scaleX = scales[0];
      var scaleY = scales[1];
      var rstX;
      var rstY;
      var obj;

      if (Util.isNil(x) || Util.isNil(y)) {
        return [];
      }

      if (Util.isArray(y) && Util.isArray(x)) {
        rstX = [];
        rstY = [];

        for (var i = 0, j = 0; i < x.length && j < y.length; i++, j++) {
          obj = coord.convertPoint({
            x: scaleX.scale(x[i]),
            y: scaleY.scale(y[j])
          });
          rstX.push(obj.x);
          rstY.push(obj.y);
        }
      } else if (Util.isArray(y)) {
        x = scaleX.scale(x);
        rstY = [];
        Util.each(y, function (yVal) {
          yVal = scaleY.scale(yVal);
          obj = coord.convertPoint({
            x: x,
            y: yVal
          });

          if (rstX && rstX !== obj.x) {
            if (!Util.isArray(rstX)) {
              rstX = [rstX];
            }

            rstX.push(obj.x);
          } else {
            rstX = obj.x;
          }

          rstY.push(obj.y);
        });
      } else if (Util.isArray(x)) {
        y = scaleY.scale(y);
        rstX = [];
        Util.each(x, function (xVal) {
          xVal = scaleX.scale(xVal);
          obj = coord.convertPoint({
            x: xVal,
            y: y
          });

          if (rstY && rstY !== obj.y) {
            if (!Util.isArray(rstY)) {
              rstY = [rstY];
            }

            rstY.push(obj.y);
          } else {
            rstY = obj.y;
          }

          rstX.push(obj.x);
        });
      } else {
        x = scaleX.scale(x);
        y = scaleY.scale(y);
        var point = coord.convertPoint({
          x: x,
          y: y
        });
        rstX = point.x;
        rstY = point.y;
      }

      return [rstX, rstY];
    }
  }]);

  return Position;
}(Base);

module.exports = Position;

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/*
 * @Author: ThinkGIS
 * @Date: 2018-06-14 20:13:18
 * @Last Modified by: ThinkGIS
 * @Last Modified time: 2018-07-02 18:24:58
 */
var Base = __webpack_require__(12);
/**
 * 视觉通道 symbol
 * @class Attr.symbol
 */


var _Symbol =
/*#__PURE__*/
function (_Base) {
  _inherits(_Symbol, _Base);

  function _Symbol(cfg) {
    var _this;

    _classCallCheck(this, _Symbol);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(_Symbol).call(this, cfg));
    _this.names = ['symbol'];
    _this.type = 'symbol';
    _this.gradient = null;
    return _this;
  }

  return _Symbol;
}(Base);

module.exports = _Symbol;

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/*
 * @Author: ThinkGIS
 * @Date: 2018-06-14 20:13:18
 * @Last Modified by: ThinkGIS
 * @Last Modified time: 2018-07-15 17:26:40
 */
var Base = __webpack_require__(12);
/**
 * 视觉通道 symbol
 * @class Attr.symbol
 */


var Filter =
/*#__PURE__*/
function (_Base) {
  _inherits(Filter, _Base);

  function Filter(cfg) {
    var _this;

    _classCallCheck(this, Filter);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Filter).call(this, cfg));
    _this.names = ['filter'];
    _this.type = 'filter';
    _this.gradient = null;
    return _this;
  }

  return Filter;
}(Base);

module.exports = Filter;

/***/ }),
/* 286 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["circle"] = circle;
/* harmony export (immutable) */ __webpack_exports__["triangle"] = triangle;
/* harmony export (immutable) */ __webpack_exports__["diamond"] = diamond;
/* harmony export (immutable) */ __webpack_exports__["square"] = square;
/* harmony export (immutable) */ __webpack_exports__["hexagon"] = hexagon;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygon__ = __webpack_require__(72);

/**
 * shape circle
 * @param {enum} type  渲染类型
 * @return {object} 顶点坐标和索引坐标
 */

function circle(type) {
  var points = polygonPoint(30);
  return __WEBPACK_IMPORTED_MODULE_0__polygon__[type]([points]);
}
/**
 * @param {enum} type  渲染类型
 * @param {boolean} extrude  是否进行高度拉伸
 * @return {object} 顶点坐标和索引坐标
 */

function triangle(type) {
  var points = polygonPoint(3);
  return __WEBPACK_IMPORTED_MODULE_0__polygon__[type]([points]);
}
/**
 * @param {enum} type  渲染类型
 * @param {boolean} extrude  是否进行高度拉伸
 * @return {object} 顶点坐标和索引坐标
 */

function diamond(type) {
  var points = polygonPoint(4);
  return __WEBPACK_IMPORTED_MODULE_0__polygon__[type]([points]);
}
function square(type) {
  return diamond(type);
}
/**
 * @param {enum} type  渲染类型
 * @param {boolean} extrude  是否进行高度拉伸
 * @return {object} 顶点坐标和索引坐标
 */

function hexagon(type) {
  var points = polygonPoint(6);
  return __WEBPACK_IMPORTED_MODULE_0__polygon__[type]([points]);
}
/**
 * 规则多边形
 * @param {*} pointCount 顶点个数
 * @param {*} extrude  是否拔高
 * @return {Array} 顶点坐标
 */

function polygonPoint(pointCount) {
  var step = Math.PI * 2 / pointCount;
  var line = [];

  for (var i = 0; i < pointCount; i++) {
    line.push(step * i);
  } // debugger


  var points = line.map(function (t) {
    var x = Math.sin(t + Math.PI / 4),
        y = Math.cos(t + Math.PI / 4);
    return [x, y, 0];
  });
  return points;
}

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length,
      outerLen = hasHoles ? holeIndices[0] * dim : data.length,
      outerNode = linkedList(data, 0, outerLen, dim, true),
      triangles = [];
  if (!outerNode) return triangles;
  var minX, minY, maxX, maxY, x, y, invSize;
  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];

    for (var i = dim; i < outerLen; i += dim) {
      x = data[i];
      y = data[i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 1 / invSize : 0;
  }

  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
  return triangles;
} // create a circular doubly linked list from polygon points in the specified winding order


function linkedList(data, start, end, dim, clockwise) {
  var i, last;

  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
} // eliminate colinear or duplicate points


function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  var p = start,
      again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)


function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return; // interlink polygon nodes in z-order

  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop = ear,
      prev,
      next; // iterate through ears, slicing them one by one

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear); // skipping the next vertice leads to less sliver triangles

      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(ear, triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
} // check whether a polygon node forms a valid ear with adjacent nodes


function isEar(ear) {
  var a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear

  var p = ear.next.next;

  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed

  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
      minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
      maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
      maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

  var minZ = zOrder(minTX, minTY, minX, minY, invSize),
      maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  var p = ear.prevZ,
      n = ear.nextZ; // look for points inside the triangle in both directions

  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  } // look for remaining points in decreasing z-order


  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  } // look for remaining points in increasing z-order


  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  return true;
} // go through all polygon nodes and cure small local self-intersections


function cureLocalIntersections(start, triangles, dim) {
  var p = start;

  do {
    var a = p.prev,
        b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim); // remove two nodes involved

      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return p;
} // try splitting polygon into two and triangulate them independently


function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  var a = start;

  do {
    var b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        var c = splitPolygon(a, b); // filter colinear points around the cuts

        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next); // run earcut on each half

        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
} // link every hole into the outer loop, producing a single-ring polygon without holes


function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [],
      i,
      len,
      start,
      end,
      list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX); // process holes from left to right

  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and and link it


function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);

  if (outerNode) {
    var b = splitPolygon(outerNode, hole);
    filterPoints(b, b.next);
  }
} // David Eberly's algorithm for finding a bridge between hole and outer polygon


function findHoleBridge(hole, outerNode) {
  var p = outerNode,
      hx = hole.x,
      hy = hole.y,
      qx = -Infinity,
      m; // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;

        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }

        m = p.x < p.next.x ? p : p.next;
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null;
  if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  var stop = m,
      mx = m.x,
      my = m.y,
      tanMin = Infinity,
      tan;
  p = m.next;

  while (p !== stop) {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  }

  return m;
} // interlink polygon nodes in z-order


function indexCurve(start, minX, minY, invSize) {
  var p = start;

  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


function sortLinked(list) {
  var i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
} // z-order of a point given coords and inverse of the longer side of data bbox


function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
} // find the leftmost node of a polygon ring


function getLeftmost(start) {
  var p = start,
      leftmost = start;

  do {
    if (p.x < leftmost.x) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
} // check if a point lies within a convex triangle


function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
} // signed area of a triangle


function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal


function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect


function intersects(p1, q1, p2, q2) {
  if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
  return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
} // check if a polygon diagonal intersects any polygon segments


function intersectsPolygon(a, b) {
  var p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);

  return false;
} // check if a polygon diagonal is locally inside the polygon


function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon


function middleInside(a, b) {
  var p = a,
      inside = false,
      px = (a.x + b.x) / 2,
      py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);

  return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring


function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y),
      b2 = new Node(b.i, b.x, b.y),
      an = a.next,
      bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)


function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  // vertice index in coordinates array
  this.i = i; // vertex coordinates

  this.x = x;
  this.y = y; // previous and next vertice nodes in a polygon ring

  this.prev = null;
  this.next = null; // z-order curve value

  this.z = null; // previous and next nodes in z-order

  this.prevZ = null;
  this.nextZ = null; // indicates whether this is a steiner point

  this.steiner = false;
} // return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation


earcut.deviation = function (data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));

  if (hasHoles) {
    for (var i = 0, len = holeIndices.length; i < len; i++) {
      var start = holeIndices[i] * dim;
      var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }

  var trianglesArea = 0;

  for (i = 0; i < triangles.length; i += 3) {
    var a = triangles[i] * dim;
    var b = triangles[i + 1] * dim;
    var c = triangles[i + 2] * dim;
    trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
  }

  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
  var sum = 0;

  for (var i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }

  return sum;
} // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts


earcut.flatten = function (data) {
  var dim = data[0][0].length,
      result = {
    vertices: [],
    holes: [],
    dimensions: dim
  },
      holeIndex = 0;

  for (var i = 0; i < data.length; i++) {
    for (var j = 0; j < data[i].length; j++) {
      for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
    }

    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }

  return result;
};

/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["meshLine"] = meshLine;
/* harmony export (immutable) */ __webpack_exports__["arc"] = arc;
/* harmony export (immutable) */ __webpack_exports__["defaultLine"] = defaultLine;
/* harmony export (immutable) */ __webpack_exports__["Line"] = Line;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_polyline_normals__ = __webpack_require__(289);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_polyline_normals___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_polyline_normals__);
function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }



/**
 * shape meshLine
 * @param {array} geo  坐标点
 * @param {object} props  属性数据
 * @param {int} index  原始数据ndex
 * @return {object} 顶点坐标，索引坐标
 */

function meshLine(geo, props, index) {
  var dataLength = geo.length;
  var width = props.size[0] * 50 || 100;
  var dem = props.size[1] || 0;
  var posArray = [];
  var indexArray = [];
  var points = [];

  for (var i = 0; i < dataLength; i++) {
    var previous = i === 0 ? geo[0] : geo[i - 1];
    var next = i === dataLength - 1 ? geo[dataLength - 1] : geo[i + 1];
    var current = geo[i];
    previous = [previous[0], previous[1], 0];
    next = [next[0], next[1], 0];
    current = [current[0], current[1], 0];
    var dir = null;

    if (i === 0 || i === dataLength - 1) {
      dir = new __WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"](1, 1, 1);
    } else {
      var dir1 = new __WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"]();
      var dir2 = new __WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"]();
      dir = new __WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"]();
      dir1.subVectors(_construct(__WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"], _toConsumableArray(current)), _construct(__WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"], _toConsumableArray(previous))).normalize();
      dir2.subVectors(_construct(__WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"], _toConsumableArray(next)), _construct(__WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"], _toConsumableArray(current))).normalize();
      dir.addVectors(dir1, dir2).normalize();
    }

    var normal = [-dir.y, dir.x, 0];
    normal = [normal[0] * width, normal[1] * width, 0];
    var n1 = [normal[0], normal[1], 0];
    var n2 = [-normal[0], -normal[1], 0];
    var p1 = new __WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"]();
    var p2 = new __WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"]();
    p1.addVectors(_construct(__WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"], _toConsumableArray(current)), _construct(__WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"], n1));
    p2.addVectors(_construct(__WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"], _toConsumableArray(current)), _construct(__WEBPACK_IMPORTED_MODULE_0__core_three__["Vector3"], n2));
    points.push([p1.x, p1.y, dem], [p2.x, p2.y, dem]);
  } // end of for


  for (var _i = 0; _i < points.length - 2; _i += 2) {
    var ct = _i;
    var cb = _i + 1;
    var nt = _i + 2;
    var nb = _i + 3;
    posArray.push(points[ct], points[cb], points[nt]);
    posArray.push(points[nt], points[cb], points[nb]);
    indexArray.push(index, index, index);
    indexArray.push(index, index, index);
  }

  return {
    positions: posArray,
    indexes: indexArray
  };
}
/**
 * shape arc
 * @param {array} geo  坐标点
 * @param {int} index  原始数据index
 * @return {object} 顶点坐标，起始点坐标，索引坐标
 */

function arc(geo, props, positionsIndex) {
  var segNum = 50;
  var posArray = [];
  var instanceArray = [];
  var sizes = [];
  var colors = [];
  var size = props.size,
      color = props.color;
  var defaultInstance = [geo[0][0], geo[0][1], geo[1][0], geo[1][1]];
  var indexArray = [];
  var c = 0;
  var index = positionsIndex;

  for (var i = 0; i < segNum; i++) {
    posArray.push(i, 1, i);
    posArray.push(i, -1, i);
    instanceArray.push.apply(instanceArray, defaultInstance);
    instanceArray.push.apply(instanceArray, defaultInstance);
    sizes.push(size, size);
    colors.push.apply(colors, _toConsumableArray(color));
    colors.push.apply(colors, _toConsumableArray(color));

    if (i !== segNum - 1) {
      indexArray[c++] = index + 0;
      indexArray[c++] = index + 1;
      indexArray[c++] = index + 2;
      indexArray[c++] = index + 1;
      indexArray[c++] = index + 3;
      indexArray[c++] = index + 2;
    }

    index += 2;
  }

  return {
    positions: posArray,
    indexArray: indexArray,
    instances: instanceArray,
    colors: colors,
    sizes: sizes
  };
}
/**
 * shape defaultLine
 * @param {array} geo  坐标点
 * @param {int} index  原始数据index
 * @return {object} 顶点坐标,索引坐标
 */

function defaultLine(geo, index) {
  var indexArray = [];
  var positions = [];
  geo.slice(0, geo.length - 1).forEach(function (coor, i) {
    positions.push(coor, geo[i + 1]);
    indexArray.push(index, index);
  });
  return {
    positions: positions,
    indexes: indexArray
  };
} // mesh line

function Line(path, props, positionsIndex) {
  var dash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (path.length === 1) path = path[0]; // 面坐标转线坐标

  var positions = [];
  var pickingIds = [];
  var normal = [];
  var miter = [];
  var colors = [];
  var indexArray = [];
  var normals = __WEBPACK_IMPORTED_MODULE_1_polyline_normals___default()(path);
  var attrDistance = [];
  var sizes = [];
  var c = 0;
  var index = positionsIndex;
  var size = props.size,
      color = props.color,
      id = props.id;
  path.forEach(function (point, pointIndex, list) {
    var i = index;
    colors.push.apply(colors, _toConsumableArray(color));
    colors.push.apply(colors, _toConsumableArray(color));
    pickingIds.push(id);
    pickingIds.push(id);
    sizes.push(size[0]);
    sizes.push(size[0]);

    if (pointIndex !== list.length - 1) {
      indexArray[c++] = i + 0;
      indexArray[c++] = i + 3;
      indexArray[c++] = i + 1;
      indexArray[c++] = i + 0;
      indexArray[c++] = i + 2;
      indexArray[c++] = i + 3;
    }

    point[2] = size[1];
    positions.push.apply(positions, _toConsumableArray(point));
    positions.push.apply(positions, _toConsumableArray(point));

    if (dash) {
      var d = pointIndex / (list.length - 1);
      attrDistance.push(d, d);
    }

    index += 2;
  });
  normals.forEach(function (n) {
    var norm = n[0];
    var m = n[1];
    normal.push(norm[0], norm[1], 0);
    normal.push(norm[0], norm[1], 0);
    miter.push(-m);
    miter.push(m);
  });
  return {
    positions: positions,
    normal: normal,
    indexArray: indexArray,
    miter: miter,
    colors: colors,
    sizes: sizes,
    pickingIds: pickingIds,
    attrDistance: attrDistance
  };
}

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(290);

var lineA = [0, 0];
var lineB = [0, 0];
var tangent = [0, 0];
var miter = [0, 0];

module.exports = function (points, closed) {
  var curNormal = null;
  var out = [];

  if (closed) {
    points = points.slice();
    points.push(points[0]);
  }

  var total = points.length;

  for (var i = 1; i < total; i++) {
    var last = points[i - 1];
    var cur = points[i];
    var next = i < points.length - 1 ? points[i + 1] : null;
    util.direction(lineA, cur, last);

    if (!curNormal) {
      curNormal = [0, 0];
      util.normal(curNormal, lineA);
    }

    if (i === 1) //add initial normals
      addNext(out, curNormal, 1);

    if (!next) {
      //no miter, simple segment
      util.normal(curNormal, lineA); //reset normal

      addNext(out, curNormal, 1);
    } else {
      //miter with last
      //get unit dir of next line
      util.direction(lineB, next, cur); //stores tangent & miter

      var miterLen = util.computeMiter(tangent, miter, lineA, lineB, 1);
      addNext(out, miter, miterLen);
    }
  } //if the polyline is a closed loop, clean up the last normal


  if (points.length > 2 && closed) {
    var last2 = points[total - 2];
    var cur2 = points[0];
    var next2 = points[1];
    util.direction(lineA, cur2, last2);
    util.direction(lineB, next2, cur2);
    util.normal(curNormal, lineA);
    var miterLen2 = util.computeMiter(tangent, miter, lineA, lineB, 1);
    out[0][0] = miter.slice();
    out[total - 1][0] = miter.slice();
    out[0][1] = miterLen2;
    out[total - 1][1] = miterLen2;
    out.pop();
  }

  return out;
};

function addNext(out, normal, length) {
  out.push([[normal[0], normal[1]], length]);
}

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

var add = __webpack_require__(291);

var set = __webpack_require__(292);

var normalize = __webpack_require__(293);

var subtract = __webpack_require__(294);

var dot = __webpack_require__(295);

var tmp = [0, 0];

module.exports.computeMiter = function computeMiter(tangent, miter, lineA, lineB, halfThick) {
  //get tangent line
  add(tangent, lineA, lineB);
  normalize(tangent, tangent); //get miter as a unit vector

  set(miter, -tangent[1], tangent[0]);
  set(tmp, -lineA[1], lineA[0]); //get the necessary length of our miter

  return halfThick / dot(miter, tmp);
};

module.exports.normal = function normal(out, dir) {
  //get perpendicular
  set(out, -dir[1], dir[0]);
  return out;
};

module.exports.direction = function direction(out, a, b) {
  //get unit dir of two lines
  subtract(out, a, b);
  normalize(out, out);
  return out;
};

/***/ }),
/* 291 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/***/ }),
/* 292 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 293 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }

  return out;
}

/***/ }),
/* 294 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/***/ }),
/* 295 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/***/ }),
/* 296 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export vertexNormals */
/* harmony export (immutable) */ __webpack_exports__["a"] = faceNormals;
var DEFAULT_NORMALS_EPSILON = 1e-6;
var DEFAULT_FACE_EPSILON = 1e-6;
/**
 * Estimate the vertex normals of a mesh
 * @param {*} faces 索引坐标
 * @param {*} positions 顶点
 * @param {*} specifiedEpsilon 参数
 * @return {*} normals
 */

function vertexNormals(faces, positions, specifiedEpsilon) {
  var N = positions.length;
  var normals = new Array(N);
  var epsilon = specifiedEpsilon === void 0 ? DEFAULT_NORMALS_EPSILON : specifiedEpsilon; // Initialize normal array

  for (var i = 0; i < N; ++i) {
    normals[i] = [0.0, 0.0, 0.0];
  } // Walk over all the faces and add per-vertex contribution to normal weights


  for (var _i = 0; _i < faces.length / 3; ++_i) {
    var f = [faces[_i * 3], faces[_i * 3 + 1], faces[_i * 3 + 2]];
    var p = 0;
    var c = f[f.length - 1];
    var n = f[0];

    for (var j = 0; j < f.length; ++j) {
      // Shift indices back
      p = c;
      c = n;
      n = f[(j + 1) % f.length];
      var v0 = positions[p];
      var v1 = positions[c];
      var v2 = positions[n]; // Compute infineteismal arcs

      var d01 = new Array(3);
      var m01 = 0.0;
      var d21 = new Array(3);
      var m21 = 0.0;

      for (var k = 0; k < 3; ++k) {
        d01[k] = v0[k] - v1[k];
        m01 += d01[k] * d01[k];
        d21[k] = v2[k] - v1[k];
        m21 += d21[k] * d21[k];
      } //  Accumulate values in normal


      if (m01 * m21 > epsilon) {
        var norm = normals[c];
        var w = 1.0 / Math.sqrt(m01 * m21);

        for (var _k = 0; _k < 3; ++_k) {
          var u = (_k + 1) % 3;
          var v = (_k + 2) % 3;
          norm[_k] += w * (d21[u] * d01[v] - d21[v] * d01[u]);
        }
      }
    }
  } //  Scale all normals to unit length


  for (var _i2 = 0; _i2 < N; ++_i2) {
    var _norm = normals[_i2];
    var m = 0.0;

    for (var _k2 = 0; _k2 < 3; ++_k2) {
      m += _norm[_k2] * _norm[_k2];
    }

    if (m > epsilon) {
      var _w = 1.0 / Math.sqrt(m);

      for (var _k3 = 0; _k3 < 3; ++_k3) {
        _norm[_k3] *= _w;
      }
    } else {
      for (var _k4 = 0; _k4 < 3; ++_k4) {
        _norm[_k4] = 0.0;
      }
    }
  } //  Return the resulting set of patches


  return normals;
} //  Compute face normals of a mesh

function faceNormals(faces, positions, specifiedEpsilon) {
  var N = faces.length / 3;
  var normals = new Array(N);
  var epsilon = specifiedEpsilon === void 0 ? DEFAULT_FACE_EPSILON : specifiedEpsilon;

  for (var i = 0; i < N; ++i) {
    var pos = [positions[faces[i * 3]], positions[faces[i * 3 + 1]], positions[faces[i * 3 + 2]]];
    var d01 = new Array(3);
    var d21 = new Array(3);

    for (var j = 0; j < 3; ++j) {
      d01[j] = pos[1][j] - pos[0][j];
      d21[j] = pos[2][j] - pos[0][j];
    }

    var n = new Array(3);
    var l = 0.0;

    for (var _j = 0; _j < 3; ++_j) {
      var u = (_j + 1) % 3;
      var v = (_j + 2) % 3;
      n[_j] = d01[u] * d21[v] - d01[v] * d21[u];
      l += n[_j] * n[_j];
    }

    if (l > epsilon) {
      l = 1.0 / Math.sqrt(l);
    } else {
      l = 0.0;
    }

    for (var _j2 = 0; _j2 < 3; ++_j2) {
      n[_j2] *= l;
    }

    normals[i] = n;
  }

  return normals;
}

/***/ }),
/* 297 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nuniform float u_opacity;\nuniform sampler2D u_texture;\nuniform vec4 u_baseColor;\nuniform vec4 u_brightColor;\nuniform vec4 u_windowColor;\nuniform float u_zoom;\nuniform float u_time;\nuniform float u_near;\nuniform float u_far;\nvarying vec2 v_texCoord;\nvarying  vec4 v_color;\nvarying float v_lightWeight;\nvarying float v_size;\n\nvec3 getWindowColor(float n, float hot, vec3 brightColor, vec3 darkColor) {\n    float s = step(hot, n);\n    //vec3 color = mix(brightColor,brightColor - vec3(0.4,0.4,0.4),n);\n    vec3 color = mix(brightColor,vec3(1.0,1.0,1.0),n);\n    return mix(darkColor, color, s);\n}\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat LinearizeDepth() \n{\n    float z = gl_FragCoord.z * 2.0 - 1.0;  \n    return (2.0 * u_near * u_far) / (u_far + u_near - z * (u_far - u_near));\t\n}\n\nvec3 fog(vec3 color, vec3 fogColor, float depth){\n    float fogFactor=clamp(depth,0.0,1.0);\n    vec3 output_color=mix(fogColor,color,fogFactor);\n    return output_color;\n}\n\nfloat sdRect(vec2 p, vec2 sz) {  \n  vec2 d = abs(p) - sz;\n  float outside = length(max(d, 0.));\n  float inside = min(max(d.x, d.y), 0.);\n  return outside + inside;\n}\n\n\nvoid main() {\n   if(v_color.w == 0.0) {\n     discard;\n     return;\n   }\n    vec3 baseColor = u_baseColor.xyz;\n    vec3 brightColor = u_brightColor.xyz;\n    vec3 windowColor = u_windowColor.xyz;\n    float targetColId = 5.;\n    float depth = 1.0 - LinearizeDepth() / u_far * u_zoom;  \n    vec3 fogColor = vec3(23.0/255.0,31.0/255.0,51.0/255.0); \n   #ifdef ANIMATE \n     if(v_texCoord.x < 0.) { //顶部颜色\n       vec3 foggedColor = fog(baseColor.xyz + vec3(0.12*0.9,0.2*0.9,0.3*0.9),fogColor,depth);\n       gl_FragColor = vec4( foggedColor, v_color.w * u_opacity);\n     }else { // 侧面颜色\n        vec2 st = v_texCoord; \n        vec2  UvScale = v_texCoord;\n        float tStep = min(0.08,max(0.05* (18.0-u_zoom),0.02));\n        float tStart = 0.25 * tStep;\n        float tEnd = 0.75 * tStep;\n        float u = mod(UvScale.x, tStep);\n        float v = mod(UvScale.y, tStep);\n        float ux = floor(UvScale.x/tStep);\n        float uy = floor(UvScale.y/tStep);\n        float n = random(vec2(ux,uy));\n        float lightP = u_time;\n        float head = 1.0- step(0.005,st.y);\n        /*step3*/\n        // 将窗户颜色和墙面颜色区别开来\n        float sU = step(tStart, u) - step(tEnd, u);\n        float sV = step(tStart, v) - step(tEnd, v);\n        vec2 windowSize = vec2(abs(tEnd-tStart),abs(tEnd-tStart));\n        float dist = sdRect(vec2(u,v), windowSize);\n        float s = sU * sV;\n   \n        float curColId = floor(UvScale.x / tStep);\n        float sCol = step(targetColId - 0.2, curColId) - step(targetColId + 0.2, curColId);\n        \n        float mLightP = mod(lightP, 2.);\n        float sRow = step(mLightP - 0.2, st.y) - step(mLightP, st.y);\n        if(ux == targetColId){\n            n =0.;\n        }\n        float timeP = min(0.95, abs ( sin(u_time/6.0) ) );\n        float hot = smoothstep(1.0,0.0,timeP);\n        vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), s);\n        //vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), 1.0);\n        float sFinal = s * sCol * sRow;\n        color += mix(baseColor, brightColor, sFinal*n);\n        // if (st.y<0.01){\n        // color = baseColor;\n        //  }\n        // if(head ==1.0) { // 顶部亮线\n        //     color = brightColor;\n        // }\n        color = color * v_lightWeight;\n\n        vec3 foggedColor = fog(color,fogColor,depth);\n         \n        gl_FragColor = vec4(foggedColor,1.0); \n     }\n   #else\n       gl_FragColor = vec4(v_color.xyz , v_color.w * u_opacity);\n   #endif\n \n}"

/***/ }),
/* 298 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define ambientRatio 0.5\n#define diffuseRatio 0.4\n#define specularRatio 0.1\nattribute vec4 a_color; \nattribute vec4 a_idColor;\nattribute vec2 faceUv;\nattribute vec3 a_shape;\nattribute vec3 a_size;\nuniform float u_zoom;\nvarying vec2 v_texCoord;\nvarying  vec4 v_color;\nvarying float v_lightWeight;\nvarying float v_size;\n\nvoid main() {\n   float scale = pow(2.0,(20.0 - u_zoom));\n  mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n  vec3 newposition =  position;\n   #ifdef SHAPE \n    newposition =position + a_size * scale* a_shape;\n  #endif\n   v_texCoord = faceUv;\n  if(normal == vec3(0.,0.,1.)){\n     v_color = a_color;\n     gl_Position =  matModelViewProjection  * vec4(newposition, 1.0);\n     return;\n  }\n  \n  vec3 worldPos = vec3(vec4(newposition,1.0) * modelMatrix);\n  vec3 worldNormal = vec3(vec4(normal,1.0) * modelMatrix);\n  // //cal light weight\n  vec3 viewDir = normalize(cameraPosition - worldPos);\n  //vec3 lightDir = normalize(vec3(1, -10.5, 12));\n  vec3 lightDir = normalize(vec3(0.,-10.,1.));\n  vec3 halfDir = normalize(viewDir+lightDir);\n  // //lambert\n  float lambert = dot(worldNormal, lightDir);\n    //specular\n  float specular = pow( max(0.0, dot(worldNormal, halfDir)), 32.0);\n    //sum to light weight\n  float lightWeight = ambientRatio + diffuseRatio * lambert + specularRatio * specular;\n  v_texCoord = faceUv;\n  v_lightWeight = lightWeight;\n  // v_size = a_size;\n  v_color =vec4(a_color.rgb*lightWeight, a_color.w); \n  gl_Position =  matModelViewProjection * vec4(newposition, 1.0);\n}"

/***/ }),
/* 299 */
/***/ (function(module, exports) {

module.exports = "    precision highp float;\n    uniform float u_opacity;\n    varying vec4 v_color;\n    varying float vTime;\n    void main() {\n      vec4 color = v_color;\n  \n      #ifdef ANIMATE \n        if (vTime > 1.0 || vTime < 0.0) {\n            discard;\n      } \n      color.a= color.a * vTime * 1.5;\n      #endif\n      gl_FragColor = color;\n      gl_FragColor.a =color.a*u_opacity;\n}"

/***/ }),
/* 300 */
/***/ (function(module, exports) {

module.exports = "    precision highp float;\n    attribute vec4 a_color;\n    uniform float currentTime;\n    uniform float u_time;\n    varying float vTime;\n    varying vec4 v_color;\n    void main() {\n      mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n      v_color = a_color;\n      #ifdef ANIMATE \n        vTime = 1.0- (mod(u_time*50.,3600.)- position.z) / 100.;\n      #endif\n      gl_Position = matModelViewProjection * vec4(position.xy,0., 1.0);\n    }"

/***/ }),
/* 301 */
/***/ (function(module, exports) {

module.exports = "  precision mediump float;\n  uniform float u_opacity;\n  varying vec4 v_color;\n  \n  void main() {\n      if(v_color.a == 0.){\n        discard;\n      }\n      gl_FragColor = v_color;\n      gl_FragColor.a = v_color.a*u_opacity;\n\n  }"

/***/ }),
/* 302 */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\nattribute vec4 a_color;\nattribute vec4 a_instance;\nattribute float a_size;\nuniform float u_zoom;\nuniform float u_time;\nuniform mat4 matModelViewProjection;\nuniform float segmentNumber;  \nvarying vec4 v_color;\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.0));\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n    vec2 x = mix(source, target, ratio);\n    vec2 center = mix(source, target, 0.5);\n    float dSourceCenter = distance(source, center);\n    float dXCenter = distance(x, center);\n    return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n     float vertex_height = paraboloid(source, target, segmentRatio);\n    \n    return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n    );\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * a_size * pow(2.0,20.0-u_zoom) / 2.0;\n  return offset;\n}\n\n\nvoid main() {\n    float visindex =mod(u_time *10.,segmentNumber);\n    mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n    vec2 source = a_instance.rg;\n    vec2 target = a_instance.ba;\n    float segmentIndex = position.x;\n    float segmentRatio = getSegmentRatio(segmentIndex);\n    float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n    float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n    \n    vec3 curr = getPos(source, target, segmentRatio);\n    vec3 next = getPos(source, target, nextSegmentRatio);\n    vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, position.y);\n    gl_Position =matModelViewProjection * vec4(vec3(curr + vec3(offset, 0.0)),1.0);\n    // float apha = 0.;\n    // if( position.x> 0. && position.x <visindex)\n    //   apha =1.0;\n    // vec3 c1 = vec3(0.929,0.972,0.917);\n    // vec3 c2 = vec3(0.062,0.325,0.603); \n   // v_color = mix(c1, c2, segmentRatio);\n    v_color = a_color;\n    \n\n}"

/***/ }),
/* 303 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nattribute float a_miter;\nattribute vec4 a_color;\nattribute float a_size;\nuniform float u_zoom;\nvarying vec4 v_color;\nvoid main() {\n mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n vec3 pointPos = position.xyz + vec3(normal * a_size * pow(2.0,20.0-u_zoom) / 2.0 * a_miter);\n v_color = a_color;\ngl_Position = matModelViewProjection * vec4(pointPos, 1.0);\n\n}"

/***/ }),
/* 304 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nuniform float u_opacity;\nvarying vec4 v_color;\nvoid main() {\n    gl_FragColor = v_color;\n    gl_FragColor.a =  v_color.a * u_opacity ;\n}\n"

/***/ }),
/* 305 */
/***/ (function(module, exports) {

module.exports = "varying float v_lineU;\nuniform float u_opacity;\nuniform float u_dashSteps;\nuniform float u_dashSmooth;\nuniform float u_dashDistance;\nvarying vec4 v_color;\nvoid main() {\n    float lineUMod = mod(v_lineU, 1.0/u_dashSteps) * u_dashSteps;\n    float dash = smoothstep(u_dashDistance, u_dashDistance+u_dashSmooth, length(lineUMod-0.5));\n    gl_FragColor = vec4(v_color.xyz * vec3(dash), v_color.a*u_opacity * dash);\n}"

/***/ }),
/* 306 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nattribute float a_miter;\nattribute vec4 a_color;\nattribute float a_size;\nuniform float u_zoom;\nvarying vec4 v_color;\nattribute float a_distance;\nvarying float v_lineU;\nvoid main() {\n v_lineU = a_distance;\n mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n vec3 pointPos = position.xyz + vec3(normal * a_size * pow(2.0,20.0-u_zoom) / 2.0 * a_miter);\n v_color = a_color;\n gl_Position = matModelViewProjection * vec4(pointPos, 1.0);\n}"

/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PointLayer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_layer__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_buffer_point__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_material_pointMaterial__ = __webpack_require__(308);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_material_polygonMaterial__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_buffer_text__ = __webpack_require__(311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geom_material_textMaterial__ = __webpack_require__(312);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_shader_radar_frag_glsl__ = __webpack_require__(315);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_shader_radar_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__geom_shader_radar_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__geom_shader_warn_frag_glsl__ = __webpack_require__(316);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__geom_shader_warn_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__geom_shader_warn_frag_glsl__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }










/**
 * point shape 2d circle, traingle text,image
 * shape 3d   cube，column, sphere
 * shape Model ,自定义
 * image
 *
 */

var PointLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(PointLayer, _Layer);

  function PointLayer() {
    _classCallCheck(this, PointLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(PointLayer).apply(this, arguments));
  }

  _createClass(PointLayer, [{
    key: "render",
    value: function render() {
      this.type = 'point';
      this.init();

      if (!this._hasRender) {
        this._prepareRender(this.shapeType);

        this._hasRender = true;
      } else {
        this._initAttrs();

        this._needUpdateFilter || this._needUpdateColor ? this._updateFilter() : null;
      }

      return this;
    }
  }, {
    key: "_prepareRender",
    value: function _prepareRender() {
      if (this.shapeType === 'text') {
        // 绘制文本图层
        this._textPoint();

        return;
      }

      var source = this.layerSource;

      var _this$get = this.get('styleOptions'),
          opacity = _this$get.opacity,
          strokeWidth = _this$get.strokeWidth,
          stroke = _this$get.stroke,
          shape = _this$get.shape;

      this._buffer = new __WEBPACK_IMPORTED_MODULE_2__geom_buffer_point__["a" /* default */]({
        type: this.shapeType,
        imagePos: this.scene.image.imagePos,
        coordinates: source.geoData,
        properties: this.StyleData
      });
      var geometry = this.geometry = new __WEBPACK_IMPORTED_MODULE_1__core_three__["BufferGeometry"]();
      var mtl;

      if (this.shapeType === '2d' || this.shapeType === '3d') {
        mtl = new __WEBPACK_IMPORTED_MODULE_4__geom_material_polygonMaterial__["a" /* default */]({
          u_opacity: opacity,
          u_zoom: this.scene.getZoom()
        }); //   mtl= new pickingMaterial({
        //     u_opacity: opacity,
        //     u_zoom: this.scene.getZoom()
        //   })
        // mtl.setDefinesvalue('point', true);

        mtl.setDefinesvalue('SHAPE', true);

        if (shape === 'radar') {
          mtl.fragmentShader = __WEBPACK_IMPORTED_MODULE_7__geom_shader_radar_frag_glsl___default.a;
        }

        if (shape === 'warn') {
          mtl.fragmentShader = __WEBPACK_IMPORTED_MODULE_8__geom_shader_warn_frag_glsl___default.a;
        }
      } else {
        // sdf 绘制点
        mtl = new __WEBPACK_IMPORTED_MODULE_3__geom_material_pointMaterial__["a" /* default */]({
          u_opacity: opacity,
          u_strokeWidth: strokeWidth,
          u_stroke: stroke,
          shape: this.shapeType || false,
          u_texture: this.scene.image.texture
        }, {
          SHAPE: this.shapeType !== 'image',
          TEXCOORD_0: this.shapeType === 'image'
        });
      }

      var attributes = this._buffer.attributes;
      geometry.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.vertices, 3));
      geometry.addAttribute('a_color', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.colors, 4));
      geometry.addAttribute('pickingId', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.pickingIds, 1));

      if (this.shapeType === 'image') {
        geometry.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.uvs, 2));
        geometry.addAttribute('a_size', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.sizes, 1));
      } else if (this.shapeType === undefined) {
        geometry.addAttribute('a_size', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.sizes, 1));
      } else {
        // 多边形面
        geometry.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.normals, 3));
        geometry.addAttribute('a_shape', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.shapePositions, 3));
        geometry.addAttribute('a_size', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.a_size, 3));

        if (shape) {
          geometry.addAttribute('faceUv', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.faceUv, 2));
        }
      }

      var mesh;

      if (this.shapeType === 'image') {
        mesh = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Points"](geometry, mtl);
      } else if (this.shapeType === undefined) {
        // 散点图
        mesh = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Points"](geometry, mtl);
      } else {
        mesh = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Mesh"](geometry, mtl);
      }

      this.add(mesh);
    }
  }, {
    key: "_textPoint",
    value: function _textPoint() {
      var _this = this;

      var source = this.layerSource;
      var styleOptions = this.get('styleOptions');
      var buffer = new __WEBPACK_IMPORTED_MODULE_5__geom_buffer_text__["a" /* default */]({
        type: this.shapeType,
        coordinates: source.geoData,
        properties: this.StyleData,
        style: this.get('styleOptions')
      });
      buffer.on('completed', function () {
        var color = styleOptions.color,
            stroke = styleOptions.stroke;
        var geometry = new __WEBPACK_IMPORTED_MODULE_1__core_three__["BufferGeometry"]();
        geometry.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](buffer.attributes.originPoints, 3));
        geometry.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](buffer.attributes.textureElements, 2));
        geometry.addAttribute('a_txtsize', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](buffer.attributes.textSizes, 2));
        geometry.addAttribute('a_txtOffsets', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](buffer.attributes.textOffsets, 2));
        geometry.addAttribute('a_color', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](buffer.attributes.colors, 4));

        var _this$scene$getSize = _this.scene.getSize(),
            width = _this$scene$getSize.width,
            height = _this$scene$getSize.height;

        var material = new __WEBPACK_IMPORTED_MODULE_6__geom_material_textMaterial__["a" /* default */]({
          name: _this.layerId,
          u_texture: buffer.bufferStruct.textTexture,
          u_strokeWidth: 1,
          u_stroke: stroke,
          u_textSize: buffer.bufferStruct.textSize,
          u_gamma: 0.11,
          u_buffer: 0.8,
          u_color: color,
          u_glSize: [width, height]
        });
        var mesh = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Mesh"](geometry, material);

        _this.add(mesh);
      });
    }
  }]);

  return PointLayer;
}(__WEBPACK_IMPORTED_MODULE_0__core_layer__["a" /* default */]);



/***/ }),
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PointMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_point_frag_glsl__ = __webpack_require__(309);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_point_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_point_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shader_point_vert_glsl__ = __webpack_require__(310);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shader_point_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shader_point_vert_glsl__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var PointMaterial =
/*#__PURE__*/
function (_Material) {
  _inherits(PointMaterial, _Material);

  _createClass(PointMaterial, [{
    key: "getDefaultParameters",
    value: function getDefaultParameters() {
      return {
        uniforms: {
          u_opacity: {
            value: 1
          },
          u_stroke: {
            value: [1.0, 1.0, 1.0, 1.0]
          },
          u_strokeWidth: {
            value: 1
          }
        },
        defines: {
          SHAPE: false,
          TEXCOORD_0: false
        }
      };
    }
  }]);

  function PointMaterial(_uniforms, _defines, parameters) {
    var _this;

    _classCallCheck(this, PointMaterial);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PointMaterial).call(this, parameters));

    var _this$getDefaultParam = _this.getDefaultParameters(),
        uniforms = _this$getDefaultParam.uniforms,
        defines = _this$getDefaultParam.defines;

    _this.uniforms = Object.assign(uniforms, _this.setUniform(_uniforms));
    _this.defines = Object.assign(defines, _defines);
    _this.type = 'PointMaterial';
    _this.vertexShader = __WEBPACK_IMPORTED_MODULE_3__shader_point_vert_glsl___default.a;
    _this.fragmentShader = __WEBPACK_IMPORTED_MODULE_2__shader_point_frag_glsl___default.a;
    _this.transparent = true;

    if (!_uniforms.shape) {
      _this.blending = __WEBPACK_IMPORTED_MODULE_0__core_three__["AdditiveBlending"];
    }

    if (_uniforms.u_texture) {
      _this.defines.TEXCOORD_0 = true;
    }

    return _this;
  }

  return PointMaterial;
}(__WEBPACK_IMPORTED_MODULE_1__material__["a" /* default */]);



/***/ }),
/* 309 */
/***/ (function(module, exports) {

module.exports = "\nprecision highp float;\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\nuniform float u_strokeWidth;\nuniform vec4 u_stroke;\nuniform float u_opacity;\nuniform sampler2D u_texture;\n\nvarying vec2 v_rs;\nvarying vec2 v_uv;\nvarying vec4 v_color;\nvarying float v_shape;\n\nconst float u_buffer = 0.75;\n// const float u_gamma = 2.0 * 1.4142 / 10.0;\nconst float u_gamma = 0.08;\n// const float u_scale = 128.0;\nconst vec3 halo = vec3( 1.0 ); \n\nvoid main() {\n    // 纹理坐标\n    #ifdef TEXCOORD_0\n    vec2 pos =  v_uv + gl_PointCoord / 512.0 * 64.0;\n    pos.y = 1.0 - pos.y;\n    vec4 textureColor = texture2D(u_texture, pos);\n    gl_FragColor =textureColor;\n    return;\n    #endif\n     if(v_color.a == 0.)\n      discard;\n    vec4 pcolor = v_color * u_opacity;\n    float ro = v_rs.x;\n    float ri = v_rs.y;\n    float d = 0.0;\n    if(ro < 3.0) {\n      gl_FragColor = pcolor;\n      return;\n    }\n\n    // vec4 textureColor = texture2D(u_texture, gl_PointCoord);\n    vec2 st = gl_PointCoord * 2. - 1.;\n    float a = atan(st.x,st.y)+PI ;\n    float r = TWO_PI/ v_shape;\n    float ratio =1.0 + (1.1 - smoothstep(2.8, 6.0,v_shape));\n    float dis2center = cos(floor(.5+a/r)*r-a)*length(st) * ro * ratio;\n    float alpha = smoothstep(ro,ro+0.1, dis2center);\n    \n    if(alpha == 1.) {\n      discard;\n    }\n    if(u_strokeWidth > 0.0){//有border\n        if(dis2center> ro- u_strokeWidth ){\n            gl_FragColor = vec4(u_stroke.xyz,u_stroke.a*(ro- dis2center));\n            return;\n        }else if(dis2center>ri){\n            gl_FragColor= u_stroke * alpha ;\n            return;\n        }\n    }\n\n    if(dis2center > ri- u_strokeWidth){\n        float factor = ri-dis2center;//填充色的百分比\n        if (u_strokeWidth == 0.0) {\n            float a = pcolor.a*factor;\n            gl_FragColor = vec4(pcolor.rgb, a);\n        } else {\n            float a = u_stroke.a*(1.0-factor) +pcolor.a*factor;\n            gl_FragColor = vec4(u_stroke.rgb * (1.0-factor) + pcolor.rgb * factor, a);\n        }\n        } else{\n            gl_FragColor= pcolor;\n        }\n    gl_FragColor *= u_opacity;\n}\n\n"

/***/ }),
/* 310 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nattribute vec4 a_color;\nattribute float a_size;\nattribute float a_shape;\nattribute vec4 a_idColor;\nuniform vec4 u_stroke;\nuniform float u_strokeWidth;\nuniform float u_opacity;\nuniform float u_zoom;\nvarying vec4 v_color;\nvarying vec2 v_rs;\nvarying vec2 v_uv;\nvarying float v_shape;\n\nvoid main() {\n  mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n   v_color = a_color;\n\n   gl_Position =  matModelViewProjection  * vec4(position, 1.0);\n   gl_PointSize = a_size;\n   v_rs = vec2(a_size / 2.0, a_size / 2.0- u_strokeWidth);\n    #ifdef TEXCOORD_0\n      \n       v_uv = uv;\n    #endif\n    #ifdef SHAPE\n      v_shape = a_shape;\n    #endif\n}\n\n"

/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TextBuffer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bufferBase__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_ajax__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__global__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__global___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__global__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var Space = 1;

var TextBuffer =
/*#__PURE__*/
function (_BufferBase) {
  _inherits(TextBuffer, _BufferBase);

  function TextBuffer() {
    _classCallCheck(this, TextBuffer);

    return _possibleConstructorReturn(this, _getPrototypeOf(TextBuffer).apply(this, arguments));
  }

  _createClass(TextBuffer, [{
    key: "geometryBuffer",
    value: function geometryBuffer() {
      var _this = this;

      this.metrics = {
        buffer: 3,
        family: 'ios9',
        size: 24
      };
      var coordinates = this.get('coordinates');
      var properties = this.get('properties');

      var _this$get = this.get('style'),
          _this$get$textOffset = _this$get.textOffset,
          textOffset = _this$get$textOffset === void 0 ? [0, 0] : _this$get$textOffset;

      var chars = [];
      properties.forEach(function (element) {
        var text = element.shape || '';
        text = text.toString();

        for (var j = 0; j < text.length; j++) {
          var code = text.charCodeAt(j);

          if (chars.indexOf(code) === -1) {
            chars.push(text.charCodeAt(j));
          }
        }
      });

      this._loadTextInfo(chars);

      this.on('SourceLoaded', function () {
        var textureElements = [];
        var colors = [];
        var originPoints = [];
        var textSizes = [];
        var textOffsets = [];
        properties.forEach(function (element, index) {
          var size = element.size;
          var pos = coordinates[index]; // const pen = { x: pos[0] - dimensions.advance / 2, y: pos[1] };

          var pen = {
            x: textOffset[0],
            y: textOffset[1]
          };
          var text = element.shape || '';
          text = text.toString();

          for (var i = 0; i < text.length; i++) {
            var chr = text.charCodeAt(i);
            var color = element.color;

            _this._drawGlyph(pos, chr, pen, size, colors, textureElements, originPoints, textSizes, textOffsets, color);
          }
        });
        _this.bufferStruct.style = properties;
        _this.attributes = {
          originPoints: originPoints,
          textSizes: textSizes,
          textOffsets: textOffsets,
          colors: colors,
          textureElements: textureElements
        };

        _this.emit('completed');
      });
    }
  }, {
    key: "_loadTextInfo",
    value: function _loadTextInfo(chars) {
      var _this2 = this;

      Object(__WEBPACK_IMPORTED_MODULE_1__util_ajax__["b" /* getJSON */])({
        url: "".concat(__WEBPACK_IMPORTED_MODULE_3__global___default.a.sdfHomeUrl, "/getsdfdata?chars=").concat(chars.join('|'))
      }, function (e, info) {
        _this2.metrics.chars = info.info;

        _this2._loadTextTexture(info.url);
      });
    }
  }, {
    key: "_loadTextTexture",
    value: function _loadTextTexture(url) {
      var _this3 = this;

      var img = new Image();
      img.crossOrigin = 'anonymous';

      img.onload = function () {
        _this3.bufferStruct.textTexture = _this3._creatTexture(img);

        _this3.emit('SourceLoaded');
      };

      img.src = url;
    }
    /**
     * 计算每个标注词语的位置
     * @param {*} pos 文字三维空间坐标
     * @param {*} chr 字符
     * @param {*} pen 字符在词语的偏移量
     * @param {*} size 字体大小
     * @param {*} colors 颜色
     * @param {*} textureElements  纹理坐标
     * @param {*} originPoints 初始位置数据
     * @param {*} textSizes 文字大小数组
     * @param {*} textOffsets 字体偏移量数据
     * @param {*} color 文字颜色
     */

  }, {
    key: "_drawGlyph",
    value: function _drawGlyph(pos, chr, pen, size, colors, textureElements, originPoints, textSizes, textOffsets, color) {
      var metrics = this.metrics;
      var metric = metrics.chars[chr];
      if (!metric) return;
      var scale = size / metrics.size;
      var width = metric[0];
      var height = metric[1];
      var horiBearingX = metric[2];
      var horiBearingY = metric[3];
      var horiAdvance = metric[4];
      var posX = metric[5];
      var posY = metric[6];
      var buffer = metrics.buffer;

      if (width > 0 && height > 0) {
        width += buffer * 2;
        height += buffer * 2; // Add a quad (= two triangles) per glyph.

        var originX = (horiBearingX - buffer + width / 2) * scale;
        var originY = -(height / 2 - horiBearingY) * scale; // const originY = (height / 2 - horiBearingY) * scale;
        // const originY = 0;

        var offsetWidth = width / 2 * scale / (1.0 - horiBearingX * 1.5 / horiAdvance);
        var offsetHeight = horiAdvance / 2 * scale;
        var offsetX = pen.x;
        var offsetY = pen.y;
        originPoints.push(pos[0] + originX, pos[1] + originY, 0, pos[0] + originX, pos[1] + originY, 0, pos[0] + originX, pos[1] + originY, 0, pos[0] + originX, pos[1] + originY, 0, pos[0] + originX, pos[1] + originY, 0, pos[0] + originX, pos[1] + originY, 0);
        textSizes.push(offsetWidth, offsetHeight, -offsetWidth, offsetHeight, -offsetWidth, -offsetHeight, offsetWidth, offsetHeight, -offsetWidth, -offsetHeight, offsetWidth, -offsetHeight);
        textOffsets.push(offsetX, offsetY, offsetX, offsetY, offsetX, offsetY, offsetX, offsetY, offsetX, offsetY, offsetX, offsetY);
        colors.push.apply(colors, _toConsumableArray(color).concat(_toConsumableArray(color), _toConsumableArray(color), _toConsumableArray(color), _toConsumableArray(color), _toConsumableArray(color)));
        textureElements.push(posX + width, posY, posX, posY, posX, posY + height, posX + width, posY, posX, posY + height, posX + width, posY + height);
      }

      pen.x = pen.x + (horiAdvance + Space) * scale;
    }
  }, {
    key: "_measureText",
    value: function _measureText(text, size) {
      var dimensions = {
        advance: 0
      };
      var metrics = this.metrics;
      var scale = size / metrics.size;

      for (var i = 0; i < text.length; i++) {
        var code = text.charCodeAt(i);
        var horiAdvance = metrics.chars[code][4];
        dimensions.advance += (horiAdvance + Space) * scale;
      }

      return dimensions;
    }
  }, {
    key: "_creatTexture",
    value: function _creatTexture(image) {
      this.bufferStruct.textSize = [image.width, image.height];
      var texture = new __WEBPACK_IMPORTED_MODULE_2__core_three__["Texture"](image);
      texture.minFilter = __WEBPACK_IMPORTED_MODULE_2__core_three__["LinearFilter"];
      texture.magFilter = __WEBPACK_IMPORTED_MODULE_2__core_three__["LinearFilter"];
      texture.needsUpdate = true;
      return texture;
    }
  }]);

  return TextBuffer;
}(__WEBPACK_IMPORTED_MODULE_0__bufferBase__["a" /* default */]);



/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TextMaterial;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_text_frag_glsl__ = __webpack_require__(313);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_text_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_text_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_text_vert_glsl__ = __webpack_require__(314);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_text_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_text_vert_glsl__);



function TextMaterial(options) {
  var material = new __WEBPACK_IMPORTED_MODULE_0__material__["a" /* default */]({
    uniforms: {
      u_opacity: {
        value: options.u_opacity || 1.0
      },
      u_texture: {
        value: options.u_texture
      },
      u_strokeWidth: {
        value: options.u_strokeWidth
      },
      u_stroke: {
        value: options.u_stroke
      },
      u_textSize: {
        value: options.u_textSize
      },
      u_scale: {
        value: options.u_scale
      },
      u_gamma: {
        value: options.u_gamma
      },
      u_buffer: {
        value: options.u_buffer
      },
      u_color: {
        value: options.u_color
      },
      u_glSize: {
        value: options.u_glSize
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_2__shader_text_vert_glsl___default.a,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_1__shader_text_frag_glsl___default.a,
    transparent: true
  });
  return material;
}

/***/ }),
/* 313 */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\nuniform sampler2D u_texture;\nvarying vec4  v_color;\nuniform vec4 u_stroke;\nuniform float u_strokeWidth;\nuniform float u_buffer;\nuniform float u_gamma;\n\nvarying vec2 v_texcoord;\n\nvoid main() {\n\n    float dist = texture2D(u_texture, vec2(v_texcoord.x,1.0-v_texcoord.y)).r;\n    float alpha;\n    if(u_strokeWidth == 0.0){\n            alpha = smoothstep(u_buffer - u_gamma, u_buffer, dist);\n            gl_FragColor = vec4(v_color.rgb, alpha * v_color.a);\n\n    }else{\n\n        if(dist <= u_buffer - u_gamma){\n\n            alpha = smoothstep(u_strokeWidth - u_gamma, u_strokeWidth, dist);\n            gl_FragColor = vec4(u_stroke.rgb, alpha * u_stroke.a);\n        }else if(dist < u_buffer){\n            alpha = smoothstep(u_buffer - u_gamma, u_buffer, dist);\n            gl_FragColor = vec4(alpha * v_color.rgb + (1.0 - alpha) * u_stroke.rgb, 1.0 * v_color.a * alpha + (1.0 - alpha) * u_stroke.a);\n        }else{\n            alpha = 1.0;\n            gl_FragColor = vec4(v_color.rgb, alpha * v_color.a);\n        }\n        \n    }\n}"

/***/ }),
/* 314 */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\nattribute vec2 a_txtsize; \nattribute vec2 a_txtOffsets;\nattribute vec4 a_color;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_scale;\nuniform vec2 u_textSize;\nuniform vec2 u_glSize;\nvarying vec2 v_texcoord;\nvarying vec4  v_color;\n\nvoid main() {\n     mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n      vec4 cur_position = matModelViewProjection * vec4(position.xy, 0, 1);\n      gl_Position = cur_position / cur_position.w + vec4((a_txtOffsets + a_txtsize)/ u_glSize * 2.0,0.0, 0.0) +vec4(abs(a_txtsize.x)/u_glSize.x *2.0, -abs(a_txtsize.y)/u_glSize.y* 2.0, 0.0, 0.0);\n    v_color = a_color;\n    v_texcoord = uv / u_textSize;\n    \n}\n"

/***/ }),
/* 315 */
/***/ (function(module, exports) {

module.exports = "//Sci-fi radar based on the work of gmunk for Oblivion\n//http://work.gmunk.com/OBLIVION-GFX\nprecision highp float;\n#define SMOOTH(r,R) (1.0-smoothstep(R-0.01,R+0.01, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-0.01,a+0.01,x)*(1.0-smoothstep(b-0.01,b+0.01,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\nuniform float u_time;\nvarying vec2 v_texCoord;\nvarying  vec4 v_color;\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90. * u_time;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n                            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.0,1.0);\n        return SMOOTH(l,0.01) + 0.9*gradient;\n        // return SMOOTH(l,1.);\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float x = uv.x;\n    float y = uv.y;\n    float r = sqrt( dot( d, d ) );\n   \n\n     float w = abs(uv.x)-abs(uv.y);\n     float z1 = smoothstep(-0.020,-0.012,w);\n     float z2 = smoothstep(-0.02,-0.012,-w);\n     float z3 = z1*z2 * (1.0 - step(radius,r));\n     return z3;\n}\n\nvoid main()\n{\n    vec3 finalColor;\n\tvec2 uv = v_texCoord * 2.0 - 1.0;\n    vec2 c = vec2(0.,0.);\n    finalColor = vec3( 0.3 * _cross(uv, c, 0.6) );\n    finalColor += ( circle(uv, c, 0.2, 0.01)\n                   + circle(uv, c, 0.4, 0.01) ) * blue1;\n    finalColor += (circle(uv, c, 0.6, 0.02) );\n    finalColor += movingLine(uv, c, 0.6) * v_color.xyz;\n    finalColor += circle(uv, c, 0.1, 0.01) * v_color.xyz;\n\n    float alpha = 1.0;\n    if(finalColor==vec3(0.)) alpha = 0.;\n    gl_FragColor = vec4(finalColor, alpha);\n}"

/***/ }),
/* 316 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_ES\nprecision mediump float;\n#endif\n#define SMOOTH(r,R) (1.0-smoothstep(R-0.01,R+0.01, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-0.01,a+0.01,x)*(1.0-smoothstep(b-0.01,b+0.01,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\nuniform float u_time;\nvarying vec2 v_texCoord;\nvarying  vec4 v_color;\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 0.2+mod(0.1*u_time, 0.30);\n    return (0.5-0.6*cos(30.0*u_time)) * SMOOTH(r,0.06)\n        + SMOOTH(0.1,r)-SMOOTH(0.12,r) \n        + smoothstep(max(0.1,R-0.2),R,r)-SMOOTH(R,r);\n}\nvoid main() {\n    vec3 finalColor;\n    vec2 uv = v_texCoord * 2.0 - 1.0;\n    vec2 c = vec2(0.,0.);\n    if( length(uv-c) < 0.96 )\n    {\n        finalColor += bip2(uv,c) * v_color.xyz;\n    }\n    float alpha = 1.0;\n    if(finalColor==vec3(0.)) alpha = 0.;\n    gl_FragColor = vec4(finalColor, alpha);\n    \n}"

/***/ }),
/* 317 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineLayer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_layer__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_buffer_index__ = __webpack_require__(318);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_material_lineMaterial__ = __webpack_require__(75);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var LineLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(LineLayer, _Layer);

  function LineLayer() {
    _classCallCheck(this, LineLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(LineLayer).apply(this, arguments));
  }

  _createClass(LineLayer, [{
    key: "shape",
    value: function shape(type) {
      this.shapeType = type;
      return this;
    }
  }, {
    key: "render",
    value: function render() {
      this.type = 'polyline';
      this.init();
      var source = this.layerSource;
      var StyleData = this.StyleData;
      var style = this.get('styleOptions');
      var buffer = this._buffer = new __WEBPACK_IMPORTED_MODULE_2__geom_buffer_index__["a" /* LineBuffer */]({
        coordinates: source.geoData,
        properties: StyleData,
        shapeType: this.shapeType,
        style: style
      });

      var _this$get = this.get('styleOptions'),
          opacity = _this$get.opacity;

      var animateOptions = this.get('animateOptions');
      var geometry = new __WEBPACK_IMPORTED_MODULE_1__core_three__["BufferGeometry"]();
      var attributes = buffer.attributes;

      if (this.shapeType === 'arc') {
        geometry.setIndex(attributes.indexArray);
        geometry.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.positions, 3));
        geometry.addAttribute('a_color', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.colors, 4));
        geometry.addAttribute('a_instance', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.instances, 4));
        geometry.addAttribute('a_size', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.sizes, 1));
        var material = new __WEBPACK_IMPORTED_MODULE_3__geom_material_lineMaterial__["a" /* ArcLineMaterial */]({
          u_opacity: opacity,
          u_zoom: this.scene.getZoom()
        });
        var mesh = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Mesh"](geometry, material);
        this.add(mesh);
      } else if (this.shapeType === 'line') {
        geometry.setIndex(attributes.indexArray);
        geometry.addAttribute('pickingId', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.pickingIds, 1));
        geometry.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.positions, 3));
        geometry.addAttribute('a_color', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.colors, 4));
        geometry.addAttribute('a_size', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.sizes, 1));
        geometry.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.normal, 3));
        geometry.addAttribute('a_miter', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.miter, 1));
        var lineType = style.lineType;

        var _material;

        if (lineType !== 'dash') {
          _material = new __WEBPACK_IMPORTED_MODULE_3__geom_material_lineMaterial__["d" /* MeshLineMaterial */]({
            u_opacity: opacity,
            u_zoom: this.scene.getZoom()
          });
        } else {
          geometry.addAttribute('a_distance', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.attrDistance, 1));
          _material = new __WEBPACK_IMPORTED_MODULE_3__geom_material_lineMaterial__["b" /* DashLineMaterial */]({
            u_opacity: opacity,
            u_zoom: this.scene.getZoom()
          });
        }

        var _mesh = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Mesh"](geometry, _material);

        this.add(_mesh);
      } else {
        // 直线
        geometry.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.vertices, 3));
        geometry.addAttribute('a_color', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.colors, 4));

        var _material2 = new __WEBPACK_IMPORTED_MODULE_3__geom_material_lineMaterial__["c" /* LineMaterial */]({
          u_opacity: opacity,
          u_time: 0
        });

        if (animateOptions.enable) {
          _material2.setDefinesvalue('ANIMATE', true);
        }

        var _mesh2 = new __WEBPACK_IMPORTED_MODULE_1__core_three__["LineSegments"](geometry, _material2);

        this.add(_mesh2);
      }

      return this;
    }
  }]);

  return LineLayer;
}(__WEBPACK_IMPORTED_MODULE_0__core_layer__["a" /* default */]);



/***/ }),
/* 318 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygon__ = __webpack_require__(71);
/* unused harmony reexport PolygonBuffer */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(76);
/* unused harmony reexport PointBuffer */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__line__ = __webpack_require__(319);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__line__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polygon_line__ = __webpack_require__(320);
/* unused harmony reexport polygonLineBuffer */



 // export { default as textBuffer } from './textBuffer';

/***/ }),
/* 319 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineBuffer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bufferBase__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shape__ = __webpack_require__(29);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var LineBuffer =
/*#__PURE__*/
function (_BufferBase) {
  _inherits(LineBuffer, _BufferBase);

  function LineBuffer() {
    _classCallCheck(this, LineBuffer);

    return _possibleConstructorReturn(this, _getPrototypeOf(LineBuffer).apply(this, arguments));
  }

  _createClass(LineBuffer, [{
    key: "geometryBuffer",
    value: function geometryBuffer() {
      var _this = this;

      var coordinates = this.get('coordinates');
      var properties = this.get('properties');
      var shapeType = this.shapeType = this.get('shapeType');
      var positions = [];
      var positionsIndex = [];
      var instances = [];

      if (shapeType === 'line') {
        this.attributes = this._getMeshLineAttributes();
        return;
      } else if (shapeType === 'arc') {
        this.attributes = this._getArcLineAttributes();
        return;
      }

      coordinates.forEach(function (geo, index) {
        var props = properties[index];

        var attrData = _this._getShape(geo, props, index);

        positions.push.apply(positions, _toConsumableArray(attrData.positions));
        positionsIndex.push.apply(positionsIndex, _toConsumableArray(attrData.indexes));

        if (attrData.hasOwnProperty('instances')) {
          instances.push.apply(instances, _toConsumableArray(attrData.instances));
        }
      });
      this.bufferStruct.style = properties;
      this.bufferStruct.verts = positions;
      this.bufferStruct.indexs = positionsIndex;

      if (instances.length > 0) {
        this.bufferStruct.instances = instances;
      }

      this.attributes = this._toAttributes(this.bufferStruct);
    }
  }, {
    key: "_getShape",
    value: function _getShape(geo, props, index) {
      if (!this.shapeType) {
        return __WEBPACK_IMPORTED_MODULE_1__shape__["a" /* lineShape */].defaultLine(geo, index);
      }

      var shape = this.shapeType;

      if (shape === 'meshLine') {
        return __WEBPACK_IMPORTED_MODULE_1__shape__["a" /* lineShape */][shape](geo, props, index);
      } else if (shape === 'tubeLine') {
        return __WEBPACK_IMPORTED_MODULE_1__shape__["a" /* lineShape */][shape](geo, props, index);
      } else if (shape === 'arc') {
        return __WEBPACK_IMPORTED_MODULE_1__shape__["a" /* lineShape */][shape](geo, props, index);
      }

      return __WEBPACK_IMPORTED_MODULE_1__shape__["a" /* lineShape */].Line(geo, props, index);
    }
  }, {
    key: "_getArcLineAttributes",
    value: function _getArcLineAttributes() {
      var _this2 = this;

      var coordinates = this.get('coordinates');
      var properties = this.get('properties');
      var positions = [];
      var colors = [];
      var indexArray = [];
      var sizes = [];
      var instances = [];
      coordinates.forEach(function (geo, index) {
        var props = properties[index];
        var positionCount = positions.length / 3;

        var attrData = _this2._getShape(geo, props, positionCount);

        positions.push.apply(positions, _toConsumableArray(attrData.positions));
        colors.push.apply(colors, _toConsumableArray(attrData.colors));
        indexArray.push.apply(indexArray, _toConsumableArray(attrData.indexArray));
        instances.push.apply(instances, _toConsumableArray(attrData.instances));
        sizes.push.apply(sizes, _toConsumableArray(attrData.sizes));
      });
      return {
        positions: positions,
        colors: colors,
        indexArray: indexArray,
        sizes: sizes,
        instances: instances
      };
    }
  }, {
    key: "_getMeshLineAttributes",
    value: function _getMeshLineAttributes() {
      var coordinates = this.get('coordinates');
      var properties = this.get('properties');

      var _this$get = this.get('style'),
          lineType = _this$get.lineType;

      var positions = [];
      var pickingIds = [];
      var normal = [];
      var miter = [];
      var colors = [];
      var indexArray = [];
      var sizes = [];
      var attrDistance = [];
      coordinates.forEach(function (geo, index) {
        var props = properties[index];
        var positionCount = positions.length / 3;
        var attr = __WEBPACK_IMPORTED_MODULE_1__shape__["a" /* lineShape */].Line(geo, props, positionCount, lineType !== 'soild');
        positions.push.apply(positions, _toConsumableArray(attr.positions));
        normal.push.apply(normal, _toConsumableArray(attr.normal));
        miter.push.apply(miter, _toConsumableArray(attr.miter));
        colors.push.apply(colors, _toConsumableArray(attr.colors));
        indexArray.push.apply(indexArray, _toConsumableArray(attr.indexArray));
        sizes.push.apply(sizes, _toConsumableArray(attr.sizes));
        attrDistance.push.apply(attrDistance, _toConsumableArray(attr.attrDistance));
        pickingIds.push.apply(pickingIds, _toConsumableArray(attr.pickingIds));
      });
      return {
        positions: positions,
        normal: normal,
        miter: miter,
        colors: colors,
        indexArray: indexArray,
        pickingIds: pickingIds,
        sizes: sizes,
        attrDistance: attrDistance
      };
    }
  }, {
    key: "_toAttributes",
    value: function _toAttributes(bufferStruct) {
      var vertCount = bufferStruct.verts.length;
      var vertices = new Float32Array(vertCount * 3);
      var inposs = new Float32Array(vertCount * 4);
      var colors = new Float32Array(vertCount * 4);

      for (var i = 0; i < vertCount; i++) {
        var index = bufferStruct.indexs[i];
        var color = bufferStruct.style[index].color;
        vertices[i * 3] = bufferStruct.verts[i][0];
        vertices[i * 3 + 1] = bufferStruct.verts[i][1];
        vertices[i * 3 + 2] = bufferStruct.verts[i][2];
        colors[i * 4] = color[0];
        colors[i * 4 + 1] = color[1];
        colors[i * 4 + 2] = color[2];
        colors[i * 4 + 3] = color[3];

        if (bufferStruct.instances) {
          // 弧线
          inposs[i * 4] = bufferStruct.instances[i][0];
          inposs[i * 4 + 1] = bufferStruct.instances[i][1];
          inposs[i * 4 + 2] = bufferStruct.instances[i][2];
          inposs[i * 4 + 3] = bufferStruct.instances[i][3];
        }
      }

      return {
        vertices: vertices,
        colors: colors,
        inposs: inposs
      };
    }
  }]);

  return LineBuffer;
}(__WEBPACK_IMPORTED_MODULE_0__bufferBase__["a" /* default */]);



/***/ }),
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shape_index__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bufferBase__ = __webpack_require__(17);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var polygonLineBuffer =
/*#__PURE__*/
function (_BufferBase) {
  _inherits(polygonLineBuffer, _BufferBase);

  function polygonLineBuffer() {
    _classCallCheck(this, polygonLineBuffer);

    return _possibleConstructorReturn(this, _getPrototypeOf(polygonLineBuffer).apply(this, arguments));
  }

  _createClass(polygonLineBuffer, [{
    key: "geometryBuffer",
    value: function geometryBuffer() {
      var coordinates = this.get('coordinates');
      var properties = this.get('properties');
      var shape = this.get('shape');
      var positions = [];
      var positionsIndex = [];
      var vertsCount = 0;
      this.bufferStruct.style = properties;
      var isExtrude = properties[0].hasOwnProperty('size');
      coordinates.forEach(function (geo, index) {
        var heightValue = properties[index].size;
        var extrudeData = [];

        if (isExtrude && shape === 'extrudeline') {
          extrudeData = __WEBPACK_IMPORTED_MODULE_0__shape_index__["b" /* polygonShape */].extrudeline(geo);
          extrudeData.positions = extrudeData.positions.map(function (pos) {
            pos[2] *= heightValue;
            return pos;
          });
        } else {
          extrudeData = __WEBPACK_IMPORTED_MODULE_0__shape_index__["b" /* polygonShape */].line(geo);
        }

        positions.push(extrudeData.positions);
        positionsIndex.push.apply(positionsIndex, _toConsumableArray(extrudeData.positionsIndex.map(function (index) {
          return index + vertsCount;
        })));
        vertsCount += extrudeData.positions.length;
      });
      this.bufferStruct.indexs = positionsIndex;
      this.bufferStruct.verts = positions;
      this.bufferStruct.vertsCount = vertsCount;
    }
  }]);

  return polygonLineBuffer;
}(__WEBPACK_IMPORTED_MODULE_1__bufferBase__["a" /* default */]);



/***/ }),
/* 321 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return imageLayer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_layer__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__source_imageSource__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_buffer_image__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_material_imageMaterial__ = __webpack_require__(323);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




 // import ImageGeometry from '../geom/bufferGeometry/image';



var imageLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(imageLayer, _Layer);

  function imageLayer() {
    _classCallCheck(this, imageLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(imageLayer).apply(this, arguments));
  }

  _createClass(imageLayer, [{
    key: "source",
    value: function source(data) {
      var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      cfg.mapType = this.get('mapType');
      cfg.data = data;
      this.layerSource = new __WEBPACK_IMPORTED_MODULE_2__source_imageSource__["a" /* default */](cfg);
      return this;
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      this.init();
      this.type = 'image';
      var source = this.layerSource;

      var _this$get = this.get('styleOptions'),
          opacity = _this$get.opacity; // 加载 完成事件


      source.on('imageLoaded', function () {
        var buffer = new __WEBPACK_IMPORTED_MODULE_3__geom_buffer_image__["a" /* default */]({
          coordinates: source.geoData,
          image: source.image
        });

        _this.initGeometry(buffer.attributes);

        var material = new __WEBPACK_IMPORTED_MODULE_4__geom_material_imageMaterial__["a" /* default */]({
          u_texture: buffer.texture,
          u_opacity: opacity
        });
        var imageMesh = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Mesh"](_this.geometry, material);

        _this.add(imageMesh);
      });
      return this;
    }
  }, {
    key: "initGeometry",
    value: function initGeometry(attributes) {
      this.geometry = new __WEBPACK_IMPORTED_MODULE_1__core_three__["BufferGeometry"]();
      this.geometry.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.vertices, 3));
      this.geometry.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.uvs, 2));
    }
  }]);

  return imageLayer;
}(__WEBPACK_IMPORTED_MODULE_0__core_layer__["a" /* default */]);



/***/ }),
/* 322 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ImageBuffer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bufferBase__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__util__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_three__ = __webpack_require__(2);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var ImageBuffer =
/*#__PURE__*/
function (_BufferBase) {
  _inherits(ImageBuffer, _BufferBase);

  function ImageBuffer() {
    _classCallCheck(this, ImageBuffer);

    return _possibleConstructorReturn(this, _getPrototypeOf(ImageBuffer).apply(this, arguments));
  }

  _createClass(ImageBuffer, [{
    key: "geometryBuffer",
    value: function geometryBuffer() {
      var _this = this;

      var coordinates = this.get('coordinates');
      var images = this.get('image');

      var positions = _toConsumableArray(coordinates[0]).concat([coordinates[1][0], coordinates[0][1], 0], _toConsumableArray(coordinates[1]), _toConsumableArray(coordinates[0]), _toConsumableArray(coordinates[1]), [coordinates[0][0], coordinates[1][1], 0]);

      var image = images;

      if (__WEBPACK_IMPORTED_MODULE_1__util___default.a.isArray(images)) {
        image = images[0];
        var textures = images.map(function (img) {
          return _this._getTexture(img);
        });
        this.u_rasters = textures;
      }

      var uv = [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0];
      var texture = new __WEBPACK_IMPORTED_MODULE_2__core_three__["Texture"](image);
      texture.magFilter = __WEBPACK_IMPORTED_MODULE_2__core_three__["LinearFilter"];
      texture.minFilter = __WEBPACK_IMPORTED_MODULE_2__core_three__["LinearFilter"];
      texture.needsUpdate = true;
      var attributes = {
        vertices: new Float32Array(positions),
        uvs: new Float32Array(uv)
      };
      this.attributes = attributes;
      this.texture = texture;
    }
  }, {
    key: "_getTexture",
    value: function _getTexture(image) {
      var texture = new __WEBPACK_IMPORTED_MODULE_2__core_three__["Texture"](image);
      texture.magFilter = __WEBPACK_IMPORTED_MODULE_2__core_three__["LinearFilter"];
      texture.minFilter = __WEBPACK_IMPORTED_MODULE_2__core_three__["LinearFilter"];
    }
  }]);

  return ImageBuffer;
}(__WEBPACK_IMPORTED_MODULE_0__bufferBase__["a" /* default */]);



/***/ }),
/* 323 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageMaterial;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_image_frag_glsl__ = __webpack_require__(324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_image_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_image_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_image_vert_glsl__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_image_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_image_vert_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material__ = __webpack_require__(16);



function ImageMaterial(options) {
  var material = new __WEBPACK_IMPORTED_MODULE_2__material__["a" /* default */]({
    uniforms: {
      u_opacity: {
        value: options.u_opacity
      },
      u_texture: {
        value: options.u_texture
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_1__shader_image_vert_glsl___default.a,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_0__shader_image_frag_glsl___default.a,
    transparent: true
  });
  return material;
}

/***/ }),
/* 324 */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\nuniform sampler2D u_texture;\nuniform float u_opacity;\nvarying vec2 v_texCoord;\nvoid main() {\n  vec4 color = texture2D(u_texture,vec2(v_texCoord.x,1.0-v_texCoord.y));\n  gl_FragColor = color * u_opacity;\n}"

/***/ }),
/* 325 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nvarying vec2 v_texCoord;\nvoid main() {\n   mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n   v_texCoord = uv;\n   gl_Position =  matModelViewProjection * vec4(position, 1.0);\n}"

/***/ }),
/* 326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RasterLayer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_layer__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__source_rasterSource__ = __webpack_require__(327);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_material_rasterMaterial__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_buffer_raster__ = __webpack_require__(331);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }







var RasterLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(RasterLayer, _Layer);

  function RasterLayer() {
    _classCallCheck(this, RasterLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(RasterLayer).apply(this, arguments));
  }

  _createClass(RasterLayer, [{
    key: "source",
    value: function source(data) {
      var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      cfg.mapType = this.get('mapType');
      cfg.data = data;
      this.layerSource = new __WEBPACK_IMPORTED_MODULE_2__source_rasterSource__["a" /* default */](cfg);
      return this;
    }
  }, {
    key: "render",
    value: function render() {
      this.type = 'raster';
      this.init();
      var source = this.layerSource; // 加载 完成事件

      var styleOptions = this.get('styleOptions');
      var buffer = new __WEBPACK_IMPORTED_MODULE_4__geom_buffer_raster__["a" /* RasterBuffer */]({
        coordinates: source.geoData,
        raster: source.rasterData,
        rampColors: styleOptions.rampColors
      });
      this.initGeometry(buffer.attributes);
      var material = new __WEBPACK_IMPORTED_MODULE_3__geom_material_rasterMaterial__["a" /* default */]({
        u_texture: buffer.bufferStruct.u_raster,
        u_colorTexture: buffer.bufferStruct.u_colorTexture,
        u_opacity: 1.0,
        u_extent: buffer.bufferStruct.u_extent,
        u_min: source.rasterData.min,
        u_max: source.rasterData.max,
        u_dimension: buffer.attributes.dimension
      });
      var rasterMesh = new __WEBPACK_IMPORTED_MODULE_1__core_three__["Mesh"](this.geometry, material);
      this.add(rasterMesh);
      return this;
    }
  }, {
    key: "animateFunc",
    value: function animateFunc() {
      var _this = this;

      var animateOptions = this.get('animateOptions');
      this.material.setValue('u_bands', this.animateData.index % 3);
      this.material.setValue('u_texture', this.animateData.rasters[Math.floor(this.animateData.index / 3) % 8]);
      this.animateData.index++;

      if (animateOptions) {
        animateOptions(this.animateData.index);
      }

      setTimeout(function () {
        _this.animateId = requestAnimationFrame(_this.animateFunc.bind(_this));
      }, 500);
    }
  }, {
    key: "cancelAnimate",
    value: function cancelAnimate() {
      window.cancelAnimationFrame(this.animateId);
    }
  }, {
    key: "initGeometry",
    value: function initGeometry(attributes) {
      this.geometry = new __WEBPACK_IMPORTED_MODULE_1__core_three__["BufferGeometry"]();
      this.geometry.setIndex(attributes.indices);
      this.geometry.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.vertices, 3));
      this.geometry.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_1__core_three__["Float32BufferAttribute"](attributes.uvs, 2));
    }
  }]);

  return RasterLayer;
}(__WEBPACK_IMPORTED_MODULE_0__core_layer__["a" /* default */]);



/***/ }),
/* 327 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RasterSource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_source__ = __webpack_require__(23);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var RasterSource =
/*#__PURE__*/
function (_Source) {
  _inherits(RasterSource, _Source);

  function RasterSource() {
    _classCallCheck(this, RasterSource);

    return _possibleConstructorReturn(this, _getPrototypeOf(RasterSource).apply(this, arguments));
  }

  _createClass(RasterSource, [{
    key: "prepareData",
    value: function prepareData() {
      this.type = 'raster';
      var extent = this.get('extent');

      var lb = this._coorConvert(extent.slice(0, 2));

      var tr = this._coorConvert(extent.slice(2, 4));

      this.geoData = [lb, tr];
      this.propertiesData = [];
      this.rasterData = {
        data: this.get('data'),
        width: this.get('width'),
        height: this.get('height'),
        min: this.get('min'),
        max: this.get('max')
      };
    }
  }]);

  return RasterSource;
}(__WEBPACK_IMPORTED_MODULE_0__core_source__["a" /* default */]);



/***/ }),
/* 328 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageMaterial;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_raster_frag_glsl__ = __webpack_require__(329);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_raster_frag_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_raster_frag_glsl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_raster_vert_glsl__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_raster_vert_glsl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_raster_vert_glsl__);



function ImageMaterial(options) {
  var material = new __WEBPACK_IMPORTED_MODULE_0__material__["a" /* default */]({
    uniforms: {
      u_opacity: {
        value: options.u_opacity
      },
      u_texture: {
        value: options.u_texture
      },
      u_colorTexture: {
        value: options.u_colorTexture
      },
      u_min: {
        value: options.u_min
      },
      u_max: {
        value: options.u_max
      },
      u_extent: {
        value: options.u_extent
      },
      u_dimension: {
        value: options.u_dimension
      }
    },
    vertexShader: __WEBPACK_IMPORTED_MODULE_2__shader_raster_vert_glsl___default.a,
    fragmentShader: __WEBPACK_IMPORTED_MODULE_1__shader_raster_frag_glsl___default.a,
    transparent: false
  }); // material.roughness = 1;
  // material.metalness = 0.1;
  // material.envMapIntensity = 3;

  return material;
}

/***/ }),
/* 329 */
/***/ (function(module, exports) {

module.exports = "\nprecision highp float;\nuniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\nuniform vec2 u_dimension;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\nuniform float u_min;\nuniform float u_max;\nuniform vec4 u_extent;\n#define PI 3.141592653589793\n\nvoid main() {\n\n    \n      vec2 u_latrange = vec2(3.83718,53.5636);\n      float u_zoom = 7.0;\n      float u_maxzoom= 10.0;\n      vec2 epsilon = 1.0 / u_dimension;\n      vec2 u_light = vec2(0.5000, 5.8469);\n      vec4 u_accent = vec4(0.,0.,0.,1.);\n      vec4 u_highlight = vec4(1.0);\n      vec4 u_shadow = vec4(0.,0.,0.,1.);\n      float a = texture2D(u_texture,v_texCoord - epsilon)[0];\n      float b = texture2D(u_texture,v_texCoord+vec2(0,-epsilon.y))[0];\n      float c = texture2D(u_texture,v_texCoord+ vec2(epsilon.x - epsilon.y))[0];\n      float d = texture2D(u_texture,v_texCoord+ vec2(-epsilon.x,0))[0];\n      float e = texture2D(u_texture,v_texCoord)[0];\n      float f = texture2D(u_texture,v_texCoord+ vec2(epsilon.x,0))[0];\n      float g = texture2D(u_texture,v_texCoord+ vec2(-epsilon.x,epsilon.y))[0];\n      float h = texture2D(u_texture,v_texCoord+ vec2(0,epsilon.y))[0];\n      float i = texture2D(u_texture,v_texCoord+ epsilon)[0];\n      float exaggeration = u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;\n\n      vec2 deriv = vec2(\n          (c + f + f + i) - (a + d + d + g),\n          (g + h + h + i) - (a + b + b + c)\n      ) /  pow(2.0, (u_zoom - u_maxzoom) * exaggeration + 19.2562 - u_zoom);\n      float scaleFactor = cos(radians((u_latrange[0] - u_latrange[1]) * (1.0 - v_texCoord.y) + u_latrange[1]));\n      float slope = atan(1.25 * length(deriv) / scaleFactor);\n      float aspect = deriv.x != 0.0 ? atan(deriv.y, -deriv.x) : PI / 2.0 * (deriv.y > 0.0 ? 1.0 : -1.0);\n      \n      float intensity = u_light.x;\n      float azimuth = u_light.y + PI;\n\n      float base = 1.875 - intensity * 1.75;\n      float maxValue = 0.5 * PI;\n      float scaledSlope = intensity != 0.5 ? ((pow(base, slope) - 1.0) / (pow(base, maxValue) - 1.0)) * maxValue : slope;\n\n      float accent = cos(scaledSlope);\n      // We multiply both the accent and shade color by a clamped intensity value\n      // so that intensities >= 0.5 do not additionally affect the color values\n      // while intensity values < 0.5 make the overall color more transparent.\n      vec4 accent_color = (1.0 - accent) * v_color * clamp(intensity * 2.0, 0.0, 1.0);\n      float shade = abs(mod((aspect + azimuth) / PI + 0.5, 2.0) - 1.0);\n      vec4 shade_color = mix(u_shadow, u_highlight, shade) * sin(scaledSlope) * clamp(intensity * 2.0, 0.0, 1.0);\n      //gl_FragColor = v_color * (1.0 - shade_color.a) + shade_color;\n      gl_FragColor = v_color;\n\n}"

/***/ }),
/* 330 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nuniform vec4 u_extent;\nuniform sampler2D u_texture;\nuniform float u_size;\nuniform sampler2D u_colorTexture;\nuniform float u_min;\nuniform float u_max;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\nvoid main() {\n   mat4 matModelViewProjection = projectionMatrix * modelViewMatrix;\n   float value = texture2D(u_texture,uv)[0];\n    v_texCoord = uv;\n   value = clamp(value,u_min,u_max);\n\n   float value1 =  (value - u_min) / (u_max -u_min);\n    vec2 ramp_pos = vec2(\n        fract(16.0 * (1.0 - value1)),\n        floor(16.0 * (1.0 - value1)) / 16.0);\n    v_color = texture2D(u_colorTexture,ramp_pos);\n   vec2 range = u_extent.zw - u_extent.xy;\n   gl_Position =  matModelViewProjection * vec4(position.xy, value*100., 1.0);\n\n}"

/***/ }),
/* 331 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RasterBuffer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bufferBase__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__attr_colorscales__ = __webpack_require__(332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_three__ = __webpack_require__(2);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var RasterBuffer =
/*#__PURE__*/
function (_BufferBase) {
  _inherits(RasterBuffer, _BufferBase);

  function RasterBuffer() {
    _classCallCheck(this, RasterBuffer);

    return _possibleConstructorReturn(this, _getPrototypeOf(RasterBuffer).apply(this, arguments));
  }

  _createClass(RasterBuffer, [{
    key: "geometryBuffer",
    value: function geometryBuffer() {
      var coordinates = this.get('coordinates');

      var positions = _toConsumableArray(coordinates[0]).concat([coordinates[1][0], coordinates[0][1], 0], _toConsumableArray(coordinates[1]), _toConsumableArray(coordinates[0]), _toConsumableArray(coordinates[1]), [coordinates[0][0], coordinates[1][1], 0]);

      var imgPosUv = [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0];
      var raster = this.get('raster');
      var size = this.get('size');
      var texture = new __WEBPACK_IMPORTED_MODULE_2__core_three__["DataTexture"](new Float32Array(raster.data), raster.width, raster.height, __WEBPACK_IMPORTED_MODULE_2__core_three__["LuminanceFormat"], __WEBPACK_IMPORTED_MODULE_2__core_three__["FloatType"]);
      texture.generateMipmaps = true;
      texture.needsUpdate = true;
      var colors = this.get('rampColors');
      var colorImageData = this.getColorRamp(colors);

      var colorTexture = this._getTexture(colorImageData);

      this.bufferStruct.position = positions;
      this.bufferStruct.uv = imgPosUv;
      this.bufferStruct.u_raster = texture; //

      this.bufferStruct.u_extent = [coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]];
      this.bufferStruct.u_colorTexture = colorTexture; // 颜色表‘=

      var triangles = this._buildTriangles(raster, size, this.bufferStruct.u_extent);

      var attributes = {
        vertices: new Float32Array(triangles.vertices),
        uvs: new Float32Array(triangles.uvs),
        indices: triangles.indices,
        dimension: triangles.dimension
      };
      this.attributes = attributes;
    }
  }, {
    key: "getColorRamp",
    value: function getColorRamp(name) {
      var colorscale = name;
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 1;
      var gradient = ctx.createLinearGradient(0, 0, 256, 0);
      var data = null;

      if (typeof colorscale === 'string') {
        colorscale = __WEBPACK_IMPORTED_MODULE_1__attr_colorscales__["a" /* colorScales */][name];
      }

      if (Object.prototype.toString.call(colorscale) === '[object Object]') {
        var min = colorscale.positions[0];
        var max = colorscale.positions[colorscale.positions.length - 1];

        for (var i = 0; i < colorscale.colors.length; ++i) {
          var value = (colorscale.positions[i] - min) / (max - min);
          gradient.addColorStop(value, colorscale.colors[i]);
        }

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 1);
        data = new Uint8ClampedArray(ctx.getImageData(0, 0, 256, 1).data);
      }

      if (Object.prototype.toString.call(colorscale) === '[object Uint8Array]') {
        data = ctx.createImageData(256, 1);
      }

      return new ImageData(data, 16, 16);
    }
  }, {
    key: "_getTexture",
    value: function _getTexture(image) {
      var texture1 = new __WEBPACK_IMPORTED_MODULE_2__core_three__["Texture"](image);
      texture1.magFilter = __WEBPACK_IMPORTED_MODULE_2__core_three__["LinearFilter"];
      texture1.minFilter = __WEBPACK_IMPORTED_MODULE_2__core_three__["LinearFilter"];
      texture1.format = __WEBPACK_IMPORTED_MODULE_2__core_three__["RGBAFormat"];
      texture1.type = __WEBPACK_IMPORTED_MODULE_2__core_three__["UnsignedByteType"];
      texture1.needsUpdate = true;
      return texture1;
    }
  }, {
    key: "_buildTriangles",
    value: function _buildTriangles(raster) {
      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var extent = arguments.length > 2 ? arguments[2] : undefined;
      // const extent = [ 73.482190241, 3.82501784112, 135.106618732, 57.6300459963 ]
      var width = raster.width,
          height = raster.height;
      var indices = [];
      var vertices = [];
      var uvs = [];
      var gridX = Math.floor(width / size);
      var gridY = Math.floor(height / size);
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var stepX = (extent[2] - extent[0]) / gridX1;
      var stepY = (extent[3] - extent[1]) / gridY1;

      for (var i = 0; i < gridY1; i++) {
        var y = i * size;

        for (var j = 0; j < gridX1; j++) {
          var x = j * size;
          vertices.push(extent[0] + x * stepX, (height - y) * stepY + extent[1], 0);
          uvs.push(j / gridX);
          uvs.push(i / gridY);
        }
      }

      for (var iy = 0; iy < gridY; iy++) {
        for (var ix = 0; ix < gridX; ix++) {
          var a = ix + gridX1 * iy;
          var b = ix + gridX1 * (iy + 1);
          var c = ix + 1 + gridX1 * (iy + 1);
          var d = ix + 1 + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }

      return {
        uvs: uvs,
        indices: indices,
        vertices: vertices,
        dimension: [gridX, gridY]
      };
    }
  }]);

  return RasterBuffer;
}(__WEBPACK_IMPORTED_MODULE_0__bufferBase__["a" /* default */]);

/***/ }),
/* 332 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return colorScales; });
// code from https://github.com/santilland/plotty/blob/master/src/colorscales.js
var colorScales = {
  viridis: new Uint8Array([68, 1, 84, 255, 68, 2, 86, 255, 69, 4, 87, 255, 69, 5, 89, 255, 70, 7, 90, 255, 70, 8, 92, 255, 70, 10, 93, 255, 70, 11, 94, 255, 71, 13, 96, 255, 71, 14, 97, 255, 71, 16, 99, 255, 71, 17, 100, 255, 71, 19, 101, 255, 72, 20, 103, 255, 72, 22, 104, 255, 72, 23, 105, 255, 72, 24, 106, 255, 72, 26, 108, 255, 72, 27, 109, 255, 72, 28, 110, 255, 72, 29, 111, 255, 72, 31, 112, 255, 72, 32, 113, 255, 72, 33, 115, 255, 72, 35, 116, 255, 72, 36, 117, 255, 72, 37, 118, 255, 72, 38, 119, 255, 72, 40, 120, 255, 72, 41, 121, 255, 71, 42, 122, 255, 71, 44, 122, 255, 71, 45, 123, 255, 71, 46, 124, 255, 71, 47, 125, 255, 70, 48, 126, 255, 70, 50, 126, 255, 70, 51, 127, 255, 70, 52, 128, 255, 69, 53, 129, 255, 69, 55, 129, 255, 69, 56, 130, 255, 68, 57, 131, 255, 68, 58, 131, 255, 68, 59, 132, 255, 67, 61, 132, 255, 67, 62, 133, 255, 66, 63, 133, 255, 66, 64, 134, 255, 66, 65, 134, 255, 65, 66, 135, 255, 65, 68, 135, 255, 64, 69, 136, 255, 64, 70, 136, 255, 63, 71, 136, 255, 63, 72, 137, 255, 62, 73, 137, 255, 62, 74, 137, 255, 62, 76, 138, 255, 61, 77, 138, 255, 61, 78, 138, 255, 60, 79, 138, 255, 60, 80, 139, 255, 59, 81, 139, 255, 59, 82, 139, 255, 58, 83, 139, 255, 58, 84, 140, 255, 57, 85, 140, 255, 57, 86, 140, 255, 56, 88, 140, 255, 56, 89, 140, 255, 55, 90, 140, 255, 55, 91, 141, 255, 54, 92, 141, 255, 54, 93, 141, 255, 53, 94, 141, 255, 53, 95, 141, 255, 52, 96, 141, 255, 52, 97, 141, 255, 51, 98, 141, 255, 51, 99, 141, 255, 50, 100, 142, 255, 50, 101, 142, 255, 49, 102, 142, 255, 49, 103, 142, 255, 49, 104, 142, 255, 48, 105, 142, 255, 48, 106, 142, 255, 47, 107, 142, 255, 47, 108, 142, 255, 46, 109, 142, 255, 46, 110, 142, 255, 46, 111, 142, 255, 45, 112, 142, 255, 45, 113, 142, 255, 44, 113, 142, 255, 44, 114, 142, 255, 44, 115, 142, 255, 43, 116, 142, 255, 43, 117, 142, 255, 42, 118, 142, 255, 42, 119, 142, 255, 42, 120, 142, 255, 41, 121, 142, 255, 41, 122, 142, 255, 41, 123, 142, 255, 40, 124, 142, 255, 40, 125, 142, 255, 39, 126, 142, 255, 39, 127, 142, 255, 39, 128, 142, 255, 38, 129, 142, 255, 38, 130, 142, 255, 38, 130, 142, 255, 37, 131, 142, 255, 37, 132, 142, 255, 37, 133, 142, 255, 36, 134, 142, 255, 36, 135, 142, 255, 35, 136, 142, 255, 35, 137, 142, 255, 35, 138, 141, 255, 34, 139, 141, 255, 34, 140, 141, 255, 34, 141, 141, 255, 33, 142, 141, 255, 33, 143, 141, 255, 33, 144, 141, 255, 33, 145, 140, 255, 32, 146, 140, 255, 32, 146, 140, 255, 32, 147, 140, 255, 31, 148, 140, 255, 31, 149, 139, 255, 31, 150, 139, 255, 31, 151, 139, 255, 31, 152, 139, 255, 31, 153, 138, 255, 31, 154, 138, 255, 30, 155, 138, 255, 30, 156, 137, 255, 30, 157, 137, 255, 31, 158, 137, 255, 31, 159, 136, 255, 31, 160, 136, 255, 31, 161, 136, 255, 31, 161, 135, 255, 31, 162, 135, 255, 32, 163, 134, 255, 32, 164, 134, 255, 33, 165, 133, 255, 33, 166, 133, 255, 34, 167, 133, 255, 34, 168, 132, 255, 35, 169, 131, 255, 36, 170, 131, 255, 37, 171, 130, 255, 37, 172, 130, 255, 38, 173, 129, 255, 39, 173, 129, 255, 40, 174, 128, 255, 41, 175, 127, 255, 42, 176, 127, 255, 44, 177, 126, 255, 45, 178, 125, 255, 46, 179, 124, 255, 47, 180, 124, 255, 49, 181, 123, 255, 50, 182, 122, 255, 52, 182, 121, 255, 53, 183, 121, 255, 55, 184, 120, 255, 56, 185, 119, 255, 58, 186, 118, 255, 59, 187, 117, 255, 61, 188, 116, 255, 63, 188, 115, 255, 64, 189, 114, 255, 66, 190, 113, 255, 68, 191, 112, 255, 70, 192, 111, 255, 72, 193, 110, 255, 74, 193, 109, 255, 76, 194, 108, 255, 78, 195, 107, 255, 80, 196, 106, 255, 82, 197, 105, 255, 84, 197, 104, 255, 86, 198, 103, 255, 88, 199, 101, 255, 90, 200, 100, 255, 92, 200, 99, 255, 94, 201, 98, 255, 96, 202, 96, 255, 99, 203, 95, 255, 101, 203, 94, 255, 103, 204, 92, 255, 105, 205, 91, 255, 108, 205, 90, 255, 110, 206, 88, 255, 112, 207, 87, 255, 115, 208, 86, 255, 117, 208, 84, 255, 119, 209, 83, 255, 122, 209, 81, 255, 124, 210, 80, 255, 127, 211, 78, 255, 129, 211, 77, 255, 132, 212, 75, 255, 134, 213, 73, 255, 137, 213, 72, 255, 139, 214, 70, 255, 142, 214, 69, 255, 144, 215, 67, 255, 147, 215, 65, 255, 149, 216, 64, 255, 152, 216, 62, 255, 155, 217, 60, 255, 157, 217, 59, 255, 160, 218, 57, 255, 162, 218, 55, 255, 165, 219, 54, 255, 168, 219, 52, 255, 170, 220, 50, 255, 173, 220, 48, 255, 176, 221, 47, 255, 178, 221, 45, 255, 181, 222, 43, 255, 184, 222, 41, 255, 186, 222, 40, 255, 189, 223, 38, 255, 192, 223, 37, 255, 194, 223, 35, 255, 197, 224, 33, 255, 200, 224, 32, 255, 202, 225, 31, 255, 205, 225, 29, 255, 208, 225, 28, 255, 210, 226, 27, 255, 213, 226, 26, 255, 216, 226, 25, 255, 218, 227, 25, 255, 221, 227, 24, 255, 223, 227, 24, 255, 226, 228, 24, 255, 229, 228, 25, 255, 231, 228, 25, 255, 234, 229, 26, 255, 236, 229, 27, 255, 239, 229, 28, 255, 241, 229, 29, 255, 244, 230, 30, 255, 246, 230, 32, 255, 248, 230, 33, 255, 251, 231, 35, 255, 253, 231, 37, 255]),
  inferno: new Uint8Array([0, 0, 4, 255, 1, 0, 5, 255, 1, 1, 6, 255, 1, 1, 8, 255, 2, 1, 10, 255, 2, 2, 12, 255, 2, 2, 14, 255, 3, 2, 16, 255, 4, 3, 18, 255, 4, 3, 20, 255, 5, 4, 23, 255, 6, 4, 25, 255, 7, 5, 27, 255, 8, 5, 29, 255, 9, 6, 31, 255, 10, 7, 34, 255, 11, 7, 36, 255, 12, 8, 38, 255, 13, 8, 41, 255, 14, 9, 43, 255, 16, 9, 45, 255, 17, 10, 48, 255, 18, 10, 50, 255, 20, 11, 52, 255, 21, 11, 55, 255, 22, 11, 57, 255, 24, 12, 60, 255, 25, 12, 62, 255, 27, 12, 65, 255, 28, 12, 67, 255, 30, 12, 69, 255, 31, 12, 72, 255, 33, 12, 74, 255, 35, 12, 76, 255, 36, 12, 79, 255, 38, 12, 81, 255, 40, 11, 83, 255, 41, 11, 85, 255, 43, 11, 87, 255, 45, 11, 89, 255, 47, 10, 91, 255, 49, 10, 92, 255, 50, 10, 94, 255, 52, 10, 95, 255, 54, 9, 97, 255, 56, 9, 98, 255, 57, 9, 99, 255, 59, 9, 100, 255, 61, 9, 101, 255, 62, 9, 102, 255, 64, 10, 103, 255, 66, 10, 104, 255, 68, 10, 104, 255, 69, 10, 105, 255, 71, 11, 106, 255, 73, 11, 106, 255, 74, 12, 107, 255, 76, 12, 107, 255, 77, 13, 108, 255, 79, 13, 108, 255, 81, 14, 108, 255, 82, 14, 109, 255, 84, 15, 109, 255, 85, 15, 109, 255, 87, 16, 110, 255, 89, 16, 110, 255, 90, 17, 110, 255, 92, 18, 110, 255, 93, 18, 110, 255, 95, 19, 110, 255, 97, 19, 110, 255, 98, 20, 110, 255, 100, 21, 110, 255, 101, 21, 110, 255, 103, 22, 110, 255, 105, 22, 110, 255, 106, 23, 110, 255, 108, 24, 110, 255, 109, 24, 110, 255, 111, 25, 110, 255, 113, 25, 110, 255, 114, 26, 110, 255, 116, 26, 110, 255, 117, 27, 110, 255, 119, 28, 109, 255, 120, 28, 109, 255, 122, 29, 109, 255, 124, 29, 109, 255, 125, 30, 109, 255, 127, 30, 108, 255, 128, 31, 108, 255, 130, 32, 108, 255, 132, 32, 107, 255, 133, 33, 107, 255, 135, 33, 107, 255, 136, 34, 106, 255, 138, 34, 106, 255, 140, 35, 105, 255, 141, 35, 105, 255, 143, 36, 105, 255, 144, 37, 104, 255, 146, 37, 104, 255, 147, 38, 103, 255, 149, 38, 103, 255, 151, 39, 102, 255, 152, 39, 102, 255, 154, 40, 101, 255, 155, 41, 100, 255, 157, 41, 100, 255, 159, 42, 99, 255, 160, 42, 99, 255, 162, 43, 98, 255, 163, 44, 97, 255, 165, 44, 96, 255, 166, 45, 96, 255, 168, 46, 95, 255, 169, 46, 94, 255, 171, 47, 94, 255, 173, 48, 93, 255, 174, 48, 92, 255, 176, 49, 91, 255, 177, 50, 90, 255, 179, 50, 90, 255, 180, 51, 89, 255, 182, 52, 88, 255, 183, 53, 87, 255, 185, 53, 86, 255, 186, 54, 85, 255, 188, 55, 84, 255, 189, 56, 83, 255, 191, 57, 82, 255, 192, 58, 81, 255, 193, 58, 80, 255, 195, 59, 79, 255, 196, 60, 78, 255, 198, 61, 77, 255, 199, 62, 76, 255, 200, 63, 75, 255, 202, 64, 74, 255, 203, 65, 73, 255, 204, 66, 72, 255, 206, 67, 71, 255, 207, 68, 70, 255, 208, 69, 69, 255, 210, 70, 68, 255, 211, 71, 67, 255, 212, 72, 66, 255, 213, 74, 65, 255, 215, 75, 63, 255, 216, 76, 62, 255, 217, 77, 61, 255, 218, 78, 60, 255, 219, 80, 59, 255, 221, 81, 58, 255, 222, 82, 56, 255, 223, 83, 55, 255, 224, 85, 54, 255, 225, 86, 53, 255, 226, 87, 52, 255, 227, 89, 51, 255, 228, 90, 49, 255, 229, 92, 48, 255, 230, 93, 47, 255, 231, 94, 46, 255, 232, 96, 45, 255, 233, 97, 43, 255, 234, 99, 42, 255, 235, 100, 41, 255, 235, 102, 40, 255, 236, 103, 38, 255, 237, 105, 37, 255, 238, 106, 36, 255, 239, 108, 35, 255, 239, 110, 33, 255, 240, 111, 32, 255, 241, 113, 31, 255, 241, 115, 29, 255, 242, 116, 28, 255, 243, 118, 27, 255, 243, 120, 25, 255, 244, 121, 24, 255, 245, 123, 23, 255, 245, 125, 21, 255, 246, 126, 20, 255, 246, 128, 19, 255, 247, 130, 18, 255, 247, 132, 16, 255, 248, 133, 15, 255, 248, 135, 14, 255, 248, 137, 12, 255, 249, 139, 11, 255, 249, 140, 10, 255, 249, 142, 9, 255, 250, 144, 8, 255, 250, 146, 7, 255, 250, 148, 7, 255, 251, 150, 6, 255, 251, 151, 6, 255, 251, 153, 6, 255, 251, 155, 6, 255, 251, 157, 7, 255, 252, 159, 7, 255, 252, 161, 8, 255, 252, 163, 9, 255, 252, 165, 10, 255, 252, 166, 12, 255, 252, 168, 13, 255, 252, 170, 15, 255, 252, 172, 17, 255, 252, 174, 18, 255, 252, 176, 20, 255, 252, 178, 22, 255, 252, 180, 24, 255, 251, 182, 26, 255, 251, 184, 29, 255, 251, 186, 31, 255, 251, 188, 33, 255, 251, 190, 35, 255, 250, 192, 38, 255, 250, 194, 40, 255, 250, 196, 42, 255, 250, 198, 45, 255, 249, 199, 47, 255, 249, 201, 50, 255, 249, 203, 53, 255, 248, 205, 55, 255, 248, 207, 58, 255, 247, 209, 61, 255, 247, 211, 64, 255, 246, 213, 67, 255, 246, 215, 70, 255, 245, 217, 73, 255, 245, 219, 76, 255, 244, 221, 79, 255, 244, 223, 83, 255, 244, 225, 86, 255, 243, 227, 90, 255, 243, 229, 93, 255, 242, 230, 97, 255, 242, 232, 101, 255, 242, 234, 105, 255, 241, 236, 109, 255, 241, 237, 113, 255, 241, 239, 117, 255, 241, 241, 121, 255, 242, 242, 125, 255, 242, 244, 130, 255, 243, 245, 134, 255, 243, 246, 138, 255, 244, 248, 142, 255, 245, 249, 146, 255, 246, 250, 150, 255, 248, 251, 154, 255, 249, 252, 157, 255, 250, 253, 161, 255, 252, 255, 164, 255]),
  rainbow: {
    colors: ['#96005A', '#0000C8', '#0019FF', '#0098FF', '#2CFF96', '#97FF00', '#FFEA00', '#FF6F00', '#FF0000'],
    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]
  },
  jet: {
    colors: ['#000083', '#003CAA', '#05FFFF', '#FFFF00', '#FA0000', '#800000'],
    positions: [0, 0.125, 0.375, 0.625, 0.875, 1]
  },
  hsv: {
    colors: ['#ff0000', '#fdff02', '#f7ff02', '#00fc04', '#00fc0a', '#01f9ff', '#0200fd', '#0800fd', '#ff00fb', '#ff00f5', '#ff0006'],
    positions: [0, 0.169, 0.173, 0.337, 0.341, 0.506, 0.671, 0.675, 0.839, 0.843, 1]
  },
  hot: {
    colors: ['#000000', '#e60000', '#ffd200', '#ffffff'],
    positions: [0, 0.3, 0.6, 1]
  },
  cool: {
    colors: ['#00ffff', '#ff00ff'],
    positions: [0, 1]
  },
  spring: {
    colors: ['#ff00ff', '#ffff00'],
    positions: [0, 1]
  },
  summer: {
    colors: ['#008066', '#ffff66'],
    positions: [0, 1]
  },
  autumn: {
    colors: ['#ff0000', '#ffff00'],
    positions: [0, 1]
  },
  winter: {
    colors: ['#0000ff', '#00ff80'],
    positions: [0, 1]
  },
  bone: {
    colors: ['#000000', '#545474', '#a9c8c8', '#ffffff'],
    positions: [0, 0.376, 0.753, 1]
  },
  copper: {
    colors: ['#000000', '#ffa066', '#ffc77f'],
    positions: [0, 0.804, 1]
  },
  greys: {
    colors: ['#000000', '#ffffff'],
    positions: [0, 1]
  },
  yignbu: {
    colors: ['#081d58', '#253494', '#225ea8', '#1d91c0', '#41b6c4', '#7fcdbb', '#c7e9b4', '#edf8d9', '#ffffd9'],
    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]
  },
  greens: {
    colors: ['#00441b', '#006d2c', '#238b45', '#41ab5d', '#74c476', '#a1d99b', '#c7e9c0', '#e5f5e0', '#f7fcf5'],
    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]
  },
  wind: {
    colors: ['#3288bd', '#66c2a5', '#abdda4', '#e6f598', '#fee08b', '#fdae61', '#f46d43', '#d53e4f'],
    positions: [0, 0.1, 0.2, 0.6, 0.7, 0.8, 0.9, 1]
  },
  yiorrd: {
    colors: ['#800026', '#bd0026', '#e31a1c', '#fc4e2a', '#fd8d3c', '#feb24c', '#fed976', '#ffeda0', '#ffffcc'],
    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]
  },
  bluered: {
    colors: ['#0000ff', '#ff0000'],
    positions: [0, 1]
  },
  rdbu: {
    colors: ['#050aac', '#6a89f7', '#bebebe', '#dcaa84', '#e6915a', '#b20a1c'],
    positions: [0, 0.35, 0.5, 0.6, 0.7, 1]
  },
  picnic: {
    colors: ['#0000ff', '#3399ff', '#66ccff', '#99ccff', '#ccccff', '#ffffff', '#ffccff', '#ff99ff', '#ff66cc', '#ff6666', '#ff0000'],
    positions: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
  },
  portland: {
    colors: ['#0c3383', '#0a88ba', '#f2d338', '#f28f38', '#d91e1e'],
    positions: [0, 0.25, 0.5, 0.75, 1]
  },
  blackbody: {
    colors: ['#000000', '#e60000', '#e6d200', '#ffffff', '#a0c8ff'],
    positions: [0, 0.2, 0.4, 0.7, 1]
  },
  earth: {
    colors: ['#000082', '#00b4b4', '#28d228', '#e6e632', '#784614', '#ffffff'],
    positions: [0, 0.1, 0.2, 0.4, 0.6, 1]
  },
  electric: {
    colors: ['#000000', '#1e0064', '#780064', '#a05a00', '#e6c800', '#fffadc'],
    positions: [0, 0.15, 0.4, 0.6, 0.8, 1]
  },
  magma: new Uint8Array([0, 0, 4, 255, 1, 0, 5, 255, 1, 1, 6, 255, 1, 1, 8, 255, 2, 1, 9, 255, 2, 2, 11, 255, 2, 2, 13, 255, 3, 3, 15, 255, 3, 3, 18, 255, 4, 4, 20, 255, 5, 4, 22, 255, 6, 5, 24, 255, 6, 5, 26, 255, 7, 6, 28, 255, 8, 7, 30, 255, 9, 7, 32, 255, 10, 8, 34, 255, 11, 9, 36, 255, 12, 9, 38, 255, 13, 10, 41, 255, 14, 11, 43, 255, 16, 11, 45, 255, 17, 12, 47, 255, 18, 13, 49, 255, 19, 13, 52, 255, 20, 14, 54, 255, 21, 14, 56, 255, 22, 15, 59, 255, 24, 15, 61, 255, 25, 16, 63, 255, 26, 16, 66, 255, 28, 16, 68, 255, 29, 17, 71, 255, 30, 17, 73, 255, 32, 17, 75, 255, 33, 17, 78, 255, 34, 17, 80, 255, 36, 18, 83, 255, 37, 18, 85, 255, 39, 18, 88, 255, 41, 17, 90, 255, 42, 17, 92, 255, 44, 17, 95, 255, 45, 17, 97, 255, 47, 17, 99, 255, 49, 17, 101, 255, 51, 16, 103, 255, 52, 16, 105, 255, 54, 16, 107, 255, 56, 16, 108, 255, 57, 15, 110, 255, 59, 15, 112, 255, 61, 15, 113, 255, 63, 15, 114, 255, 64, 15, 116, 255, 66, 15, 117, 255, 68, 15, 118, 255, 69, 16, 119, 255, 71, 16, 120, 255, 73, 16, 120, 255, 74, 16, 121, 255, 76, 17, 122, 255, 78, 17, 123, 255, 79, 18, 123, 255, 81, 18, 124, 255, 82, 19, 124, 255, 84, 19, 125, 255, 86, 20, 125, 255, 87, 21, 126, 255, 89, 21, 126, 255, 90, 22, 126, 255, 92, 22, 127, 255, 93, 23, 127, 255, 95, 24, 127, 255, 96, 24, 128, 255, 98, 25, 128, 255, 100, 26, 128, 255, 101, 26, 128, 255, 103, 27, 128, 255, 104, 28, 129, 255, 106, 28, 129, 255, 107, 29, 129, 255, 109, 29, 129, 255, 110, 30, 129, 255, 112, 31, 129, 255, 114, 31, 129, 255, 115, 32, 129, 255, 117, 33, 129, 255, 118, 33, 129, 255, 120, 34, 129, 255, 121, 34, 130, 255, 123, 35, 130, 255, 124, 35, 130, 255, 126, 36, 130, 255, 128, 37, 130, 255, 129, 37, 129, 255, 131, 38, 129, 255, 132, 38, 129, 255, 134, 39, 129, 255, 136, 39, 129, 255, 137, 40, 129, 255, 139, 41, 129, 255, 140, 41, 129, 255, 142, 42, 129, 255, 144, 42, 129, 255, 145, 43, 129, 255, 147, 43, 128, 255, 148, 44, 128, 255, 150, 44, 128, 255, 152, 45, 128, 255, 153, 45, 128, 255, 155, 46, 127, 255, 156, 46, 127, 255, 158, 47, 127, 255, 160, 47, 127, 255, 161, 48, 126, 255, 163, 48, 126, 255, 165, 49, 126, 255, 166, 49, 125, 255, 168, 50, 125, 255, 170, 51, 125, 255, 171, 51, 124, 255, 173, 52, 124, 255, 174, 52, 123, 255, 176, 53, 123, 255, 178, 53, 123, 255, 179, 54, 122, 255, 181, 54, 122, 255, 183, 55, 121, 255, 184, 55, 121, 255, 186, 56, 120, 255, 188, 57, 120, 255, 189, 57, 119, 255, 191, 58, 119, 255, 192, 58, 118, 255, 194, 59, 117, 255, 196, 60, 117, 255, 197, 60, 116, 255, 199, 61, 115, 255, 200, 62, 115, 255, 202, 62, 114, 255, 204, 63, 113, 255, 205, 64, 113, 255, 207, 64, 112, 255, 208, 65, 111, 255, 210, 66, 111, 255, 211, 67, 110, 255, 213, 68, 109, 255, 214, 69, 108, 255, 216, 69, 108, 255, 217, 70, 107, 255, 219, 71, 106, 255, 220, 72, 105, 255, 222, 73, 104, 255, 223, 74, 104, 255, 224, 76, 103, 255, 226, 77, 102, 255, 227, 78, 101, 255, 228, 79, 100, 255, 229, 80, 100, 255, 231, 82, 99, 255, 232, 83, 98, 255, 233, 84, 98, 255, 234, 86, 97, 255, 235, 87, 96, 255, 236, 88, 96, 255, 237, 90, 95, 255, 238, 91, 94, 255, 239, 93, 94, 255, 240, 95, 94, 255, 241, 96, 93, 255, 242, 98, 93, 255, 242, 100, 92, 255, 243, 101, 92, 255, 244, 103, 92, 255, 244, 105, 92, 255, 245, 107, 92, 255, 246, 108, 92, 255, 246, 110, 92, 255, 247, 112, 92, 255, 247, 114, 92, 255, 248, 116, 92, 255, 248, 118, 92, 255, 249, 120, 93, 255, 249, 121, 93, 255, 249, 123, 93, 255, 250, 125, 94, 255, 250, 127, 94, 255, 250, 129, 95, 255, 251, 131, 95, 255, 251, 133, 96, 255, 251, 135, 97, 255, 252, 137, 97, 255, 252, 138, 98, 255, 252, 140, 99, 255, 252, 142, 100, 255, 252, 144, 101, 255, 253, 146, 102, 255, 253, 148, 103, 255, 253, 150, 104, 255, 253, 152, 105, 255, 253, 154, 106, 255, 253, 155, 107, 255, 254, 157, 108, 255, 254, 159, 109, 255, 254, 161, 110, 255, 254, 163, 111, 255, 254, 165, 113, 255, 254, 167, 114, 255, 254, 169, 115, 255, 254, 170, 116, 255, 254, 172, 118, 255, 254, 174, 119, 255, 254, 176, 120, 255, 254, 178, 122, 255, 254, 180, 123, 255, 254, 182, 124, 255, 254, 183, 126, 255, 254, 185, 127, 255, 254, 187, 129, 255, 254, 189, 130, 255, 254, 191, 132, 255, 254, 193, 133, 255, 254, 194, 135, 255, 254, 196, 136, 255, 254, 198, 138, 255, 254, 200, 140, 255, 254, 202, 141, 255, 254, 204, 143, 255, 254, 205, 144, 255, 254, 207, 146, 255, 254, 209, 148, 255, 254, 211, 149, 255, 254, 213, 151, 255, 254, 215, 153, 255, 254, 216, 154, 255, 253, 218, 156, 255, 253, 220, 158, 255, 253, 222, 160, 255, 253, 224, 161, 255, 253, 226, 163, 255, 253, 227, 165, 255, 253, 229, 167, 255, 253, 231, 169, 255, 253, 233, 170, 255, 253, 235, 172, 255, 252, 236, 174, 255, 252, 238, 176, 255, 252, 240, 178, 255, 252, 242, 180, 255, 252, 244, 182, 255, 252, 246, 184, 255, 252, 247, 185, 255, 252, 249, 187, 255, 252, 251, 189, 255, 252, 253, 191, 255]),
  plasma: new Uint8Array([13, 8, 135, 255, 16, 7, 136, 255, 19, 7, 137, 255, 22, 7, 138, 255, 25, 6, 140, 255, 27, 6, 141, 255, 29, 6, 142, 255, 32, 6, 143, 255, 34, 6, 144, 255, 36, 6, 145, 255, 38, 5, 145, 255, 40, 5, 146, 255, 42, 5, 147, 255, 44, 5, 148, 255, 46, 5, 149, 255, 47, 5, 150, 255, 49, 5, 151, 255, 51, 5, 151, 255, 53, 4, 152, 255, 55, 4, 153, 255, 56, 4, 154, 255, 58, 4, 154, 255, 60, 4, 155, 255, 62, 4, 156, 255, 63, 4, 156, 255, 65, 4, 157, 255, 67, 3, 158, 255, 68, 3, 158, 255, 70, 3, 159, 255, 72, 3, 159, 255, 73, 3, 160, 255, 75, 3, 161, 255, 76, 2, 161, 255, 78, 2, 162, 255, 80, 2, 162, 255, 81, 2, 163, 255, 83, 2, 163, 255, 85, 2, 164, 255, 86, 1, 164, 255, 88, 1, 164, 255, 89, 1, 165, 255, 91, 1, 165, 255, 92, 1, 166, 255, 94, 1, 166, 255, 96, 1, 166, 255, 97, 0, 167, 255, 99, 0, 167, 255, 100, 0, 167, 255, 102, 0, 167, 255, 103, 0, 168, 255, 105, 0, 168, 255, 106, 0, 168, 255, 108, 0, 168, 255, 110, 0, 168, 255, 111, 0, 168, 255, 113, 0, 168, 255, 114, 1, 168, 255, 116, 1, 168, 255, 117, 1, 168, 255, 119, 1, 168, 255, 120, 1, 168, 255, 122, 2, 168, 255, 123, 2, 168, 255, 125, 3, 168, 255, 126, 3, 168, 255, 128, 4, 168, 255, 129, 4, 167, 255, 131, 5, 167, 255, 132, 5, 167, 255, 134, 6, 166, 255, 135, 7, 166, 255, 136, 8, 166, 255, 138, 9, 165, 255, 139, 10, 165, 255, 141, 11, 165, 255, 142, 12, 164, 255, 143, 13, 164, 255, 145, 14, 163, 255, 146, 15, 163, 255, 148, 16, 162, 255, 149, 17, 161, 255, 150, 19, 161, 255, 152, 20, 160, 255, 153, 21, 159, 255, 154, 22, 159, 255, 156, 23, 158, 255, 157, 24, 157, 255, 158, 25, 157, 255, 160, 26, 156, 255, 161, 27, 155, 255, 162, 29, 154, 255, 163, 30, 154, 255, 165, 31, 153, 255, 166, 32, 152, 255, 167, 33, 151, 255, 168, 34, 150, 255, 170, 35, 149, 255, 171, 36, 148, 255, 172, 38, 148, 255, 173, 39, 147, 255, 174, 40, 146, 255, 176, 41, 145, 255, 177, 42, 144, 255, 178, 43, 143, 255, 179, 44, 142, 255, 180, 46, 141, 255, 181, 47, 140, 255, 182, 48, 139, 255, 183, 49, 138, 255, 184, 50, 137, 255, 186, 51, 136, 255, 187, 52, 136, 255, 188, 53, 135, 255, 189, 55, 134, 255, 190, 56, 133, 255, 191, 57, 132, 255, 192, 58, 131, 255, 193, 59, 130, 255, 194, 60, 129, 255, 195, 61, 128, 255, 196, 62, 127, 255, 197, 64, 126, 255, 198, 65, 125, 255, 199, 66, 124, 255, 200, 67, 123, 255, 201, 68, 122, 255, 202, 69, 122, 255, 203, 70, 121, 255, 204, 71, 120, 255, 204, 73, 119, 255, 205, 74, 118, 255, 206, 75, 117, 255, 207, 76, 116, 255, 208, 77, 115, 255, 209, 78, 114, 255, 210, 79, 113, 255, 211, 81, 113, 255, 212, 82, 112, 255, 213, 83, 111, 255, 213, 84, 110, 255, 214, 85, 109, 255, 215, 86, 108, 255, 216, 87, 107, 255, 217, 88, 106, 255, 218, 90, 106, 255, 218, 91, 105, 255, 219, 92, 104, 255, 220, 93, 103, 255, 221, 94, 102, 255, 222, 95, 101, 255, 222, 97, 100, 255, 223, 98, 99, 255, 224, 99, 99, 255, 225, 100, 98, 255, 226, 101, 97, 255, 226, 102, 96, 255, 227, 104, 95, 255, 228, 105, 94, 255, 229, 106, 93, 255, 229, 107, 93, 255, 230, 108, 92, 255, 231, 110, 91, 255, 231, 111, 90, 255, 232, 112, 89, 255, 233, 113, 88, 255, 233, 114, 87, 255, 234, 116, 87, 255, 235, 117, 86, 255, 235, 118, 85, 255, 236, 119, 84, 255, 237, 121, 83, 255, 237, 122, 82, 255, 238, 123, 81, 255, 239, 124, 81, 255, 239, 126, 80, 255, 240, 127, 79, 255, 240, 128, 78, 255, 241, 129, 77, 255, 241, 131, 76, 255, 242, 132, 75, 255, 243, 133, 75, 255, 243, 135, 74, 255, 244, 136, 73, 255, 244, 137, 72, 255, 245, 139, 71, 255, 245, 140, 70, 255, 246, 141, 69, 255, 246, 143, 68, 255, 247, 144, 68, 255, 247, 145, 67, 255, 247, 147, 66, 255, 248, 148, 65, 255, 248, 149, 64, 255, 249, 151, 63, 255, 249, 152, 62, 255, 249, 154, 62, 255, 250, 155, 61, 255, 250, 156, 60, 255, 250, 158, 59, 255, 251, 159, 58, 255, 251, 161, 57, 255, 251, 162, 56, 255, 252, 163, 56, 255, 252, 165, 55, 255, 252, 166, 54, 255, 252, 168, 53, 255, 252, 169, 52, 255, 253, 171, 51, 255, 253, 172, 51, 255, 253, 174, 50, 255, 253, 175, 49, 255, 253, 177, 48, 255, 253, 178, 47, 255, 253, 180, 47, 255, 253, 181, 46, 255, 254, 183, 45, 255, 254, 184, 44, 255, 254, 186, 44, 255, 254, 187, 43, 255, 254, 189, 42, 255, 254, 190, 42, 255, 254, 192, 41, 255, 253, 194, 41, 255, 253, 195, 40, 255, 253, 197, 39, 255, 253, 198, 39, 255, 253, 200, 39, 255, 253, 202, 38, 255, 253, 203, 38, 255, 252, 205, 37, 255, 252, 206, 37, 255, 252, 208, 37, 255, 252, 210, 37, 255, 251, 211, 36, 255, 251, 213, 36, 255, 251, 215, 36, 255, 250, 216, 36, 255, 250, 218, 36, 255, 249, 220, 36, 255, 249, 221, 37, 255, 248, 223, 37, 255, 248, 225, 37, 255, 247, 226, 37, 255, 247, 228, 37, 255, 246, 230, 38, 255, 246, 232, 38, 255, 245, 233, 38, 255, 245, 235, 39, 255, 244, 237, 39, 255, 243, 238, 39, 255, 243, 240, 39, 255, 242, 242, 39, 255, 241, 244, 38, 255, 241, 245, 37, 255, 240, 247, 36, 255, 240, 249, 33, 255])
}; // module.exports = colorScales;

/***/ }),
/* 333 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoadImage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__three__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_wolfy87_eventemitter__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_wolfy87_eventemitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_wolfy87_eventemitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_ajax__ = __webpack_require__(38);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



 // 将图片标注绘制在512*512的画布上，每个大小 64*64 支持 64种图片

var LoadImage =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(LoadImage, _EventEmitter);

  function LoadImage() {
    var _this;

    _classCallCheck(this, LoadImage);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LoadImage).call(this));
    _this.imageWidth = 64;
    _this.canvas = document.createElement('canvas');
    _this.canvas.style.cssText += 'height: 512px;width: 512px;';
    _this.canvas.width = _this.imageWidth * 8;
    _this.canvas.height = _this.imageWidth * 8;
    _this.ctx = _this.canvas.getContext('2d');
    _this.images = [];
    _this.imagesCount = 0;
    _this.imagePos = {};
    return _this;
  }

  _createClass(LoadImage, [{
    key: "addImage",
    value: function addImage(id, opt) {
      var _this2 = this;

      this.imagesCount++;
      var imageCount = this.imagesCount;
      var x = imageCount % 8 * 64;
      var y = parseInt(imageCount / 8) * 64;
      this.imagePos[id] = {
        x: x / 512,
        y: y / 512
      };
      this.texture = new __WEBPACK_IMPORTED_MODULE_0__three__["Texture"](this.canvas);

      if (typeof opt === 'string') {
        Object(__WEBPACK_IMPORTED_MODULE_2__util_ajax__["a" /* getImage */])({
          url: opt
        }, function (err, img) {
          img.id = id;

          _this2.images.push(img);

          _this2.ctx.drawImage(img, x, y, 64, 64);

          _this2.texture.magFilter = __WEBPACK_IMPORTED_MODULE_0__three__["LinearFilter"];
          _this2.texture.minFilter = __WEBPACK_IMPORTED_MODULE_0__three__["LinearFilter"];
          _this2.texture.needsUpdate = true;

          if (_this2.images.length === _this2.imagesCount) {
            _this2.emit('imageLoaded');
          }
        });
      } else {
        var width = opt.width,
            height = opt.height,
            channels = opt.channels;
        var data = new Uint8Array(width * height * channels);
        var image = new Image();
        image.width = width;
        image.height = height;
        image.data = data;
        image.id = id;
        this.images.push(image);
        this.ctx.drawImage(image, x, y, 64, 64);
        this.texture = new __WEBPACK_IMPORTED_MODULE_0__three__["CanvasTexture"](this.canvas);
        this.imagePos[id] = {
          x: x >> 9,
          y: y >> 9
        };

        if (this.images.length === this.imagesCount) {
          this.emit('imageLoaded');
        }
      }
    }
  }, {
    key: "removeImage",
    value: function removeImage() {} // todo
    // drawAllImages() {
    //   this.images.forEach((item, index) => {
    //     const x = parseInt(index / 8) * 64;
    //     const y = index % 8 * 64;
    //     this.ctx.drawImage(item, x, y, 64, 64);
    //   });
    //   this.texture = new CanvasTexture(this.canvas);
    //   this.texture.needsUpdate=true;
    // }

  }]);

  return LoadImage;
}(__WEBPACK_IMPORTED_MODULE_1_wolfy87_eventemitter___default.a);



/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MapProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_base__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__theme_index__ = __webpack_require__(335);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__global__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__global___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__global__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var DEG2RAD = Math.PI / 180;
var MapProvider =
/*#__PURE__*/
function (_Base) {
  _inherits(MapProvider, _Base);

  _createClass(MapProvider, [{
    key: "getDefaultCfg",
    value: function getDefaultCfg() {
      return __WEBPACK_IMPORTED_MODULE_2__util___default.a.assign(__WEBPACK_IMPORTED_MODULE_3__global__["scene"], {
        resizeEnable: true,
        viewMode: '3D'
      });
    }
  }]);

  function MapProvider(container, cfg) {
    var _this;

    _classCallCheck(this, MapProvider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MapProvider).call(this, cfg));
    _this.container = container;

    _this.initMap();

    _this.addOverLayer();

    setTimeout(function () {
      _this.emit('mapLoad');
    }, 100);
    return _this;
  }

  _createClass(MapProvider, [{
    key: "initMap",
    value: function initMap() {
      var mapStyle = this.get('mapStyle');

      switch (mapStyle) {
        case 'dark':
          this.set('mapStyle', __WEBPACK_IMPORTED_MODULE_1__theme_index__["a" /* DarkTheme */].mapStyle);
          break;

        case 'light':
          this.set('mapStyle', __WEBPACK_IMPORTED_MODULE_1__theme_index__["b" /* LightTheme */].mapStyle);
          break;

        default:
          this.set('mapStyle', __WEBPACK_IMPORTED_MODULE_1__theme_index__["b" /* LightTheme */].mapStyle);
      }

      this.set('zooms', [this.get('minZoom'), this.get('maxZoom')]);
      this.map = new AMap.Map(this.container, this._attrs);
    }
  }, {
    key: "asyncCamera",
    value: function asyncCamera(engine) {
      this._engine = engine;
      var camera = engine._camera;
      var scene = engine._scene;
      var pickScene = engine._picking._pickingScene;
      this.map.on('camerachange', function (e) {
        var mapCamera = e.camera;
        var fov = mapCamera.fov,
            near = mapCamera.near,
            far = mapCamera.far,
            height = mapCamera.height,
            pitch = mapCamera.pitch,
            rotation = mapCamera.rotation,
            aspect = mapCamera.aspect;
        pitch *= DEG2RAD;
        rotation *= DEG2RAD;
        camera.fov = 180 * fov / Math.PI;
        camera.aspect = aspect;
        camera.near = near;
        camera.far = far;
        camera.updateProjectionMatrix();
        camera.position.z = height * Math.cos(pitch);
        camera.position.x = height * Math.sin(pitch) * Math.sin(rotation);
        camera.position.y = -height * Math.sin(pitch) * Math.cos(rotation);
        camera.up.x = -Math.cos(pitch) * Math.sin(rotation);
        camera.up.y = Math.cos(pitch) * Math.cos(rotation);
        camera.up.z = Math.sin(pitch);
        camera.lookAt(0, 0, 0);
        scene.position.x = -e.camera.position.x;
        scene.position.y = e.camera.position.y;
        pickScene.position.x = -e.camera.position.x;
        pickScene.position.y = e.camera.position.y;
      });
    }
  }, {
    key: "projectFlat",
    value: function projectFlat(lnglat) {
      return this.map.lngLatToGeodeticCoord(lnglat);
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      return this.map.getCenter();
    }
  }, {
    key: "getCenterFlat",
    value: function getCenterFlat() {
      return this.projectFlat(this.getCenter());
    }
  }, {
    key: "addOverLayer",
    value: function addOverLayer() {
      var canvasContainer = document.getElementById(this.container);
      this.canvasContainer = canvasContainer;
      this.renderDom = document.createElement('div');
      this.renderDom.style.cssText += 'position: absolute;top: 0; z-index:1;height: 100%;width: 100%;pointer-events: none;';
      this.renderDom.id = 'l7_canvaslayer';
      canvasContainer.appendChild(this.renderDom);
    }
  }]);

  return MapProvider;
}(__WEBPACK_IMPORTED_MODULE_0__core_base__["a" /* default */]);

/***/ }),
/* 335 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dark__ = __webpack_require__(336);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__light__ = __webpack_require__(337);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__dark__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__light__["a"]; });




/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var DarkTheme = {
  mapStyle: 'amap://styles/ba3e9759545cd618392ef073c0dfda8c?isPublic=true'
};
/* harmony default export */ __webpack_exports__["a"] = (DarkTheme);

/***/ }),
/* 337 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var LightTheme = {
  mapStyle: 'amap://styles/a80c558f91b29cf56fa47f895fb1773c?isPublic=true'
};
/* harmony default export */ __webpack_exports__["a"] = (LightTheme);

/***/ }),
/* 338 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GaodeMap; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var GaodeMap =
/*#__PURE__*/
function () {
  function GaodeMap(map) {
    _classCallCheck(this, GaodeMap);

    this.map = map;
  }

  _createClass(GaodeMap, [{
    key: "getZoom",
    value: function getZoom() {
      return this.map.getZoom();
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      return this.map.getCenter();
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return this.map.getSize();
    }
  }, {
    key: "getPitch",
    value: function getPitch() {
      return this.map.getPitch();
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      return this.map.getRotation();
    }
  }, {
    key: "getStatus",
    value: function getStatus() {
      return this.map.getStatus();
    }
  }, {
    key: "getScale",
    value: function getScale() {
      return this.getScale();
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      return this.map.setZoom(zoom);
    }
  }, {
    key: "setBounds",
    value: function setBounds(bounds) {
      return this.map.setBounds(bounds);
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      return this.map.setRotation(rotation);
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      return this.map.zoomIn();
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      return this.map.zoomOut();
    }
  }, {
    key: "panTo",
    value: function panTo(lngLat) {
      return this.map.panTo(lngLat);
    }
  }, {
    key: "panBy",
    value: function panBy(x, y) {
      return this.map.panBy(x, y);
    }
  }, {
    key: "setPitch",
    value: function setPitch(pitch) {
      return this.map.setPitch(pitch);
    }
  }, {
    key: "pixelToLngLat",
    value: function pixelToLngLat(lngLat, level) {
      return this.map.pixelToLngLat(lngLat, level);
    }
  }, {
    key: "lngLatToPixel",
    value: function lngLatToPixel(lngLat, level) {
      return this.map.lnglatToPixel(lngLat, level);
    }
  }, {
    key: "containerToLngLat",
    value: function containerToLngLat(pixel) {
      var ll = new AMap.Pixel(pixel.x, pixel.y);
      return this.map.containerToLngLat(ll);
    }
  }, {
    key: "setMapStyle",
    value: function setMapStyle(style) {
      return this.map.setMapStyle(style);
    }
  }]);

  return GaodeMap;
}();



/***/ })
/******/ ]);
});
//# sourceMappingURL=L7.js.map