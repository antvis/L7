"use strict";(self.webpackChunk_antv_l7_site=self.webpackChunk_antv_l7_site||[]).push([[9393],{69393:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});const n=[{value:"The L7 Layer interface design follows graphics syntax, and all layers inherit from the base class (baseLayer).",paraId:0,tocIndex:0},{value:"Syntax example",paraId:1,tocIndex:0},{value:"const layer = new BaseLayer(option) // option - the parameter object passed into the constructor, providing the initial state of the layer\n  .source(...) // Pass in the data required by the layer and related parsers\n  .filter() //data filtering method\n  .shape(...) // Specify a specific shape for the layer, such as: circle/triangle, etc.\n  .color(...) //Specify the color configuration of the layer\n  .texture(...) //Specify the texture referenced by the layer\n  .size(...) //Set the size of layer elements\n  .animate(...) //Set the animation mode of layer elements\n  .active(...) //Specify whether the layer element supports swipe selection\n  .select(...) //Specify whether the layer element supports click selection\n  .style(...); // Specify the configuration of the layer's custom style\n\nscene.addLayer(layer);\n",paraId:2,tocIndex:0},{value:" ",paraId:3,tocIndex:2},{value:"string",paraId:3,tocIndex:2},{value:" ",paraId:3,tocIndex:2},{value:"optional",paraId:3,tocIndex:2},{value:" *default:*automatic numbering",paraId:3,tocIndex:2},{value:"Set the layer name, you can get the layer based on name",paraId:4,tocIndex:2},{value:"scene.getLayerByName(name);\n",paraId:5,tocIndex:2},{value:" ",paraId:6,tocIndex:3},{value:"bool",paraId:6,tocIndex:3},{value:" ",paraId:6,tocIndex:3},{value:"optional",paraId:6,tocIndex:3},{value:" ",paraId:6,tocIndex:3},{value:"default:",paraId:6,tocIndex:3},{value:" true",paraId:6,tocIndex:3},{value:"Is the layer visible?",paraId:7,tocIndex:3},{value:" ",paraId:8,tocIndex:4},{value:"int",paraId:8,tocIndex:4},{value:" ",paraId:8,tocIndex:4},{value:"optional",paraId:8,tocIndex:4},{value:" *default:*0",paraId:8,tocIndex:4},{value:"Layer drawing order, larger values â€‹â€‹are drawn on the upper layer, and you can control the upper and lower levels of layer drawing.",paraId:9,tocIndex:4},{value:"L7 uses a queue rendering mechanism. All layers are stored in an array internally. The rendering of each frame will sort the layer array according to the zIndex value, and then traverse the array to render the qualified layers to the scene. middle",paraId:10,tocIndex:4},{value:" ",paraId:11,tocIndex:5},{value:"number",paraId:11,tocIndex:5},{value:" ",paraId:11,tocIndex:5},{value:"optional",paraId:11,tocIndex:5},{value:" *default:*Mapbox (0-24) Gaode (2-19)",paraId:11,tocIndex:5},{value:"Layer shows minimum zoom level",paraId:12,tocIndex:5},{value:" ",paraId:13,tocIndex:6},{value:"number",paraId:13,tocIndex:6},{value:" ",paraId:13,tocIndex:6},{value:"optional",paraId:13,tocIndex:6},{value:" *default:*Mapbox (0-24) Gaode (2-19)",paraId:13,tocIndex:6},{value:"Layer shows maximum zoom level",paraId:14,tocIndex:6},{value:" ",paraId:15,tocIndex:7},{value:"bool",paraId:15,tocIndex:7},{value:" ",paraId:15,tocIndex:7},{value:"optional",paraId:15,tocIndex:7},{value:" ",paraId:15,tocIndex:7},{value:"default:",paraId:15,tocIndex:7},{value:" false",paraId:15,tocIndex:7},{value:"After layer initialization is completed, whether the map will automatically zoom to the layer range.",paraId:16,tocIndex:7},{value:" ",paraId:17,tocIndex:8},{value:"bool",paraId:17,tocIndex:8},{value:" ",paraId:17,tocIndex:8},{value:"optional",paraId:17,tocIndex:8},{value:" *default:*0",paraId:17,tocIndex:8},{value:"The layer picking cache mechanism, for example, a 1px width line is difficult to pick up (click) with the mouse. By setting this parameter, you can expand the picking range (enlarge the size of the layer object)",paraId:18,tocIndex:8},{value:" ",paraId:19,tocIndex:9},{value:"string",paraId:19,tocIndex:9},{value:" ",paraId:19,tocIndex:9},{value:"optional",paraId:19,tocIndex:9},{value:" ",paraId:19,tocIndex:9},{value:"default:",paraId:19,tocIndex:9},{value:"'normal'",paraId:19,tocIndex:9},{value:"Layer element blending effects",paraId:20,tocIndex:9},{value:"normal Normal effect Default When occlusion occurs, only the color of the previous layer will be displayed.",paraId:21,tocIndex:9},{value:"Additive overlay mode displays the superposition of the colors of the front and rear layers when occlusion occurs.",paraId:21,tocIndex:9},{value:"subtractive subtraction mode: when occlusion occurs, the subtraction of the colors of the front and rear layers is displayed.",paraId:21,tocIndex:9},{value:"max maximum value When occlusion occurs, the maximum value of the layer color rgb is displayed.",paraId:21,tocIndex:9},{value:" ",paraId:22,tocIndex:10},{value:"boolean",paraId:22,tocIndex:10},{value:" ",paraId:22,tocIndex:10},{value:"optional",paraId:22,tocIndex:10},{value:" ",paraId:22,tocIndex:10},{value:"default:",paraId:22,tocIndex:10},{value:"'false'",paraId:22,tocIndex:10},{value:"Layer events, by default only respond to the top layer, setting to true will allow events to be transmitted transparently",paraId:22,tocIndex:10},{value:"âš ï¸ The use of mask and maskfence is not recommended. After configuring 2.14.x, the version will take effect.",paraId:23,tocIndex:10},{value:"Template layer: a layer used as a template. PointLayer, LineLayer, and PolygonLayer can all be used as templates.\nMask layer: the layer cut by the template",paraId:24,tocIndex:10},{value:"Mask layer takes effect",paraId:25,tocIndex:11},{value:" ",paraId:26,tocIndex:11},{value:"array Layer",paraId:26,tocIndex:11},{value:" ",paraId:26,tocIndex:11},{value:"optional",paraId:26,tocIndex:11},{value:" ",paraId:26,tocIndex:11},{value:"default:",paraId:26,tocIndex:11},{value:"[]",paraId:26,tocIndex:11},{value:"Mask layer takes effect",paraId:27,tocIndex:12},{value:"Whether to enable the mask. It is enabled by default. It will take effect when maskLayers is not empty.",paraId:28,tocIndex:12},{value:" ",paraId:29,tocIndex:12},{value:"bool",paraId:29,tocIndex:12},{value:" ",paraId:29,tocIndex:12},{value:"optional",paraId:29,tocIndex:12},{value:" ",paraId:29,tocIndex:12},{value:"default:",paraId:29,tocIndex:12},{value:" true",paraId:29,tocIndex:12},{value:"Mask layer takes effect\n",paraId:30,tocIndex:13},{value:" ",paraId:31,tocIndex:13},{value:"boolean",paraId:31,tocIndex:13},{value:" ",paraId:31,tocIndex:13},{value:"optional",paraId:31,tocIndex:13},{value:" ",paraId:31,tocIndex:13},{value:"default:",paraId:31,tocIndex:13},{value:" true",paraId:31,tocIndex:13},{value:"Used to describe the content of the current layer and mask boundary display.",paraId:32,tocIndex:13},{value:"true",paraId:33,tocIndex:13},{value:"Show inside the mask",paraId:33,tocIndex:13},{value:"false",paraId:33,tocIndex:13},{value:"Show outside mask",paraId:33,tocIndex:13},{value:"Template layer takes effect",paraId:34,tocIndex:14},{value:" ",paraId:34,tocIndex:14},{value:"enumerate",paraId:34,tocIndex:14},{value:" ",paraId:34,tocIndex:14},{value:"optional",paraId:34,tocIndex:14},{value:" ",paraId:34,tocIndex:14},{value:"default:",paraId:34,tocIndex:14},{value:" and",paraId:34,tocIndex:14},{value:"It is invalid when there are multiple maskLayers and needs to be set on the template layer.",paraId:34,tocIndex:14},{value:"or intersection",paraId:35,tocIndex:14},{value:"and union",paraId:35,tocIndex:14},{value:"Usage example",paraId:36,tocIndex:14},{value:"const polygonLayer = new Polygon();\nconst rasterLayer = new Raster({\n  // Raster layer uses polygon mask\n  maskLayers: [polygonLayer],\n  enableMask: true,\n  maskInside: true,\n});\n",paraId:37,tocIndex:14},{value:"-----|---",paraId:38,tocIndex:15},{value:"Set layer data and parsing configuration",paraId:39,tocIndex:16},{value:"source(data, config)",paraId:39,tocIndex:16},{value:"ã€‚",paraId:39,tocIndex:16},{value:"data { geojson | json | csv }",paraId:40,tocIndex:16},{value:"config optional data source configuration items\n",paraId:40,tocIndex:16},{value:"parser data analysis, the default is the parsing layer geojson",paraId:41,tocIndex:16},{value:"transforms [transform, transform ] Multiple data processing transformations can be set",paraId:41,tocIndex:16},{value:"parser",paraId:42,tocIndex:16},{value:"and ",paraId:42,tocIndex:16},{value:"transforms",paraId:42,tocIndex:16},{value:" ",paraId:42,tocIndex:16},{value:"See source documentation",paraId:43,tocIndex:16},{value:"ã€‚",paraId:42,tocIndex:16},{value:"layer.source(data, {\n  parser: {\n    type: 'csv',\n    x: 'lng',\n    y: 'lat',\n  },\n  transforms: [\n    {\n      type: 'map',\n      callback: function (item) {\n        const [x, y] = item.coordinates;\n        item.lat = item.lat * 1;\n        item.lng = item.lng * 1;\n        item.v = item.v * 1;\n        item.coordinates = [x * 1, y * 1];\n        return item;\n      },\n    },\n    {\n      type: 'hexagon',\n      size: 6000,\n      field: 'v',\n      method: 'sum',\n    },\n  ],\n});\n",paraId:44,tocIndex:16},{value:"we are using",paraId:45,tocIndex:17},{value:"cluster",paraId:45,tocIndex:17},{value:"After configuring the aggregation graph, you can use some aggregation methods to obtain the corresponding parameters.",paraId:45,tocIndex:17},{value:"Get aggregated data for a specified zoom level",paraId:46,tocIndex:18},{value:"zoom",paraId:47,tocIndex:18},{value:"Zoom level",paraId:47,tocIndex:18},{value:"according to",paraId:48,tocIndex:19},{value:"id",paraId:48,tocIndex:19},{value:"Get the data of the aggregation node. Each aggregation node will have a unique",paraId:48,tocIndex:19},{value:"ID",paraId:48,tocIndex:19},{value:"ã€‚",paraId:48,tocIndex:19},{value:"id",paraId:49,tocIndex:19},{value:"aggregation node",paraId:49,tocIndex:19},{value:"id",paraId:49,tocIndex:19},{value:"const source = layer.getSource();\nsource.getClustersLeaves(id);\nlayer.on('click', (e) => {\n  console.log(source.getClustersLeaves(e.feature.cluster_id));\n});\n",paraId:50,tocIndex:19},{value:"Scale measures convert map data values â€‹â€‹(numbers, dates, categories, etc.) into visual values â€‹â€‹(color, size, shape). Scales Scales are a fundamental component of data visualization because they determine the nature of the visual encoding. L7 currently supports Scale for continuous, discrete, and enumerated type data, and supports mapping of position, shape, size, and color coding.",paraId:51,tocIndex:20},{value:"When using L7, there is no need to configure Scale by default because L7 will infer scale based on the data type. The inference process is as follows:",paraId:52,tocIndex:20},{value:"Check whether the user has set Scale, if not:",paraId:53,tocIndex:20},{value:"Determine the field type of the first data of the field, if the corresponding field does not exist in the data:",paraId:54,tocIndex:20},{value:"Consider a constant as a fixed value",paraId:55,tocIndex:20},{value:"'linear' if numeric;",paraId:56,tocIndex:20},{value:"If it is string type 'cat';",paraId:57,tocIndex:20},{value:"Scale details",paraId:58,tocIndex:21},{value:"å‚æ•°ï¼š (field: string, scaleOptions: IscaleOptions)",paraId:59,tocIndex:21},{value:"field",paraId:60,tocIndex:21},{value:"Specify the field name used for mapping in the data passed in source",paraId:60,tocIndex:21},{value:"scaleOptions",paraId:60,tocIndex:21},{value:"Column definition configuration, object type\n",paraId:60,tocIndex:21},{value:"type scale type",paraId:61,tocIndex:21},{value:"unknown unmatched color optional default transparent",paraId:61,tocIndex:21},{value:"domain value range optional",paraId:61,tocIndex:21},{value:"interface IscaleOptions {\n  type: ScaleTypeName;\n  domain?: any[];\n  ...\n}\n\nlayer.color('id', ['#f00', '#ff0'])\n.size('mag', [1, 80])\n.scale('mag', {\n  type: 'linear',\n  domain: [ 1, 50]\n})ï¼›\n",paraId:62,tocIndex:21},{value:"Range and domain are two very important parameters in Scale",paraId:63,tocIndex:22},{value:"domain: definition interval of map data values\nrange: range of visual values\nThe difference between different Scales lies in the different conversion methods of domain->range",paraId:64,tocIndex:22},{value:"domain: definition interval of map data values",paraId:65,tocIndex:22},{value:"range: interval definition of visual value",paraId:65,tocIndex:22},{value:"|Data Class|Measurement Type|\n|---|\n| Continuous | linear, log, pow |\n| Continuous classification | quantize quantile,threshold,diverging |\n| Classification Enumeration | cat |",paraId:66,tocIndex:22},{value:"Cat refers to the enumeration type, which is used to display categorical data, such as the distribution of crop planting areas. Different categories such as rice, corn, and soybeans need to be mapped to different colors.",paraId:67,tocIndex:23},{value:"// The three crops will be converted into corresponding colors respectively.\n// domain = ['corn','rice', 'soybean'];\n// range = ['red','white','blue'];\nconst data = [\n  { lng: 120, lat: 30, t: 'corn' },\n  { lng: 121, lat: 30, t: 'rice' },\n  { lng: 122, lat: 30, t: 'soybean' },\n];\nlayer.source(data, {\n  parser: {\n    type: 'type',\n    x: 'lng',\n    y: 'lat',\n  },\n});\nlayer.scale('t', { type: 'cat' });\nlayer.color('t', ['red', 'white', 'blue']);\n",paraId:68,tocIndex:23},{value:"The data value and the mapped value are the same\nFor example, the value field in the data records the color of each element, and the value is the result value s to be mapped.",paraId:69,tocIndex:24},{value:"// Set to identify\nlayer.scale('value', { type: 'identify' });\n\n// or\n\nlayer.scale('value'); // L7 can be automatically inferred as identify\n",paraId:70,tocIndex:24},{value:"Linear is a mapping method for continuous data. Data and visual values â€‹â€‹are converted using linear methods. For example, the data value 1-100 is linearly mapped to an offline gradient color from red to blue. Each number corresponds to a color.",paraId:71,tocIndex:25},{value:"Equal intervals divide the range of attribute values â€‹â€‹into several equally sized subranges. Equal intervals work best with common data ranges, such as percentages and temperatures. This method emphasizes the amount of a certain attribute value relative to other values.",paraId:72,tocIndex:26},{value:'Each class contains an equal number of features. Quantile classification is well suited for linearly distributed data. Quantiles assign an equal number of data values â€‹â€‹to each class. There is no empty class, nor a class with too many or too few values.\nBecause "quantile" classification is used to group features into each class in equal numbers, the resulting map is often misleading. You might place similar features into adjacent classes, or place features with widely different values â€‹â€‹into the same class. This distortion can be minimized by increasing the number of classes.',paraId:73,tocIndex:27},{value:"It allows mapping any subset (non-uniform segment) of the domain to a range of discrete values. The input domain remains continuous and divided into slices based on a set of thresholds provided to the domain attributes. The range attribute must have N+1 elements, where N is the number of threshold boundaries provided in the domain",paraId:74,tocIndex:28},{value:"Manual interval Manual interval Manually set the classification interval. Some data will have corresponding industry standards or require some special display. For example, air quality data has strict data segmentation standards",paraId:75,tocIndex:28},{value:'-1   => "red"\n0    => "white"\n0.5  => "white"\n1.0  => "blue"\n1000 => "blue\n',paraId:76,tocIndex:28},{value:"Discrete classification is often used with two opposite hues to show the change from negative values â€‹â€‹to center to positive values. These types of maps show the magnitude of values â€‹â€‹in relation to each other.",paraId:77,tocIndex:29},{value:"Get the scale instance based on the visual channel name. Make sure the layer has been initialized before calling.",paraId:78,tocIndex:30},{value:"const scale = layer.getScale('color');\nconst color = scale(1); //Convert numerical value to color\n",paraId:79,tocIndex:30},{value:"More of a method",paraId:80,tocIndex:30},{value:"scale example usage",paraId:80,tocIndex:30},{value:"Visual coding is the process of converting data into visual form. L7 currently supports three visual channels: shape, size, and color. You can specify data fields and set different graphic attributes for different elements.",paraId:81,tocIndex:31},{value:"Data filtering method, supports callback function, maps data to true | false, visible when the result is true",paraId:82,tocIndex:32},{value:"pointLayer.filter('type', (type) => {\n  // Callback\n  if (type === 'a') {\n    return false;\n  }\n  return true;\n});\n",paraId:83,tocIndex:32},{value:"A method for mapping data values â€‹â€‹to the size of graphics. For specific parameters of the size method, you can view the detailed documentation of the corresponding layer.",paraId:84,tocIndex:33},{value:"pointLayer.size(10); // constant\npointLayer.size('type'); // Use fields to map to sizes\npointLayer.size('type', [0, 10]); // Use fields to map to sizes and specify maximum and minimum values\npointLayer.size('type', (type) => {\n  // Callback\n  if (type === 'a') {\n    return 10;\n  }\n  return 5;\n});\n",paraId:85,tocIndex:33},{value:"Pass in a numeric constant, such as",paraId:86,tocIndex:34},{value:"pointLayer.size(20)",paraId:86,tocIndex:34},{value:"Map the size according to the value of the field field, using the default",paraId:87,tocIndex:35},{value:"æœ€å¤§å€¼ max:10",paraId:87,tocIndex:35},{value:" and",paraId:87,tocIndex:35},{value:"æœ€å°å€¼ min: 1",paraId:87,tocIndex:35},{value:"ã€‚",paraId:87,tocIndex:35},{value:"Use callback functions to control graph size.",paraId:88,tocIndex:36},{value:"callback",paraId:89,tocIndex:36},{value:": function callback function.",paraId:89,tocIndex:36},{value:"pointLayer.size('age', (value) => {\n  if (value === 1) {\n    return 5;\n  }\n  return 10;\n});\n",paraId:90,tocIndex:36},{value:"A method for mapping data values â€‹â€‹to the colors of a graph.",paraId:91,tocIndex:37},{value:"layer.color('red'); // constant color\nlayer.color('type'); //Map the type field and use the built-in color\nlayer.color('type', ['red', 'blue']); // Specify color\nlayer.color('type', (type) => {\n  // through callback function\n  if (type === 'a') {\n    return 'red';\n  }\n  return 'blue';\n});\nlayer.color('type*value', (type, value) => {\n  //Multiple parameters, through callback function\n  if (type === 'a' && value > 100) {\n    return 'red';\n  }\n  return 'blue';\n});\n",paraId:92,tocIndex:37},{value:"parameter:",paraId:93,tocIndex:38},{value:"value",paraId:93,tocIndex:38},{value:"ï¼šstring",paraId:93,tocIndex:38},{value:"Only supports receiving one parameter, value can be:",paraId:94,tocIndex:38},{value:"The data source field name mapped to the color attribute. If this field name does not exist in the data source, it will be parsed according to constants. In this case, the color provided by L7 by default will be used.",paraId:95,tocIndex:38},{value:"You can also directly specify a specific color value, such as '#fff', 'white', 'rgba(255,0,0,0.5)', rgb(255,0,1), etc.",paraId:96,tocIndex:38},{value:"If the data is mapped to color, the transparent color will not be displayed by default. If you need to set the color, you need to set it in scale.",paraId:97,tocIndex:38},{value:"Example",paraId:98,tocIndex:38},{value:"layer.color('name'); // Mapping data fields\nlayer.color('white'); //Specify color\n",paraId:99,tocIndex:38},{value:"parameter:",paraId:100,tocIndex:39},{value:"field",paraId:101,tocIndex:39},{value:": stringfield is the name of the data source field mapped to the color attribute. It also supports specifying multiple parameters.",paraId:101,tocIndex:39},{value:"colors",paraId:102,tocIndex:39},{value:": string | array | function",paraId:102,tocIndex:39},{value:"The parameters of colors have the following conditions: If it is empty, that is, an array of colors is not specified, then the built-in global color is used; if a color needs to be specified, it needs to be passed in in array format, then the color of the classification is determined according to the color in the array.",paraId:103,tocIndex:39},{value:"layer.scale('name',{\n  type: 'quantile'\n  unknown:'#ccc' // Set invalid color\n})\nlayer.color('name'); // use identity\nlayer.color('name', ['red', 'blue']); // Use the specified color passed in\n",paraId:104,tocIndex:39},{value:"If colors is a callback function, the parameters of the callback function are the values â€‹â€‹of the corresponding fields. The specific usage is as follows. When color is mapped to multiple fields, the parameters are passed in in the order in which the fields are declared:",paraId:105,tocIndex:39},{value:"layer.color('gender', (value) => {\n  if (value === 1) {\n    return 'red';\n  }\n  return 'blue';\n});\nlayer.color('gender*age', (gender, age) => {\n  if (age === 20 && gender == ' ç”·') {\n    return 'red';\n  }\n  return 'blue';\n});\n",paraId:106,tocIndex:39},{value:"Usually a layer can have multiple representations. The shape method is used to specify the specific representation of the layer. Take the shape of PointLayer as an example:",paraId:107,tocIndex:40},{value:"shape('circle'); // circle\nshape('triangle'); // triangle\nshape('cylinder'); // cylinder\n",paraId:108,tocIndex:40},{value:"shape(shape)",paraId:109,tocIndex:40},{value:"parameter",paraId:110,tocIndex:40},{value:"shape",paraId:110,tocIndex:40},{value:" string",paraId:110,tocIndex:40},{value:"Only supports receiving one parameter, specifying the shape drawn by the geometric image object. The following table lists the shapes supported by the different layer geometry objects.",paraId:111,tocIndex:40},{value:"layer type",paraId:112,tocIndex:40},{value:"shape type",paraId:112,tocIndex:40},{value:"Remark",paraId:112,tocIndex:40},{value:"point",paraId:112,tocIndex:40},{value:"2d:point,circle, square, triangle,hexagon,image,text 3d:circle,triangle,hexagon,square",paraId:112,tocIndex:40},{value:"line",paraId:112,tocIndex:40},{value:"line,arc, arc3d, greatcircle",paraId:112,tocIndex:40},{value:"polygon",paraId:112,tocIndex:40},{value:"fill,line, extrude",paraId:112,tocIndex:40},{value:"shape(field, shapes)",paraId:113,tocIndex:40},{value:"shape specifies the row shape based on the field, such as specifying the icon type of PointLayer/imageLayer based on the field.",paraId:114,tocIndex:40},{value:"scene.addImage(\n  '00',\n  'https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg',\n);\nscene.addImage(\n  '01',\n  'https://gw.alipayobjects.com/zos/basement_prod/30580bc9-506f-4438-8c1a-744e082054ec.svg',\n);\nscene.addImage(\n  '02',\n  'https://gw.alipayobjects.com/zos/basement_prod/7aa1f460-9f9f-499f-afdf-13424aa26bbf.svg',\n);\nconst imageLayer = new PointLayer()\n  .source(data, {\n    parser: {\n      type: 'json',\n      x: 'longitude',\n      y: 'latitude',\n    },\n  })\n  .shape('name', ['00', '01', '02'])\n  .size(20);\nscene.addLayer(imageLayer);\n",paraId:115,tocIndex:40},{value:"Online case",paraId:116},{value:"shape(field, callback)",paraId:117},{value:"Shape also supports writing callback functions",paraId:118},{value:".shape('key', value => {\n  if(value > 10) {\n    return 'circle';\n  } else {\n    return 'triangle';\n  }\n}\n",paraId:119},{value:"The style method is usually used to describe the specific style of a layer. Most layers will support some more general properties, such as the opacity property. At the same time, each layer will also have properties that are only supported by this layer, such as only\nThe windowColor attribute supported by CityBuildingLayer. Please check the detailed documentation of each layer for how to configure the attribute for each layer.",paraId:120,tocIndex:41},{value:"opacity sets transparency, supported by most layers",paraId:121,tocIndex:41},{value:"stroke line fill color only supported by point layer",paraId:122,tocIndex:41},{value:"strokeWidth The width of the line. Only supported by point layers.",paraId:123,tocIndex:41},{value:"layer.style({\n  opacity: 0.8,\n  stroke: 'white',\n});\n",paraId:124,tocIndex:41},{value:"Style data mappingðŸŒŸ",paraId:125,tocIndex:41},{value:"\nUnder normal circumstances, the style parameters will apply to all graphics on a layer. For example, if there are ten points in a PointLayer, we set opacity = 0.5, so that the transparency of the ten points is 0.5.",paraId:125,tocIndex:41},{value:"\nIn special cases, we may need to set a transparency for each point. In this case, directly setting the opacity value of the style method in the original way cannot meet the needs. For this reason, we need to provide a special assignment method.",paraId:125,tocIndex:41},{value:'\nUsually we will set separate values â€‹â€‹for each graphic of the layer based on the data passed into the layer, so we call it "style data mapping".',paraId:125,tocIndex:41},{value:"\nWe support several ways of setting parameters in style to dynamically obtain values â€‹â€‹from source data.",paraId:125,tocIndex:41},{value:"//Set the transparency of each point of the point layer based on the value of the v field in the data\nconst data = [\n  {\n    lng: 120,\n    lat: 30,\n    v: 0.5\n  },\n  ...\n]\nconst layer = new PointLayer()\n  .source(data, {\n    parser: {\n      x: 'lng',\n      y: 'lat'\n    }\n  })\n  .shape('circle')\n  .color('#f00')\n  .size({\n    // The first way to write is to get the value directly from data based on the field.\n    opacity: 'v'// opacity = 0.5\n  });\nscene.addLayer(layer);\n",paraId:126,tocIndex:41},{value:"Online case",paraId:127},{value:"from",paraId:128},{value:"L7 2.5",paraId:128},{value:"Starting from the beginning, each layer style will gradually support style data mapping. Currently, all layer styles support style data mapping.",paraId:128},{value:"style",paraId:128},{value:"The parameters are as follows:",paraId:128},{value:"layer type/shape",paraId:129},{value:"Supported style fields",paraId:129},{value:"Remark",paraId:129},{value:"pointLayer/fill",paraId:129},{value:"opacityã€strokeOpacityã€strokeWidthã€strokeã€offsets",paraId:129},{value:"shape circleã€triangle...",paraId:129},{value:"pointLayer/image",paraId:129},{value:"opacityã€offsets",paraId:129},{value:"offsets latitude and longitude offsets",paraId:129},{value:"pointLayer/normal",paraId:129},{value:"opacityã€offsets",paraId:129},{value:"pointLayer/text",paraId:129},{value:"opacityã€strokeWidthã€strokeã€textOffset",paraId:129},{value:"textOffset offset relative to text canvas position",paraId:129},{value:"pointLayer/extrude",paraId:129},{value:"opacity",paraId:129},{value:"polygonLayer/fill",paraId:129},{value:"opacity",paraId:129},{value:"polygonLayer/extrude",paraId:129},{value:"opacity",paraId:129},{value:"lineLayer/line",paraId:129},{value:"opacity",paraId:129},{value:"lineLayer/arc",paraId:129},{value:"opacityã€thetaOffset",paraId:129},{value:"thetaOffset the curvature of the arc",paraId:129},{value:"lineLayer/arc3d",paraId:129},{value:"opacity",paraId:129},{value:"lineLayer/great_circle",paraId:129},{value:"opacity",paraId:129},{value:"Online case",paraId:130},{value:"Currently, texture methods are only supported on line layers.",paraId:131,tocIndex:42},{value:"The texture method supports passing in global icon texture resources added by the scene.addImage method.",paraId:132,tocIndex:42},{value:"// First load image resources globally\nscene.addImage(\n  'plane',\n  'https://gw.alipayobjects.com/zos/bmw-prod/0ca1668e-38c2-4010-8568-b57cb33839b9.svg',\n);\n\nconst layer = new LineLayer({\n  blend: 'normal',\n})\n  .source(data, {\n    parser: {\n      type: 'json',\n      x: 'lng1',\n      y: 'lat1',\n      x1: 'lng2',\n      y1: 'lat2',\n    },\n  })\n  .size(25)\n  .shape('arc')\n  .texture('plane') // Bind texture to layer\n  .color('#8C1EB2')\n  .style({\n    lineTexture: true, // Enable line mapping function\n    iconStep: 30, // Set the spacing of the texture\n    textureBlend: 'replace', //Set the texture blending method. The default value is normal. The optional values â€‹â€‹are normal/replace.\n  });\n",paraId:133,tocIndex:42},{value:"Online case",paraId:134},{value:"If a layer has been added and you need to modify the layer display style, you can call the graphics mapping method again, and then call",paraId:135,tocIndex:43},{value:"scene.render()",paraId:135,tocIndex:43},{value:"Just update the rendering",paraId:135,tocIndex:43},{value:"Recall the scale method",paraId:136,tocIndex:44},{value:"layer.scale('value', {\n  type: 'quantile',\n});\nscene.render();\n",paraId:137,tocIndex:44},{value:"Recall color/size/filter/shape and other methods",paraId:138,tocIndex:45},{value:"layer.color('blue');\nlayer.size(10);\n\nscene.render();\n",paraId:139,tocIndex:45},{value:"layer.style({\n  opacity: 1,\n});\n\nscene.render();\n",paraId:140,tocIndex:46},{value:"Update Source data",paraId:141,tocIndex:47},{value:"parameter:",paraId:142,tocIndex:47},{value:"data data",paraId:143,tocIndex:47},{value:"option defaults to the same as the initial configuration item. If the data format is the same, it does not need to be set.",paraId:143,tocIndex:47},{value:"Calling the setData method will automatically update the layer rendering",paraId:144,tocIndex:47},{value:"layer.setData(data);\n",paraId:145,tocIndex:47},{value:"Set layer overlay method\nparameter:",paraId:146,tocIndex:48},{value:"type blend ç±»åž‹ normal ï½œ additive ï½œ subtractive ï½œ max",paraId:147,tocIndex:48},{value:"Layer display",paraId:148,tocIndex:50},{value:"layer.show();\n",paraId:149,tocIndex:50},{value:"Layer hidden",paraId:150,tocIndex:51},{value:"layer.hide();\n",paraId:151,tocIndex:51},{value:"Is the layer visible?",paraId:152,tocIndex:52},{value:"layer.isVisible();\n",paraId:153,tocIndex:52},{value:"Set layer drawing order",paraId:154,tocIndex:53},{value:"layer.setIndex(1);\n",paraId:155,tocIndex:53},{value:"Zoom to layer extents",paraId:156,tocIndex:54},{value:"layer.fitBounds();\n",paraId:157,tocIndex:54},{value:"Set the minimum zoom level of the layer",paraId:158,tocIndex:55},{value:"layer.setMinZoom(zoom);\n",paraId:159,tocIndex:55},{value:"Set the maximum zoom level of the layer",paraId:160,tocIndex:56},{value:"layer.setMinZoom(zoom);\n",paraId:161,tocIndex:56},{value:"Set the maximum zoom level of the layer",paraId:162,tocIndex:56},{value:"parameter",paraId:163,tocIndex:56},{value:"zoom {number}",paraId:164,tocIndex:56},{value:"layer.setMinZoom(zoom);\n",paraId:165,tocIndex:56},{value:"Turn on or off mousehover element highlighting effect",paraId:166,tocIndex:58},{value:"activeOption",paraId:166,tocIndex:58},{value:"color",paraId:167,tocIndex:58},{value:": Highlight color",paraId:167,tocIndex:58},{value:"mix",paraId:167,tocIndex:58},{value:": Optional parameter, the default is 0, which means the highlight color is the specified solid color. The maximum valid value is 1, which means the highlight color is all the background color.",paraId:167,tocIndex:58},{value:"activeOption: {\n  color: '#f00';\n  mix: 0.6;\n}\n",paraId:168,tocIndex:58},{value:"// Turn on Active and use the default highlight color\nlayer.active(true);\n\n// Turn on Active custom highlight color\n\nlayer.active({\n  color: 'red',\n  mix: 0.6,\n});\n\n//Turn off the highlight effect\nlayer.active(false);\n",paraId:169,tocIndex:58},{value:"Set hover highlight of specified element based on element ID",paraId:170,tocIndex:59},{value:"ðŸŒŸ Specifying element highlighting is not equal to layer highlighting. A layer contains multiple elements. Generally, a layer has as many elements as there are single pieces of data in the data array passed to source.",paraId:171,tocIndex:59},{value:"layer.setActive(featureId);\n",paraId:172,tocIndex:59},{value:"Turn on or off mouseclick element selection highlighting effect",paraId:173,tocIndex:60},{value:"selectOption\n",paraId:173,tocIndex:60},{value:"color",paraId:174,tocIndex:60},{value:": Select highlight color",paraId:174,tocIndex:60},{value:"mix",paraId:174,tocIndex:60},{value:": Optional parameter, the default is 0, which means that the selected highlight color is the specified solid color. The maximum effective value is 1, which means that all the selected highlight colors are background colors.",paraId:174,tocIndex:60},{value:"selectOption: {\n  color: '#f00';\n  mix: 0.6;\n}\n",paraId:175,tocIndex:60},{value:"// Turn on Active and use the default highlight color\nlayer.select(true);\n\n// Turn on Active custom highlight color\n\nlayer.select({\n  color: 'red',\n  mix: 0.6,\n});\n\n//Turn off the highlight effect\nlayer.select(false);\n",paraId:176,tocIndex:60},{value:"Set the specified element according to the element ID click to select and highlight",paraId:177,tocIndex:61},{value:"ðŸŒŸ Specifying element highlighting is not equal to layer highlighting. A layer contains multiple elements. Generally, a layer has as many elements as there are single pieces of data in the data array passed to source.",paraId:178,tocIndex:61},{value:"layer.setSelect(featureId);\n",paraId:179,tocIndex:61},{value:"Allows users to actively set the autoFit parameters of layers",paraId:180,tocIndex:62},{value:"\nðŸŒŸ After setting this method, it will take effect when the layer is updated, such as triggered after setData",paraId:180,tocIndex:62},{value:"// Instructions\nlayer.setAutoFit(true);\n// Internal implementation\npublic setAutoFit(autoFit: boolean): ILayer {\n    this.updateLayerConfig({\n      autoFit,\n    });\n    return this;\n  }\n",paraId:181,tocIndex:62},{value:"Supports separately obtaining the value of a graphic after scale calculation to meet the user's need to obtain certain feature values â€‹â€‹of the layer.",paraId:182,tocIndex:63},{value:"attribute value of attr scale",paraId:183,tocIndex:63},{value:"const data = [\n  { lng: 120, lat: 30, name: 'n1' },\n  { lng: 120, lat: 30, name: 'n2' },\n];\nconst layer = new PointLayer()\n  .source(data, {\n    parser: {\n      x: 'lng',\n      y: 'lat',\n      type: 'json',\n    },\n  })\n  .shape('circle')\n  .color('name', ['#f00', '#ff0'])\n  .size('name', [20, 40]);\n\nscene.addLayer(layer);\n\n// Draw two points on the scene at this time\n// A point with a color of yellow and a size of 40, corresponding to name n1\n// A point with a color of red and a size of 20, corresponding to name n2\n\nconst colorScale = layer.getScale('color'); // Get the scale generated by the color method\nconst color1 = colorScale('n1'); // '#ff0'\nconst color1 = colorScale('n2'); // '#f00'\n\nconst sizeScale = layer.getScale('size'); // Get the scale generated by the size method\nconst size1 = sizeScale('n1'); // 40\nconst size2 = sizeScale('n2'); // 20\n",paraId:184,tocIndex:63},{value:"Get legend configuration",paraId:185,tocIndex:64},{value:"type legend type",paraId:186,tocIndex:64},{value:"index optional default",paraId:186,tocIndex:64},{value:"layer.getLegendItems('color');\n\nlayer.getLegendItems('size');\n",paraId:187,tocIndex:64},{value:"Get the legend getLegendItems enhanced version returns more information",paraId:188,tocIndex:65},{value:"return value",paraId:189,tocIndex:65},{value:"type legend type",paraId:190,tocIndex:65},{value:"field mapping field",paraId:190,tocIndex:65},{value:"items legend items",paraId:190,tocIndex:65},{value:"layer.getLegend('color');\n\nlayer.getLegend('size');\n",paraId:191,tocIndex:65},{value:"Add Mask layer\n",paraId:192,tocIndex:67},{value:"const polygonLayer = new Polygon();\nlayer.addMask(polygonLayer);\nscene.render();\n",paraId:193,tocIndex:67},{value:"const polygonLayer = new Polygon();\nlayer.removeMask(polygonLayer);\nscene.render();\n",paraId:194,tocIndex:68},{value:"layer.disableMask();\nscene.render();\n",paraId:195,tocIndex:69},{value:"layer.disableMask();\nscene.render();\n",paraId:196,tocIndex:70},{value:"Mouse event callback parameter target",paraId:197,tocIndex:71},{value:"layer.on(eventName, (target) => console.log(target));\n",paraId:198,tocIndex:71},{value:"x: number x coordinate of the mouse at the map location",paraId:199,tocIndex:71},{value:"y: number The y coordinate of the mouse's position on the map",paraId:199,tocIndex:71},{value:"type: string mouse event type",paraId:199,tocIndex:71},{value:"lngLat: longitude object {lng:number, lat: number}; the latitude and longitude of the mouse location",paraId:199,tocIndex:71},{value:"feature: any; geographical feature information selected by the data",paraId:199,tocIndex:71},{value:"featureId: number | null; ID of the geographical feature selected in the data",paraId:199,tocIndex:71},{value:"click event",paraId:200,tocIndex:72},{value:"layer.on('click', (e) => console.log(e));\n",paraId:201,tocIndex:72},{value:"double click",paraId:202,tocIndex:73},{value:"layer.on('dblclick', (e) => console.log(e));\n",paraId:203,tocIndex:73},{value:"mouse move event",paraId:204,tocIndex:74},{value:"layer.on('mousemove', (e) => console.log(e));\n",paraId:205,tocIndex:74},{value:"mouse removal",paraId:206,tocIndex:75},{value:"layer.on('mouseout', (e) => console.log(e));\n",paraId:207,tocIndex:75},{value:"mouse raised",paraId:208,tocIndex:76},{value:"layer.on('mouseup', (e) => console.log(e));\n",paraId:209,tocIndex:76},{value:"mouse pressed",paraId:210,tocIndex:77},{value:"layer.on('mousedown', (e) => console.log(e));\n",paraId:211,tocIndex:77},{value:"right click",paraId:212,tocIndex:78},{value:"layer.on('contextmenu', (e) => console.log(e));\n",paraId:213,tocIndex:78},{value:"Double click to pick element",paraId:214,tocIndex:79},{value:"layer.on('dblclick', (e) => console.log(e));\n",paraId:215,tocIndex:79},{value:"No element was picked up by clicking",paraId:216,tocIndex:80},{value:"layer.on('unclick', (e) => console.log(e));\n",paraId:217,tocIndex:80},{value:"Element not picked up by mouse movement",paraId:218,tocIndex:81},{value:"layer.on('unmousemove', (e) => console.log(e));\n",paraId:219,tocIndex:81},{value:"The element is not picked up when the mouse is raised",paraId:220,tocIndex:82},{value:"layer.on('unmouseup', (e) => console.log(e));\n",paraId:221,tocIndex:82},{value:"The element is not picked up when the mouse is pressed",paraId:222,tocIndex:83},{value:"layer.on('unmousedown', (e) => console.log(e));\n",paraId:223,tocIndex:83},{value:"Select the element with the right mouse button",paraId:224,tocIndex:84},{value:"layer.on('uncontextmenu', (e) => console.log(e));\n",paraId:225,tocIndex:84},{value:"All mouse events are not picked up",paraId:226,tocIndex:85},{value:"layer.on('unpick', (e) => console.log(e));\n",paraId:227,tocIndex:85},{value:"Usage example",paraId:228,tocIndex:85},{value:"layer.on('click', (ev) => {}); // Left mouse button click event on layer\nlayer.on('mouseenter', (ev) => {}); // The mouse enters the layer element\nlayer.on('mousemove', (ev) => {}); // Triggered when the mouse moves on the layer\nlayer.on('mouseout', (ev) => {}); // Triggered when the mouse moves out of the layer element\nlayer.on('mouseup', (ev) => {}); // Triggered when the mouse is clicked and raised on the layer\nlayer.on('mousedown', (ev) => {}); // Triggered when the mouse is clicked on the layer\nlayer.on('contextmenu', (ev) => {}); // Right-click menu of layer elements\n\n//Events when the mouse is outside the layer\nlayer.on('unclick', (ev) => {}); // Click outside the layer\nlayer.on('unmousemove', (ev) => {}); // Move outside the layer\nlayer.on('unmouseup', (ev) => {}); // Mouse up outside the layer\nlayer.on('unmousedown', (ev) => {}); // Triggered when clicked outside the layer\nlayer.on('uncontextmenu', (ev) => {}); // Right-click outside the layer\nlayer.on('unpick', (ev) => {}); // All events for operations outside the layer\n",paraId:229,tocIndex:85},{value:"Parameter option",paraId:230,tocIndex:87},{value:"target current layer",paraId:231,tocIndex:87},{value:"type event type",paraId:231,tocIndex:87},{value:"Triggered after layer initialization is completed",paraId:232,tocIndex:87},{value:"layer.on('inited', (option) => {});\n",paraId:233,tocIndex:87},{value:"Add layer to scene",paraId:234,tocIndex:88},{value:"Parameter option",paraId:235,tocIndex:88},{value:"target current layer",paraId:236,tocIndex:88},{value:"type event type",paraId:236,tocIndex:88},{value:"layer.on('add', (type) => console.log(type));\n",paraId:237,tocIndex:88},{value:"Fires when a layer is removed",paraId:238,tocIndex:89},{value:"Parameter option",paraId:239,tocIndex:89},{value:"target current layer",paraId:240,tocIndex:89},{value:"type event type",paraId:240,tocIndex:89},{value:"layer.on('remove', (type) => console.log(type));\n",paraId:241,tocIndex:89},{value:"Data mapping is updated, the legend changes, mainly color and size",paraId:242,tocIndex:90},{value:"The data mapping is updated, the legend changes, and the color changes\nParameter option",paraId:243,tocIndex:91},{value:"type legend type",paraId:244,tocIndex:91},{value:"field mapping field",paraId:244,tocIndex:91},{value:"items legend items",paraId:244,tocIndex:91},{value:"layer.on('legend:color', (ev) => console.log(ev));\n",paraId:245,tocIndex:91},{value:"The data mapping is updated, the legend changes, and the size changes\nParameter option",paraId:246,tocIndex:92},{value:"type legend type",paraId:247,tocIndex:92},{value:"field mapping field",paraId:247,tocIndex:92},{value:"items legend items",paraId:247,tocIndex:92},{value:"layer.on('legend:size', (ev) => console.log(ev));\n",paraId:248,tocIndex:92},{value:"Parameter option",paraId:249,tocIndex:94},{value:"box [x1: number, y1: number, x2: number, y2: number] compared to",paraId:250,tocIndex:94},{value:"cb (...args: any[]) => void callback method passed in, returns the feature inside the box selection",paraId:250,tocIndex:94},{value:"layer.boxSelect(box, cb);\n// (x1, y1), (x2, y2) The pixel coordinates of the upper left corner and lower right corner of the selected box relative to the upper left corner of the map\n//cb is the callback function passed in. The parameter returned by the callback function is the selected feature object array. The fields of the object are related to the data passed in by the user.\n",paraId:251,tocIndex:94}]}}]);