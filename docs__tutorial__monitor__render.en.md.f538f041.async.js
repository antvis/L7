"use strict";(self.webpackChunk_antv_l7_site=self.webpackChunk_antv_l7_site||[]).push([[875],{48238:function(e,n,r){r.r(n);r(92326),r(1364),r(43033),r(2043),r(10474);var i=r(27498),t=(r(52972),r(32149),r(13437),r(75910)),a=r(10465),o=r(92379),c=r(49510),d=r(651);n.default=function(){return(0,d.jsx)(t.dY,{children:(0,d.jsx)(o.Suspense,{fallback:(0,d.jsx)(a.Z,{}),children:(0,d.jsx)(d.Fragment,{children:(0,d.jsxs)("div",{className:"markdown",children:[(0,d.jsx)("style",{dangerouslySetInnerHTML:{__html:"\n h3 { color: #873bf4; border-bottom: 1px solid #f0f0f0; margin: 1.2em 0 0.4em; } p { margin: 0.6em 0; } h4 { border-bottom: 1px solid #f0f0f0; }h4::before { content: '> '; opacity: 0.5; } "}}),(0,d.jsx)("p",{children:c.texts[0].value}),(0,d.jsxs)("h3",{id:"accomplish",children:[(0,d.jsx)("a",{"aria-hidden":"true",tabIndex:"-1",href:"#accomplish",children:(0,d.jsx)("span",{className:"icon icon-link"})}),"accomplish"]}),(0,d.jsx)("p",{children:c.texts[1].value}),(0,d.jsx)(i.Z,{lang:"javascript",children:c.texts[2].value})]})})})})}},9730:function(e,n,r){r.d(n,{T:function(){return i.T}});var i=r(80427)},71297:function(e,n,r){r.d(n,{Z:function(){return i.Z}});var i=r(87785)},49510:function(e,n,r){r.r(n),r.d(n,{texts:function(){return i}});const i=[{value:"In map applications, rendering big data geographical data is a very common requirement. In order to ensure the smoothness of the application, it is necessary to pursue the ultimate rendering performance. For this reason, monitoring engine rendering content is of practical significance for optimizing performance and building map visualization application performance indicators. significance.",paraId:0},{value:"The following describes how to use the capabilities provided by L7 to simply obtain the rendering performance information of the application.",paraId:1,tocIndex:0},{value:"import { Scene } from '@antv/l7';\nimport { GaodeMap } from '@antv/l7-maps';\n\nconst scene = new Scene({\n  id: 'map',\n  map: new GaodeMap({\n    center: [ 60, 40.7128 ],\n    zoom: 2\n  }),\n  debug: true\n});\nscene.on('loaded', () => {\n  const debugService = scene.getDebugService();\n  // Enable monitoring of each frame rendering\n  debugService.renderDebug(true)\n  debugService.on('renderEnd', renderInfo => {\n    const {\n      renderUid, // The unique number of the current frame rendering\n      renderStart, // current frame rendering start time\n      renderEnd, // current frame rendering end time\n      renderDuration // current frame rendering time\n    } = renderInfo;\n    ...\n  }\n\n  setTimeout(() => {\n    debugService.renderDebug(false);\n    debugService.off('renderEnd');\n  }, 1000); // Monitor the rendering within 1s\n});\n",paraId:2,tocIndex:0}]}}]);