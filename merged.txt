---
title: 本地运行
order: 1
---
<embed src="@/docs/common/style.md"></embed>

### 一、打开L7demo页面


选择一个任意一个你想看的 `demo`。

<img src="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*bKT5TrlYlGEAAAAAAAAAAABkARQnAQ" alt="L7 地理可视化" width = "50%" height = "100%">

你可能没有注意到，代码区的上方有一排工具按钮。


### 二、打开 codesandbox。

点击左侧第三个按钮，你就进入了 `codesandbox`。

![L7 地理可视化](https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*TrpMSJrrSDMAAAAAAAAAAABkARQnAQ)

<img src="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*coZsTLbX2FQAAAAAAAAAAABkARQnAQ" alt="L7 地理可视化" width = "50%" height = "100%">

你发现你进入了一个在线的代码编辑器，在这里面你可以修改代码，并且能够随时看到效果。        

你可能想说我就想本地跑起来，不想在线修改。      

当然是是可以的。        

### 三、下载demo源码

1. 在 `codesandbox` 的文件目录工具有下载按钮，参照图中红色部分。

2. 点击下载你可以把这个 `demo` 的源码下载到本地。

### 四、启动项目

解压项目，进入项目目录。

1. 安装环境依赖

如果不知道  `yarn` 可能需要补充一下前端知识了，如果没有 `yarn` 环境你需要安装一下。

```bash
yarn install 
```

2. 启动项目

```bash
yarn start
```
浏览器会自动打开 [http://localhost:3000/](http://localhost:3000/)，这样 `demo` 就跑起来了。

<img src="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*oQQ2RbOzx0oAAAAAAAAAAABkARQnAQ" alt="L7 地理可视化" width = "50%" height = "100%">

现在你可以尽情的本地修改代码，添加自己的图层了。    
`L7` 所有 `demo` 都可以在 `codesandbox` 打开，你可以下载代码。


---
title: local run
order: 1
---

<embed src="@/docs/common/style.md"></embed>

### 1. Open the L7demo page

Choose any one you want to see`demo`。

<img src="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*bKT5TrlYlGEAAAAAAAAAAABkARQnAQ" alt="L7 地理可视化" width = "50%" height = "100%">

You may not have noticed that there is a row of tool buttons above the code area.

### 2. Open codesandbox.

Click the third button on the left and you will enter`codesandbox`。

![L7 地理可视化](https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*TrpMSJrrSDMAAAAAAAAAAABkARQnAQ)

<img src="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*coZsTLbX2FQAAAAAAAAAAABkARQnAQ" alt="L7 地理可视化" width = "50%" height = "100%">

You find that you have entered an online code editor, where you can modify the code and see the effect at any time.

You may want to say that I just want to run it locally and don't want to modify it online.

Of course it is possible.

### 3. Download demo source code

1. exist`codesandbox`The file directory tool has a download button, refer to the red part in the picture.

2. Click to download and you can put this`demo`Download the source code locally.

### 4. Start the project

Unzip the project and enter the project directory.

1. Install environment dependencies

If you don't know`yarn`You may need to add some front-end knowledge, if not`yarn`You need to install the environment.

```bash
yarn install 
```

2. Startup project

```bash
yarn start
```

The browser will automatically open<http://localhost:3000/>,so`demo`Just started running.

<img src="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*oQQ2RbOzx0oAAAAAAAAAAABkARQnAQ" alt="L7 地理可视化" width = "50%" height = "100%">

Now you can freely modify the code locally and add your own layers.\
`L7`all`demo`All can be found in`codesandbox`Open and you can download the code.
---
title: 图层初始化
order: 1
---
<embed src="@/docs/common/style.md"></embed>

在地图应用中，渲染大数据的地理数据是十分常见的需求，为了保证应用的流畅性，需要追求极致的渲染性能，为此监控引擎渲染内容对于优化性能，建设地图可视化应用性能指标有切实的意义。

### 实现

下面介绍如何使用 L7 提供的能力简单获取图层的初始化的信息。

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 60, 40.7128 ],
    zoom: 2
  }),
  debug: true
});
scene.on('loaded', () => {
  const debugService = scene.getDebugService();
  const layer = new PointLayer()
  .source([{lng: 120, lat: 30}], {
    parser: {
      type: 'json',
      x: 'lng',
      y: 'lat',
    }
  })
  .shape('circle')
  .size(10)
  .color('#f00');
  layer.on('inited', () => {
    console.log(debugService.getLog(layer.id));
  })
  scene.addLayer(layer);
});
```

---
title: 渲染监控
order: 3
---
<embed src="@/docs/common/style.md"></embed>

在地图应用中，渲染大数据的地理数据是十分常见的需求，为了保证应用的流畅性，需要追求极致的渲染性能，为此监控引擎渲染内容对于优化性能，建设地图可视化应用性能指标有切实的意义。

### 实现

下面介绍如何使用 L7 提供的能力简单获取应用的渲染性能信息。

```javascript
import { Scene } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 60, 40.7128 ],
    zoom: 2
  }),
  debug: true
});
scene.on('loaded', () => {
  const debugService = scene.getDebugService();
  // 开启每帧渲染的监控
  debugService.renderDebug(true)
  debugService.on('renderEnd', renderInfo => {
    const {
      renderUid,			// 当前帧渲染唯一编号
      renderStart,		// 当前帧渲染开始时间
      renderEnd,			// 当前帧渲染结束时间
      renderDuration	// 当前帧渲染时间
    } = renderInfo;
    ...
  }
                  
  setTimeout(() => {
    debugService.renderDebug(false);
    debugService.off('renderEnd');
  }, 1000); // 监听 1s 内的渲染情况
});
```

---
title: Layer init
order: 1
---

<embed src="@/docs/common/style.md"></embed>

In map applications, rendering big data geographical data is a very common requirement. In order to ensure the smoothness of the application, it is necessary to pursue the ultimate rendering performance. For this reason, monitoring engine rendering content is of practical significance for optimizing performance and building map visualization application performance indicators. significance.

### accomplish

The following describes how to use the capabilities provided by L7 to simply obtain the initialization information of the layer.

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 60, 40.7128 ],
    zoom: 2
  }),
  debug: true
});
scene.on('loaded', () => {
  const debugService = scene.getDebugService();
  const layer = new PointLayer()
  .source([{lng: 120, lat: 30}], {
    parser: {
      type: 'json',
      x: 'lng',
      y: 'lat',
    }
  })
  .shape('circle')
  .size(10)
  .color('#f00');
  layer.on('inited', () => {
    console.log(debugService.getLog(layer.id));
  })
  scene.addLayer(layer);
});
```
---
title: Render 
order: 3
---

<embed src="@/docs/common/style.md"></embed>

In map applications, rendering big data geographical data is a very common requirement. In order to ensure the smoothness of the application, it is necessary to pursue the ultimate rendering performance. For this reason, monitoring engine rendering content is of practical significance for optimizing performance and building map visualization application performance indicators. significance.

### accomplish

The following describes how to use the capabilities provided by L7 to simply obtain the rendering performance information of the application.

```javascript
import { Scene } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 60, 40.7128 ],
    zoom: 2
  }),
  debug: true
});
scene.on('loaded', () => {
  const debugService = scene.getDebugService();
  // Enable monitoring of each frame rendering
  debugService.renderDebug(true)
  debugService.on('renderEnd', renderInfo => {
    const {
      renderUid, // The unique number of the current frame rendering
      renderStart, // current frame rendering start time
      renderEnd, // current frame rendering end time
      renderDuration // current frame rendering time
    } = renderInfo;
    ...
  }
                  
  setTimeout(() => {
    debugService.renderDebug(false);
    debugService.off('renderEnd');
  }, 1000); // Monitor the rendering within 1s
});
```
---
title: Map init
order: 1
---

<embed src="@/docs/common/style.md"></embed>

In map applications, rendering big data geographical data is a very common requirement. In order to ensure the smoothness of the application, it is necessary to pursue the ultimate rendering performance. For this reason, monitoring engine rendering content is of practical significance for optimizing performance and building map visualization application performance indicators. significance.

### accomplish

The following describes how to use the capabilities provided by L7 to simply obtain map initialization information.

```javascript
import { Scene } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 60, 40.7128 ],
    zoom: 2
  }),
  debug: true
});
scene.on('loaded', () => {
  const debugService = scene.getDebugService();
  console.log(debugService.getLog('map');)
});
```
---
title: 地图初始化
order: 1
---
<embed src="@/docs/common/style.md"></embed>

在地图应用中，渲染大数据的地理数据是十分常见的需求，为了保证应用的流畅性，需要追求极致的渲染性能，为此监控引擎渲染内容对于优化性能，建设地图可视化应用性能指标有切实的意义。

### 实现

下面介绍如何使用 L7 提供的能力简单获取地图的初始化的信息。

```javascript
import { Scene } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 60, 40.7128 ],
    zoom: 2
  }),
  debug: true
});
scene.on('loaded', () => {
  const debugService = scene.getDebugService();
  console.log(debugService.getLog('map');)
});
```

---
title: Radar
order: 4
---

<embed src="@/docs/common/style.md"></embed>

Point layers also support a special layer type: radar charts.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*YJmVRpmW7FEAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

Let’s introduce how to draw a common radar chart.

* you can`L7`Found on the official website[Online case](/examples/point/scatter#radarpoint)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 120, 30 ],
    zoom: 13
  })
});

const layer = new PointLayer()
  .source([{ lng: 120, lat: 30 } ],
    {
      parser: {
        type: 'json',
        x: 'lng',
        y: 'lat'
      }
    }
  )
  .shape('radar')
  .size(100)
  .color('#d00')
  .style({
    speed: 5
  })
  .animate(true);
```

### source

Radar charts accept plain point data.

### shape

Radar chart`shape`is a fixed value`radar`。

### animate

The radar chart needs to be`animate`Set as`true`will take effect

```javascript
.animate(true)

.animate({
  enable: true
})
```

### style

pass`speed`Set rotation speed, default is`1`, the larger the value, the faster the speed.
---
title: 雷达图
order: 4
---
<embed src="@/docs/common/style.md"></embed>

点图层还支持一种特殊的图层类型：雷达图。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*YJmVRpmW7FEAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个常见的雷达图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/scatter#radarpoint)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 120, 30 ],
    zoom: 13
  })
});

const layer = new PointLayer()
  .source([{ lng: 120, lat: 30 } ],
    {
      parser: {
        type: 'json',
        x: 'lng',
        y: 'lat'
      }
    }
  )
  .shape('radar')
  .size(100)
  .color('#d00')
  .style({
    speed: 5
  })
  .animate(true);
```

### source

雷达图接受普通的点数据。
### shape

雷达图的 `shape` 为固定值 `radar`。

### animate

雷达图需要将 `animate` 设置为 `true` 才会生效

```javascript
.animate(true)

.animate({
  enable: true
})
```
### style

通过 `speed` 设置旋转速度，默认为 `1`，值越大转速越快。---
title: 复合图表地图
order: 8
---
<embed src="@/docs/common/style.md"></embed>

我们在通过自定义 `Marker` 代替点图层节点的时候剋插入实现自定义图表，如使用二维统计图表代替点状符号。复合图表地图中常用扩展图形有柱状图、曲线图、玫瑰图等

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*6AR6Qq0Bq-MAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单的地图复合图表。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/chart#bar)


```javascript
import { Scene, Marker } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';
import * as G2 from '@antv/g2';
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 2.6125016864608597, 49.359131 ],
    zoom: 4.19
  })
});
scene.on('loaded', () => {
  addChart();
  scene.render();
});
function addChart() {
  fetch('https://gw.alipayobjects.com/os/basement_prod/0b96cca4-7e83-449a-93d0-2a77053e74ab.json')
    .then(res => res.json())
    .then(data => {
      data.nodes.forEach(function(item) {
        const el = document.createElement('div');
        const total = item.gdp.Agriculture + item.gdp.Industry + item.gdp.Service;
        const size = Math.min(parseInt(total / 30000, 10), 70);
        if (size < 30) { return; }
        const itemData = [ {
            item: 'Agriculture',
            count: item.gdp.Agriculture,
            percent: item.gdp.Agriculture / total
          },
          {
            item: 'Industry',
            count: item.gdp.Industry,
            percent: item.gdp.Industry / total
          },
          {
            item: 'Service',
            count: item.gdp.Service,
            percent: item.gdp.Service / total
          }
        ];
        const chart = new G2.Chart({
          container: el,
          width: size,
          height: size,
          render: 'svg',
          padding: 0
        });
        chart.legend(false);
        chart.source(itemData);
        chart.tooltip(false);
        chart.axis('count', { grid: false });
        chart.interval()
          .position('item*count')
          .color('item', [ '#5CCEA1', '#5D7092', '#5B8FF9' ])
          .opacity(1);
        chart.render();
        const marker = new Marker({ element: el })
        .setLnglat({
          lng: item.coordinates[0],
          lat: item.coordinates[1]
        });
        scene.addMarker(marker);
      });
    });
}
```---
title: 3D Column
order: 1
---

<embed src="@/docs/common/style.md"></embed>

`3D`Column charts are columns of varying heights displayed over a geographic area, with the height of the column proportional to its value in the data set.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*RVw4QKTJe7kAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Below we will introduce how to draw a common`3D`Column chart.

* you can`L7`Found on the official website[Online case](/examples/point/column/#clumn_shape)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    pitch: 66.02383,
    center: [ 121.400257, 31.25287 ],
    zoom: 14.55,
    rotation: 134.95
  })
});
fetch('https://gw.alipayobjects.com/os/basement_prod/893d1d5f-11d9-45f3-8322-ee9140d288ae.json')
  .then(res => res.json())
  .then(data => {
    const pointLayer = new PointLayer({})
    .source(data, {
      parser: {
        type: 'json',
        x: 'longitude',
        y: 'latitude'
      }
    })
    .shape('name', [ 'cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn' ])
    .color('name', [ '#739DFF', '#61FCBF', '#FFDE74', '#FF896F' ]);
    .size('unit_price', h => [ 6, 6, h / 500 ] 
    scene.addLayer(pointLayer);
  })
```

### shape

`3D`Column chart`shape`The method supports the following parameters:

* `cylinder`cylinder
* `triangleColumn`triangular prism
* `hexagonColumn`hexagonal column
* `squareColumn`four corner pillars

### size

`3D`column chart`size`Support setting three dimensions`[w, l, z]`：

* `w`Width
* `l`long
* `z`high

1. `size`Set constant

```js
layer.size([2,2,3])
```

2. `size`Set callback function

```js
layer.size('unit_price', h => {
  return [ 6, 6, h / 500 ];
})
```

### animate

`3D`Column chart supports growth animation, through`animate`Method to set, specific usage can be viewed[Detailed documentation](</api/point_layer/animate#Growth animation>)

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*l-SUQ5nU6n8AAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### style

`3D`Column charts have special`style`Attributes, specific usage can be found[Detailed documentation](/api/point_layer/style#3d-column)
---
title: Chart
order: 8
---

<embed src="@/docs/common/style.md"></embed>

We are customizing`Marker`When replacing point layer nodes, you can insert a custom chart, such as using a two-dimensional statistical chart instead of point symbols. Commonly used extended graphics in composite chart maps include bar charts, curve charts, rose charts, etc.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*6AR6Qq0Bq-MAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a simple map composite chart.

* you can`L7`Found on the official website[Online case](/examples/point/chart#bar)

```javascript
import { Scene, Marker } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';
import * as G2 from '@antv/g2';
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 2.6125016864608597, 49.359131 ],
    zoom: 4.19
  })
});
scene.on('loaded', () => {
  addChart();
  scene.render();
});
function addChart() {
  fetch('https://gw.alipayobjects.com/os/basement_prod/0b96cca4-7e83-449a-93d0-2a77053e74ab.json')
    .then(res => res.json())
    .then(data => {
      data.nodes.forEach(function(item) {
        const el = document.createElement('div');
        const total = item.gdp.Agriculture + item.gdp.Industry + item.gdp.Service;
        const size = Math.min(parseInt(total / 30000, 10), 70);
        if (size < 30) { return; }
        const itemData = [ {
            item: 'Agriculture',
            count: item.gdp.Agriculture,
            percent: item.gdp.Agriculture / total
          },
          {
            item: 'Industry',
            count: item.gdp.Industry,
            percent: item.gdp.Industry / total
          },
          {
            item: 'Service',
            count: item.gdp.Service,
            percent: item.gdp.Service / total
          }
        ];
        const chart = new G2.Chart({
          container: el,
          width: size,
          height: size,
          render: 'svg',
          padding: 0
        });
        chart.legend(false);
        chart.source(itemData);
        chart.tooltip(false);
        chart.axis('count', { grid: false });
        chart.interval()
          .position('item*count')
          .color('item', [ '#5CCEA1', '#5D7092', '#5B8FF9' ])
          .opacity(1);
        chart.render();
        const marker = new Marker({ element: el })
        .setLnglat({
          lng: item.coordinates[0],
          lat: item.coordinates[1]
        });
        scene.addMarker(marker);
      });
    });
}
```
---
title: 3D 柱图
order: 1
---
<embed src="@/docs/common/style.md"></embed>

`3D` 柱图是在地理区域上方显示的不同高度的柱体，柱子的高度与其在数据集中的数值会成正比。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*RVw4QKTJe7kAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个常见的 `3D` 柱图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/column/#clumn_shape)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    pitch: 66.02383,
    center: [ 121.400257, 31.25287 ],
    zoom: 14.55,
    rotation: 134.95
  })
});
fetch('https://gw.alipayobjects.com/os/basement_prod/893d1d5f-11d9-45f3-8322-ee9140d288ae.json')
  .then(res => res.json())
  .then(data => {
    const pointLayer = new PointLayer({})
    .source(data, {
      parser: {
        type: 'json',
        x: 'longitude',
        y: 'latitude'
      }
    })
    .shape('name', [ 'cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn' ])
    .color('name', [ '#739DFF', '#61FCBF', '#FFDE74', '#FF896F' ]);
    .size('unit_price', h => [ 6, 6, h / 500 ] 
    scene.addLayer(pointLayer);
  })
```

### shape

`3D` 柱图 `shape` 方法支持以下参数：

- `cylinder` 圆柱体
- `triangleColumn` 三角柱
- `hexagonColumn` 六角柱
- `squareColumn` 四角柱

### size

`3D` 柱图的 `size` 支持设置三个维度 `[w, l, z]`：

- `w` 宽
- `l` 长
- `z` 高度

1. `size` 设置常量

```js
 layer.size([2,2,3])
```

2. `size` 设置回调函数

```js
layer.size('unit_price', h => {
  return [ 6, 6, h / 500 ];
})
```

### animate

`3D` 柱图支持生长动画，通过 `animate` 方法进行设置，具体使用可以查看[详细文档](/api/point_layer/animate#生长动画)

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*l-SUQ5nU6n8AAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### style

`3D` 柱图有特殊的 `style` 属性，具体使用可以查找[详细文档](/api/point_layer/style#3d-column)---
title: Simple
order: 9
---

<embed src="@/docs/common/style.md"></embed>

Point layers support the simple points of sprite mode. Point layers in sprite mode are more efficient and the points always face the camera.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*dVFmQIKh5TUAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a simple point layer.

* you can`L7`Found on the official website[Online case](/examples/point/simple#simple)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    pitch: 20,
    center: [ 120, 20 ],
    zoom: 3
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/d3564b06-670f-46ea-8edb-842f7010a7c6.json')
    .then(res => res.json())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data)
        .shape('simple')
        .size(15)
        .color('mag', mag =>  mag > 4.5 ? '#5B8FF9' : '#5CCEA1';)
        .style({
          opacity: 0.6,
          strokeWidth: 3
        });
      scene.addLayer(pointLayer);
    });
});
```

### shape

Simple point layer use`shape`The parameters are fixed to`simple`。

### use

* The use of simple point layers behaves the same as general point layers.

* A simple point layer is essentially a sprite map, so a simple point layer always faces the camera (a normal 2D point layer stays facing up)

* 🌟 When the user has no requirements for the orientation of the point layer or the visual effect of the point layer is relatively simple, it is recommended to use a simple point layer as much as possible, which can save a lot of performance

* 🌟 Since the simple point layer is essentially a sprite map, there is a size limit: generally \[1, 64], which varies between different devices.

```javascript
// L7 provides query methods for quick viewing

scene.getPointSizeRange(); // Float32Array - [min, max]
```
---
title: 简单点
order: 9
---
<embed src="@/docs/common/style.md"></embed>

点图层支持精灵模式的简单点，精灵模式的点图层效率更高，点始终面向相机。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*dVFmQIKh5TUAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单点图层。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/simple#simple)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    pitch: 20,
    center: [ 120, 20 ],
    zoom: 3
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/d3564b06-670f-46ea-8edb-842f7010a7c6.json')
    .then(res => res.json())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data)
        .shape('simple')
        .size(15)
        .color('mag', mag =>  mag > 4.5 ? '#5B8FF9' : '#5CCEA1';)
        .style({
          opacity: 0.6,
          strokeWidth: 3
        });
      scene.addLayer(pointLayer);
    });
});
```

### shape

简单点图层使用的 `shape` 参数固定为 `simple`。

### use

- 简单点图层的使用和一般的点图层表现一致

- 简单点图层的实质是精灵贴图，因此简单点图层始终面向相机（普通的 2D 点图层保持面向上）

- 🌟 当用户对点图层的朝向没有要求或是对点图层的可视化效果要求比较简单，那么推荐尽量使用简单点图层，可以节省大量性能

- 🌟 简单点图层由于实质是精灵贴图，因此有大小限制：一般是 [1, 64]，不同设备之间存在差异

```javascript
// L7 提供了查询方法快速查看

scene.getPointSizeRange(); // Float32Array - [min, max]
```
---
title: 聚合图
order: 2
---
<embed src="@/docs/common/style.md"></embed>

聚合图通常用来描述数据在地理上表现的聚合情况，类似热力图，可以用来表示数据点位的集中。    

🌟 目前 `L7` 只有点数据支持聚合图，聚类方法主要从数据层聚合数据，在 `Source` 方法配置 `cluster` 参数。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*paQsRKykjL4AAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个常见的聚合图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/cluster/#cluster)

```js
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 120.19382669582967, 30.258134 ],
    style: 'dark',
    zoom: 3
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/d3564b06-670f-46ea-8edb-842f7010a7c6.json')
    .then(res => res.json())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data, { cluster: true })
        .shape('circle')
        .scale('point_count', {
          type: 'quantile'
        })
        .size('point_count', [ 5, 10, 15, 20, 25 ])
        .active(true)
        .color('yellow')
        .style({
          opacity: 0.5,
          strokeWidth: 1
        });
      scene.addLayer(pointLayer);
    });
});
```

### source

聚合图在接受普通的点数据之后还需要配置聚合参数。

```js
const source = new Source(data, {
  cluster: true,
  clusterOption: {
    radius: 40,
    minZoom: 0,
    maxZoom: 16,
  }
})
```

- `cluster: boolean` 表示是否对数据进行聚合操作，目前只有点图层支持，默认值为 `false`。
- `clusterOption: IClusterOption` 具体的聚合参数
  - `radius: number` 聚合半径，默认值为 `40`。
  - `minZoom: number` 最小聚合缩放等级，默认值为 `0`。
  - `maxZoom: number` 最大聚合缩放等级，默认值为 `16`。

```js
interface IClusterOption {
  radius,
  minZoom
  maxZoom
}
```

[在线案例](/examples/point/cluster#cluster)

### shape

聚合图使用通用的聚合样式，`shape` 只要使用点图层类型的 `shape` 即可。

### FAQ

`PointLayer` 的聚合图采用 `WebGL` 绘制，不支持自定义具体聚合样式，如果有自定义的需求可以使用 `MarkerLayer` 的聚合功能，你可以通过 `Dom` 完全自定义样式。

[MarkerLayer 聚合](/api/component/markerlayer)
---
title: Dot
order: 4
---

<embed src="@/docs/common/style.md"></embed>

The brightness map is also called the point density map. The more the number of internal points per unit area, the brighter the brightness will be. The brightness map is generally used to express the distribution of massive point data.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*xr8BQouXGvoAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a simple brightness map.

* you can`L7`Found on the official website[Online case](/examples/gallery/basic#normal)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 121.417463, 31.215175 ],
    style: 'dark',
    zoom: 11
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/rmsportal/BElVQFEFvpAKzddxFZxJ.txt')
    .then(res => res.text())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data, {
          parser: {
            type: 'csv',
            y: 'lat',
            x: 'lng'
          }
        })
        .size(0.5)
        .color('#080298');
      scene.addLayer(pointLayer);
    });
});
```

### shape

Using the brightness map requires converting`shape`The parameters are set to`dot`, or not set`shape`function.
---
title: 亮度图
order: 4
---
<embed src="@/docs/common/style.md"></embed>

亮度图又称点密度图，单位面积的内点的个数越多，亮度会越亮，亮度图一般用来表达海量点数据分布情况

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*xr8BQouXGvoAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单的亮度图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/gallery/basic#normal)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 121.417463, 31.215175 ],
    style: 'dark',
    zoom: 11
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/rmsportal/BElVQFEFvpAKzddxFZxJ.txt')
    .then(res => res.text())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data, {
          parser: {
            type: 'csv',
            y: 'lat',
            x: 'lng'
          }
        })
        .size(0.5)
        .color('#080298');
      scene.addLayer(pointLayer);
    });
});
```

### shape

使用亮度图需要将 `shape` 的参数设置为 `dot`，或者不设置 `shape` 函数。
---
title: cluster
order: 2
---

<embed src="@/docs/common/style.md"></embed>

Aggregation graphs are usually used to describe the aggregation of data geographically. Similar to heat maps, they can be used to represent the concentration of data points.

🌟 Currently`L7`Only point data supports aggregated graphs. The clustering method mainly aggregates data from the data layer. In`Source`Method configuration`cluster`parameter.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*paQsRKykjL4AAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a common aggregation chart.

* you can`L7`Found on the official website[Online case](/examples/point/cluster/#cluster)

```js
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 120.19382669582967, 30.258134 ],
    style: 'dark',
    zoom: 3
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/d3564b06-670f-46ea-8edb-842f7010a7c6.json')
    .then(res => res.json())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data, { cluster: true })
        .shape('circle')
        .scale('point_count', {
          type: 'quantile'
        })
        .size('point_count', [ 5, 10, 15, 20, 25 ])
        .active(true)
        .color('yellow')
        .style({
          opacity: 0.5,
          strokeWidth: 1
        });
      scene.addLayer(pointLayer);
    });
});
```

### source

After accepting ordinary point data, the aggregation chart also needs to configure aggregation parameters.

```js
const source = new Source(data, {
  cluster: true,
  clusterOption: {
    radius: 40,
    minZoom: 0,
    maxZoom: 16,
  }
})
```

* `cluster: boolean`Indicates whether to perform aggregation operations on data. Currently only point layers support it. The default value is`false`。
* `clusterOption: IClusterOption`Specific aggregation parameters
  * `radius: number`Aggregation radius, default value is`40`。
  * `minZoom: number`Minimum aggregate zoom level, default value is`0`。
  * `maxZoom: number`Maximum aggregate zoom level, default value is`16`。

```js
interface IClusterOption {
  radius,
  minZoom
  maxZoom
}
```

[Online case](/examples/point/cluster#cluster)

### shape

Aggregation graphs use common aggregation styles,`shape`Just use the point layer type`shape`That’s it.

### FAQ

`PointLayer`The aggregation graph uses`WebGL`Drawing does not support customizing specific aggregation styles. You can use it if you have customized requirements.`MarkerLayer`The aggregation function, you can pass`Dom`Fully customizable styling.

[MarkerLayer Aggregation](/api/component/markerlayer)
---
title: iconfont
order: 7
---

<embed src="@/docs/common/style.md"></embed>

In addition to supporting drawing text annotations, the point layer also supports drawing and building simple icons by drawing text, that is, drawing`iconfont`. Through simple icons drawn with text, we can`color`Method to directly modify the color.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*WdOfSI_uyxIAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

Below we will introduce how to draw a simple`iconfont`Icon point layer.

* you can`L7`Found on the official website[Online case](/examples/point/text#iconfont)

```javascript
// Specify iconfont to be mapped to the name of the font style
const fontFamily = 'iconfont';
//Specify iconfont font file
const fontPath ='//at.alicdn.com/t/font_2534097_fcae9o2mxbv.woff2?t=1622200439140';
//Add resources globally
scene.addFontFace(fontFamily, fontPath);
// Add the mapping of the iconfont field globally
scene.addIconFont('icon1', '');
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/bmw-prod/70408903-80db-4278-a318-461604acb2df.json')
    .then((res) => res.json())
    .then((data) => {
      const pointLayer = new PointLayer({})
        .source(data.list, {
          parser: {
            type: 'json',
            x: 'j',
            y: 'w',
          },
        })
        .shape('icon', 'text') //Specify that the field to be mapped is icon, and the shape type is the same as ordinary text annotation, which is text.
        .size(20)
        .color('w', ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99'])
        .style({
          textAnchor: 'center', // The position of the text relative to the anchor point center|left|right|top|bottom|top-left
          textOffset: [40, 0], // Offset of text relative to anchor point [horizontal, vertical]
          padding: [0, 0], // Text bounding box padding [horizontal, vertical], affects the collision detection results and prevents adjacent texts from being too close
          stroke: '#ffffff', // stroke color
          fontFamily,
          iconfont: true, // Enable iconfont mapping
        });
      scene.addLayer(pointLayer);
    });
});
```

1. `iconfont`Drawn is`unicode`Icon, you need to specify the corresponding icon in advance when using it`unicode`mapping file.
2. about`iconfont`Resource usage can go to`iconfont`Official website[Official website portal](https://iconfont.cn/)。

### shape(field: string, shapeType: 'text'): ILayer

`iconfont`In fact, it is a special text annotation, so`shape`The usage is consistent with the usage of ordinary text annotation.

* `field`Labeled field name.
* `shapeType`The default is`text`。

```javascript
layer.shape('iconfontField', 'text');
```

### style

we are using`iconfont`When drawing simple icons, you need to`style`method lieutenant general`iconfont`The parameters are set to`true`。

✨ iconfont The use of other style parameters is consistent with the parameters of ordinary text annotations.
---
title: iconfont 标注
order: 7
---
<embed src="@/docs/common/style.md"></embed>

点图层除了支持绘制文字标注之外还支持通过绘制文字的方式绘制建简单的图标，即绘制 `iconfont`。通过文字方式绘制的简单图标，我们可以 `color` 方法直接修改颜色。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*WdOfSI_uyxIAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单的 `iconfont` 图标点图层。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/text#iconfont)

```javascript
// 指定 iconfont 映射为字体样式的名称
const fontFamily = 'iconfont';
// 指定 iconfont 字体文件
const fontPath ='//at.alicdn.com/t/font_2534097_fcae9o2mxbv.woff2?t=1622200439140';
// 全局添加资源
scene.addFontFace(fontFamily, fontPath);
// 全局添加 iconfont 字段的映射
scene.addIconFont('icon1', '&#xe6d4;');
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/bmw-prod/70408903-80db-4278-a318-461604acb2df.json')
    .then((res) => res.json())
    .then((data) => {
      const pointLayer = new PointLayer({})
        .source(data.list, {
          parser: {
            type: 'json',
            x: 'j',
            y: 'w',
          },
        })
        .shape('icon', 'text') // 指定需要映射字段为 icon、shape 类型和普通的文字标注一样为 text
        .size(20)
        .color('w', ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99'])
        .style({
          textAnchor: 'center', // 文本相对锚点的位置 center|left|right|top|bottom|top-left
          textOffset: [40, 0], // 文本相对锚点的偏移量 [水平, 垂直]
          padding: [0, 0], // 文本包围盒 padding [水平，垂直]，影响碰撞检测结果，避免相邻文本靠的太近
          stroke: '#ffffff', // 描边颜色
          fontFamily,
          iconfont: true, // 开启 iconfont 映射
        });
      scene.addLayer(pointLayer);
    });
});
```

1. `iconfont` 绘制的是 `unicode` 图标，在使用的时候需要提前指定对应的 `unicode` 映射文件。
2. 关于 `iconfont` 资源使用可以前往 `iconfont` 官网 [官网传送门](https://iconfont.cn/)。

### shape(field: string, shapeType: 'text'): ILayer

`iconfont` 其实就是特殊的文本标注，因此 `shape` 的用法和普通文本标注的用法保持一致。

- `field` 标注的字段名称。
- `shapeType` 默认为 `text`。

```javascript
layer.shape('iconfontField', 'text');
```

### style

我们在使用 `iconfont` 绘制简单图标的时候需要在 `style` 方法中将 `iconfont` 参数设置为 `true`。

✨ iconfont 其他 style 参数的使用和普通的文本标注的参数保持一致。
---
title: 符号图
order: 5
---
<embed src="@/docs/common/style.md"></embed>

点图层支持绘制图标，在地理区域上放置不同图片作为符号，通常表示不同地理要素分布情况

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*oVyHT5S3sv0AAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个常见的符号地图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/image/#image)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 121.434765, 31.256735 ],
    zoom: 14.83
  })
});
scene.addImage('00', 'https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg');
scene.addImage('01', 'https://gw.alipayobjects.com/zos/basement_prod/30580bc9-506f-4438-8c1a-744e082054ec.svg');
scene.addImage('02', 'https://gw.alipayobjects.com/zos/basement_prod/7aa1f460-9f9f-499f-afdf-13424aa26bbf.svg');
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/893d1d5f-11d9-45f3-8322-ee9140d288ae.json')
    .then(res => res.json())
    .then(data => {
      const imageLayer = new PointLayer()
        .source(data, {
          parser: {
            type: 'json',
            x: 'longitude',
            y: 'latitude'
          }
        })
        .shape('name', [ '00', '01', '02' ])
        .size(25);
      scene.addLayer(imageLayer);
    });
});
```

### addImage(field: string, url: string): void

为了使用点图层绘制图标，我们需要事先在 `scene` 全局添加对应的图片资源。之后我们就可以在点图层的 `shape` 方法中指定对应的图片。

```js
scene.addImage('02', 'https://gw.alipayobjects.com/zos/basement_prod/7aa1f460-9f9f-499f-afdf-13424aa26bbf.svg');
```

### shape

我们需要通过 `shape` 方法指定当前点图层需要加载的图片资源 `ID`，`ID` 是用户使用 `scene.addImage(id, url)` 全局添加图片资源时候的 `ID`，即符号图需要把 `shape` 设置成图片的 `id`。

```javascript
scene.addImage('00','https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg');
scene.addImage('01','https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg');

layer.shape('00');
```

⚠️ 符号图的 `ID` 不能与点图层已有 shape 名称相同，比如不能设置 `circle`。

同样符号图 `shape` 也支持数据映射

```javascript
const scatter = new PointLayer()
  .source(data)
  .shape('name', v => {
    switch(v) {
      case 'p1':
        return '00';
      case 'p2':
        return '01';
    }
  })
  .size(5)
  .style({
    opacity: 0.3,
    strokeWidth: 1,
  });
```

⚠️ 符号图不应该设置 `color` 传入颜色，`color` 设置的颜色会覆盖图片的颜色。

⚠️ 为了得到更好的现实效果（图片清晰，无明显锯齿），我们在选择图片以及设置图标大小的时候应保持相当，或者在 L7 图层中设置的图标大小略小于实际图片的像素大小。

[在线案例](/examples/point/image#image)
### style
#### billboard

1. 默认通过 `PointLayer` 实例化的 `image` 本质上是精灵贴图，因此有始终面向相机的特性，同时贴图的大小也收到设备的限制。  
2. 由于精灵始终面向相机，因此我们也无法自定义配置 `image` 的旋转角度。

为了解决上述的两个问题（1. 大小受限，2. 无法自定义旋转角度），我们单独提供了非精灵模式`billboard` 的模式。  

只需要在 style 中配置  billboard 为 ```false```

```javascript
const imageLayer = new PointLayer({ layerType: 'fillImage',})
  .source(data, {
    parser: {
      type: 'json',
      x: 'longitude',
      y: 'latitude',
    },
  })
  .shape('name', ['00', '01', '02'])
  .style({
    rotation: 0,
    billboard: false,
  })
  .size(45);

```

##### rotation

我们支持使用 `rotation` 自定义配置图标的旋转角度（顺时针方向、角度制）。

- `rotation`: number|undefined // 角度单位 0-360

```ts
layer.style({
  rotation: 90
})
```

rotation 支持常量，也支持数据映射

```ts
layer.style({
  rotation: {
    field: 'rotate',
    value: [0,360]
  }
})
```

```tsx
layer.style({
  rotation: {
    field: 'rotate',
    value: (rotate)=>{
      return rotate
    }
  }
})
```
  

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*1kBZTaains4AAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/point/image#fillimage)


符号图的 非 billboard 模式支持 `rotation` 方法根据数据映射旋转角度。

 
```javascript
const imageLayer = new PointLayer()
  .source(data)
  .shape('wind', (wind) => {
    if (wind === 'up') {
      return 'arrBlue';
    }
    return 'arrRed';
  })
  .size(15)
  .style({
    rotation: 0, // 
    billboard: false,
  });
scene.addLayer(imageLayer);
```

[在线案例](/examples/point/image#monsoon)
---
title: 散点图
order: 2
---
<embed src="@/docs/common/style.md"></embed>

散点图在地理区域上放置相等大小的圆点，用来表示地域上的空间布局或数据分布。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*LnlmQ7sFWigAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个常见的散点图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/scatter/#scatter)


```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ -121.24357, 37.58264 ],
    zoom: 6.45
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/6c4bb5f2-850b-419d-afc4-e46032fc9f94.csv')
    .then(res => res.text())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data, {
          parser: {
            type: 'csv',
            x: 'Longitude',
            y: 'Latitude'
          }
        })
        .shape('circle')
        .size(4)
        .color('Magnitude', [
          '#0A3663',
          '#1558AC',
          '#3771D9',
          '#4D89E5',
          '#64A5D3',
          '#72BED6',
          '#83CED6',
          '#A6E1E0',
          '#B8EFE2',
          '#D7F9F0'
        ])
      scene.addLayer(pointLayer);
    });
});
```

### shape

散点图 `shape` 一般设置成常量，通常是 `2D` 的图表。

- circle
- square
- hexagon
- triangle
- pentagon
- octogon
- hexagram
- rhombus
- vesica




---
title: Scatter
order: 2
---

<embed src="@/docs/common/style.md"></embed>

A scatter plot places equal-sized dots over a geographical area to represent the spatial layout or distribution of data over a geographical area.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*LnlmQ7sFWigAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a common scatter plot.

* you can`L7`Found on the official website[Online case](/examples/point/scatter/#scatter)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ -121.24357, 37.58264 ],
    zoom: 6.45
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/6c4bb5f2-850b-419d-afc4-e46032fc9f94.csv')
    .then(res => res.text())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data, {
          parser: {
            type: 'csv',
            x: 'Longitude',
            y: 'Latitude'
          }
        })
        .shape('circle')
        .size(4)
        .color('Magnitude', [
          '#0A3663',
          '#1558AC',
          '#3771D9',
          '#4D89E5',
          '#64A5D3',
          '#72BED6',
          '#83CED6',
          '#A6E1E0',
          '#B8EFE2',
          '#D7F9F0'
        ])
      scene.addLayer(pointLayer);
    });
});
```

### shape

Scatter plot`shape`Generally set to a constant, usually`2D`chart.

* circle
* square
* hexagon
* triangle
* pentagon
* octogon
* hexagram
* rhombus
* vesica
---
title: Symbol
order: 5
---

<embed src="@/docs/common/style.md"></embed>

The point layer supports drawing icons and placing different pictures as symbols on geographical areas, usually representing the distribution of different geographical features.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*oVyHT5S3sv0AAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a common symbol map.

* you can`L7`Found on the official website[Online case](/examples/point/image/#image)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 121.434765, 31.256735 ],
    zoom: 14.83
  })
});
scene.addImage('00', 'https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg');
scene.addImage('01', 'https://gw.alipayobjects.com/zos/basement_prod/30580bc9-506f-4438-8c1a-744e082054ec.svg');
scene.addImage('02', 'https://gw.alipayobjects.com/zos/basement_prod/7aa1f460-9f9f-499f-afdf-13424aa26bbf.svg');
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/893d1d5f-11d9-45f3-8322-ee9140d288ae.json')
    .then(res => res.json())
    .then(data => {
      const imageLayer = new PointLayer()
        .source(data, {
          parser: {
            type: 'json',
            x: 'longitude',
            y: 'latitude'
          }
        })
        .shape('name', [ '00', '01', '02' ])
        .size(25);
      scene.addLayer(imageLayer);
    });
});
```

### addImage(field: string, url: string): void

In order to draw an icon using a point layer, we need to`scene`Add corresponding image resources globally. Then we can click on the layer`shape`Specify the corresponding image in the method.

```js
scene.addImage('02', 'https://gw.alipayobjects.com/zos/basement_prod/7aa1f460-9f9f-499f-afdf-13424aa26bbf.svg');
```

### shape

we need to pass`shape`The method specifies the image resources that need to be loaded for the current point layer.`ID`，`ID`is used by users`scene.addImage(id, url)`When adding image resources globally`ID`, that is, the symbolic diagram needs to`shape`set as picture`id`。

```javascript
scene.addImage('00','https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg');
scene.addImage('01','https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg');

layer.shape('00');
```

⚠️ Symbol diagram`ID`It cannot be the same as the existing shape name of the point layer. For example, it cannot be set.`circle`。

Same symbol diagram`shape`Data mapping is also supported

```javascript
const scatter = new PointLayer()
  .source(data)
  .shape('name', v => {
    switch(v) {
      case 'p1':
        return '00';
      case 'p2':
        return '01';
    }
  })
  .size(5)
  .style({
    opacity: 0.3,
    strokeWidth: 1,
  });
```

⚠️ Symbol diagram should not be set`color`Pass in color,`color`The color you set will override the color of the image.

⚠️ In order to get a better realistic effect (the picture is clear and has no obvious aliasing), we should keep it consistent when selecting the picture and setting the icon size, or the icon size set in the L7 layer is slightly smaller than the pixel size of the actual picture.

[Online case](/examples/point/image#image)

### style

#### billboard

1. Pass by default`PointLayer`instantiated`image`It is essentially a sprite map, so it always faces the camera, and the size of the map is also limited by the device.
2. Since the sprite always faces the camera, we can't customize the configuration either`image`of rotation angle.

In order to solve the above two problems (1. Limited size, 2. Unable to customize the rotation angle), we provide a separate non-elf mode`billboard`mode.

Just configure billboard in style as`false`

```javascript
const imageLayer = new PointLayer({ layerType: 'fillImage',})
  .source(data, {
    parser: {
      type: 'json',
      x: 'longitude',
      y: 'latitude',
    },
  })
  .shape('name', ['00', '01', '02'])
  .style({
    rotation: 0,
    billboard: false,
  })
  .size(45);
```

##### rotation

We support using`rotation`Customize the rotation angle of the configuration icon (clockwise, angle system).

* `rotation`: number|undefined // Angle unit 0-360

```ts
layer.style({
  rotation: 90
})
```

rotation supports constants and data mapping

```ts
layer.style({
  rotation: {
    field: 'rotate',
    value: [0,360]
  }
})
```

```tsx
layer.style({
  rotation: {
    field: 'rotate',
    value: (rotate)=>{
      return rotate
    }
  }
})
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*1kBZTaains4AAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/point/image#fillimage)

Non-billboard mode support for symbol graphs`rotation`Method maps rotation angle based on data.

```javascript
const imageLayer = new PointLayer()
  .source(data)
  .shape('wind', (wind) => {
    if (wind === 'up') {
      return 'arrBlue';
    }
    return 'arrRed';
  })
  .size(15)
  .style({
    rotation: 0, // 
    billboard: false,
  });
scene.addLayer(imageLayer);
```

[Online case](/examples/point/image#monsoon)
---
title: text
order: 6
---

<embed src="@/docs/common/style.md"></embed>

Point layers support drawing text labels.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*7blvQ4v7Q1UAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a common text annotation map.

* you can`L7`Found on the official website[Online case](/examples/point/text/#point_text)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 110, 36 ],
    style: 'light',
    zoom: 3
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/rmsportal/oVTMqfzuuRFKiDwhPSFL.json')
    .then(res => res.json())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data.list, {
          parser: {
            type: 'json',
            x: 'j',
            y: 'w'
          }
        })
        .shape('m', 'text')
        .size(12)
        .color('w', [ '#0e0030', '#0e0030', '#0e0030' ])
        .style({
          textAnchor: 'center', // The position of the text relative to the anchor point center|left|right|top|bottom|top-left
          textOffset: [ 0, 0 ], // Offset of text relative to anchor point [horizontal, vertical]
          spacing: 2, // character spacing
          padding: [ 1, 1 ], // Text bounding box padding [horizontal, vertical], affects the collision detection results and prevents adjacent texts from being too close
          stroke: '#ffffff', // stroke color
          strokeWidth: 0.3, // Stroke width
        });
      scene.addLayer(pointLayer);
    });
});
```

### shape(field: name: shapeType: 'text'): ILayer

* `field`Labeled field name.
* `shapeType`The default value is`text`。

```javascript
layer.shape('name', 'text');
```

### style

* textAnchor `string`The position of the text relative to the anchor point`'right' | 'top-right' | 'left' | 'bottom-right' | 'left' | 'top-left' | 'bottom-left' | 'bottom' | 'bottom-right' | 'bottom-left' | 'top' | 'top-right' | 'top-left' | 'center';`
* padding:`number`Text bounding box padding \[horizontal, vertical], affects the collision detection results and prevents adjacent text from being too close
* spacing: number text spacing
* stroke:`string`; stroke color
* strokeWidth `number`stroke width
* strokeOpacity `number`stroke transparency
* fontWeight `string`Font weight
* fontFamily `string`Font size
* textOffset `[number, number]`text offset
* textAllowOverlap:`boolean`Whether to allow text masking
* raisingHeight sets the raising height of the text label
---
title: 文本标注
order: 6
---
<embed src="@/docs/common/style.md"></embed>

点图层支持绘制文本标注。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*7blvQ4v7Q1UAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个常见的文本标注地图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/text/#point_text)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 110, 36 ],
    style: 'light',
    zoom: 3
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/rmsportal/oVTMqfzuuRFKiDwhPSFL.json')
    .then(res => res.json())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data.list, {
          parser: {
            type: 'json',
            x: 'j',
            y: 'w'
          }
        })
        .shape('m', 'text')
        .size(12)
        .color('w', [ '#0e0030', '#0e0030', '#0e0030' ])
        .style({
          textAnchor: 'center', // 文本相对锚点的位置 center|left|right|top|bottom|top-left
          textOffset: [ 0, 0 ], // 文本相对锚点的偏移量 [水平, 垂直]
          spacing: 2, // 字符间距
          padding: [ 1, 1 ], // 文本包围盒 padding [水平，垂直]，影响碰撞检测结果，避免相邻文本靠的太近
          stroke: '#ffffff', // 描边颜色
          strokeWidth: 0.3, // 描边宽度
        });
      scene.addLayer(pointLayer);
    });
});
```

### shape(field: name: shapeType: 'text'): ILayer

- `field` 标注的字段名称。
- `shapeType` 默认值为 `text`。

```javascript
layer.shape('name', 'text');
```

### style

- textAnchor `string` 文本相对锚点的位置
  `'right' | 'top-right' | 'left' | 'bottom-right' | 'left' | 'top-left' | 'bottom-left' | 'bottom' | 'bottom-right' | 'bottom-left' | 'top' | 'top-right' | 'top-left' | 'center';`
- padding: `number` 文本包围盒 padding [水平，垂直]，影响碰撞检测结果，避免相邻文本靠的太近
- spacing: number 文本间隔
- stroke: `string`; 描边颜色
- strokeWidth `number` 描边宽度
- strokeOpacity `number` 描边透明度
- fontWeight `string` 字体粗细
- fontFamily `string` 字号
- textOffset `[number, number]` 文本偏移量
- textAllowOverlap: `boolean` 是否允许文字遮盖
- raisingHeight 设置文本标注的抬升高度
---
title: Marker
order: 8
---

<embed src="@/docs/common/style.md"></embed>

Points on the map can be customized`DOM`, we will customize`DOM`called`Marker`。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_855bab/afts/img/A*2vBbRYT2bgIAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Below we will introduce how to draw a simple`Marker`layers.

* you can`L7`Found on the official website[Online case](/examples/component/marker#marker)

```javascript
import { Scene, Marker } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 105.790327, 36.495636 ],
    zoom: 4
  })
});
scene.on('loaded', () => {
  addMarkers();
  scene.render();
});
function addMarkers() {
  fetch('https://gw.alipayobjects.com/os/basement_prod/67f47049-8787-45fc-acfe-e19924afe032.json')
    .then(res => res.json())
    .then(nodes => {
      for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].g !== '1' || nodes[i].v === '') { continue; }
        const el = document.createElement('label');
        el.className = 'labelclass';
        el.textContent = nodes[i].v + '℃';
        el.style.background = getColor(nodes[i].v);
        el.style.borderColor = getColor(nodes[i].v);
        const marker = new Marker({
          element: el
        }).setLnglat({ lng: nodes[i].x * 1, lat: nodes[i].y });
        scene.addMarker(marker);
      }
    });
}
function getColor(v) {
  return v > 50
    ? '#800026'
    : v > 40
      ? '#BD0026'
      : v > 30
        ? '#E31A1C'
        : v > 20
          ? '#FC4E2A'
          : v > 10
            ? '#FD8D3C'
            : v > 5
              ? '#FEB24C'
              : v > 0
                ? '#FED976'
                : '#FFEDA0';
}
```

### Use documentation

[Marker documentation](/api/component/marker/marker)

[MarkerLayer documentation](/api/component/marker/markerlayer)
---
title: Marker
order: 8
---
<embed src="@/docs/common/style.md"></embed>

地图上的点可以是自定义的 `DOM`，我们将自定的 `DOM` 称为 `Marker` 。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_855bab/afts/img/A*2vBbRYT2bgIAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单的 `Marker` 图层。

- 你可以在 `L7` 官网上找到[在线案例](/examples/component/marker#marker)

```javascript
import { Scene, Marker } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 105.790327, 36.495636 ],
    zoom: 4
  })
});
scene.on('loaded', () => {
  addMarkers();
  scene.render();
});
function addMarkers() {
  fetch('https://gw.alipayobjects.com/os/basement_prod/67f47049-8787-45fc-acfe-e19924afe032.json')
    .then(res => res.json())
    .then(nodes => {
      for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].g !== '1' || nodes[i].v === '') { continue; }
        const el = document.createElement('label');
        el.className = 'labelclass';
        el.textContent = nodes[i].v + '℃';
        el.style.background = getColor(nodes[i].v);
        el.style.borderColor = getColor(nodes[i].v);
        const marker = new Marker({
          element: el
        }).setLnglat({ lng: nodes[i].x * 1, lat: nodes[i].y });
        scene.addMarker(marker);
      }
    });
}
function getColor(v) {
  return v > 50
    ? '#800026'
    : v > 40
      ? '#BD0026'
      : v > 30
        ? '#E31A1C'
        : v > 20
          ? '#FC4E2A'
          : v > 10
            ? '#FD8D3C'
            : v > 5
              ? '#FEB24C'
              : v > 0
                ? '#FED976'
                : '#FFEDA0';
}
```

### 使用文档

[Marker 文档](/api/component/marker/marker)

[MarkerLayer 文档](/api/component/marker/markerlayer)
---
title: Bubble
order: 0
---

<embed src="@/docs/common/style.md"></embed>

Dots of different sizes appear above the geographic area of ​​the bubble chart, and the area of ​​the circle is proportional to its value in the data set.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*fNGiS7YI1tIAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let’s introduce how to draw a common bubble chart.

* you can`L7`Found on the official website[Online case](/examples/point/bubble/#point)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 140.067171, 36.26186 ],
    zoom: 5.32,
    maxZoom: 10
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/d3564b06-670f-46ea-8edb-842f7010a7c6.json')
    .then(res => res.json())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data)
        .shape('circle')
        .size('mag', [ 1, 25 ])
        .color('mag', mag => {
          return mag > 4.5 ? '#5B8FF9' : '#5CCEA1';
        })
        .style({
          opacity: 0.3,
          strokeWidth: 1
        });
      scene.addLayer(pointLayer);
    });
});
```

### source

Bubble charts accept plain point data.

### shape

bubble chart`shape`Generally`circle`,can also be`square`、`triangle`and other shapes.

### size

bubble chart`size`Generally used to represent a certain field in the data, so constants are not used but data mapping is used.

```js
layer.size('area', [1, 100]); // Use interval mapping
layer.size('area', area => { // Use callback function to implement mapping
  return area * 10;
})
```

### color

bubble chart`color`It is generally used to represent a certain field in the data, so constants are not used but data mapping is used.

```js
layer.color('area', ['#f00', '#ff0']); // Use interval mapping
layer.color('area', area => { // Use callback function to implement mapping
  if(area > 100) {
    return '#f00';
  } else {
    return '#ff0';
  }
})
```
---
title: 气泡图
order: 0
---
<embed src="@/docs/common/style.md"></embed>

气泡图地理区域上方会显示不同大小的圆点，圆形面积与其在数据集中的数值会成正比。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*fNGiS7YI1tIAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个常见的气泡图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/bubble/#point)

```javascript
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 140.067171, 36.26186 ],
    zoom: 5.32,
    maxZoom: 10
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/d3564b06-670f-46ea-8edb-842f7010a7c6.json')
    .then(res => res.json())
    .then(data => {
      const pointLayer = new PointLayer({})
        .source(data)
        .shape('circle')
        .size('mag', [ 1, 25 ])
        .color('mag', mag => {
          return mag > 4.5 ? '#5B8FF9' : '#5CCEA1';
        })
        .style({
          opacity: 0.3,
          strokeWidth: 1
        });
      scene.addLayer(pointLayer);
    });
});
```

### source

气泡图接受普通的点数据。
### shape

气泡图的 `shape` 一般为 `circle`，也可以是 `square`、`triangle` 等其他形状。

### size

气泡图的 `size` 一般用于表示数据中的某个字段，因此不会使用常量而是使用数据映射。

```js
layer.size('area', [1, 100]); // 使用区间映射
layer.size('area', area => {  // 使用回调函数实现映射
  return area * 10;
})
```

### color

气泡图的 `color` 一般也会用于表示数据中的某个字段，因此不会使用常量而是使用数据映射。

```js
layer.color('area', ['#f00', '#ff0']); // 使用区间映射
layer.color('area', area => {  // 使用回调函数实现映射
  if(area > 100) {
    return '#f00';
  } else {
    return '#ff0';
  }
})
```---
title: wave
order: 3
---

<embed src="@/docs/common/style.md"></embed>

When the animation mode is turned on, the plane point layer is a special layer type: water wave point. The layer is made up of rings that spread outward.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*pcp3RKnNK1oAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

A simple water wave point case can be implemented according to the following code.

* you can`L7`Found on the official website[Online case](/examples/point/scatter#animatepoint)。

* Specific usage can be viewed[Detailed documentation](</api/point_layer/animate#Water wave point>)。

```js
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 112, 23.69 ],
    zoom: 2.5
  })
});
fetch('https://gw.alipayobjects.com/os/basement_prod/9078fd36-ce8d-4ee2-91bc-605db8315fdf.csv')
  .then(res => res.text())
  .then(data => {
    const pointLayer = new PointLayer({})
      .source(data, {
        parser: {
          type: 'csv',
          x: 'Longitude',
          y: 'Latitude'
        }
      })
      .shape('circle')
      .animate(true)
      .size(40)
      .color('#ffa842')
    scene.addLayer(pointLayer);
  });
```

### shape

In order to achieve water wave points, the point layer`shape`The parameters only need to be`circle`、`triangle`、`square`Just wait for the flat graphics.

### animate

* boolean ｜ animateOption

```javascript
.animate(true)

.animate({
  enable: true
})
```

#### Water wave configuration items

* `speed`water wave speed
* `rings`Water wave ring number

### size

In the water wave point layer, due to the transparent edges, the size of the points looks smaller than the non-water wave points of the same size.
---
title: 水波图
order: 3
---
<embed src="@/docs/common/style.md"></embed>

平面点图层在开启动画模式的情况下，是一种特殊的图层类型：水波点。图层由一圈圈向外扩散的圆环构成。


<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*pcp3RKnNK1oAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

根据下面的代码可以实现一个简单的水波点案例。

- 你可以在 `L7` 官网上找到[在线案例](/examples/point/scatter#animatepoint)。

- 具体的使用可以查看[详细文档](/api/point_layer/animate#水波点)。

```js
import { Scene, PointLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 112, 23.69 ],
    zoom: 2.5
  })
});
fetch('https://gw.alipayobjects.com/os/basement_prod/9078fd36-ce8d-4ee2-91bc-605db8315fdf.csv')
  .then(res => res.text())
  .then(data => {
    const pointLayer = new PointLayer({})
      .source(data, {
        parser: {
          type: 'csv',
          x: 'Longitude',
          y: 'Latitude'
        }
      })
      .shape('circle')
      .animate(true)
      .size(40)
      .color('#ffa842')
    scene.addLayer(pointLayer);
  });
```
### shape

为了实现水波点，点图层的 `shape` 参数只要是 `circle`、`triangle`、`square` 等平面图形即可。

### animate

- boolean ｜ animateOption

```javascript
.animate(true)

.animate({
  enable: true
})
```

#### 水波配置项

- `speed` 水波速度
- `rings` 水波环数

### size

在水波点图层中，由于边缘透明的原因，点的大小看上去要比相同 size 的非水波点要小一些。
---
title: Scale 度量
order: 2
---
<embed src="@/docs/common/style.md"></embed>

## Scale 简介

Scale 度量是用于将地图数据值（数字、日期、类别等数据）转成视觉变量（颜色、大小、形状）。Scale 是数据可视化的基本元素，因为它们决定了数据视觉编码的方式。L7 目前支持连续、离散、枚举类型等常用的 Scale。

![L7 Scale](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*AOIvTpmPOmgAAAAAAAAAAAAADmJ7AQ/original)

## Scale 中的两个重要概念:

Range 和 Domain

Domain: 地图数据值的定义区间

Range：视觉值的区间定义



不同 Scale 的差异在于 Domain-> Range 的转换方法不同

|数据类|度量类型|
|----|------|
| 连续 | linear、log、pow |
| 连续分类 | quantize quantile,threshold,diverging |
| 分类 枚举| cat |


## L7 Scale

在使用 L7 过程中，默认情况下不需要进行 Scale 的配置，因为 L7 会根据数据类型对 scale 推断，推断过程如下：

查看用户是否设置了 Scale，如果没有:

判断字段的第一条数据的字段类型，如果数据中不存在对应的字段：

认为是常量为固定值

如果是数字则为 'linear';

如果是字符串类型 'cat';

## Cat 枚举

Cat 指枚举类型，用于展示分类数据，比如农作物种植区分布图，水稻、玉米、大豆等不同类别需要映射为不同的颜色。在 L7 如果判断字段的值为字符串，将认为是 Cat 类型并自动获取类型的唯一值，设置为 domain 。这样三种作物就会被一一映射成对应的颜色。

```tsx

const data = [
   {
   type:'A',
   x: 110,
   y:30
 },
 {
   type:'B',
   x: 110,
   y:32
 },
 {
   type:'C',
   x: 110,
   y:31
 }
 ,{
   type:'D',
   x: 111,
   y:33
 }，
 ,{
   type:'E',
   x: 112,
   y:30
 }
 ,{
   type:'F',
   x: 110,
   y:30
 }
]
layer.color('type',['red','white','blue','yellow'])
```

如上面的代码所示，图层没有设置 Scale, L7 根据第一个数据"A"的类型 ,推断为枚举类型。同时取出该字段的去重后的所有值 ['A','B','C','D','E','F'] 设置为 scale 的 domain, 那么 range 就是对应的颜色 ['red','white','blue','yellow']。

![L7 scale Cat映射](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*rO53SYNk8hgAAAAAAAAAAAAADmJ7AQ/original)

如果不设置 domain，L7 内部会自动计算 domain，domain 顺序跟数据顺序相关。如果希望固定domain 可自己设置 domain。domain 数值 和 range数值 一一对应。

```

layer.scale('type', {
  type: 'cat',
  domain: ['B', 'A', 'C', 'D'],
});
layer.color('type', ['red', 'white', 'blue', 'yellow']);

```
![L7 Cat ](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*kyP2RpUXdGUAAAAAAAAAAAAADmJ7AQ/original)

## Linear 连续线性

线性是连续数据的映射方法，数据和视觉值是通过线性方法计算的。如数据范围domain [0,1000] 线性映射到 range [red,blue] 渐变色，就是依据线性函完成一一转换。

![L7 Scale 线性](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*Z_rGRr-jgI0AAAAAAAAAAAAADmJ7AQ/original')

```tsx
layer.color('rate', ['#ffffcc', '#b6e2b6', '#64c1c0', '#338cbb', '#253494'])
```
对于连续型
数据 L7 默认会设置为 linear, domain为数据的min、max值。颜色会根据 range 颜色生成渐变色。linear
默认可不设置 domain 区间

```ts
layer.scale('value', {
  type: 'linear',
  domain: [5, 100], // 可定义domain,也可以不设置，自定根据数据计算
});
```

## quantize 连续等间距

等间距分类会根据属性值范围划分为若干个大小相等的子范围。相等间隔最适用于常见的数据范围，如百分比和温度。这种方法强调的是某个属性值相对于其他值的量。

![L7 Scale 连续等间距](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*YmwwQ5L-d7QAAAAAAAAAAAAADmJ7AQ/original)

等间距分类只与数据 mix、max 有关，如果没有设置 domain,将自动计算数据的 min、max 进行分段，分段个数依据 range 颜色的个数。等间距会出现空类，而且每个分类要素分布不均匀。

```tsx
layer.color('type', ['red', 'white', 'blue', 'yellow']);
```
你也可以自定义 domain

```ts

layer.scale('value', {
  type: 'quantize',
  domain: [5, 100],
});

layer.color('type', ['red', 'white', 'blue', 'yellow']);

```
![L7 scale quantize](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*N61_Q6-U7jIAAAAAAAAAAAAADmJ7AQ/original)

## quantile 连续等分位 

等分位要求每个分类区间都含有相等数量的要素。分位数为每个分类分配相等数量数据值，不存在空类，也不存在值过多或过少的类。

![L7 scale quantile](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*2SFpSLRD3yYAAAAAAAAAAAAADmJ7AQ/original)

等分位与数据的分布相关，需要拿到全量数据才能计算，因此等分位的 scale 不能单独设置 domain，只能自动计算。

```tsx

layer.scale('value', {
  type: 'quantile',
});

layer.color('value', ['red', 'white', 'blue', 'yellow']);
```

![L7 Scale quantile](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*EMcjSrYe1l0AAAAAAAAAAAAADmJ7AQ/original)


## threshold 自定义分类


自定义分类可以设定任意分类区间映射到对于视觉变量。domain 仍然是连续的，并根据提供的domain 进行分类。range 属性必须有 N+1 个元素，其中 N 是 domain 的个数。

threshold 为自定义分段，在使用时必须为 Scale 设置 domain, domain可以依据需求任意设置。

```tsx
layer.scale('rate', {
          type: 'threshold',
          domain: [3, 6, 8, 10],
        })
        .color('rate', ['#ffffcc', '#b6e2b6', '#64c1c0', '#338cbb', '#253494'])

```

![ L7 Scale threshold](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*e1YyRKELsjwAAAAAAAAAAAAADmJ7AQ/original)


## diverging 离散分类 

离散分类通常与两种相反的色调一起使用，以显示从负值到中心到正值的变化。这些类型的地图显示了彼此相关的值的大小。

![L7 diverging](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*8anRRLJNu6YAAAAAAAAAAAAADmJ7AQ/original)


diverging 如果没有设置 domain 会自动根据数据计算min、middle、max 三个值作为domain。range 至少需要设置三个颜色，形成双极色带。

```ts
layer.scale('rate', {
         type: 'diverging'
         domain: [3, 6, 8, 10], //  the input domain and output range of a diverging scal
       })
       .color('rate', ['#ffffcc', '#b6e2b6', '#64c1c0', '#338cbb', '#253494'])
```

![L7 scale diverging](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*4rcDQIRdRdEAAAAAAAAAAAAADmJ7AQ/original)---
title: 3D Extrude
order: 1
---

<embed src="@/docs/common/style.md"></embed>

In addition to the flat filled map on the map, the geometry layer can also be a geometric block with height.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*yxRiTJDOrS8AAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

Below we will introduce how to draw a simple`3D`Fill in the figure.

* you can`L7`Found on the official website[Online case](/examples/polygon/3d/#polygonstylemap)

```javascript
import { Scene, PolygonLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'dark',
    pitch: 50,
    center: [ 118.8, 32.056 ],
    zoom: 10
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/bmw-prod/94763191-2816-4c1a-8d0d-8bcf4181056a.json')
    .then(res => res.json())
    .then(data => {
      const filllayer = new PolygonLayer({
        name: 'fill',
        zIndex: 3
      })
        .source(data)
        .shape('extrude')
        .color('unit_price', [
        '#87CEFA',
        '#00BFFF',
        '#7FFFAA',
        '#00FF7F',
        '#32CD32',
        '#F0E68C',
        '#FFD700',
        '#FF7F50',
        '#FF6347',
        '#FF0000'
      ])
        .size('unit_price', unit_price => unit_price * 50)
        .style({
          opacity:{
            field:'unit_price',
            value: [ 0, 1 ]
          }
          pickLight: true
        })
      scene.addLayer(filllayer);
    });
});
```

### source

It is recommended to use the standard geometry layer`GeoJSON`data.

### shape

3D Polygon Stretch the polygon upward along the Z axis

* extrude constants do not support data mapping

```javascript
layer.shape('extrude');
```

### size

size represents the height of the stretch and supports data mapping

```javascript
layer.size(10); // Set height to constant
layer.size('floor', [0, 2000]); // Data mapping based on floor field defaults to line
layer.size('floor', (floor) => {
  //Set size through callback function
  return floor * 2;
});
```

### style

* `pickLight`Sets whether the picking highlight color of the 3D fill map calculates lighting.

`pickLight`The default is`false`Indicates that lighting calculations will not be performed on the picked colors. When turned on, some additional calculations will be added.

```javascript
style({
  pickLight: true, //default is false
});
```

* `heightFixed`set up`3D`The height of the fill image is always fixed.

default`3D`The height of the filled image will be`zoom`The level is related, and is used to keep the pixel length of the graphics height constant, and in some cases we need to keep the actual height of the graphics unchanged rather than the pixel height.

```javascript
style({
  heightfixed: true, //default is false
});
```

🌟 Supported starting from v2.7.6.

[Online case](/examples/react/covid#covid_extrude)

* `raisingHeight`set up`3D`The elevation of the fill pattern.

🌟 The prerequisite for setting the lifting height is`heightfixed`for`true`。\
🌟 Supported starting from v2.8.17.

<img width="40%" style="display: block;margin: 0 auto;" alt="面图层填充图" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*D8GeSKNZxWIAAAAAAAAAAAAAARQnAQ">

[Online case](/examples/polygon/3d#floatmap)

* `mapTexture`set up`3D`The top texture of the fill image.
  🌟 Setting up`mapTexture`allows the user to configure the gradient color on the side.
  🌟 Supported starting from v2.8.17.

<img width="40%" style="display: block;margin: 0 auto;" alt="面图层填充图" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*K18EQZoe4awAAAAAAAAAAAAAARQnAQ">

```javascript
const provincelayer = new PolygonLayer({})
  .source(data)
  .size(150000)
  .shape('extrude')
  .color('#0DCCFF')
  .style({
    heightfixed: true,
    pickLight: true,
    raisingHeight: 200000,
    mapTexture:
      'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*0tmIRJG9cQQAAAAAAAAAAAAAARQnAQ',
    sourceColor: '#333',
    targetColor: '#fff',
  });
```

* `topsurface`:`boolean`Controls the visibility of the top surface, the default is`true`。

* `sidesurface`:`boolean`Control the visibility of the sides, the default is`true`。

[Online case](/examples/polygon/3d#texture3D)
---
title: 水面图层
order: 2
---

<embed src="@/docs/common/style.md"></embed>

Geometry layers support a special representation, the water surface layer.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BiawTbtX-CYAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

Next we will introduce how to draw water surface.

* you can`L7`Found on the official website[Online case](/examples/polygon/fill#ocean)

🌟 Simple water surface is supported starting from v2.8.1.\
🌟 Supports realistic water surfaces starting from version v2.8.4.

### simulated water surface

<img width="60%" style="display: block;margin: 0 auto;" alt="拟真水面" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BiawTbtX-CYAAAAAAAAAAAAAARQnAQ">

### source

It is recommended to use the standard geometry layer`GeoJSON`data.

### shape

we need to set`shape`for`ocean`。

### animate

The settings we need to display`animate`for`true`。

```javascript
layer.animate(true);
```

### style

* `watercolor`The color of shallow water areas defaults to '#6D99A8'.

* `watercolor2`The color of deep water areas defaults to '#0F121C'.

[Online case](/examples/polygon/fill#ocean)

### simple water surface

<img width="60%" style="display: block;margin: 0 auto;" alt="简单水面" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*1kqvSYvWP3MAAAAAAAAAAAAAARQnAQ">

### source

It is recommended to use the standard geometry layer`GeoJSON`data.

### shape

we need to set`shape`for`water`。

### animate

The settings we need to display`animate`for`true`。

```javascript
layer.animate(true);
```

### style

* `speed`we can pass`speed`to control the flow speed of the water surface.

```javascript
style({
  speed: 0.5,
});
```

* `waterTexture`We can replace the texture of the water surface by setting this property.\
  The default value is '<https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ>'

[Online case](/examples/polygon/fill#water)
---
title: water fill
order: 2
---
<embed src="@/docs/common/style.md"></embed>


几何体图层支持特殊的表现形式，水面图层。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BiawTbtX-CYAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制水面。

- 你可以在 `L7` 官网上找到[在线案例](/examples/polygon/fill#ocean)

🌟 从 v2.8.1 版本开始支持简单水面。  
🌟 从 v2.8.4 版本开始支持拟真水面。

### 拟真水面

<img width="60%" style="display: block;margin: 0 auto;" alt="拟真水面" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BiawTbtX-CYAAAAAAAAAAAAAARQnAQ">

### source

几何体图层推荐使用标准的 `GeoJSON` 数据。

### shape

我们需要设置 `shape` 为 `ocean`。

### animate

我们需要显示的设置 `animate` 为 `true`。

```javascript
layer.aniamte(true);
```

### style

- `watercolor` 浅水区域的颜色 默认为 '#6D99A8'。

- `watercolor2` 深水区域的颜色 默认为 '#0F121C'。

[在线案例](/examples/polygon/fill#ocean)

### 简单水面

<img width="60%" style="display: block;margin: 0 auto;" alt="简单水面" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*1kqvSYvWP3MAAAAAAAAAAAAAARQnAQ">

### source

几何体图层推荐使用标准的 `GeoJSON` 数据。
### shape

我们需要设置 `shape` 为 `water`。

### animate

我们需要显示的设置 `animate` 为 `true`。

```javascript
layer.aniamte(true);
```

### style

- `speed` 我们可以通过 `speed` 来控制水面的流速度。

```javascript
style({
  speed: 0.5,
});
```

- `waterTexture` 我们可以通过设置该属性来替换水面的纹理。   
  默认值是 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ'

[在线案例](/examples/polygon/fill#water)
---
title: 3D 填充图
order: 1
---
<embed src="@/docs/common/style.md"></embed>


几何体图层在地图上除了平面的填充图，还可以是有高度的几何体块。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*yxRiTJDOrS8AAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单的 `3D` 填充图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/polygon/3d/#polygonstylemap)

```javascript
import { Scene, PolygonLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'dark',
    pitch: 50,
    center: [ 118.8, 32.056 ],
    zoom: 10
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/bmw-prod/94763191-2816-4c1a-8d0d-8bcf4181056a.json')
    .then(res => res.json())
    .then(data => {
      const filllayer = new PolygonLayer({
        name: 'fill',
        zIndex: 3
      })
        .source(data)
        .shape('extrude')
        .color('unit_price', [
        '#87CEFA',
        '#00BFFF',
        '#7FFFAA',
        '#00FF7F',
        '#32CD32',
        '#F0E68C',
        '#FFD700',
        '#FF7F50',
        '#FF6347',
        '#FF0000'
      ])
        .size('unit_price', unit_price => unit_price * 50)
        .style({
          opacity:{
            field:'unit_price',
            value: [ 0, 1 ]
          }
          pickLight: true
        })
      scene.addLayer(filllayer);
    });
});

```

### source

几何体图层推荐使用标准的 `GeoJSON` 数据。

### shape

3D Polygon 将多边形沿 Z 轴向上拉伸

- extrude 常量不支持数据映射

```javascript
layer.shape('extrude');
```

### size

size 代表拉伸的高度，支持数据映射

```javascript
layer.size(10); // 高度设置成常量
layer.size('floor', [0, 2000]); // 根据floor字段进行数据映射默认为线
layer.size('floor', (floor) => {
  // 通过回调函数设置size
  return floor * 2;
});
```

### style

- `pickLight` 设置 3D 填充图的拾取高亮色是否计算光照。

`pickLight` 默认为 `false` 表示对拾取的颜色不进行光照计算，开启后会增加部分额外的计算。

```javascript
style({
  pickLight: true, //  默认为 false
});
```

- `heightFixed` 设置 `3D` 填充图的高度时候固定。

默认 `3D` 填充图的高度会和 `zoom` 的层级相关，并以此来保持图形高度的像素长度不变，而在某些情况下我们需要保持图形的实际高度不变而不是像素高度不变。

```javascript
style({
  heightfixed: true, //  默认为 false
});
```

🌟 在 v2.7.6 版本开始支持。

[在线案例](/examples/react/covid#covid_extrude)

- `raisingHeight` 设置 `3D` 填充图的抬升高度。

🌟 设置抬升高度的前提是 `heightfixed` 为 `true`。  
🌟 在 v2.8.17 版本开始支持。

<img width="40%" style="display: block;margin: 0 auto;" alt="面图层填充图" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*D8GeSKNZxWIAAAAAAAAAAAAAARQnAQ">

[在线案例](/examples/polygon/3d#floatmap)

- `mapTexture` 设置 `3D` 填充图的顶面纹理。
  🌟 在设置 `mapTexture` 的时候允许用户配置侧面的渐变色。
  🌟 在 v2.8.17 版本开始支持。

<img width="40%" style="display: block;margin: 0 auto;" alt="面图层填充图" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*K18EQZoe4awAAAAAAAAAAAAAARQnAQ">

```javascript
const provincelayer = new PolygonLayer({})
  .source(data)
  .size(150000)
  .shape('extrude')
  .color('#0DCCFF')
  .style({
    heightfixed: true,
    pickLight: true,
    raisingHeight: 200000,
    mapTexture:
      'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*0tmIRJG9cQQAAAAAAAAAAAAAARQnAQ',
    sourceColor: '#333',
    targetColor: '#fff',
  });
```

- `topsurface`: `boolean`
  控制顶面的显隐，默认为 `true`。

- `sidesurface`: `boolean`
  控制侧面的显隐，默认为 `true`。

[在线案例](/examples/polygon/3d#texture3D)
---
title: fill
order: 0
---

<embed src="@/docs/common/style.md"></embed>

The simplest representation of a geometry layer on a map is a fill map, which fills a specified area with a specified color.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*4Kp4Qp00kq4AAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a simple filled diagram.

* you can`L7`Found on the official website[Online case](/examples/polygon/fill#usa)

```javascript
import { Scene, PolygonLayer, LineLayer, Popup } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ -96, 37.8 ],
    zoom: 3
  })
});
scene.on('loaded', () => {
  fetch(
    'https://gw.alipayobjects.com/os/basement_prod/d36ad90e-3902-4742-b8a2-d93f7e5dafa2.json'
  )
    .then(res => res.json())
    .then(data => {
      const color = [ 'rgb(255,255,217)', 'rgb(237,248,177)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(12,44,132)' ];
      const layer = new PolygonLayer({})
        .source(data)
        .scale('density', {
          type: 'quantile'
        })
        .color(
          'density', color
        )
        .shape('fill')
        .active(true);
      const layer2 = new LineLayer({
        zIndex: 2
      })
        .source(data)
        .color('#fff')
        .active(true)
        .size(1)
        .style({
          lineType: 'dash',
          dashArray: [ 2, 2 ],
        });
      scene.addLayer(layer);
      scene.addLayer(layer2);
    });
});
```

### source

It is recommended to use the standard geometry layer`GeoJSON`data.

### shape

Draw a filled diagram, the shape is`fill`Constant, data mapping is not supported

```javascript
layer.shape('fill');
```

### size

Fill image does not need to be set`size`;

### style

* `opacityLinear`Sets the radial gradient of the geometric fill.

```javascript
style({ opacity Linear: { enable: true, // true - false dir: 'in', // n - out },
});
```

[radial gradient in](/examples/polygon/fill#china_linear_in)

<img width="60%" style="display: block;margin: 0 auto;" alt="面图层填充图" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*XjT5T4cT_CYAAAAAAAAAAAAAARQnAQ">

[radial gradient out](/examples/polygon/fill#china_linear_out)

<img width="60%" style="display: block;margin: 0 auto;" alt="面图层填充图" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*Ob62Q7JDpZ4AAAAAAAAAAAAAARQnAQ">

* `raisingHeight`set up`3D`The elevation of the fill pattern.
---
title: 填充图
order: 0
---
<embed src="@/docs/common/style.md"></embed>

几何体图层在地图上最简单的表现就是填充图，即使用指定的颜色填充指定区域。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*4Kp4Qp00kq4AAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单的填充图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/polygon/fill#usa)

```javascript
import { Scene, PolygonLayer, LineLayer, Popup } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ -96, 37.8 ],
    zoom: 3
  })
});
scene.on('loaded', () => {
  fetch(
    'https://gw.alipayobjects.com/os/basement_prod/d36ad90e-3902-4742-b8a2-d93f7e5dafa2.json'
  )
    .then(res => res.json())
    .then(data => {
      const color = [ 'rgb(255,255,217)', 'rgb(237,248,177)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(12,44,132)' ];
      const layer = new PolygonLayer({})
        .source(data)
        .scale('density', {
          type: 'quantile'
        })
        .color(
          'density', color
        )
        .shape('fill')
        .active(true);
      const layer2 = new LineLayer({
        zIndex: 2
      })
        .source(data)
        .color('#fff')
        .active(true)
        .size(1)
        .style({
          lineType: 'dash',
          dashArray: [ 2, 2 ],
        });
      scene.addLayer(layer);
      scene.addLayer(layer2);
    });
});

```

### source

几何体图层推荐使用标准的 `GeoJSON` 数据。

### shape

绘制填充图，shape 为 `fill` 常量，不支持数据映射

```javascript
layer.shape('fill');
```

### size

填充图不需要设置 `size`;

### style

- `opacityLinear` 设置几何填充图的径向渐变。

```javascript
style({
  opacityLinear: {
    enable: true, // true - false
    dir: 'in', // in - out
  },
});
```

[径向渐变 in](/examples/polygon/fill#china_linear_in)

<img width="60%" style="display: block;margin: 0 auto;" alt="面图层填充图" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*XjT5T4cT_CYAAAAAAAAAAAAAARQnAQ">

[径向渐变 out](/examples/polygon/fill#china_linear_out)

<img width="60%" style="display: block;margin: 0 auto;" alt="面图层填充图" src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*Ob62Q7JDpZ4AAAAAAAAAAAAAARQnAQ">

- `raisingHeight` 设置 `3D` 填充图的抬升高度。
---
title: Scale
order: 2
---

<embed src="@/docs/common/style.md"></embed>

## Introduction to Scale

Scale measures are used to convert map data values ​​(numbers, dates, categories, etc.) into visual variables (color, size, shape). Scales are fundamental elements of data visualization because they determine how data is visually encoded. L7 currently supports common Scales such as continuous, discrete, and enumerated types.

![L7 Scale](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*AOIvTpmPOmgAAAAAAAAAAAAADmJ7AQ/original)

## Two important concepts in Scale:

Range and Domain

Domain: definition interval of map data values

Range: interval definition of visual value

The difference between different Scales lies in the different conversion methods of Domain->Range

| data class                 | Measurement type                      |
| -------------------------- | ------------------------------------- |
| continuous                 | linear、log、pow                        |
| continuous classification  | quantize quantile,threshold,diverging |
| Classification Enumeration | cat                                   |

## L7 Scale

When using L7, there is no need to configure Scale by default because L7 will infer scale based on the data type. The inference process is as follows:

Check whether the user has set Scale, if not:

Determine the field type of the first data of the field, if the corresponding field does not exist in the data:

Consider a constant as a fixed value

'linear' if numeric;

If it is string type 'cat';

## Cat enumeration

Cat refers to the enumeration type, which is used to display categorical data, such as the distribution of crop planting areas. Different categories such as rice, corn, and soybeans need to be mapped to different colors. In L7, if the value of a field is judged to be a string, it will be considered to be of Cat type and the unique value of the type will be automatically obtained and set to domain. In this way, the three crops will be mapped to the corresponding colors one by one.

```tsx
const data = [
   {
   type:'A',
   x: 110,
   y:30
 },
 {
   type:'B',
   x: 110,
   y:32
 },
 {
   type:'C',
   x: 110,
   y:31
 }
 ,{
   type:'D',
   x: 111,
   y:33
 }，
 ,{
   type:'E',
   x: 112,
   y:30
 }
 ,{
   type:'F',
   x: 110,
   y:30
 }
]
layer.color('type',['red','white','blue','yellow'])
```

As shown in the code above, the layer does not set Scale, L7 infers the enumeration type based on the type of the first data "A". At the same time, take out all the deduplicated values ​​of the field \['A', 'B', 'C', 'D', 'E', 'F'] and set them to the domain of the scale, then the range is the corresponding color \[' red','white','blue','yellow'].

![L7 scale Cat映射](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*rO53SYNk8hgAAAAAAAAAAAAADmJ7AQ/original)

If the domain is not set, L7 will automatically calculate the domain internally, and the domain order is related to the data order. If you want to fix the domain, you can set the domain yourself. There is a one-to-one correspondence between domain values ​​and range values.

```
layer.scale('type', {
  type: 'cat',
  domain: ['B', 'A', 'C', 'D'],
});
layer.color('type', ['red', 'white', 'blue', 'yellow']);
```

![L7 Cat ](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*kyP2RpUXdGUAAAAAAAAAAAAADmJ7AQ/original)

## Linear continuous linear

Linear is a mapping method for continuous data, where data and visual values ​​are calculated using linear methods. For example, if the data range domain \[0,1000] is linearly mapped to the range \[red, blue] gradient color, the one-to-one conversion is completed based on the linear function.

![L7 Scale 线性](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*Z_rGRr-jgI0AAAAAAAAAAAAADmJ7AQ/original')

```tsx
layer.color('rate', ['#ffffcc', '#b6e2b6', '#64c1c0', '#338cbb', '#253494'])
```

For continuous
Data L7 is set to linear by default, and domain is the min and max values ​​of the data. The color will generate a gradient color based on the range color. linear
The domain interval can not be set by default

```ts
layer.scale('value', {
  type: 'linear',
  domain: [5, 100], // The domain can be defined or not set. It can be calculated based on the data.
});
```

## quantize continuous equally spaced

Equally spaced classification is divided into several equal-sized subranges based on the attribute value range. Equal intervals work best with common data ranges, such as percentages and temperatures. This method emphasizes the amount of a certain attribute value relative to other values.

![L7 Scale 连续等间距](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*YmwwQ5L-d7QAAAAAAAAAAAAADmJ7AQ/original)

Equally spaced classification is only related to the data mix and max. If domain is not set, the min and max of the data will be automatically calculated for segmentation. The number of segments is based on the number of range colors. Empty classes will appear at equal intervals, and each classification element will be unevenly distributed.

```tsx
layer.color('type', ['red', 'white', 'blue', 'yellow']);
```

You can also customize the domain

```ts
layer.scale('value', {
  type: 'quantize',
  domain: [5, 100],
});

layer.color('type', ['red', 'white', 'blue', 'yellow']);
```

![L7 scale quantize](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*N61_Q6-U7jIAAAAAAAAAAAAADmJ7AQ/original)

## quantile continuous equal quantiles

Equiquantiles require that each classification interval contains an equal number of features. Quantiles assign an equal number of data values ​​to each category; there are no empty classes or classes with too many or too few values.

![L7 scale quantile](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*2SFpSLRD3yYAAAAAAAAAAAAADmJ7AQ/original)

The decile is related to the distribution of the data and needs to be calculated in full amount of data. Therefore, the scale of the decile cannot be set separately and can only be calculated automatically.

```tsx
layer.scale('value', {
  type: 'quantile',
});

layer.color('value', ['red', 'white', 'blue', 'yellow']);
```

![L7 Scale quantile](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*EMcjSrYe1l0AAAAAAAAAAAAADmJ7AQ/original)

## threshold custom classification

Custom classification can set any classification interval to map to the visual variable. The domain is still contiguous and classified according to the provided domain. The range attribute must have N+1 elements, where N is the number of domains.

Threshold is a custom segment. When using it, you must set the domain for Scale. The domain can be set arbitrarily according to your needs.

```tsx
layer.scale('rate', {
          type: 'threshold',
          domain: [3, 6, 8, 10],
        })
        .color('rate', ['#ffffcc', '#b6e2b6', '#64c1c0', '#338cbb', '#253494'])
```

![ L7 Scale threshold](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*e1YyRKELsjwAAAAAAAAAAAAADmJ7AQ/original)

## diverging discrete classification

Discrete classification is often used with two opposite hues to show the change from negative values ​​to center to positive values. These types of maps show the magnitude of values ​​in relation to each other.

![L7 diverging](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*8anRRLJNu6YAAAAAAAAAAAAADmJ7AQ/original)

If diverging does not set the domain, it will automatically calculate the three values ​​of min, middle, and max based on the data as the domain. Range needs to set at least three colors to form a bipolar color band.

```ts
layer.scale('rate', {
         type: 'diverging'
         domain: [3, 6, 8, 10], //  the input domain and output range of a diverging scal
       })
       .color('rate', ['#ffffcc', '#b6e2b6', '#64c1c0', '#338cbb', '#253494'])
```

![L7 scale diverging](https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*4rcDQIRdRdEAAAAAAAAAAAAADmJ7AQ/original)
---
title: Raster Tile
order: 1
---

<embed src="@/docs/common/style.md"></embed>

Raster tile layers include image rasters and data rasters, where image rasters are usually loaded`png/jpg`Images, data rasters are loaded`tiff/lerc`and other raster data files.

### Draw picture raster - TMS

```javascript
// Image tile layer - satellite image
const layer = new RasterLayer().source(
  'http://webst0{1-4}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
  {
    parser: {
      type: 'rasterTile',
      updateStrategy: 'overlap',
    },
  },
);
```

### Draw image raster - WMS

```javascript
// Draw WMS format tiles
const url =
  'https://pnr.sz.gov.cn/d-suplicmap/dynamap_1/rest/services/LAND_CERTAIN/MapServer/export?F=image&FORMAT=PNG32&TRANSPARENT=true&layers=show:1&SIZE=256,256&BBOX={bbox}&BBOXSR=4326&IMAGESR =3857&DPI=90';

const layer = new RasterLayer().source(url, {
  parser: {
    type: 'rasterTile',
    tileSize: 256,
    zoomOffset: 1,
  },
});
```

### Draw picture raster - WMTS

```javascript
// Draw WMTS format tiles
const url1 =
  'https://t0.tianditu.gov.cn/img_w/wmts?tk=b72aa81ac2b3cae941d1eb213499e15e&';
const layer1 = new RasterLayer().source(url1, {
  parser: {
    type: 'rasterTile',
    tileSize: 256,
    wmtsOptions: {
      layer: 'img',
      tileMatrixset: 'w',
      format: 'tiles',
    },
  },
});
```

### Draw data raster - arraybuffer

```javascript
const tileSource = new Source(
  'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',
  {
    parser: {
      type: 'rasterTile',
      dataType: 'arraybuffer',
      tileSize: 256,
      maxZoom: 13.1,
      format: async (data) => {
        const tiff = await GeoTIFF.fromArrayBuffer(data);
        const image = await tiff.getImage();
        const width = image.getWidth();
        const height = image.getHeight();
        const values = await image.readRasters();
        return { rasterData: values[0], width, height };
      },
    },
  },
);

layer.source(tileSource).style({
  domain: [0.001, 11.001],
  clampLow: false,
  rampColors: {
    colors: colorList,
    positions,
  },
});
```

### Plot data raster - rgb

```javascript
const url = 'https://gw.alipayobjects.com/zos/raptor/1667832825992/LC08_3857_clip_2.tif';
const tiffdata = await getTiffData(url);
const layer = new RasterLayer({ zIndex: 10 })
  .source([
      {
        data: tiffdata,
        bands: [7, 6, 5].map((v) => v - 1),
      },
    ],
    {
      parser: {
        type: 'rasterRgb',
        format: async (data, bands) => {
          const tiff = await GeoTIFF.fromArrayBuffer(data);
          const image1 = await tiff.getImage();
          const value = await image1.readRasters();
          return bands.map((band) => {
            return {
              rasterData: value[band],
              width: value.width,
              height: value.height,
            };
          });
        },
        operation: 'rgb',
        extent: [
          130.39565357746957,
          46.905730725742366,
          130.73364094187343,
          47.10217234153133,
        ],
      },
    },
  )
```
---
title: 栅格瓦片
order: 1
---
<embed src="@/docs/common/style.md"></embed>

栅格瓦片图层包括图片栅格和数据栅格，其中图片栅格通常加载 `png/jpg` 图片，数据栅格则加载 `tiff/lerc` 等栅格数据文件.

### 绘制图片栅格 - TMS

```javascript
// 图片瓦片图层 - 卫星图
const layer = new RasterLayer().source(
  'http://webst0{1-4}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
  {
    parser: {
      type: 'rasterTile',
      updateStrategy: 'overlap',
    },
  },
);
```

### 绘制图片栅格 - WMS

```javascript
// 绘制 WMS 格式瓦片
const url =
  'https://pnr.sz.gov.cn/d-suplicmap/dynamap_1/rest/services/LAND_CERTAIN/MapServer/export?F=image&FORMAT=PNG32&TRANSPARENT=true&layers=show:1&SIZE=256,256&BBOX={bbox}&BBOXSR=4326&IMAGESR=3857&DPI=90';

const layer = new RasterLayer().source(url, {
  parser: {
    type: 'rasterTile',
    tileSize: 256,
    zoomOffset: 1,
  },
});
```

### 绘制图片栅格 - WMTS

```javascript
// 绘制 WMTS 格式瓦片
const url1 =
  'https://t0.tianditu.gov.cn/img_w/wmts?tk=b72aa81ac2b3cae941d1eb213499e15e&';
const layer1 = new RasterLayer().source(url1, {
  parser: {
    type: 'rasterTile',
    tileSize: 256,
    wmtsOptions: {
      layer: 'img',
      tileMatrixset: 'w',
      format: 'tiles',
    },
  },
});
```

### 绘制数据栅格 - arraybuffer

```javascript
const tileSource = new Source(
  'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',
  {
    parser: {
      type: 'rasterTile',
      dataType: 'arraybuffer',
      tileSize: 256,
      maxZoom: 13.1,
      format: async (data) => {
        const tiff = await GeoTIFF.fromArrayBuffer(data);
        const image = await tiff.getImage();
        const width = image.getWidth();
        const height = image.getHeight();
        const values = await image.readRasters();
        return { rasterData: values[0], width, height };
      },
    },
  },
);

layer.source(tileSource).style({
  domain: [0.001, 11.001],
  clampLow: false,
  rampColors: {
    colors: colorList,
    positions,
  },
});
```

### 绘制数据栅格 - rgb

```javascript
const url = 'https://gw.alipayobjects.com/zos/raptor/1667832825992/LC08_3857_clip_2.tif';
const tiffdata = await getTiffData(url);
const layer = new RasterLayer({ zIndex: 10 })
  .source([
      {
        data: tiffdata,
        bands: [7, 6, 5].map((v) => v - 1),
      },
    ],
    {
      parser: {
        type: 'rasterRgb',
        format: async (data, bands) => {
          const tiff = await GeoTIFF.fromArrayBuffer(data);
          const image1 = await tiff.getImage();
          const value = await image1.readRasters();
          return bands.map((band) => {
            return {
              rasterData: value[band],
              width: value.width,
              height: value.height,
            };
          });
        },
        operation: 'rgb',
        extent: [
          130.39565357746957,
          46.905730725742366,
          130.73364094187343,
          47.10217234153133,
        ],
      },
    },
  )
```---
title: 瓦片
order: 0
---
<embed src="@/docs/common/style.md"></embed>

瓦片图层相比于普通的图层而言，在使用上有许多需要注意的地方。
### option

在初始化瓦片的时候，除了普通图层支持的 `options` 参数之外，还需要需要我们提前设置矢量数据相关的参数。
- `featureId`: string
  - 用于可以自定义指定。用于指定瓦片的拾取高亮。
- `sourceLayer`: string
  - 用于必须传入，且要在返回的矢量数据中存在，指定绘制矢量数据中那一图层数据。

```javascript
const layer = new RasterLayer({
  featureId: 'id',
  sourceLayer: 'water',
});
```

#### Mask

瓦片图层的掩模使用和普通的图层一样，同样在 `options` 中设置 `mask、maskfence` 参数即可，不过矢量瓦片图层暂时不支持设置掩模。

```js
 fetch('https://gw.alipayobjects.com/os/bmw-prod/fccd80c0-2611-49f9-9a9f-e2a4dd12226f.json')
  .then(res => res.json())
  .then(maskData => {
    const layer = new RasterLayer({
      mask: true,
      maskfence: maskData
    });
    
    const tileSource = new Source('https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',{
        parser: {
          type: 'rasterTile',
          dataType: 'arraybuffer',
          tileSize: 256,
          maxZoom: 13.1,
          format: async data => {
            const tiff = await GeoTIFF.fromArrayBuffer(data);
            const image = await tiff.getImage();
            const width = image.getWidth();
            const height = image.getHeight();
            const values = await image.readRasters();
            return { rasterData: values[0], width, height };
          }
        }
      });
    layer.source(tileSource)
      .style({
        domain: [ 0.001, 11.001 ],
        clampLow: false,
        rampColors: {
          colors: colorList,
          positions
        }
      });
    scene.addLayer(layer);
  });
```

### source

在有些场景下，尤其是是矢量瓦片地图的场景，同一份瓦片数据会同时包含多图层的数据，此时我们需要让多图层复用同一个 `source` 对象。如下图所示，我们使用同一份数据绘制省市的面、边界和名称，此时我们就应该复用 `source` 对象。

<img width="80%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*cMFMTqF7WoIAAAAAAAAAAAAAARQnAQ'>

```javascript
  const tileSource = new Source(
    'http://localhost:3000/file.mbtiles/{z}/{x}/{y}.pbf',
    {
      parser: {
        type: 'mvt',
        tileSize: 256,
        zoomOffset: 0,
        maxZoom: 9,
        extent: [-180, -85.051129, 179, 85.051129],
      },
    });
  const option = {
    featureId: 'NAME_CHN',
    sourceLayer: 'city'
  }
  const linelayer = new LineLayer(option)
    .source(tileSource)
    .color('#f00')
    .size(1)
    .style({
      opacity: 0.5,
    });
  this.scene.addLayer(linelayer);

  const polygonlayer = new PolygonLayer(option)
    .source(tileSource)
    .color('citycode', (v: string) => {
        return getRandomColor(v);
      }
    })
    .style({
      opacity: 0.4,
    })
    .select(true);
  this.scene.addLayer(polygonlayer);

  const pointlayer = new PointLayer(option)
    .source(tileSource)
    .shape('NAME_CHN', 'text')
    .color('#f00')
    .size(12)
    .style({
      stroke: '#fff',
      strokeWidth: 2,
    });

  this.scene.addLayer(pointlayer);
```
### event

在使用上，瓦片图层绑定事件的操作和普通图层事件保持一致，但是在事件的返回参数中，瓦片图层对分布的数据进行合并操作，以求获取到当前图层的完整数据。

```javascript
layer.on('click', e => {...})；
```---
title: Tile
order: 0
---

<embed src="@/docs/common/style.md"></embed>

Compared with ordinary layers, tile layers have many things to pay attention to when using them.

### option

When initializing tiles, in addition to those supported by ordinary layers`options`In addition to parameters, we also need to set parameters related to vector data in advance.

* `featureId`: string
  * For customizable designation. Used to specify the pick highlight of the tile.
* `sourceLayer`: string
  * It must be passed in and must exist in the returned vector data to specify which layer data in the vector data to draw.

```javascript
const layer = new RasterLayer({
  featureId: 'id',
  sourceLayer: 'water',
});
```

#### Mask

The mask of the tile layer is the same as that of the ordinary layer.`options`Medium settings`mask、maskfence`Parameters are enough, but the vector tile layer does not support setting masks for the time being.

```js
fetch('https://gw.alipayobjects.com/os/bmw-prod/fccd80c0-2611-49f9-9a9f-e2a4dd12226f.json')
  .then(res => res.json())
  .then(maskData => {
    const layer = new RasterLayer({
      mask: true,
      maskfence: maskData
    });
    
    const tileSource = new Source('https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',{
        parser: {
          type: 'rasterTile',
          dataType: 'arraybuffer',
          tileSize: 256,
          maxZoom: 13.1,
          format: async data => {
            const tiff = await GeoTIFF.fromArrayBuffer(data);
            const image = await tiff.getImage();
            const width = image.getWidth();
            const height = image.getHeight();
            const values = await image.readRasters();
            return { rasterData: values[0], width, height };
          }
        }
      });
    layer.source(tileSource)
      .style({
        domain: [ 0.001, 11.001 ],
        clampLow: false,
        rampColors: {
          colors: colorList,
          positions
        }
      });
    scene.addLayer(layer);
  });
```

### source

In some scenarios, especially those involving vector tile maps, the same tile data will contain data from multiple layers at the same time. In this case, we need to reuse the same tile for multiple layers.`source`object. As shown in the figure below, we use the same data to draw the areas, boundaries and names of provinces and cities. At this time we should reuse`source`object.

<img width="80%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*cMFMTqF7WoIAAAAAAAAAAAAAARQnAQ'>

```javascript
const tileSource = new Source(
    'http://localhost:3000/file.mbtiles/{z}/{x}/{y}.pbf',
    {
      parser: {
        type: 'mvt',
        tileSize: 256,
        zoomOffset: 0,
        maxZoom: 9,
        extent: [-180, -85.051129, 179, 85.051129],
      },
    });
  const option = {
    featureId: 'NAME_CHN',
    sourceLayer: 'city'
  }
  const linelayer = new LineLayer(option)
    .source(tileSource)
    .color('#f00')
    .size(1)
    .style({
      opacity: 0.5,
    });
  this.scene.addLayer(linelayer);

  const polygonlayer = new PolygonLayer(option)
    .source(tileSource)
    .color('citycode', (v: string) => {
        return getRandomColor(v);
      }
    })
    .style({
      opacity: 0.4,
    })
    .select(true);
  this.scene.addLayer(polygonlayer);

  const pointlayer = new PointLayer(option)
    .source(tileSource)
    .shape('NAME_CHN', 'text')
    .color('#f00')
    .size(12)
    .style({
      stroke: '#fff',
      strokeWidth: 2,
    });

  this.scene.addLayer(pointlayer);
```

### event

In use, the operation of the tile layer binding event is consistent with that of the ordinary layer event, but in the return parameters of the event, the tile layer merges the distributed data in order to obtain the completeness of the current layer. data.

```javascript
layer.on('click', e => {...})；
```
---
title: 矢量瓦片
order: 2
---
<embed src="@/docs/common/style.md"></embed>

矢量瓦片通常可以用于大数据量地理数据的渲染，借助瓦片的特性分布请求渲染数据，从而达到减少请求、加载时间的等待，优化使用体验的目的。同时，在不需要全量加载数据的场景下，通过矢量瓦片的形式可以在保证体验的前提下有效减少数据的渲染量，减少渲染压力。

### 绘制矢量瓦片 - point

```javascript
import { PointLayer } from '@antv/l7';
const point = new PointLayer({
  featureId: 'COLOR',
  sourceLayer: 'ecoregions2',
})
  .source(vectorSource)
  .shape('circle')
  .color('red')
  .size(10);
```

### 绘制矢量瓦片 - line

```javascript
import { LineLayer } from '@antv/l7';
const line = new LineLayer({
  featureId: 'COLOR',
  sourceLayer: 'ecoregions2',
})
  .source(vectorSource)
  .color('COLOR')
  .size(2);
```

### 绘制矢量瓦片 - polygon

```javascript
// 矢量瓦片图层
import { PolygonLayer } from '@antv/l7';
const polygon = new PolygonLayer({ 
  featureId: 'COLOR'，
  sourceLayer: 'ecoregions2',
})
.source(source)
.color('red');
```

### 绘制矢量瓦片 - 掩模图层

矢量掩模图层一般配合栅格图层使用，对栅格图层进行掩模处理。

```js
import { MaskLayer } from '@antv/l7';
const mask = new MaskLayer({sourceLayer: 'ecoregions2' })
.source( 'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/rs_l7/{z}/{x}/{y}.pbf' {
  parser: {
      type: 'mvt',
      maxZoom: 9,
      extent: [-180, -85.051129, 179, 85.051129],
  }});
```

### 绘制矢量瓦片 - 测试图层

```js
// 测试瓦片图层
const debugerLayer = new TileDebugLayer();
```---
title: Vector Tile
order: 2
---

<embed src="@/docs/common/style.md"></embed>

Vector tiles can usually be used to render large amounts of geographical data. The characteristics of tiles are used to distribute request rendering data, thereby reducing the waiting time of requests and loading times and optimizing the user experience. At the same time, in scenarios that do not require full loading of data, vector tiles can effectively reduce the amount of data rendering and reduce rendering pressure while ensuring the experience.

### Draw vector tiles - point

```javascript
import { PointLayer } from '@antv/l7';
const point = new PointLayer({
  featureId: 'COLOR',
  sourceLayer: 'ecoregions2',
})
  .source(vectorSource)
  .shape('circle')
  .color('red')
  .size(10);
```

### Draw vector tiles - line

```javascript
import { LineLayer } from '@antv/l7';
const line = new LineLayer({
  featureId: 'COLOR',
  sourceLayer: 'ecoregions2',
})
  .source(vectorSource)
  .color('COLOR')
  .size(2);
```

### Draw vector tiles - polygon

```javascript
// Vector tile layer
import { PolygonLayer } from '@antv/l7';
const polygon = new PolygonLayer({
  featureId: 'COLOR'，
  sourceLayer: 'ecoregions2',
})
.source(source)
.color('red');
```

### Draw vector tiles - mask layer

Vector mask layers are generally used in conjunction with raster layers to mask raster layers.

```js
import { MaskLayer } from '@antv/l7';
const mask = new MaskLayer({sourceLayer: 'ecoregions2' })
.source( 'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/rs_l7/{z}/{x}/{y}.pbf' {
  parser: {
      type: 'mvt',
      maxZoom: 9,
      extent: [-180, -85.051129, 179, 85.051129],
  }});
```

### Draw vector tiles - test layer

```js
//Test tile layer
const debugerLayer = new TileDebugLayer();
```
---
title: FAQ
order: 16
---

<embed src="@/docs/common/style.md"></embed>

### 项目中 L7 各个依赖包版本不一致导致报错

```js
Error: Cannot apply @injectable decorator multiple times.
```

<img height="300px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BsMyRZDuB54AAAAAAAAAAAAAARQnAQ'>

🌟 解决方法：  
删除 `node_modules` 下所有不同版本的 `L7` 包，重新安装启动即可。

### 禁止地图交互

1. 初始化的时候可以在 `map` 配置项设置

- 高德地图可查看 https://lbs.amap.com/api/javascript-api/reference/map
- mapbox https://docs.mapbox.com/mapbox-gl-js/api/#map

2. 加载完成后设置
   调用 `scene` 的 [setMapStatus](/api/scene/scene/#setmapstatus) 方法

### webcontext lost
1. 浏览器存在 `webgl` 实例上限，一般浏览器为 16 个，因此浏览器中可以存在的地图实例是有限的。
2. 在销毁地图后需要调用 `scene.destroy();` 对 `webgl` 实例进行销毁。
---
title: FAQ
order: 16
---

<embed src="@/docs/common/style.md"></embed>

### Inconsistent versions of each dependent package of L7 in the project lead to error reporting

```js
Error: Cannot apply @injectable decorator multiple times.
```

<img height="300px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BsMyRZDuB54AAAAAAAAAAAAAARQnAQ'>

🌟Solution:\
delete`node_modules`Download all different versions of`L7`package, reinstall and start.

### Disable map interaction

1. During initialization, you can`map`Configuration item settings

* Gaode map can be viewed<https://lbs.amap.com/api/javascript-api/reference/map>
* mapbox <https://docs.mapbox.com/mapbox-gl-js/api/#map>

2. Set after loading is complete
   transfer`scene`of[setMapStatus](/api/scene/scene/#setmapstatus)method

### webcontext lost

1. Browser exists`webgl`The upper limit of instances is 16 in general browsers, so the number of map instances that can exist in the browser is limited.
2. Need to be called after destroying the map`scene.destroy();`right`webgl`The instance is destroyed.
---
title: Introduction
order: 0
description:  L7 地理空间数据可视分析引擎
keywords: 可视化核心特性
---

<embed src="@/docs/common/style.md"></embed>

# L7 geospatial data visual analysis engine

✨ 2022.11.22 Version 2.11.0 officially released

⚠️ We will continue to follow up on user needs for version 1.x[Old version official website address](https://antv-2018.alipay.com/zh-cn/l7/1.x/index.html)

L7 is an open source large-scale geospatial data visual analysis development framework based on WebGL launched by Ant Financial’s AntV data visualization team. The L in L7 stands for Location, and 7 represents the seven continents of the world, implying the ability to provide visual analysis of global location data. L7 is based on graphic semiotics, converting abstract and complex spatial data into 2D and 3D symbols, and achieving rich visual expression through visual variables such as color, size, volume, and texture.

<video id="video" style="display: block;margin: 0 auto;" width="800px" height="600px" controls="" preload="none" poster="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*rjkiQLCoZxUAAAAAAAAAAABkARQnAQ">
<source id="mp4" src="https://gw.alipayobjects.com/mdn/antv_site/afts/file/A*viKwSJl2OGIAAAAAAAAAAABkARQnAQ"; type="video/map4">
      <source id="webm" src="https://gw.alipayobjects.com/os/basement_prod/65d5dbe8-d78d-4c6b-9318-fa06b1456784.webm" type="video/webm">
      <source id="ogv" src="https://media.w3.org/2010/05/sintel/trailer.ogv" type="video/ogg">
<p>Your user agent does not support the HTML5 Video element.</p>
</video>

## Core features

🌏 Data-driven visual display

Data-driven, from numbers to shapes, it supports a variety of map visualization types to gain better insight into data.

🌏 2D, 3D integrated massive data high-performance rendering

Real-time, dynamic rendering of millions of spatial data.

🌏 Simple and flexible data access

Supports CSV, JSON, geojson and other data format access, and can customize data formats according to needs without complex spatial data conversion.

🌏 Support multiple map basemaps and support offline intranet deployment

Amap is a legal and compliant geographical base map in China, and Mapbox meets the needs of international business.

## Supports rich chart types

### point layer

* bubble chart
* Scatter plot
* symbolic map
* 3D column map
* aggregate map
* composite chart map
* Custom Marker

### line layer

* Route map
* Arc, supports 2D arc, 3D arc and great circle route
* Contour

### polygon layer

* fill chart
* 3D fill plot

### Heat layer

* Classic heat map
* Cellular heat map
* Grid heat map

### raster layer

* picture
* Raster

### Tile map

* grid tiles
* vector tiles

### Technical support service group

For more technical details and detailed progress, please pay attention[GitHub](https://github.com/antvis/L7), everyone is welcome to give a little star, so that more people can see this open source project.

We will respond promptly to L7 related technical issues and demand feedback.

We will respond promptly to L7 related technical issues and demand feedback. Geospatial Visualization L7 Support Group DingTalk Group

* Group number 1: 30460926 (Nearly full)
* Group number 2: 32292906 (full)
* Group number 3: 1935013288
* WeChat group: Add WeChat ID: think-gis to join the group Remarks L7 Invite to join the group
---
title: 简介
order: 0
description:  L7 地理空间数据可视分析引擎
keywords: 可视化核心特性
---

<embed src="@/docs/common/style.md"></embed>

# L7 地理空间数据可视分析引擎

✨ 2022.11.22 2.11.0 版本正式发布

⚠️ 1.x 版本的用户需求我们持续跟进 [旧版官网地址](https://antv-2018.alipay.com/zh-cn/l7/1.x/index.html)

L7 是由蚂蚁金服 AntV 数据可视化团队推出的基于 WebGL 的开源大规模地理空间数据可视分析开发框架。L7 中的 L 代表 Location，7 代表世界七大洲，寓意能为全球位置数据提供可视分析的能力。L7 以图形符号学为理论基础，将抽象复杂的空间数据转化成 2D、3D 符号，通过颜色、大小、体积、纹理等视觉变量实现丰富的可视化表达。

<video id="video" style="display: block;margin: 0 auto;" width="800px" height="600px" controls="" preload="none" poster="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*rjkiQLCoZxUAAAAAAAAAAABkARQnAQ">
<source id="mp4" src="https://gw.alipayobjects.com/mdn/antv_site/afts/file/A*viKwSJl2OGIAAAAAAAAAAABkARQnAQ"; type="video/map4">
      <source id="webm" src="https://gw.alipayobjects.com/os/basement_prod/65d5dbe8-d78d-4c6b-9318-fa06b1456784.webm" type="video/webm">
      <source id="ogv" src="https://media.w3.org/2010/05/sintel/trailer.ogv" type="video/ogg">
<p>Your user agent does not support the HTML5 Video element.</p>
</video>

## 核心特性

🌏 数据驱动可视化展示

数据驱动，从数到形，支持丰富的地图可视化类型，更好洞察数据。

🌏 2D，3D 一体化的海量数据高性能渲染

百万级空间数据实时，动态渲染。

🌏 简单灵活的数据接入

支持 CSV，JSON，geojson 等数据格式接入，可以根据需求自定义数据格式，无需复杂的空间数据转换。

🌏 多地图底图支持，支持离线内网部署

高德地图国内合法合规的地理底图，Mapbox 满足国际化业务需求。

## 支持丰富的图表类型

### 点图层

- 气泡图
- 散点图
- 符号地图
- 3D 柱状地图
- 聚合地图
- 复合图表地图
- 自定义 Marker

### 线图层

- 路径地图
- 弧线，支持 2D 弧线、3D 弧线以及大圆航线
- 等值线

### 面图层

- 填充图
- 3D 填充图

### 热力图层

- 经典热力图
- 蜂窝热力图
- 网格热力图

### 栅格图层

- 图片
- Raster

### 瓦片地图

- 栅格瓦片
- 矢量瓦片

### 技术支持服务群

更多技术细节，详细进展，请关注 [GitHub](https://github.com/antvis/L7)，欢迎大家来给点点 Star，让更多人看到这个开源的项目。

L7 相关技术问题，需求反馈，可在 [GitHub Issue 区反馈]（https://github.com/antvis/L7/issues），我们会及时响应。 

同时我们还提供用户交流群

- 群号 3：1935013288
- 微信群：加微信号：antv2030 入群 备注 L7 邀请进群


---
title: Leaflet 地图
order: 2
---
<embed src="@/docs/common/style.md"></embed>

`L7` 通过提供插件的形式实现了对 `Leaflet` 的支持，实现 `Leaflet` 地图和 `L7` 可视化图层的融合。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*lkWkTpJjPlYAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### L7-Leaflet

- `L7-Leaflet` 是对外开源的插件 [github 地址](https://github.com/antvis/L7-Leaflet)

### 安装

#### npm
```bash
 npm install  @antv/l7-leaflet
```

#### cdn
```javascript
<script src="https://unpkg.com/@antv/l7-leaflet"></script>
```

### 使用

#### L7 plugin for Lealfet use in Leaflet

```js
import * as L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import { LineLayer } from '@antv/l7';
import { L7Layer } from '@antv/l7-leaflet';

import React, { useEffect } from 'react';

export default () => {
  useEffect(() => {
    const map = L.map('map', {
      minZoom: 1,
    }).setView([30, 112], 3);
    const mapType = 'vec';
    L.tileLayer(
      'https://t{s}.tianditu.gov.cn/' +
        mapType +
        '_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=' +
        mapType +
        '&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILECOL={x}&TILEROW={y}&TILEMATRIX={z}&tk=b72aa81ac2b3cae941d1eb213499e15e',
      {
        subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
        attribution:
          '&copy; <a href="http://lbs.tianditu.gov.cn/home.html">天地图 GS(2022)3124号 - 甲测资字1100471</a>',
      },
    ).addTo(map);
    const mapLabelType = 'cva';
    L.tileLayer(
      'https://t{s}.tianditu.gov.cn/' +
        mapLabelType +
        '_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=' +
        mapLabelType +
        '&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILECOL={x}&TILEROW={y}&TILEMATRIX={z}&tk=b72aa81ac2b3cae941d1eb213499e15e',
      {
        subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
      },
    ).addTo(map);

    L.marker([30, 112])
      .addTo(map)
      .setIcon(
        new L.Icon({
          iconUrl:
            'https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*6ONoRKNECC0AAAAAAAAAAAAAARQnAQ',
          iconSize: [16, 16],
        }),
      )
      .bindPopup('A pretty CSS3 popup.<br> Easily customizable.')
      .openPopup();

    const l7layer = new L7Layer().addTo(map);
    const scene = l7layer.getScene();
    fetch('https://gw.alipayobjects.com/os/rmsportal/UEXQMifxtkQlYfChpPwT.txt')
      .then((res) => res.text())
      .then((data) => {
        const layer = new LineLayer({})
          .source(data, {
            parser: {
              type: 'csv',
              x: 'lng1',
              y: 'lat1',
              x1: 'lng2',
              y1: 'lat2',
            },
          })
          .size(1)
          .shape('arc')
          .color('#8C1EB2')
          .style({
            opacity: 0.8,
            blur: 0.99,
          });
        scene.addLayer(layer);
      });
  }, []);

  return (
    <div
      id="map"
      style={{
        height: '500px',
        position: 'relative',
      }}
    />
  );
};
```

#### Leafet BaseMap for L7 use in L7

```js
import * as L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import { LineLayer } from '@antv/l7';
import { L7Layer } from '@antv/l7-leaflet';
import React, { useEffect } from 'react';

export default () => {
  useEffect(() => {
    const map = L.map('map', {
      minZoom: 1,
    }).setView([30, 112], 3);
    const mapType = 'vec';
    L.tileLayer(
      'https://t{s}.tianditu.gov.cn/' +
        mapType +
        '_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=' +
        mapType +
        '&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILECOL={x}&TILEROW={y}&TILEMATRIX={z}&tk=b72aa81ac2b3cae941d1eb213499e15e',
      {
        subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
        attribution:
          '&copy; <a href="http://lbs.tianditu.gov.cn/home.html">天地图 GS(2022)3124号 - 甲测资字1100471</a>',
      },
    ).addTo(map);
    const mapLabelType = 'cva';
    L.tileLayer(
      'https://t{s}.tianditu.gov.cn/' +
        mapLabelType +
        '_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=' +
        mapLabelType +
        '&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILECOL={x}&TILEROW={y}&TILEMATRIX={z}&tk=b72aa81ac2b3cae941d1eb213499e15e',
      {
        subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
      },
    ).addTo(map);

    L.marker([30, 112])
      .addTo(map)
      .setIcon(
        new L.Icon({
          iconUrl:
            'https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*6ONoRKNECC0AAAAAAAAAAAAAARQnAQ',
          iconSize: [16, 16],
        }),
      )
      .bindPopup('A pretty CSS3 popup.<br> Easily customizable.')
      .openPopup();

    const l7layer = new L7Layer().addTo(map);
    const scene = l7layer.getScene();
    fetch('https://gw.alipayobjects.com/os/rmsportal/UEXQMifxtkQlYfChpPwT.txt')
      .then((res) => res.text())
      .then((data) => {
        const layer = new LineLayer({})
          .source(data, {
            parser: {
              type: 'csv',
              x: 'lng1',
              y: 'lat1',
              x1: 'lng2',
              y1: 'lat2',
            },
          })
          .size(1)
          .shape('arc')
          .color('#8C1EB2')
          .style({
            opacity: 0.8,
            blur: 0.99,
          });
        scene.addLayer(layer);
      });
  }, []);

  return (
    <div
      id="map"
      style={{
        height: '500px',
        position: 'relative',
      }}
    />
  );
};
```
---
title: Use Offline
order: 0
---

<embed src="@/docs/common/style.md"></embed>

at present`L7`Support Gao Dehe`Mapbox`Two base maps, the Amap map is used online`API`Offline deployment is not possible. If you have offline deployment requirements, you can use it.`MapBox`Make a base map.`L7`The interface layer unifies the direct differences between different basemaps, and a set of visualization codes can be run on`L7`On any supported basemap. This article mainly introduces how to use it offline and accelerate its use in China.`MapBox`, and also provides online font services, which you can also download for local use.

### How to introduce Mapbox in L7

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { Mapbox } from '@antv/l7-maps';
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'dark',
    center: [ 103.83735604457024, 1.360253881403068 ],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313,
    token:'xxxx'
  })
});
```

### Why go offline

* Offline deployment
* Domestic acceleration
* Do not use`mapbox token`

### How to use MapBox offline

As long as you don't use`MapBox`The data base map service can be used offline.`mapbox`All data service resources are in`style`configured inside. In addition to data services, there are also some static resources, which are mainly used for image annotation and text annotation.

`mapbox`If the data resources themselves are deployed and used separately in foreign countries, the loading speed experience is still very good.

Let's find out first`MapBox`What configuration items the style contains.

#### Mapbox style parameters

* `version`：`JS SDK`The corresponding version must be 8.
* `name`: The naming of the style.
* `sprite`: Sprite map, which contains all the sporadic icon images involved in a map into one large image.
* `glyphs`：`.pbf`Format font style, such as Microsoft Yahei and other font libraries.
* `sources`: The resource file of the layer, which can support vector slices, raster,`dem`raster, picture,`geojson`, video and other formats.
* `layers`: It is a description of each layer style. This is the key to rendering the map style. You can customize the map style.

Specific parameters and their`api`Can refer to`mapbox`official website.

If you want to achieve localization, you only need`sprite`，`glyphs`Localization is fine, and the map service can load other services.

If you don't need to use`MapBox`Data service, used to complete the visualization layer`L7`Rendering is even simpler.

You just need to`MapBox`Map style settings`blank`。

```javascript
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'blank',
    center: [ 103.83735604457024, 1.360253881403068 ],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313
  })
});
```

`blank`The style is considered to be a baseless style, so there is no need to use it in this style.`mapbox`service, there is no need to use`mapbox`of`token`。

#### Localized sprite map

If you need to use`mapbox`For field image annotation, you need to localize sprite image resources<br />Just download two files<br />sprite.json mainly records the position of each chart on the big picture<br />sprite.png A big picture composed of each small icon

Online sprite service address:<br /><https://lzxue.github.io/font-glyphs/sprite/sprite>

#### localized fonts

If needed use`mapbox`The article annotation function needs to be localized. If your rendering capabilities are all using`L7`To achieve this, this process is also unnecessary.

`L7`Online font service provided<br />Currently supports 4 fonts.

* Alibaba inclusive body
* noto
* opensan
* roboto

*If you have new font requirements, you can submit a PR and we will automatically generate an online font service for you. You can use it online or download it for local use.*

Font service download:[gh-pages branch](https://github.com/lzxue/font-glyphs/tree/gh-pages) you can`clone`Come down and use it directly.

**You can also use online services**<br />github service<br /><https://lzxue.github.io/font-glyphs/glyphs/{fontstack}/{range}.pbf><br />Ant CDN:<br /><https://gw.alipayobjects.com/os/antvdemo/assets/mapbox/glyphs/{fontstack}/{range}.pbf>

#### Map service localization

1.Load[Third-party basemap](https://github.com/htoooth/Leaflet.ChineseTmsProviders), the raster tile layer is used as the base map, such as Sky Map, Amap,`google`Grid tiles are available<br />2.Download[opensteetmap ](https://openmaptiles.com/downloads/planet/)Vector tile map as base map<br />3. Publish base map service or vector tile service for your own business data.

**Here is a more complete solution**<br /> <https://jingsam.github.io/foxgis-server-lite/#/>

####

All service resources have been prepared so that we can use them independently`mapbox`Service, no need to apply again`mapbox`of`token`。

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { Mapbox } from '@antv/l7-maps';
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: {
      "version": 8,
        "name": "blank",
        "sprite": "https://lzxue.github.io/font-glyphs/sprite/sprite",
        "glyphs": "https://gw.alipayobjects.com/os/antvdemo/assets/mapbox/glyphs/{fontstack}/{range}.pbf",
          "sources": {},
          "layers": [
            {
              id: 'background',
              type: 'background',
              paint: {
                'background-color': 'white',
              },
            },
          ]
        },
    center: [ 103.83735604457024, 1.360253881403068 ],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313,
    token:'xxxx'
  })
});
```

[Offline, use mapbox demo without token](https://codesandbox.io/embed/frosty-architecture-tv6uv?fontsize=14\&hidenavigation=1\&theme=dark)<br />
---
title: Leaflet Map
order: 2
---

<embed src="@/docs/common/style.md"></embed>

`L7`Implemented by providing plug-ins`Leaflet`support, implementation`Leaflet`map and`L7`Fusion of visualization layers.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*lkWkTpJjPlYAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### L7-Leaflet

* `L7-Leaflet`It is an open source plug-in[github address](https://github.com/antvis/L7-Leaflet)

### Install

#### npm

```bash
npm install  @antv/l7-leaflet
```

#### cdn

```javascript
<script src="https://unpkg.com/@antv/l7-leaflet"></script>
```

### use

#### L7 plugin for Lealfet use in Leaflet

```js
import * as L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import { LineLayer } from '@antv/l7';
import { L7Layer } from '@antv/l7-leaflet';

import React, { useEffect } from 'react';

export default () => {
  useEffect(() => {
    const map = L.map('map', {
      minZoom: 1,
    }).setView([30, 112], 3);
    const mapType = 'vec';
    L.tileLayer(
      'https://t{s}.tianditu.gov.cn/' +
        mapType +
        '_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=' +
        mapType +
        '&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILECOL={x}&TILEROW={y}&TILEMATRIX={z}&tk=b72aa81ac2b3cae941d1eb213499e15e',
      {
        subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
        attribution:
          '© <a href="http://lbs.tianditu.gov.cn/home.html">天地图 GS(2022)3124号 - 甲测资字1100471</a>',
      },
    ).addTo(map);
    const mapLabelType = 'cva';
    L.tileLayer(
      'https://t{s}.tianditu.gov.cn/' +
        mapLabelType +
        '_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=' +
        mapLabelType +
        '&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILECOL={x}&TILEROW={y}&TILEMATRIX={z}&tk=b72aa81ac2b3cae941d1eb213499e15e',
      {
        subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
      },
    ).addTo(map);

    L.marker([30, 112])
      .addTo(map)
      .setIcon(
        new L.Icon({
          iconUrl:
            'https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*6ONoRKNECC0AAAAAAAAAAAAAARQnAQ',
          iconSize: [16, 16],
        }),
      )
      .bindPopup('A pretty CSS3 popup.<br> Easily customizable.')
      .openPopup();

    const l7layer = new L7Layer().addTo(map);
    const scene = l7layer.getScene();
    fetch('https://gw.alipayobjects.com/os/rmsportal/UEXQMifxtkQlYfChpPwT.txt')
      .then((res) => res.text())
      .then((data) => {
        const layer = new LineLayer({})
          .source(data, {
            parser: {
              type: 'csv',
              x: 'lng1',
              y: 'lat1',
              x1: 'lng2',
              y1: 'lat2',
            },
          })
          .size(1)
          .shape('arc')
          .color('#8C1EB2')
          .style({
            opacity: 0.8,
            blur: 0.99,
          });
        scene.addLayer(layer);
      });
  }, []);

  return (
    <div
      id="map"
      style={{
        height: '500px',
        position: 'relative',
      }}
    />
  );
};
```

#### Leafet BaseMap for L7 use in L7

```js
import * as L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import { LineLayer } from '@antv/l7';
import { L7Layer } from '@antv/l7-leaflet';
import React, { useEffect } from 'react';

export default () => {
  useEffect(() => {
    const map = L.map('map', {
      minZoom: 1,
    }).setView([30, 112], 3);
    const mapType = 'vec';
    L.tileLayer(
      'https://t{s}.tianditu.gov.cn/' +
        mapType +
        '_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=' +
        mapType +
        '&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILECOL={x}&TILEROW={y}&TILEMATRIX={z}&tk=b72aa81ac2b3cae941d1eb213499e15e',
      {
        subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
        attribution:
          '© <a href="http://lbs.tianditu.gov.cn/home.html">天地图 GS(2022)3124号 - 甲测资字1100471</a>',
      },
    ).addTo(map);
    const mapLabelType = 'cva';
    L.tileLayer(
      'https://t{s}.tianditu.gov.cn/' +
        mapLabelType +
        '_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=' +
        mapLabelType +
        '&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILECOL={x}&TILEROW={y}&TILEMATRIX={z}&tk=b72aa81ac2b3cae941d1eb213499e15e',
      {
        subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
      },
    ).addTo(map);

    L.marker([30, 112])
      .addTo(map)
      .setIcon(
        new L.Icon({
          iconUrl:
            'https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*6ONoRKNECC0AAAAAAAAAAAAAARQnAQ',
          iconSize: [16, 16],
        }),
      )
      .bindPopup('A pretty CSS3 popup.<br> Easily customizable.')
      .openPopup();

    const l7layer = new L7Layer().addTo(map);
    const scene = l7layer.getScene();
    fetch('https://gw.alipayobjects.com/os/rmsportal/UEXQMifxtkQlYfChpPwT.txt')
      .then((res) => res.text())
      .then((data) => {
        const layer = new LineLayer({})
          .source(data, {
            parser: {
              type: 'csv',
              x: 'lng1',
              y: 'lat1',
              x1: 'lng2',
              y1: 'lat2',
            },
          })
          .size(1)
          .shape('arc')
          .color('#8C1EB2')
          .style({
            opacity: 0.8,
            blur: 0.99,
          });
        scene.addLayer(layer);
      });
  }, []);

  return (
    <div
      id="map"
      style={{
        height: '500px',
        position: 'relative',
      }}
    />
  );
};
```
---
title: Use Offline
order: 0
---
<embed src="@/docs/common/style.md"></embed>

目前 `L7` 支持高德和 `Mapbox` 两种底图，高德地图由于使用在线 `API` 不能做离线部署，如果你有离线部署的需求可以采用 `MapBox`做底图。`L7` 在接口层统一了不同底图直接的差异，一套可视化代码可以运行在 `L7` 支持的任意底图上。本文主要介绍如何离线使用，国内加速使用 `MapBox`，同时也提供了在线的字体服务，你也可也下载到本地使用。

### L7 如何引入 Mapbox

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { Mapbox } from '@antv/l7-maps';
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'dark',
    center: [ 103.83735604457024, 1.360253881403068 ],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313,
    token:'xxxx'
  })
});
```
### 为什么离线化

- 离线部署
- 国内加速
- 不使用 `mapbox token`

### 如何离线化使用 MapBox

你只要不使用 `MapBox` 的数据底图服务就可以离线使用，`mapbox` 所有数据服务资源都是在 `style` 里面配置的。除了数据服务以外还有一些静态资源，这些主要是图片标注，文字标注的时候使用。    

`mapbox` 本身数据资源在国外如果在国内单独部署使用，加载速度体验还是很好的。   

我们先了解一下 `MapBox` 样式包含哪些配置项。    

#### Mapbox 样式参数

- `version`：`JS SDK` 对应版本必须为 8。
- `name`：样式的命名。
- `sprite`：雪碧图，将一个地图涉及到的所有零星图标图片都包含到一张大图中。
- `glyphs`：`.pbf` 格式的字体样式，例如微软雅黑等字体库。
- `sources`：图层的资源文件，可以支持矢量切片、栅格、`dem` 栅格、图片、`geojson`、视频等格式。
- `layers`：是对每个图层样式的描述，这里就是对地图样式渲染的关键，可以做定制化地图样式。

具体参数及其 `api` 可以参考 `mapbox` 官网。   

如果做到本地化只需要 `sprite`，`glyphs` 本地化就可以了，地图服务可以加载其他服务。    

如果你不需要使用 `MapBox` 数据服务，可视化层完成用 `L7` 渲染那就更简单了。

你只需要将 `MapBox` 的地图样式设置 `blank`。  

```javascript
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'blank',
    center: [ 103.83735604457024, 1.360253881403068 ],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313
  })
});
```

`blank` 样式以为无底图样式，这种样式下就不需要使用 `mapbox` 服务，也不需要使用 `mapbox` 的 `token`。   

#### 本地化雪碧图

如果你需要使用 `mapbox` 字段的图片标注，你需要本地化雪碧图资源<br />只需要下载两个文件即可<br />sprite.json 主要记录每个图表在大图上位置<br />sprite.png  每个小图标组成的大图

在线雪碧图服务地址:<br />[https://lzxue.github.io/font-glyphs/sprite/sprite](https://lzxue.github.io/font-glyphs/sprite/sprite)

#### 本地化字体

如果需要使用 `mapbox` 文章标注功能需要本地化，如果你的渲染能力都是用 `L7` 实现的，这个过程也是不需要的。    

`L7` 提供了在线字体服务<br /> 目前支持4种字体。

- 阿里巴巴普惠体
- noto
- opensan
- roboto

_如果你有新的字体需求可提PR，帮你自动生成在线可用的字体服务，你可以在线使用，也可以下载到本地使用。_

字体服务下载：[gh-pages分支](https://github.com/lzxue/font-glyphs/tree/gh-pages) 你可以 `clone` 下来直接使用。

**你也可以使用在线服务**<br />github服务<br />[https://lzxue.github.io/font-glyphs/glyphs/{fontstack}/{range}.pbf](https://lzxue.github.io/font-glyphs/glyphs/{fontstack}/{range}.pbf)<br />蚂蚁CDN：<br />[https://gw.alipayobjects.com/os/antvdemo/assets/mapbox/glyphs/{fontstack}/{range}.pbf](https://gw.alipayobjects.com/os/antvdemo/assets/mapbox/glyphs/{fontstack}/{range}.pbf)

#### 地图服务本地化

1.加载[第三方底图](https://github.com/htoooth/Leaflet.ChineseTmsProviders)，栅格瓦片图层做底图，如天地图，高德，`google` 的栅格瓦片都可以<br />
2.下载[opensteetmap ](https://openmaptiles.com/downloads/planet/)矢量瓦片地图做底图<br />
3.自己业务数据发布底图服务，或者矢量瓦片服务。

**这里还有个更完备的解决方案**<br /> [https://jingsam.github.io/foxgis-server-lite/#/](https://jingsam.github.io/foxgis-server-lite/#/)

#### 

所有的服务资源已经准备好了，这样我们就可以独立使用 `mapbox` 服务，不需要再申请 `mapbox` 的 `token`。

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { Mapbox } from '@antv/l7-maps';
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: {
      "version": 8,
        "name": "blank",
        "sprite": "https://lzxue.github.io/font-glyphs/sprite/sprite",
        "glyphs": "https://gw.alipayobjects.com/os/antvdemo/assets/mapbox/glyphs/{fontstack}/{range}.pbf",
          "sources": {},
          "layers": [
            {
              id: 'background',
              type: 'background',
              paint: {
                'background-color': 'white',
              },
            },
          ]
        },
    center: [ 103.83735604457024, 1.360253881403068 ],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313,
    token:'xxxx'
  })
});
```

[离线，无token使用mapbox demo](https://codesandbox.io/embed/frosty-architecture-tv6uv?fontsize=14&hidenavigation=1&theme=dark)<br />
---
title: No Map
order: 2
---

<embed src="@/docs/common/style.md"></embed>

In many cases we just do simple geographical visualization without loading a map. This tutorial will tell you how to use basemapless mode in L7.

* `L7`Added a baseless map style at the map style level`blank`No basemap mode.
* Do not need to use`mapbox token`, no need to register`mapbox`account.

```javascript
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'blank',
    center: [ 103.83735604457024, 1.360253881403068 ],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313
  })
});
```

🌟 If you just need to make a map of China and fill the world map like this, it is recommended that you use this mode.
---
title: 使用无底图模式
order: 2
---
<embed src="@/docs/common/style.md"></embed>

很多情况下我们只是做些简单的地理可视化，不需要加载地图，本教程就是告诉大家如果在L7中使用无底图模式。

- `L7` 在地图样式层面增加了无底图样式 `blank` 无底图模式。  
- 不需要使用 `mapbox token` ，也不需要注册 `mapbox` 账户。   

```javascript
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'blank',
    center: [ 103.83735604457024, 1.360253881403068 ],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313
  })
});
```
🌟 如果你只是需要做个中国地图，世界地图这样填充图，建议你采用这样的模式。
---
title: Tianditu
order: 2
---

`L7`Supports loading sky map tiles through tile layers.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*2_vQT6N8Ug8AAAAAAAAAAAAADmJ7AQ/original'>
  </div>
</div>

### accomplish

Below we will introduce how to quickly create a map of the sky.

```js
import { Scene, RasterLayer } from '@antv/l7';
import { Map } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new Map({
    center: [ 90.268, 40.3628 ],
    zoom: 3
  })
});
scene.on('loaded', () => {
  // 底图服务
  const baseLayer = new RasterLayer({ zIndex: 1 });
  .source(
    'https://t1.tianditu.gov.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}&tk=6557fd8a19b09d6e91ae6abf9d13ccbd',
    {
      parser: {
        type: 'rasterTile',
        tileSize: 256,
      }
    }
  );
  // 注记服务
  const annotionLayer = new RasterLayer({ zIndex: 2 });
  .source(
    'https://t1.tianditu.gov.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}&tk=6557fd8a19b09d6e91ae6abf9d13ccbd',
    {
      parser: {
        type: 'rasterTile',
        tileSize: 256,
      }
    }
  );
  scene.addLayer(baseLayer);
  scene.addLayer(annotionLayer);
});
```
---
title: MapBox Map
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Using Mapbox Maps

1\. Register MapBox token

Registered address[Mapbox Access Tokens](https://docs.mapbox.com/help/how-mapbox-works/access-tokens/#creating-and-managing-access-tokens)

2\. Introduce mapbox.gl JS and css

To use mapbox, you need to introduce mapbox separately.

```html
<link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel='stylesheet' />
  
  <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js'></script>
```

### Introducing L7

```html
<script src="https://unpkg.com/@antv/l7"></script>
```

#### Add a div tag to specify the map container

At the same time, you need to set the height and width of the Div.

```html
<div id="map"></div>
```

### Initialize L7 Scene

```javascript
const scene = new L7.Scene({
    id: 'map',
    map: new L7.Mapbox({
      style: 'dark', // 样式URL
      center: [120.19382669582967, 30.258134],
      pitch: 0,
      zoom: 12,
      token: 'mapbox token',
    }),
  });
```

In this way we have completed instantiating the mapbox map through L7

### Add visualization layer

```javascript
fetch('https://gw.alipayobjects.com/os/rmsportal/oVTMqfzuuRFKiDwhPSFL.json')
  .then(res => res.json())
  .then(data => {
    const pointLayer = new L7.PointLayer({})
      .source(data.list, {
        parser: {
          type: 'json',
          x: 'j',
          y: 'w'
        }
      })
      .shape('cylinder')
      .size('t', function(level) {
        return [ 1, 2, level * 2 + 20 ];
      })
      .color('t', [
        '#094D4A',
        '#146968',
        '#1D7F7E',
        '#289899',
        '#34B6B7',
        '#4AC5AF',
        '#5FD3A6',
        '#7BE39E',
        '#A1EDB8',
        '#CEF8D6'
      ])
      .style({
        opacity: 1.0
      });
    scene.addLayer(pointLayer);
  });
```

### Complete demo code

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>创建地图场景</title>
    <style> ::-webkit-scrollbar{display:none;}html,body{overflow:hidden;margin:0;}
    	#map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>
<div id="map"></div>
  <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel='stylesheet' />
  
  <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js'></script>
<script src="https://unpkg.com/@antv/l7"></script>
<script>
  const scene = new L7.Scene({
    id: 'map',
    map: new L7.Mapbox({
      style: 'dark', // 样式URL
      center: [120.19382669582967, 30.258134],
      pitch: 0,
      zoom: 12,
      token: 'mapbox token',
    }),
  });

fetch('https://gw.alipayobjects.com/os/rmsportal/oVTMqfzuuRFKiDwhPSFL.json')
  .then(res => res.json())
  .then(data => {
    const pointLayer = new L7.PointLayer({})
      .source(data.list, {
        parser: {
          type: 'json',
          x: 'j',
          y: 'w'
        }
      })
      .shape('cylinder')
      .size('t', function(level) {
        return [ 1, 2, level * 2 + 20 ];
      })
      .color('t', [
        '#094D4A',
        '#146968',
        '#1D7F7E',
        '#289899',
        '#34B6B7',
        '#4AC5AF',
        '#5FD3A6',
        '#7BE39E',
        '#A1EDB8',
        '#CEF8D6'
      ])
      .style({
        opacity: 1.0
      });
    scene.addLayer(pointLayer);
  });

</script>
</body>
</html>
```
---
title: MapBox 地图
order: 0
---
<embed src="@/docs/common/style.md"></embed>
## 使用Mapbox 地图

1、注册MapBox token

   注册地址 [Mapbox Access Tokens](https://docs.mapbox.com/help/how-mapbox-works/access-tokens/#creating-and-managing-access-tokens)

2、引入mapbox.gl JS 和 css

使用mapbox 需要单独引入 mapbox

```html
  <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel='stylesheet' />
  
  <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js'></script>
```


### 引入 L7 


```html
<script src="https://unpkg.com/@antv/l7"></script>
```


####  添加div 标签指定地图容器

同时需要为Div设置 高度和宽度

``` html
<div id="map"></div>
````

### 初始化 L7 Scene


```javascript
  const scene = new L7.Scene({
    id: 'map',
    map: new L7.Mapbox({
      style: 'dark', // 样式URL
      center: [120.19382669582967, 30.258134],
      pitch: 0,
      zoom: 12,
      token: 'mapbox token',
    }),
  });


```

这样我们就完成了通过L7 实例化mapbox地图


### 添加可视化图层



```javascript

fetch('https://gw.alipayobjects.com/os/rmsportal/oVTMqfzuuRFKiDwhPSFL.json')
  .then(res => res.json())
  .then(data => {
    const pointLayer = new L7.PointLayer({})
      .source(data.list, {
        parser: {
          type: 'json',
          x: 'j',
          y: 'w'
        }
      })
      .shape('cylinder')
      .size('t', function(level) {
        return [ 1, 2, level * 2 + 20 ];
      })
      .color('t', [
        '#094D4A',
        '#146968',
        '#1D7F7E',
        '#289899',
        '#34B6B7',
        '#4AC5AF',
        '#5FD3A6',
        '#7BE39E',
        '#A1EDB8',
        '#CEF8D6'
      ])
      .style({
        opacity: 1.0
      });
    scene.addLayer(pointLayer);
  });

  ```


### 完整demo 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>创建地图场景</title>
    <style> ::-webkit-scrollbar{display:none;}html,body{overflow:hidden;margin:0;}
    	#map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>
<div id="map"></div>
  <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel='stylesheet' />
  
  <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js'></script>
<script src="https://unpkg.com/@antv/l7"></script>
<script>
  const scene = new L7.Scene({
    id: 'map',
    map: new L7.Mapbox({
      style: 'dark', // 样式URL
      center: [120.19382669582967, 30.258134],
      pitch: 0,
      zoom: 12,
      token: 'mapbox token',
    }),
  });

fetch('https://gw.alipayobjects.com/os/rmsportal/oVTMqfzuuRFKiDwhPSFL.json')
  .then(res => res.json())
  .then(data => {
    const pointLayer = new L7.PointLayer({})
      .source(data.list, {
        parser: {
          type: 'json',
          x: 'j',
          y: 'w'
        }
      })
      .shape('cylinder')
      .size('t', function(level) {
        return [ 1, 2, level * 2 + 20 ];
      })
      .color('t', [
        '#094D4A',
        '#146968',
        '#1D7F7E',
        '#289899',
        '#34B6B7',
        '#4AC5AF',
        '#5FD3A6',
        '#7BE39E',
        '#A1EDB8',
        '#CEF8D6'
      ])
      .style({
        opacity: 1.0
      });
    scene.addLayer(pointLayer);
  });

</script>
</body>
</html>

```



---
title: 天地图
order: 2
---

`L7` 支持通过瓦片图层的方式来加载天地图瓦片。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*2_vQT6N8Ug8AAAAAAAAAAAAADmJ7AQ/original'>
  </div>
</div>

### 实现

下面我们来介绍如何快速创建天地图地图。

```js
import { Scene, RasterLayer } from '@antv/l7';
import { Map } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new Map({
    center: [ 90.268, 40.3628 ],
    zoom: 3
  })
});
scene.on('loaded', () => {
  // 底图服务
  const baseLayer = new RasterLayer({ zIndex: 1 });
  .source(
    'https://t1.tianditu.gov.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}&tk=6557fd8a19b09d6e91ae6abf9d13ccbd',
    {
      parser: {
        type: 'rasterTile',
        tileSize: 256,
      }
    }
  );
  // 注记服务
  const annotionLayer = new RasterLayer({ zIndex: 2 });
  .source(
    'https://t1.tianditu.gov.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}&tk=6557fd8a19b09d6e91ae6abf9d13ccbd',
    {
      parser: {
        type: 'rasterTile',
        tileSize: 256,
      }
    }
  );
  scene.addLayer(baseLayer);
  scene.addLayer(annotionLayer);
});

```---
title: Amap Plugin
order: 3
---

<embed src="@/docs/common/style.md"></embed>

When we use Gaode Map as the map base map, we can use the plug-in provided by Gaode Map to achieve our needs.

### AMap.LineSearch

* Road query

```javascript
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'blank',
    center: [ 103.83735604457024, 1.360253881403068 ],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313
  })
});
```

[Online case](/examples/amapplugin/bus#busstop)

### MP.Tulbar

* Map toolbar

```javascript
scene.on('loaded', () => {
  window.AMap.plugin([ 'AMap.ToolBar', 'AMap.LineSearch' ], () => {
    scene.map.addControl(new AMap.ToolBar());

    const linesearch = new AMap.LineSearch({
      pageIndex: 1, //Page number, default value is 1
      pageSize: 1, //The number of results displayed on a single page, the default value is 20, the maximum value is 50
      city: 'Beijing', // Limit the query city, which can be the city name (Chinese/Chinese full spelling), city code, the default value is "National"
      extensions: 'all' // Whether to return bus route details, the default value is "base"
    });
```

[Online case](/examples/amapplugin/bus#busstop)

### AMap.TileLayer

* load using`xyz`map tiles

```javascript
scene.on('loaded', () => {
  var xyzTileLayer = new window.AMap.TileLayer({
    getTileUrl:
      'https://wprd0{1,2,3,4}.is.autonavi.com/appmaptile?x=[x]&y=[y]&z=[z]&size=1&scl=1&style=8&ltype=11',
    zIndex: 100,
  });
  scene.map.add(xyzTileLayer);
});
```

[Online case](/examples/amapplugin/bus#xyztile)

### AMap.TileLayer.Satellite

* Load using default satellite tiles

```javascript
scene.on('loaded', () => {
    scene.map.add(new window.AMap.TileLayer.Satellite());
});
```

[Online case](/examples/amapplugin/bus#satellite)
---
title: 使用高德插件
order: 3
---
<embed src="@/docs/common/style.md"></embed>

我们在使用高德地图作为地图底图的时候，可以借助高德地图提供的插件实现也中需求。

### AMap.LineSearch

- 道路查询

```javascript
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'blank',
    center: [ 103.83735604457024, 1.360253881403068 ],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313
  })
});
```

[在线案例](/examples/amapplugin/bus#busstop)

### AMap.ToolBar

- 地图工具栏

```javascript
scene.on('loaded', () => {
  window.AMap.plugin([ 'AMap.ToolBar', 'AMap.LineSearch' ], () => {
    scene.map.addControl(new AMap.ToolBar());

    const linesearch = new AMap.LineSearch({
      pageIndex: 1, // 页码，默认值为1
      pageSize: 1, // 单页显示结果条数，默认值为20，最大值为50
      city: '北京', // 限定查询城市，可以是城市名（中文/中文全拼）、城市编码，默认值为『全国』
      extensions: 'all' // 是否返回公交线路详细信息，默认值为『base』
    });
```

[在线案例](/examples/amapplugin/bus#busstop)

### AMap.TileLayer

- 加载使用 `xyz` 地图瓦片

```javascript
scene.on('loaded', () => {
  var xyzTileLayer = new window.AMap.TileLayer({
    getTileUrl:
      'https://wprd0{1,2,3,4}.is.autonavi.com/appmaptile?x=[x]&y=[y]&z=[z]&size=1&scl=1&style=8&ltype=11',
    zIndex: 100,
  });
  scene.map.add(xyzTileLayer);
});
```
[在线案例](/examples/amapplugin/bus#xyztile)

### AMap.TileLayer.Satellite

- 加载使用默认的卫星瓦片

```javascript
 scene.on('loaded', () => {
    scene.map.add(new window.AMap.TileLayer.Satellite());
});
```

[在线案例](/examples/amapplugin/bus#satellite)

---
title: GaodeMap
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Use Amap

### Register an account and apply for a Key

1. first,[Register a developer account](https://lbs.amap.com/dev/id/choose), become a developer of Amap open platform

2. After logging in, enter the "Application Management" page and "Create a New Application"

3. for application[Add Key](https://lbs.amap.com/dev/key/app), please select "Web client (JSAPI)" for "Service Platform"

### Introducing L7

Amap version 2.0 dynamically introduces the Amap map within L7`JS API`, so it is no longer necessary to introduce Gaode separately`JS API`, just set`type`for`amap`and pass in`token`。

```html
<script src="https://unpkg.com/@antv/l7"></script>
```

### Add a div tag to specify the map container

At the same time, it is necessary to`div`Set the height and width.

```html
<div id="map"></div>
```

### Initialize L7 Scene

```javascript
const scene = new L7.Scene({
    id: 'map',
    map: new L7.GaodeMap({
      style: 'dark', // Style URL
      center: [120.19382669582967, 30.258134],
      pitch: 0,
      zoom: 12,
      token: 'Amap token',
    }),
  });
```

In this way we have completed passing`L7`Instantiate the Gaode map.

### Add visualization layer

* First we need to get the data and get the data method. Here we get the online geographical data.
* Then we can initialize a`Layer`, and added to`Scene`The layer addition is completed.

```javascript
fetch('https://gw.alipayobjects.com/os/rmsportal/oVTMqfzuuRFKiDwhPSFL.json')
  .then(res => res.json())
  .then(data => {
    const pointLayer = new L7.PointLayer({})
      .source(data.list, {
        parser: {
          type: 'json',
          x: 'j',
          y: 'w'
        }
      })
      .shape('cylinder')
      .size('t', function(level) {
        return [ 1, 2, level * 2 + 20 ];
      })
      .color('t', [
        '#094D4A',
        '#146968',
        '#1D7F7E',
        '#289899',
        '#34B6B7',
        '#4AC5AF',
        '#5FD3A6',
        '#7BE39E',
        '#A1EDB8',
        '#CEF8D6'
      ]);
    scene.addLayer(pointLayer);
  });
```

### Complete demo code

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>创建地图场景</title>
    <style>
       html,body{overflow:hidden;margin:0;}
    	#map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script src="https://unpkg.com/@antv/l7"></script>
<script>

  const scene = new L7.Scene({
    id: 'map',
    map: new L7.GaodeMap({
      style: 'dark', // 样式URL
      center: [120.19382669582967, 30.258134],
      pitch: 0,
      zoom: 12,
      token: '高德地图token',
    }),
  });

fetch('https://gw.alipayobjects.com/os/rmsportal/oVTMqfzuuRFKiDwhPSFL.json')
  .then(res => res.json())
  .then(data => {
    const pointLayer = new L7.PointLayer({})
      .source(data.list, {
        parser: {
          type: 'json',
          x: 'j',
          y: 'w'
        }
      })
      .shape('cylinder')
      .size('t', function(level) {
        return [ 1, 2, level * 2 + 20 ];
      })
      .color('t', [
        '#094D4A',
        '#146968',
        '#1D7F7E',
        '#289899',
        '#34B6B7',
        '#4AC5AF',
        '#5FD3A6',
        '#7BE39E',
        '#A1EDB8',
        '#CEF8D6'
      ]);
    scene.addLayer(pointLayer);
  });

</script>
</body>
</html>
```
---
title: 高德地图
order: 0
---
<embed src="@/docs/common/style.md"></embed>
## 使用高德地图

### 注册账号并申请Key

1. 首先，[注册开发者账号](https://lbs.amap.com/dev/id/choose)，成为高德开放平台开发者

2. 登陆之后，在进入「应用管理」 页面「创建新应用」

3. 为应用[添加 Key](https://lbs.amap.com/dev/key/app)，「服务平台」一项请选择「 Web 端 ( JSAPI ) 」

### 引入 L7 

高德 2.0 版本在L7内部动态引入了高德地图 `JS API` ，因此不再需要单独引入高德 `JS API`，只需设置 `type` 为 `amap` 并且传入 `token`。 

```html
<script src="https://unpkg.com/@antv/l7"></script>
```

### 添加 div 标签指定地图容器

同时需要为 `div`设置 高度和宽度。

``` html
<div id="map"></div>
```

### 初始化 L7 Scene


```javascript
  const scene = new L7.Scene({
    id: 'map',
    map: new L7.GaodeMap({
      style: 'dark', // 样式URL
      center: [120.19382669582967, 30.258134],
      pitch: 0,
      zoom: 12,
      token: '高德地图token',
    }),
  });
```

这样我们就完成了通过 `L7` 实例化高德地图。

### 添加可视化图层

- 首先我们需要获取数据，获取数据方法，这里我们获取在线的地理数据。
- 然后我们就可以初始一个 `Layer`，并添加到 `Scene` 就完成了图层的添加。

``` javascript
fetch('https://gw.alipayobjects.com/os/rmsportal/oVTMqfzuuRFKiDwhPSFL.json')
  .then(res => res.json())
  .then(data => {
    const pointLayer = new L7.PointLayer({})
      .source(data.list, {
        parser: {
          type: 'json',
          x: 'j',
          y: 'w'
        }
      })
      .shape('cylinder')
      .size('t', function(level) {
        return [ 1, 2, level * 2 + 20 ];
      })
      .color('t', [
        '#094D4A',
        '#146968',
        '#1D7F7E',
        '#289899',
        '#34B6B7',
        '#4AC5AF',
        '#5FD3A6',
        '#7BE39E',
        '#A1EDB8',
        '#CEF8D6'
      ]);
    scene.addLayer(pointLayer);
  });
  ```

### 完整 demo 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>创建地图场景</title>
    <style>
       html,body{overflow:hidden;margin:0;}
    	#map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script src="https://unpkg.com/@antv/l7"></script>
<script>

  const scene = new L7.Scene({
    id: 'map',
    map: new L7.GaodeMap({
      style: 'dark', // 样式URL
      center: [120.19382669582967, 30.258134],
      pitch: 0,
      zoom: 12,
      token: '高德地图token',
    }),
  });

fetch('https://gw.alipayobjects.com/os/rmsportal/oVTMqfzuuRFKiDwhPSFL.json')
  .then(res => res.json())
  .then(data => {
    const pointLayer = new L7.PointLayer({})
      .source(data.list, {
        parser: {
          type: 'json',
          x: 'j',
          y: 'w'
        }
      })
      .shape('cylinder')
      .size('t', function(level) {
        return [ 1, 2, level * 2 + 20 ];
      })
      .color('t', [
        '#094D4A',
        '#146968',
        '#1D7F7E',
        '#289899',
        '#34B6B7',
        '#4AC5AF',
        '#5FD3A6',
        '#7BE39E',
        '#A1EDB8',
        '#CEF8D6'
      ]);
    scene.addLayer(pointLayer);
  });

</script>
</body>
</html>

```---
title: 路径图
order: 0
---
<embed src="@/docs/common/style.md"></embed>

我们经常需要在地图上绘制诸如道路、行动路线、水系等常见的路径，可以将这些绘制线的统称为路径图，即用一组首尾不闭合的点坐标对来定位的线图层。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*KEupSZ_p0pYAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个常见的路径图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/gallery/animate#animate_path_texture)

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 120.15, 30.246 ],
    zoom: 13.5,
    style: 'dark',
    rotation: -90
  })
});
scene.addImage('arrow', 'https://gw.alipayobjects.com/zos/bmw-prod/ce83fc30-701f-415b-9750-4b146f4b3dd6.svg');
fetch('https://gw.alipayobjects.com/os/basement_prod/40ef2173-df66-4154-a8c0-785e93a5f18e.json')
.then(res => res.json())
.then(data => {
  const layer = new LineLayer({})
    .source(data)
    .size(3)
    .shape('line')
    .texture('arrow')
    .color('rgb(22,119,255)')
    .animate({
      interval: 1, // 间隔
      duration: 1, // 持续时间，延时
      trailLength: 2 // 流线长度
    })
    .style({
      opacity: 0.6,
      lineTexture: true, // 开启线的贴图功能
      iconStep: 10, // 设置贴图纹理的间距
      borderWidth: 0.4, // 默认文 0，最大有效值为 0.5
      borderColor: '#fff' // 默认为 #ccc
    });
  scene.addLayer(layer);
});
```
### shape

我们一般将路径图的 `shape` 参数设置成 `line`。

### size

对于路径图，我们一般只要设置常量表示路径的宽度即可。

```javascript
layer.size(2); // 绘制宽度为 2 的路径
```
### style

<embed src="@/docs/common/features/linear.zh.md"></embed>

<embed src="@/docs/common/features/dash.zh.md"></embed>

<embed src="@/docs/common/features/border.zh.md"></embed>

<embed src="@/docs/common/features/texture.zh.md"></embed>

<embed src="@/docs/common/features/animate.zh.md"></embed>---
title: Path
order: 0
---

<embed src="@/docs/common/style.md"></embed>

We often need to draw common paths such as roads, action routes, water systems, etc. on the map. These drawn lines can be collectively called a path map, that is, a line layer positioned with a set of point coordinate pairs that are not closed at the beginning and end.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*KEupSZ_p0pYAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a common path diagram.

* you can`L7`Found on the official website[Online case](/examples/gallery/animate#animate_path_texture)

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 120.15, 30.246 ],
    zoom: 13.5,
    style: 'dark',
    rotation: -90
  })
});
scene.addImage('arrow', 'https://gw.alipayobjects.com/zos/bmw-prod/ce83fc30-701f-415b-9750-4b146f4b3dd6.svg');
fetch('https://gw.alipayobjects.com/os/basement_prod/40ef2173-df66-4154-a8c0-785e93a5f18e.json')
.then(res => res.json())
.then(data => {
  const layer = new LineLayer({})
    .source(data)
    .size(3)
    .shape('line')
    .texture('arrow')
    .color('rgb(22,119,255)')
    .animate({
      interval: 1, // interval
      duration: 1, // duration, delay
      trailLength: 2 // streamline length
    })
    .style({
      opacity: 0.6,
      lineTexture: true, // Enable line mapping function
      iconStep: 10, // Set the spacing of the texture
      borderWidth: 0.4, //The default value is 0, the maximum valid value is 0.5
      borderColor: '#fff' // Default is #ccc
    });
  scene.addLayer(layer);
});
```

### shape

We generally refer to the path diagram as`shape`The parameters are set to`line`。

### size

For path diagrams, we generally only need to set a constant to represent the width of the path.

```javascript
layer.size(2); // Draw a path with width 2
```

### style

<embed src="@/docs/common/features/linear.zh.md"></embed>

<embed src="@/docs/common/features/dash.zh.md"></embed>

<embed src="@/docs/common/features/border.zh.md"></embed>

<embed src="@/docs/common/features/texture.zh.md"></embed>

<embed src="@/docs/common/features/animate.zh.md"></embed>
---
title: 大圆航线
order: 3
---
<embed src="@/docs/common/style.md"></embed>

把地球看做一个球体，通过地面上任意两点和地心做一平面，平面与地球表面相交看到的圆周就是大圆。两点之间的大圆劣弧线是两点在地面上的最短距离。沿着这一段大圆弧线航行时的航线称为大圆航线。


<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*6Qm_QY69sBMAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单的大圆弧线。

- 你可以在 `L7` 官网上找到[在线案例](/examples/line/arc/#arccircle)


```javascript
import { Scene, LineLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'dark',
    center: [ 107.77791556935472, 35.443286920228644 ],
    zoom: 2.9142882493605033
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/rmsportal/UEXQMifxtkQlYfChpPwT.txt')
    .then(res => res.text())
    .then(data => {
      const layer = new LineLayer({})
        .source(data, {
          parser: {
            type: 'csv',
            x: 'lng1',
            y: 'lat1',
            x1: 'lng2',
            y1: 'lat2'
          }
        })
        .size(1)
        .shape('greatcircle')
        .color('#8C1EB2')
        .style({
          opacity: 0.8
        });
      scene.addLayer(layer);
    });
});

```

### source

绘制弧线需要同时提供起点和止点的坐标（起止点调换位置，弧线的形状会对称相反，飞线动画的方向也会相反）。

```javascript
const data = [{
  lng1: 120, lat1: 30,
  lng2: 130, lat2: 30
}]
layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng2',
    y1: 'lat2',
  },
});
```

### shape

为了绘制大圆弧线图，我们需要将 `shape` 的参数设置成 `greatcircle`。


<embed src="@/docs/common/features/animate.zh.md"></embed>

### style

<embed src="@/docs/common/features/linear.zh.md"></embed>

<embed src="@/docs/common/features/dash.zh.md"></embed>

<embed src="@/docs/common/features/texture.zh.md"></embed>
---
title: Simple Line
order: 4
---

<embed src="@/docs/common/style.md"></embed>

The simple line layer provides users with a better choice for large data volumes and can easily render line segments with hundreds of thousands of nodes. However, compared with ordinary line layers, the simple line layer is also lost. some other abilities.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*HulgSKEJAKMAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a simple line.

* you can`L7`Found on the official website[Online case](/examples/gallery/animate#grid)

```javascript
import { LineLayer } from '@antv/l7';
const layer = new LineLayer()
  .source(data)
  .shape('simple')
  .size(10) // The size method does not take effect. The line width is always 1px.
  .color('#f00')
  .style(...)
```

### shape

In order to draw a simple line we need to`shape`The parameters are set to`simple`。

<embed src="@/docs/common/features/linear.zh.md"></embed>

🌟 Simple line layer does not support animation and textures
---
title: 简单线图层
order: 4
---
<embed src="@/docs/common/style.md"></embed>

简单线图层为用户提供了一种大数据量性能更优的选择，能轻松渲染有几十万个节点的线段，但相应的，对比与普通的线图层，简单线图层也丢失了一些其他能力。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*HulgSKEJAKMAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制简单线。

- 你可以在 `L7` 官网上找到[在线案例](/examples/gallery/animate#grid)

```javascript
import { LineLayer } from '@antv/l7';
const layer = new LineLayer()
  .source(data)
  .shape('simple')
  .size(10) // size 方法不生效 线宽始终为 1px
  .color('#f00')
  .style(...)
```

### shape

为了绘制简单线，我们需要将 `shape` 的参数设置成 `simple`。

<embed src="@/docs/common/features/linear.zh.md"></embed>

🌟 简单线图层不支持动画和纹理
---
title: Great Circle
order: 3
---

<embed src="@/docs/common/style.md"></embed>

Consider the earth as a sphere, and draw a plane through any two points on the ground and the center of the earth. The circle seen when the plane intersects the earth's surface is a great circle. The great circle arc between two points is the shortest distance between the two points on the ground. The route along this great arc is called a great circle route.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*6Qm_QY69sBMAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a simple large arc line.

* you can`L7`Found on the official website[Online case](/examples/line/arc/#arccircle)

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'dark',
    center: [ 107.77791556935472, 35.443286920228644 ],
    zoom: 2.9142882493605033
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/rmsportal/UEXQMifxtkQlYfChpPwT.txt')
    .then(res => res.text())
    .then(data => {
      const layer = new LineLayer({})
        .source(data, {
          parser: {
            type: 'csv',
            x: 'lng1',
            y: 'lat1',
            x1: 'lng2',
            y1: 'lat2'
          }
        })
        .size(1)
        .shape('greatcircle')
        .color('#8C1EB2')
        .style({
          opacity: 0.8
        });
      scene.addLayer(layer);
    });
});
```

### source

To draw an arc, you need to provide the coordinates of both the starting point and the ending point (if the starting and ending points are swapped, the shape of the arc will be symmetrical and opposite, and the direction of the flying line animation will be opposite).

```javascript
const data = [{
  lng1: 120, lat1: 30,
  lng2: 130, lat2: 30
}]
layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng2',
    y1: 'lat2',
  },
});
```

### shape

In order to draw a great arc line graph, we need to`shape`The parameters are set to`greatcircle`。

<embed src="@/docs/common/features/animate.zh.md"></embed>

### style

<embed src="@/docs/common/features/linear.zh.md"></embed>

<embed src="@/docs/common/features/dash.zh.md"></embed>

<embed src="@/docs/common/features/texture.zh.md"></embed>
---
title: 地理围墙
order: 5
---
<embed src="@/docs/common/style.md"></embed>

地理围墙在原有线图层的基础上赋予了高度的概念，其他的使用和普通的线图保持一致。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*mLfxTb4mI6AAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制简单的地理围墙。

- 你可以在 `L7` 官网上找到[在线案例](/examples/line/wall/#hangzhou_wall)

## 使用

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 119.297868, 29.732983 ],
    zoom: 7.11,
    rotation: 1.22,
    pitch: 45.42056074766357,
    style: 'dark'
  })
});

scene.on('loaded', () => {
  fetch(
    'https://gw.alipayobjects.com/os/bmw-prod/93a55259-328e-4e8b-8dc2-35e05844ed31.json'
  )
    .then(res => res.json())
    .then(data => {
      const layer = new LineLayer({})
        .source(data)
        .size(40)
        .shape('wall')
        .style({
          opacity: 'testOpacity',
          sourceColor: '#0DCCFF',
          targetColor: 'rbga(255,255,255, 0)'
        });
      scene.addLayer(layer);
    });
});

```


### shape

为了绘制地理围墙，我们需要将 `shape` 的参数设置成 `wall`。

<embed src="@/docs/common/features/animate.zh.md"></embed>

### style

<embed src="@/docs/common/features/linear.zh.md"></embed>

🌟 目前渐变色的方向为垂直向上

<embed src="@/docs/common/features/texture.zh.md"></embed>

🌟 地理围栏支持了新的样式参数 iconStepCount

- 纹理间隔只有在开启纹理的时候才会生效
- 纹理间隔支持配置纹理之间的间距
- 纹理间隔需要和纹理间距配合使用

```javascript
.style({
  lineTexture: true, // 开启线的贴图功能
  iconStep: 40, // 设置贴图纹理的间距
  iconStepCount: 4
})
```

<img width="80%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*3f8ORIbjJmkAAAAAAAAAAAAAARQnAQ'>

#### heightfixed

`wall` 支持了固定高度配置 `heightfixed`。

```javascript
 .style({
     heightfixed: true // 默认为 false，开启后实际世界高度不变（注意调整尺寸）
 })
```
---
title: 3D Arc
order: 2
---

<embed src="@/docs/common/style.md"></embed>

In addition to 2D arcs, we also point out 3D arcs. In use, just change`shape`parameters.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*xvaaQo2c0gMAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Below we will introduce how to draw a simple`3D`Arc diagram.

* you can`L7`Found on the official website[Online case](/examples/line/arc#trip_arc)

```javascript
import { LineLayer } from '@antv/l7';
const layer = new LineLayer({})
  .source(data, {
    parser: {
      type: 'csv',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(1)
  .shape('arc')
  .color('#8C1EB2')
  .style({
    opacity: 0.8,
  });
```

### source

To draw an arc, you need to provide the coordinates of both the starting point and the ending point (if the starting and ending points are swapped, the shape of the arc will be symmetrical and opposite, and the direction of the flying line animation will be opposite).

```javascript
const data = [{
  lng1: 120, lat1: 30,
  lng2: 130, lat2: 30
}]
layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng2',
    y1: 'lat2',
  },
});
```

### shape

In order to draw an arc graph, we need to`shape`The parameters are set to`arc3d`。

<embed src="@/docs/common/features/animate.zh.md"></embed>

### style

<embed src="@/docs/common/features/linear.zh.md"></embed>

<embed src="@/docs/common/features/dash.zh.md"></embed>

<embed src="@/docs/common/features/texture.zh.md"></embed>
---
title: Wall
order: 5
---

<embed src="@/docs/common/style.md"></embed>

Geographic fencing gives the concept of height based on the original line layer, and other uses are consistent with ordinary line drawings.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*mLfxTb4mI6AAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a simple geofence.

* you can`L7`Found on the official website[Online case](/examples/line/wall/#hangzhou_wall)

## use

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [ 119.297868, 29.732983 ],
    zoom: 7.11,
    rotation: 1.22,
    pitch: 45.42056074766357,
    style: 'dark'
  })
});

scene.on('loaded', () => {
  fetch(
    'https://gw.alipayobjects.com/os/bmw-prod/93a55259-328e-4e8b-8dc2-35e05844ed31.json'
  )
    .then(res => res.json())
    .then(data => {
      const layer = new LineLayer({})
        .source(data)
        .size(40)
        .shape('wall')
        .style({
          opacity: 'testOpacity',
          sourceColor: '#0DCCFF',
          targetColor: 'rbga(255,255,255, 0)'
        });
      scene.addLayer(layer);
    });
});
```

### shape

In order to draw geofences we need to`shape`The parameters are set to`wall`。

<embed src="@/docs/common/features/animate.zh.md"></embed>

### style

<embed src="@/docs/common/features/linear.zh.md"></embed>

🌟 The current gradient direction is vertically upward

<embed src="@/docs/common/features/texture.zh.md"></embed>

🌟 Geofence supports new style parameter iconStepCount

* Texture interval will only take effect when texture is turned on
* Texture spacing supports configuring the spacing between textures
* Texture spacing needs to be used in conjunction with texture spacing

```javascript
.style({
  lineTexture: true, // Enable line mapping function
  iconStep: 40, // Set the spacing of the texture
  iconStepCount: 4
})
```

<img width="80%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*3f8ORIbjJmkAAAAAAAAAAAAAARQnAQ'>

#### heightfixed

`wall`Fixed height configuration supported`heightfixed`。

```javascript
.style({
     heightfixed: true // The default is false. The actual world height does not change after it is turned on (note the size adjustment)
 })
```
---
title: 3D 弧线图
order: 2
---
<embed src="@/docs/common/style.md"></embed>

除了 2D 的弧线，我们还指出 3D 的弧线，在使用上只要改变 `shape` 的参数即可。


<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*xvaaQo2c0gMAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单的 `3D` 弧线图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/line/arc#trip_arc)

```javascript
import { LineLayer } from '@antv/l7';
const layer = new LineLayer({})
  .source(data, {
    parser: {
      type: 'csv',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(1)
  .shape('arc')
  .color('#8C1EB2')
  .style({
    opacity: 0.8,
  });
```

### source

绘制弧线需要同时提供起点和止点的坐标（起止点调换位置，弧线的形状会对称相反，飞线动画的方向也会相反）。

```javascript
const data = [{
  lng1: 120, lat1: 30,
  lng2: 130, lat2: 30
}]
layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng2',
    y1: 'lat2',
  },
});
```

### shape

为了绘制弧线图，我们需要将 `shape` 的参数设置成 `arc3d`。

<embed src="@/docs/common/features/animate.zh.md"></embed>

### style

<embed src="@/docs/common/features/linear.zh.md"></embed>

<embed src="@/docs/common/features/dash.zh.md"></embed>

<embed src="@/docs/common/features/texture.zh.md"></embed>
---
title: 弧线图
order: 1
---
<embed src="@/docs/common/style.md"></embed>

有时候为了可视化效果，会选择使用弧线连接地图上的两点。同时也可以使用弧线完成一些有趣的效果。


<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*dUk8RbtjUDIAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何使用弧线绘制一个模拟的风场。

- 你可以在 `L7` 官网上找到[在线案例](/examples/line/animate/#wind)

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 60, 40.7128 ],
    zoom: 2
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/bmw-prod/7455fead-1dc0-458d-b91a-fb4cf99e701e.txt')
    .then(res => res.text())
    .then(data => {
      const layer = new LineLayer({ blend: 'normal' })
        .source(data,
          {
            parser: {
              type: 'csv',
              x: 'lng1',
              y: 'lat1',
              x1: 'lng2',
              y1: 'lat2'
            }
          })
        .size(1)
        .shape('arc')
        .color('#6495ED')
        .animate({
          duration: 4,
          interval: 0.2,
          trailLength: 0.6
        });
      scene.addLayer(layer);
    });
});
```

### source

绘制弧线需要同时提供起点和止点的坐标（起止点调换位置，弧线的形状会对称相反，飞线动画的方向也会相反）。

```javascript
const data = [{
  lng1: 120, lat1: 30,
  lng2: 130, lat2: 30
}]
layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng2',
    y1: 'lat2',
  },
});
```
### shape

为了绘制弧线图，我们需要将 `shape` 的参数设置成 `arc`。


<embed src="@/docs/common/features/animate.zh.md"></embed>

### style

<embed src="@/docs/common/features/segment_number.zh.md"></embed>

<embed src="@/docs/common/features/theta_offset.zh.md"></embed>

<embed src="@/docs/common/features/linear.zh.md"></embed>

<embed src="@/docs/common/features/dash.zh.md"></embed>

<embed src="@/docs/common/features/texture.zh.md"></embed>
---
title: Arc
order: 1
---

<embed src="@/docs/common/style.md"></embed>

Sometimes for the sake of visualization, you will choose to use arcs to connect two points on the map. At the same time, you can also use arcs to achieve some interesting effects.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*dUk8RbtjUDIAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### accomplish

Next we will introduce how to use arcs to draw a simulated wind field.

* you can`L7`Found on the official website[Online case](/examples/line/animate/#wind)

```javascript
import { Scene, LineLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 60, 40.7128 ],
    zoom: 2
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/bmw-prod/7455fead-1dc0-458d-b91a-fb4cf99e701e.txt')
    .then(res => res.text())
    .then(data => {
      const layer = new LineLayer({ blend: 'normal' })
        .source(data,
          {
            parser: {
              type: 'csv',
              x: 'lng1',
              y: 'lat1',
              x1: 'lng2',
              y1: 'lat2'
            }
          })
        .size(1)
        .shape('arc')
        .color('#6495ED')
        .animate({
          duration: 4,
          interval: 0.2,
          trailLength: 0.6
        });
      scene.addLayer(layer);
    });
});
```

### source

To draw an arc, you need to provide the coordinates of both the starting point and the ending point (if the starting and ending points are swapped, the shape of the arc will be symmetrical and opposite, and the direction of the flying line animation will be opposite).

```javascript
const data = [{
  lng1: 120, lat1: 30,
  lng2: 130, lat2: 30
}]
layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng2',
    y1: 'lat2',
  },
});
```

### shape

In order to draw an arc graph, we need to`shape`The parameters are set to`arc`。

<embed src="@/docs/common/features/animate.zh.md"></embed>

### style

<embed src="@/docs/common/features/segment_number.zh.md"></embed>

<embed src="@/docs/common/features/theta_offset.zh.md"></embed>

<embed src="@/docs/common/features/linear.zh.md"></embed>

<embed src="@/docs/common/features/dash.zh.md"></embed>

<embed src="@/docs/common/features/texture.zh.md"></embed>
---
title: 快速 issue
order: 5
---
<embed src="@/docs/common/style.md"></embed>

### 为什么提 Issue

- Issue 是开放的，看到的同学可以解答，提出想法，提升 Issue 的解决效率
- Issue 能够做到很好的任务管理
- 如果该问题得到解决，遇到同样问题是人，可以参考解决。

### 如何提 issue 

1. 提交问题前，请先阅读 https://l7.antv.antgroup.com/tutorial/quickstart 上的文档。
2. 我们推荐如果是小问题（错别字修改，小的 bug fix）直接提交 PR。
3. 如果是一个新需求，请提供：详细需求描述，最好是有伪代码实现。
4. 如果是一个 BUG，请提供：复现步骤，错误日志以及相关配置，并尽量填写下面的模板中的条目。
5. 如果可以，请提供尽可能精简的 codesandbox 链接，可使用 codesandbox 模板 https://codesandbox.io/s/45smpb，方便我们排查问题。
6. 扩展阅读：[如何向开源项目提交无法解答的问题](https://zhuanlan.zhihu.com/p/25795393)

### 如果提供复现 demo

复现demo 是指可运行的代码环境，不是复制代码，推荐使用 https://codesandbox.io/s/45smpb ，同时官网提供了自动跳转到codebox 的能力。

- L7 demo 页面找到，需要复现的图层或者相似的demo
- 在 sandbox 打开 当前demo

<img src="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*bKT5TrlYlGEAAAAAAAAAAABkARQnAQ" alt="L7 地理可视化" width = "50%" height = "100%">

你可能没有注意到，代码区的上方有一排工具按钮。


点击左侧第三个按钮，你就进入了 `codesandbox`。

![L7 地理可视化](https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*TrpMSJrrSDMAAAAAAAAAAABkARQnAQ)

<img src="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*coZsTLbX2FQAAAAAAAAAAABkARQnAQ" alt="L7 地理可视化" width = "50%" height = "100%">

你发现你进入了一个在线的代码编辑器，在这里面你可以修改代码，复现你发现的问题，然后保存，并在链接复制到 Issue 内容中。


### 现在你可以去 L7 仓库提 issue

https://github.com/antvis/L7/issues/new

如果还没有 star L7,可顺手点个 star。
---
title: Data
order: 2
---

<embed src="@/docs/common/style.md"></embed>

## data

Currently, the data formats supported by L7 are:`GeoJSON`，`CSV`，`JSON`，`Image`。

* `GeoJSON`Supports all standard spatial data formats such as points, lines, and areas.

* `CSV`Supports data types such as points, line segments, and arcs.

* `JSON`Supports simple point, line, and area data types, but does not support multi-point, multi-line, and multi-area data formats.

### GeoJSON

`GeoJSON`Is a format for encoding various geographic data structures. GeoJSON objects can represent geometries, features, or feature collections. GeoJSON supports the following geometry types: point, line, polygon, multipoint, multiline, polygon, and geometry collection. Features in GeoJSON include a geometric object and other attributes, and feature collections represent a series of features.

```json
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {},
      "geometry": {
        "type": "Polygon",
        "coordinates": [
          [
            [
              110.478515625,
              32.76880048488168
            ],
            [
              117.68554687499999,
              32.76880048488168
            ],
            [
              117.68554687499999,
              37.64903402157866
            ],
          ]
        ]
      }
    }
  ]
}
```

## Geostatistical analysis tools

[turfjs](http://turfjs.org/): Javascript library for geographic data calculation, processing, statistics, and analysis

## Online tools

<http://geojson.io/>You can view, draw and modify GeoJSON data online

<https://mapshaper.org/>Can view larger geojson and simplify GeoJSON data

## Data resources

#### National administrative division GeoJSON supports province, city and county latitude

[geojson, svg download](http://datav.aliyun.com/tools/atlas/#\&lat=33.50475906922609\&lng=104.32617187499999\&zoom=4)

#### HighCharts Global Administrative Division Dataset

<https://img.hcharts.cn/mapdata/>
---
title: 数据
order: 2
---

<embed src="@/docs/common/style.md"></embed>

## 数据

目前L7支持的数据格式有 `GeoJSON`，`CSV`，`JSON`，`Image`。

- `GeoJSON` 支持点、线、面等所有的标准空间数据格式。

- `CSV` 支持点、线段、弧线等数据类型。

- `JSON` 支持简单的点、线，面数据类型，不支持多点，多线的，多面数据格式。


### GeoJSON

`GeoJSON` 是一种对各种地理数据结构进行编码的格式。GeoJSON对象可以表示几何、特征或者特征集合。GeoJSON支持下面几何类型：点、线、面、多点、多线、多面和几何集合。GeoJSON里的特征包含一个几何对象和其他属性，特征集合表示一系列特征。

```json
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {},
      "geometry": {
        "type": "Polygon",
        "coordinates": [
          [
            [
              110.478515625,
              32.76880048488168
            ],
            [
              117.68554687499999,
              32.76880048488168
            ],
            [
              117.68554687499999,
              37.64903402157866
            ],
          ]
        ]
      }
    }
  ]
}
```

## 地理统计分析工具
[turfjs](http://turfjs.org/):  地理数据计算，处理，统计，分析的Javascript 库

## 在线工具

[http://geojson.io/](http://geojson.io/)    可以在线查看，绘制，修改GeoJSON数据

[https://mapshaper.org/](https://mapshaper.org/)  可以查看较大的geojson，还能够简化GeoJSON数据

## 数据资源

#### 全国行政区划GeoJON 支持省市县维度 
[geojson, svg下载](http://datav.aliyun.com/tools/atlas/#&lat=33.50475906922609&lng=104.32617187499999&zoom=4)

#### HighCharts 全球行政区划数据集

[https://img.hcharts.cn/mapdata/](https://img.hcharts.cn/mapdata/)

---
title: Quick Issue
order: 5
---

<embed src="@/docs/common/style.md"></embed>

### Why issue

* Issues are open, and students who see them can answer them, put forward ideas, and improve the efficiency of solving Issues.
* Issue can achieve good task management
* If this problem is solved, people who encounter the same problem can refer to the solution.

### How to raise an issue

1. Before submitting a question, please read<https://l7.antv.antgroup.com/tutorial/quickstart>documentation on.
2. We recommend that if it is a minor issue (typos correction, minor bug fix), submit a PR directly.
3. If it is a new requirement, please provide: a detailed description of the requirement, preferably with pseudocode implementation.
4. If it is a BUG, ​​please provide: reproduction steps, error logs and related configurations, and try to fill in the entries in the template below.
5. If possible, please provide a link to codesandbox that is as concise as possible, using codesandbox templates<https://codesandbox.io/s/45smpb，方便我们排查问题。>
6. Further reading:[How to submit unanswered questions to open source projects](https://zhuanlan.zhihu.com/p/25795393)

### If you provide a reproduction demo

Reproducing demo refers to a runnable code environment, not copying code, and is recommended.<https://codesandbox.io/s/45smpb>, and the official website provides the ability to automatically jump to the codebox.

* Found on the L7 demo page, the layer or similar demo that needs to be reproduced
* Open the current demo in the sandbox

<img src="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*bKT5TrlYlGEAAAAAAAAAAABkARQnAQ" alt="L7 地理可视化" width = "50%" height = "100%">

You may not have noticed that there is a row of tool buttons above the code area.

Click the third button on the left and you will enter`codesandbox`。

![L7 地理可视化](https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*TrpMSJrrSDMAAAAAAAAAAABkARQnAQ)

<img src="https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*coZsTLbX2FQAAAAAAAAAAABkARQnAQ" alt="L7 地理可视化" width = "50%" height = "100%">

You find that you have entered an online code editor, where you can modify the code to reproduce the problems you discovered, then save it and copy the link to the Issue content.

### Now you can go to the L7 warehouse to file an issue

<https://github.com/antvis/L7/issues/new>

If you don’t have star L7 yet, you can click star now.
---
title: 图层高亮
order: 0
---
<embed src="@/docs/common/style.md"></embed>

地理可视化除了数据展示，还需要用户交互，用户交互一般分为两种。

- 图层交互
- 数据交互

### 图层交互

鼠标在可视化图层上进行相关操作，然后图层会有相应的响应。`L7` 的 `Layer` 图层目前原生支持两种交互能力。

- `active` 鼠标滑过高亮
- `select` 鼠标选中高亮

#### active(activeOption | boolean): void

- 开启或者关闭 `mousehover` 元素高亮效果。
- `activeOption`
  - `color`: 高亮颜色
  - `mix`: 可选参数，默认为 0，表示高亮颜色是指定纯色，最大有效值是1，表示高亮色全部是底色

```javascript
// 开启 Active  使用默认高亮颜色
layer.active(true)

//  开启 Active  自定义高亮颜色

layer.active({
  color: 'red',
  mix: .6,
})

// 关闭高亮效果
layer.active(false)
```

#### select(selectOption | boolean): void

- 开启或者关闭 `mouseclick` 元素选中高亮效果。
- `selectOption`
  - `color`: 选中高亮颜色
  - `mix`: 可选参数，默认为 0，表示选中高亮颜色是指定纯色，最大有效值是1，表示选中高亮色全部是底色

```javascript
// 开启 Active  使用默认高亮颜色
layer.select(true)

//  开启 Active  自定义高亮颜色

layer.select({
  color: 'red',
  mix: .6,
})

// 关闭高亮效果
layer.select(false)
```

### 数据交互

有些时候我们可能需要直接指定某个数据高亮，比如鼠标点击数据面板的数据，我们需要高亮地图对应的元素。

#### setActive(id: number): void

```javascript
layer.setActive(id);
```

#### setSelect(id: number): void

```javascript
layer.setSelect(id);
```


---
title: HightLight
order: 0
---

<embed src="@/docs/common/style.md"></embed>

In addition to data display, geographical visualization also requires user interaction. User interaction is generally divided into two types.

* Layer interaction
* Data interaction

### Layer interaction

The mouse performs related operations on the visualization layer, and the layer will respond accordingly.`L7`of`Layer`Layers currently natively support two interaction capabilities.

* `active`Mouse over highlight
* `select`Mouse selection highlight

#### active(activeOption | boolean): void

* Turn on or off`mousehover`Element highlighting effect.
* `activeOption`
  * `color`: Highlight color
  * `mix`: Optional parameter, the default is 0, which means the highlight color is the specified solid color. The maximum valid value is 1, which means the highlight color is all the background color.

```javascript
// Turn on Active and use the default highlight color
layer.active(true)

// Turn on Active custom highlight color

layer.active({
  color: 'red',
  mix: .6,
})

//Turn off the highlight effect
layer.active(false)
```

#### select(selectOption | boolean): void

* Turn on or off`mouseclick`Element selection highlight effect.
* `selectOption`
  * `color`: Select highlight color
  * `mix`: Optional parameter, the default is 0, which means that the selected highlight color is the specified solid color. The maximum effective value is 1, which means that all the selected highlight colors are background colors.

```javascript
// Turn on Active and use the default highlight color
layer.select(true)

// Turn on Active custom highlight color

layer.select({
  color: 'red',
  mix: .6,
})

//Turn off the highlight effect
layer.select(false)
```

### Data interaction

Sometimes we may need to directly specify a certain data highlight. For example, when the mouse clicks on the data in the data panel, we need to highlight the corresponding element of the map.

#### setActive(id: number): void

```javascript
layer.setActive(id);
```

#### setSelect(id: number): void

```javascript
layer.setSelect(id);
```
---
title: Quick Start
order: 1
---

<embed src="@/docs/common/style.md"></embed>

`L7`Available online`CDN`as well as`NPM`Quick access in the form of packages. pass`L7`With the capabilities provided, we can quickly complete map visualization.

## Installation introduction

### Introduced via npm

```javascript
//Install L7 dependencies
npm install --save @antv/l7
//Install third-party basemap dependencies
npm install --save @antv/l7-maps
```

### Imported via CDN

```html
<head>
<! --Introducing the latest version of L7-->
<script src = 'https://unpkg.com/@antv/l7'></script>
<! --Specify the version number to introduce L7-->
<script src = 'https://unpkg.com/@antv/l7@2.0.11'></script>
</head>
```

CDN reference obtains and initializes all objects through the L7 namespace when used, such as L7.scene, L7.GaodeMap

```javascript
import { Scene } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new L7.Scene({
  id: 'map',
  map: new L7.GaodeMap({
    style: 'dark',
    center: [110.770672, 34.159869],
    pitch: 45,
  }),
});
```

## Basic tutorial

### Map component usage

1. To initialize the map, you first need to add a Dom to the page for map initialization.

```html
<div style="min-height: 500px; justify-content: center;position: relative" id="map"/>
```

2. Initialize Gaode map

```javascript
import { GaodeMap } from '@antv/l7-maps';
//Similarly you can also initialize a Mapbox map
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    pitch: 35.210526315789465,
    style: 'dark',
    center: [ 104.288144, 31.239692 ],
    zoom: 4.4
  })
})
```

🌟 At this point, interactive map content will appear on the page.

### Draw fill plot

After the map initialization is completed, we can add visual data to the map. Here we take China's administrative district data as an example of how to visualize surface data.
Data source: Chinese provinces[GeoJSON](https://gw.alipayobjects.com/os/bmw-prod/d6da7ac1-8b4f-4a55-93ea-e81aa08f0cf3.json)data.

1. We use polygon layers to draw administrative division data and obtain geometric planes covering the map surface.

```javascript
import {  PolygonLayer } from '@antv/l7';
 const chinaPolygonLayer = new PolygonLayer({})
  .source(data)
  .color('name', [
    'rgb(239,243,255)',
    'rgb(189,215,231)',
    'rgb(107,174,214)',
    'rgb(49,130,189)',
    'rgb(8,81,156)'
  ]);
```

2. After the layer is created, we need to add it to`Scene`displayed in .

```javascript
scene.addLayer(chinaPolygonLayer)
```

![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*iUZVSYBtKnMAAAAAAAAAAAAAARQnAQ)

3. Simple filling visualization is still not intuitive enough, we can use`LineLayer`and`PointLayer`Add administrative division strokes and administrative division text labels.

![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*Tf95Qp43Z6IAAAAAAAAAAAAAARQnAQ)

4. The visualization becomes clearer after adding borders and text annotations.

[View full code](https://codesandbox.io/s/l7-tianchongtujiaocheng-275ix?file=/index.js)

### Interactive fill plot

Simply displaying the data does not meet my needs. We may need to view the relevant information of each block or add some highlighting effects.

#### Highlight by default

`L7`Add a default highlight effect to the layer, and the default highlight effect can change the color.

```javascript
chinaPolygonLayer.active(true) // Turn on the default highlighting effect

chinaPolygonLayer.active({color: red}) // Turn on and set the highlight color to red
```

| **![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*vik-Q7frCMMAAAAAAAAAAAAAARQnAQ)** | **![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*RJiaS498G4wAAAAAAAAAAAAAARQnAQ)** |
| ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| Default blue highlight effect                                                                           | Change highlight color                                                                                  |

#### Custom highlight effect

The default highlight effect can only change the color, which may not meet my needs. We may need a white stroke. Can this be achieved? The answer is definitely yes.

1. Add a new layer as the highlight layer, set the data to empty data and the shape to`line`

```javascript
const hightLayer = new LineLayer({
  zIndex: 4, //Set the display level
  name: 'highlight'
}) .source({
    type: 'FeatureCollection',
    features: [ ]
  })
  .shape('line')
  .size(2)
  .color('red');
scene.addLayer(hightLayer);
```

2. In this way, we can listen to the mouse events of the layer that needs to be highlighted, obtain the currently selected data, and then update`hightLayer`It can also achieve stroke highlighting effect.

```javascript
chinaPolygonLayer.on('click', feature => {
    hightLayer.setData({
      type: 'FeatureCollection',
      features: [ feature.feature ]
    });
  });
```

![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*fr9DTY54rhUAAAAAAAAAAAAAARQnAQ)

3. Add a click highlight red stroke effect to the layer

At this point we have learned how to customize the highlight effect. Here is a small question: "How to achieve the double stroke highlight effect?"

[View example](https://codesandbox.io/s/zidingyigaoliang-7vkso?file=/index.js)

#### Add information Popup information window

During mouse interaction, in addition to highlighting the crossed area, we also need information related to the information area, here`L7`provided`Popup`Components are used to display relevant information on the map.

Introduce objects

```javascript
import { Popup } from "@antv/l7";
```

We can decide when to display Popup by listening to mouse events on Layer.

```javascript
layer.on('mousemove', e => {
   const popup = new Popup({
     offsets: [ 0, 0 ],
     closeButton: false
   })
   .setLnglat(e.lngLat)
   .setHTML(`<span>地区: ${e.feature.properties.name}</span><br><span>确诊数: ${e.feature.properties.case}</span>`);
   scene.addPopup(popup);
   });
```

![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*2isvTq-s0OMAAAAAAAAAAAAAARQnAQ)

[View example](https://codesandbox.io/s/popup-x3j00?file=/index.js)

### Add legend

Above we have learned how to visualize data. On the map we can treat different areas as different colors, but how to understand what different colors mean, we need to add a legend.

`L7`There is currently no default legend component. You need to create the legend yourself. Here we introduce how to`L7 Control`The base class creates a legend component. Of course, you can also implement an independent legend.`Dom`components.

`L7`Provides a default`Zoom`，`Scale`，`Logo`These components are all based on the same base class`Control`Components, today we are based on`Control`Implement a custom legend component.

1. introduce`Control`base class

```javascript
import { Control } from "@antv/l7";
```

2. Initialize base class

```javascript
const legend = new Control({
  position: "bottomright"
});
```

3. set up`Control`Show content

by extension`Control`of`onAdd`We can freely customize the method`Control`Need to display content and interaction.

```javascript
legend.onAdd = function () {
  var el = document.createElement("div");
  el.className = "infolegend legend";
  var grades = [0, 10, 20, 50, 100, 200, 500];
  for (var i = 0; i < grades.length; i++) {
    el.innerHTML +=
      '<i style="background:' + color[i] + '"></i> ' + grades[i] +
      (grades[i + 1] ? "–" + grades[i + 1] + "<br>" : "+");
  }
  return el;
};
```

4. Add to map

```javascript
scene.addControl(legend)
```

![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*7VNfRodZ_8AAAAAAAAAAAAAAARQnAQ)

[View example](https://codesandbox.io/s/tuli-keov0?file=/index.js)

Here we introduce how to define it by yourself`Control`way to implement the legend, by customizing`Control`Many of our map components, such as full-screen components, positioning components, and many other components needed for business, lucky students can try them out.

### Timing change diagram

What we visualized above is static data, but many times our data changes with time. How to visualize time series data? Here we introduce two time series data visualization methods.

#### Prepare data

Geographical data:[U.S. state administrative division data](https://gw.alipayobjects.com/os/basement_prod/d36ad90e-3902-4742-b8a2-d93f7e5dafa2.json)Attribute data:[0908-1008 COVID-19 diagnosis data by state in the United States in the past 30 days](https://gw.alipayobjects.com/os/bmw-prod/bed5e504-04d5-4d96-a335-163e038dc65a.csv)。

#### update data

As time changes, the data will definitely change, so the simplest way is to update the data every time.

```javascript
otherPolygonLayer.setData(newData);
```

[Complete example](https://codesandbox.io/s/shujugengxin-kgwy0?file=/index.js)

#### update color

A large part of the scenarios for updating time series data are updating attribute data, such as data from different years in each province.`GDP`Data, spatial data itself has not changed (no increase or decrease and no boundary update). In this case, the surface layer may only need to be updated according to the new data. Pass of course`setData`It can also be achieved.`L7`Looking at the internal implementation mechanism Update`color`is more efficient than`setData`Much more efficient.

Update the data display by updating the color mapping field.

```javascript
const setColor = (d) => {
      return d > 100000
        ? color[7]
        : d > 80000
        ? color[6]
        : d > 40000
        ? color[5]
        : d > 20000
        ? color[4]
        : d > 10000
        ? color[3]
        : d > 5000
        ? color[2]
        : d > 1000
        ? color[1]
        : color[0];
    }

chinaPolygonLayer.color('2020-09-01', setColor)
chinaPolygonLayer.color('2020-09-02', setColor)
```

Note that the updated color takes effect and needs to be called`Scene.render();`。

[View example](https://codesandbox.io/s/shujugengxin-forked-0zul8?file=/index.js)

### Add map label

`L7`Base`WebGL`It is relatively simple to draw simple points, lines, and surfaces. It is more difficult to implement more complex map annotations. In order to solve this problem`L7`Added`Marker`Components you can base on`DOM`Achieve various complex annotations.

```javascript
import { Marker } from '@antv/l7';
 const el = document.createElement('label');
 el.className = 'labelclass';
el.textContent = nodes[i].v + '℃';
el.style.background = 'red';
el.style.borderColor = '#fff;
const marker = new Marker({ element: el})
  .setLnglat({ lng: 112, lat: 30});
scene.addMarker(marker);
```

![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*8X9uRZPI3-oAAAAAAAAAAAAAARQnAQ)

[View full code](https://codesandbox.io/s/nifty-yonath-k6zor?file=/index.html)

### Add map component

In addition to the map visualization layer, we may need to add auxiliary map tools such as zoom in and out, scale bar, layer list and other components.

```javascript
import { Scale, Zoom } from '@antv/l7';
const zoomControl = new Zoom({ position: 'topright' });
const scaleControl = new Scale({ position: 'bottomright'});
//Add to map scene
scene.addControl(zoomControl);
scene.addControl(scaleControl);
```

#### Custom component

The legend introduced above is a custom component. We can also add any component content or add map interaction to the component.
For more usage methods, please refer to`L7`Provides default components[Source code](https://github.com/antvis/L7/tree/master/packages/component/src/control)

## Use templates for different projects

Different project templates in`CodeSandbox`You can preview it or download it locally.

### React

[address](https://codesandbox.io/s/l720react-jfwyz)

### Vue

[address](https://codesandbox.io/s/l720vue-uef1x)

### Angular

[address](https://codesandbox.io/s/angulartest-chpff)

### HTML CDN

[address](https://codesandbox.io/s/l7cdndemo-gfg9m)
---
title: 网格热力图
order: 1
---
<embed src="@/docs/common/style.md"></embed>

将一组点数据按照等大小的正方形网格进行聚合，一个正方形网格代表网格内所有点的统计值。方格热力图特点以方格网布局。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*XPBuSIPPgsgAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单的网格热力图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/heatmap/grid#china)

```javascript
import { Scene, HeatmapLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 107.054293, 35.246265 ],
    zoom: 4.056
  })
});
scene.on('loaded', () => {
  fetch(
    'https://gw.alipayobjects.com/os/basement_prod/7359a5e9-3c5e-453f-b207-bc892fb23b84.csv'
  )
    .then(res => res.text())
    .then(data => {
      const layer = new HeatmapLayer({})
        .source(data, {
          parser: {
            type: 'csv',
            x: 'lng',
            y: 'lat'
          },
          transforms: [
            {
              type: 'grid',
              size: 20000,
              field: 'v',
              method: 'sum'
            }
          ]
        })
        .shape('square')
        .style({
          coverage: 1,
          angle: 0
        })
        .color(
          'count',
          [
            '#0B0030',
            '#100243',
            '#100243',
            '#1B048B',
            '#051FB7',
            '#0350C1',
            '#0350C1',
            '#0072C4',
            '#0796D3',
            '#2BA9DF',
            '#30C7C4',
            '#6BD5A0',
            '#A7ECB2',
            '#D0F4CA'
          ].reverse()
        );

      scene.addLayer(layer);
    });
});

```

### source

网格数据只支持点数据作为数据源，数据格式支持 `csv`、`json`、`geojson`。

#### 设置网格聚合参数

布局方法 通过 `source` 的 `tansforms` 属性配置。

- type  数据聚合类型 `hexagon`。
- size  网格半径 单位 米。
- field  聚合字段。
- method 聚合方法 `count`，`max`，`min`，`sum`，`mean` 5 个统计维度。

```javascript
layer.source(data, {
  parser: {
    type: 'csv',
    x: 'lng',
    y: 'lat',
  },
  transforms: [
    {
      type: 'grid',
      size: 15000,
      field: 'v',
      method: 'sum',
    },
  ],
});
```

### shape

网格热力图虽然是以标准四边形网格进行数据聚合，但是展示效果上可以设置为各种形状，形状只支持常量。

#### 2d

- circle,
- triangle
- square
- heaxgon

```javascript
layer.shape('circle');
```

#### 3d

- cylinder
- triangleColumn
- hexagonColumn
- squareColumn,

```javascript
layer.shape('cylinder');
```

### size

### 2D shape

不需要设置 size 方法

### 3D 图形

size 表示高度, 支持常量和数据映射

```javascript
layer.size(10); // 常量
layer.size('value', [10, 50]); // 根据value 字段映射大小
layer.size('value', (value) => {}); // 回调函数设置高度
```

### color

同 layer color 方法

### style

- coverage 网格覆盖度 0 - 1
- angle 网格旋转角度 0 - 360
- opacity 透明度 0 - 1.0

```javascript
layer.style({
  coverage: 0.9,
  angle: 0,
  opacity: 1.0,
});
```---
title: Grid Heatmap
order: 1
---

<embed src="@/docs/common/style.md"></embed>

Aggregate a set of point data into square grids of equal size. A square grid represents the statistical values ​​of all points in the grid. The grid heat map features a grid layout.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*XPBuSIPPgsgAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a simple grid heat map.

* you can`L7`Found on the official website[Online case](/examples/heatmap/grid#china)

```javascript
import { Scene, HeatmapLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'light',
    center: [ 107.054293, 35.246265 ],
    zoom: 4.056
  })
});
scene.on('loaded', () => {
  fetch(
    'https://gw.alipayobjects.com/os/basement_prod/7359a5e9-3c5e-453f-b207-bc892fb23b84.csv'
  )
    .then(res => res.text())
    .then(data => {
      const layer = new HeatmapLayer({})
        .source(data, {
          parser: {
            type: 'csv',
            x: 'lng',
            y: 'lat'
          },
          transforms: [
            {
              type: 'grid',
              size: 20000,
              field: 'v',
              method: 'sum'
            }
          ]
        })
        .shape('square')
        .style({
          coverage: 1,
          angle: 0
        })
        .color(
          'count',
          [
            '#0B0030',
            '#100243',
            '#100243',
            '#1B048B',
            '#051FB7',
            '#0350C1',
            '#0350C1',
            '#0072C4',
            '#0796D3',
            '#2BA9DF',
            '#30C7C4',
            '#6BD5A0',
            '#A7ECB2',
            '#D0F4CA'
          ].reverse()
        );

      scene.addLayer(layer);
    });
});
```

### source

Grid data only supports point data as the data source, and the data format supports`csv`、`json`、`geojson`。

#### Set grid aggregation parameters

layout method pass`source`of`tansforms`Property configuration.

* type data aggregation type`hexagon`。
* size grid radius in meters.
* field Aggregation field.
* method aggregation method`count`，`max`，`min`，`sum`，`mean`5 statistical dimensions.

```javascript
layer.source(data, {
  parser: {
    type: 'csv',
    x: 'lng',
    y: 'lat',
  },
  transforms: [
    {
      type: 'grid',
      size: 15000,
      field: 'v',
      method: 'sum',
    },
  ],
});
```

### shape

Although the grid heat map uses a standard quadrilateral grid for data aggregation, the display effect can be set to various shapes, and the shape only supports constants.

#### 2d

* circle,
* triangle
* square
* heaxgon

```javascript
layer.shape('circle');
```

#### 3d

* cylinder
* triangleColumn
* hexagonColumn
* squareColumn,

```javascript
layer.shape('cylinder');
```

### size

### 2D shape

No need to set size method

### 3D graphics

size represents height, supports constants and data mapping

```javascript
layer.size(10); // constant
layer.size('value', [10, 50]); // Map size based on value field
layer.size('value', (value) => {}); // Callback function to set height
```

### color

Same as layer color method

### style

* coverage Grid coverage 0 - 1
* angle Grid rotation angle 0 - 360
* opacity transparency 0 - 1.0

```javascript
layer.style({
  coverage: 0.9,
  angle: 0,
  opacity: 1.0,
});
```
---
title: hexagon heatmap
order: 2
---

<embed src="@/docs/common/style.md"></embed>

Aggregate a set of point data into hexagonal grids of equal size. One hexagonal grid represents the statistical values ​​of all points in the grid. The Honeycomb Heatmap feature is laid out in a hexagonal heatmap grid.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*SLcGSbvZoEwAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let’s introduce how to draw a simple cellular heat map.

* you can`L7`Found on the official website[Online case](/examples/heatmap/hexagon/#china)

```javascript
import { Scene, HeatmapLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'dark',
    pitch: 43,
    center: [ 120.13383079335335, 29.651873105004427 ],
    zoom: 7.068989519212174
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/a1a8158d-6fe3-424b-8e50-694ccf61c4d7.csv')
    .then(res => res.text())
    .then(data => {
      const layer = new HeatmapLayer({})
        .source(data, {
          parser: {
            type: 'csv',
            x: 'lng',
            y: 'lat'
          },
          transforms: [
            {
              type: 'hexagon',
              size: 2500,
              field: 'v',
              method: 'sum'
            }
          ]
        })
        .size('sum', sum => {
          return sum * 200;
        })
        .shape('hexagonColumn')
        .style({
          coverage: 0.8,
          angle: 0,
        })
        .color('sum', [
          '#094D4A',
          '#146968',
          '#1D7F7E',
          '#289899',
          '#34B6B7',
          '#4AC5AF',
          '#5FD3A6',
          '#7BE39E',
          '#A1EDB8',
          '#C3F9CC',
          '#DEFAC0',
          '#ECFFB1'
        ]);
      scene.addLayer(layer);
    });
});
```

### source

Grid data only supports point data as the data source, and the data format supports`csv`、`json`、`geojson`。

#### Set grid aggregation parameters

layout method pass`source`of`tansforms`Property configuration.

* type data aggregation type`hexagon`。
* size grid radius in meters.
* field Aggregation field.
* method aggregation method`count`，`max`，`min`，`sum`，`mean`5 statistical dimensions.

```javascript
layer.source(data, {
  parser: {
    type: 'csv',
    x: 'lng',
    y: 'lat',
  },
  transforms: [
    {
      type: 'hexagon',
      size: 15000,
      field: 'v',
      method: 'sum',
    },
  ],
});
```

### shape

Although the grid heat map uses a standard quadrilateral grid for data aggregation, the display effect can be set to its shape. The shape only supports constants.

#### 2d

* circle,
* triangle
* square
* heaxgon

```javascript
layer.shape('circle');
```

#### 3d

* cylinder
* triangleColumn
* hexagonColumn
* squareColumn,

```javascript
layer.shape('cylinder');
```

### size

### 2D shape

No need to set size method

### 3D graphics

size represents height, supports constants and data mapping

```javascript
layer.size(10); // constant
layer.size('value', [10, 50]); // Map size based on value field
layer.size('value', (value) => {}); // Callback function to set height
```

### style

* coverage Grid coverage 0 - 1
* angle Grid rotation angle 0 - 360
* opacity transparency 0 - 1.0

```javascript
layer.style({
  coverage: 0.9,
  angle: 0,
  opacity: 1.0,
});
```
---
title: 蜂窝热力图
order: 2
---
<embed src="@/docs/common/style.md"></embed>

将一组点数据按照等大小的六边形网格进行聚合，一个六边形网格代表网格内所有点的统计值。蜂窝热力图特点以六边形热力图网格布局。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*SLcGSbvZoEwAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个简单的蜂窝热力图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/heatmap/hexagon/#china)

```javascript
import { Scene, HeatmapLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'dark',
    pitch: 43,
    center: [ 120.13383079335335, 29.651873105004427 ],
    zoom: 7.068989519212174
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/a1a8158d-6fe3-424b-8e50-694ccf61c4d7.csv')
    .then(res => res.text())
    .then(data => {
      const layer = new HeatmapLayer({})
        .source(data, {
          parser: {
            type: 'csv',
            x: 'lng',
            y: 'lat'
          },
          transforms: [
            {
              type: 'hexagon',
              size: 2500,
              field: 'v',
              method: 'sum'
            }
          ]
        })
        .size('sum', sum => {
          return sum * 200;
        })
        .shape('hexagonColumn')
        .style({
          coverage: 0.8,
          angle: 0,
        })
        .color('sum', [
          '#094D4A',
          '#146968',
          '#1D7F7E',
          '#289899',
          '#34B6B7',
          '#4AC5AF',
          '#5FD3A6',
          '#7BE39E',
          '#A1EDB8',
          '#C3F9CC',
          '#DEFAC0',
          '#ECFFB1'
        ]);
      scene.addLayer(layer);
    });
});

```

### source

网格数据只支持点数据作为数据源，数据格式支持 `csv`、`json`、`geojson`。

#### 设置网格聚合参数

布局方法 通过 `source` 的 `tansforms` 属性配置。

- type  数据聚合类型 `hexagon`。
- size  网格半径 单位 米。
- field  聚合字段。
- method 聚合方法 `count`，`max`，`min`，`sum`，`mean` 5 个统计维度。

```javascript
layer.source(data, {
  parser: {
    type: 'csv',
    x: 'lng',
    y: 'lat',
  },
  transforms: [
    {
      type: 'hexagon',
      size: 15000,
      field: 'v',
      method: 'sum',
    },
  ],
});
```

### shape

网格热力图虽然是以标准四边形网格进行数据聚合，但是展示效果上可以设置为其形状，形状只支持常量

#### 2d

- circle,
- triangle
- square
- heaxgon

```javascript
layer.shape('circle');
```

#### 3d

- cylinder
- triangleColumn
- hexagonColumn
- squareColumn,

```javascript
layer.shape('cylinder');
```

### size

### 2D shape

不需要设置 size 方法

### 3D 图形

size 表示高度, 支持常量和数据映射

```javascript
layer.size(10); // 常量
layer.size('value', [10, 50]); // 根据value 字段映射大小
layer.size('value', (value) => {}); // 回调函数设置高度
```

### style

- coverage 网格覆盖度 0 - 1
- angle 网格旋转角度 0 - 360
- opacity 透明度 0 - 1.0

```javascript
layer.style({
  coverage: 0.9,
  angle: 0,
  opacity: 1.0,
});
```---
title: 经典热力图
order: 0
---
<embed src="@/docs/common/style.md"></embed>


热力图是地图可视化场景中十分常见的需求。在区域范围内数据具有的一定热度分级分布情况的聚合面状现象，常用于描述人群分布、密度和变化趋势等。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*QstiQq4JBOIAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### 实现

下面我们来介绍如何绘制一个经典热力图。

- 你可以在 `L7` 官网上找到[在线案例](/examples/heatmap/heatmap/#heatmap)

```javascript
import { Scene, HeatmapLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'dark',
    center: [ 127.5671666579043, 7.445038892195569 ],
    zoom: 2.632456779444394
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/d3564b06-670f-46ea-8edb-842f7010a7c6.json')
    .then(res => res.json())
    .then(data => {
      const layer = new HeatmapLayer({})
        .source(data)
        .shape('heatmap')
        .size('mag', [ 0, 1.0 ]) // weight映射通道
        .style({
          intensity: 2,
          radius: 20,
          rampColors: {
            colors: [
              '#FF4818',
              '#F7B74A',
              '#FFF598',
              '#91EABC',
              '#2EA9A1',
              '#206C7C'
            ].reverse(),
            positions: [ 0, 0.2, 0.4, 0.6, 0.8, 1.0 ]
          }
        });
      scene.addLayer(layer);
    });
});
```
### source

经典热力图只支持点数据作为数据源，数据格式支持 `csv`、`json`、`geojson`。

```js
const source = new Source([{
  lng: 120, lat: 30
},...], {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat'
  }
})
```
### shape

经典热力图的 `shape` 为常量 `heatmap`。

### size

我们需要将值映射到 `[0, 1]` 的值域空间。

- `field`: 热力图权重字段
- `values`: 数据映射区间 热力图显示 `[0, 1]` 效果最佳

```javascript
layer.size('weight', [0, 1]);
```

### color

热力图通过 `style` 的指定参数配置颜色。

### style

- `intensity`   全局热力权重，推荐权重范围 `1 - 5`。
- `radius`      热力半径，单位像素。
- `rampColors`  色带参数。

#### rampColors

- `colors`  颜色数组
- `positions` 数据区间

配置值域映射颜色的色带，值域的范围为 `[0 - 1]`, 对应的我们需要为每一个 `position` 位置设置一个颜色值。

⚠️ colors, positions 的长度要相同

```javascript
layer.style({
  rampColors: {
    colors: ['#FF4818', '#F7B74A', '#FFF598', '#91EABC', '#2EA9A1', '#206C7C'],
    positions: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
  },
});
```
---
title: heatmap
order: 0
---

<embed src="@/docs/common/style.md"></embed>

Heat maps are a very common requirement in map visualization scenarios. The aggregate surface phenomenon of a certain degree of heat distribution within a region is often used to describe crowd distribution, density, and changing trends.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*QstiQq4JBOIAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

### accomplish

Let's introduce how to draw a classic heat map.

* you can`L7`Found on the official website[Online case](/examples/heatmap/heatmap/#heatmap)

```javascript
import { Scene, HeatmapLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'dark',
    center: [ 127.5671666579043, 7.445038892195569 ],
    zoom: 2.632456779444394
  })
});
scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/basement_prod/d3564b06-670f-46ea-8edb-842f7010a7c6.json')
    .then(res => res.json())
    .then(data => {
      const layer = new HeatmapLayer({})
        .source(data)
        .shape('heatmap')
        .size('mag', [ 0, 1.0 ]) // weight映射通道
        .style({
          intensity: 2,
          radius: 20,
          rampColors: {
            colors: [
              '#FF4818',
              '#F7B74A',
              '#FFF598',
              '#91EABC',
              '#2EA9A1',
              '#206C7C'
            ].reverse(),
            positions: [ 0, 0.2, 0.4, 0.6, 0.8, 1.0 ]
          }
        });
      scene.addLayer(layer);
    });
});
```

### source

Classic heat maps only support point data as the data source, and the data format supports`csv`、`json`、`geojson`。

```js
const source = new Source([{
  lng: 120, lat: 30
},...], {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat'
  }
})
```

### shape

Classic heat map`shape`is a constant`heatmap`。

### size

We need to map the value to`[0, 1]`value range space.

* `field`:Heat map weight field
* `values`: Data mapping interval heat map display`[0, 1]`best effect

```javascript
layer.size('weight', [0, 1]);
```

### color

Heatmap passed`style`The specified parameters configure the color.

### style

* `intensity`Global thermal weight, recommended weight range`1 - 5`。
* `radius`Thermal radius, unit pixel.
* `rampColors`Ribbon parameters.

#### rampColors

* `colors`Color array
* `positions`data interval

Configure the color band of the value range mapping color. The range of the value range is`[0 - 1]`, correspondingly we need to provide each`position`Position sets a color value.

⚠️ colors, positions must be the same length

```javascript
layer.style({
  rampColors: {
    colors: ['#FF4818', '#F7B74A', '#FFF598', '#91EABC', '#2EA9A1', '#206C7C'],
    positions: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
  },
});
```
---
title: 快速上手
order: 1
---
<embed src="@/docs/common/style.md"></embed>

`L7` 可以通过在线 `CDN` 以及 `NPM` 包等形式快速接入。通过 `L7` 提供的能力，我们可以快速完成地图可视化的绘制。

## 安装引入
### 通过 npm 引入

```javascript
// 安装L7 依赖
npm install --save @antv/l7
// 安装第三方底图依赖
npm install --save @antv/l7-maps
```

### 通过 CDN 引入

```html
<head>
<! --引入最新版的L7--> 
<script src = 'https://unpkg.com/@antv/l7'></script>
<! --指定版本号引入L7--> 
<script src = 'https://unpkg.com/@antv/l7@2.0.11'></script>
</head>
```
CDN 引用 在使用时通过 L7 命名空间获取所有对象并初始化，如 L7.scene、L7.GaodeMap

```javascript
import { Scene } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new L7.Scene({
  id: 'map',
  map: new L7.GaodeMap({
    style: 'dark',
    center: [110.770672, 34.159869],
    pitch: 45,
  }),
});
```

## 基础教程
### 地图组件使用

1. 初始化地图首先需要在页面中新增一个Dom 用于地图初始化。

```html
<div style="min-height: 500px; justify-content: center;position: relative" id="map"/>
```

2. 初始化高德地图

```javascript
import { GaodeMap } from '@antv/l7-maps';
// 同样你也可以初始化一个 Mapbox 地图
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    pitch: 35.210526315789465,
    style: 'dark',
    center: [ 104.288144, 31.239692 ],
    zoom: 4.4
  })
})
```
🌟 此时在页面上就会出现可交互的地图内容。

### 绘制填充图

地图初始化完成之后我们，那我们就可以往地图添加可视化数据了，这里我们以中国行政区区数据为例，如何可视化面数据。
数据源： 中国各省 [GeoJSON](https://gw.alipayobjects.com/os/bmw-prod/d6da7ac1-8b4f-4a55-93ea-e81aa08f0cf3.json) 数据。

1. 我们使用面图层来绘制行政区划数据，得到覆盖在地图表面的几何平面。

```javascript
import {  PolygonLayer } from '@antv/l7';
 const chinaPolygonLayer = new PolygonLayer({})
  .source(data)
  .color('name', [
    'rgb(239,243,255)',
    'rgb(189,215,231)',
    'rgb(107,174,214)',
    'rgb(49,130,189)',
    'rgb(8,81,156)'
  ]);
```

2. 图层创建完成之后我们需要将它添加到 `Scene` 中进行显示。

```javascript
scene.addLayer(chinaPolygonLayer)
```
![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*iUZVSYBtKnMAAAAAAAAAAAAAARQnAQ)

3. 简单的填充可视化还是不够直观，我们可以使用 `LineLayer` 和 `PointLayer` 增加行政区划描边和行政区划文字标注。

![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*Tf95Qp43Z6IAAAAAAAAAAAAAARQnAQ)

4. 添边界和文本标注之后可视化效果更加清晰。

[查看完整代码](https://codesandbox.io/s/l7-tianchongtujiaocheng-275ix?file=/index.js)

### 交互式填充图

单纯的数据展现出来，并不能满足我的需求，我们可能需要查看每个区块的相关信息，或者添加一些高亮效果。
#### 默认高亮

`L7` 图层添加默认的高亮效果，默认的高亮效果可以改变颜色。

```javascript
chinaPolygonLayer.active(true) //  开启默认高亮效果

chinaPolygonLayer.active({color: red}) // 开启并设置高亮颜色为红色
```


| **![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*vik-Q7frCMMAAAAAAAAAAAAAARQnAQ)** | **![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*RJiaS498G4wAAAAAAAAAAAAAARQnAQ)** |
| --- | --- |
| 默认蓝色高亮效果 | 更改高亮颜色 |


#### 自定义高亮效果

默认的高亮效果只能改变颜色，可能并不能满足我的需求，我们可能需要白色的描边，这能够实现吗，答案肯定是可以的。

1. 添加一个新的图层的作为高亮图层, 数据我们设置成空数据，形状设置成 `line`

```javascript
const hightLayer = new LineLayer({
  zIndex: 4, // 设置显示层级
  name: 'hightlight'
}) .source({
    type: 'FeatureCollection',
    features: [ ]
  })
  .shape('line')
  .size(2)
  .color('red');
scene.addLayer(hightLayer);
```

2. 这样我们就可以监听需要高亮图层的鼠标事件，获取当前选中的数据，然后更新 `hightLayer` 既可实现描边高亮效果。

```javascript
chinaPolygonLayer.on('click', feature => {
    hightLayer.setData({
      type: 'FeatureCollection',
      features: [ feature.feature ]
    });
  });
```

![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*fr9DTY54rhUAAAAAAAAAAAAAARQnAQ)

3. 为图层添加点击高亮红色描边效果

到这里我们就学会了如何自定义高亮效果，这里提个小问题“如何实现双描边的高亮效果？”

[查看示例](https://codesandbox.io/s/zidingyigaoliang-7vkso?file=/index.js)

#### 添加信息 Popup 信息窗

鼠标交互时，我们除了高亮显示划过的区域我们还需要信息区域相关的信息，这里 `L7` 提供了 `Popup` 组件用于在地图显示相关信息。

引入对象
```javascript
import { Popup } from "@antv/l7";
```
我们可以通过对 Layer 监听鼠标事件，决定何时显示Popup,
```javascript
 layer.on('mousemove', e => {
   const popup = new Popup({
     offsets: [ 0, 0 ],
     closeButton: false
   })
   .setLnglat(e.lngLat)
   .setHTML(`<span>地区: ${e.feature.properties.name}</span><br><span>确诊数: ${e.feature.properties.case}</span>`);
   scene.addPopup(popup);
   });
```

![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*2isvTq-s0OMAAAAAAAAAAAAAARQnAQ)

[查看示例](https://codesandbox.io/s/popup-x3j00?file=/index.js)
### 添加图例

上面我们已经学会了如何可视化数据，在地图我们将不同的区域可视为不同颜色，但是如何读懂不同的颜色表达的什么含义，我们需要添加一个图例。

`L7` 目前没有默认的图例组件，需要自己创建图例，这里我们介绍通过 `L7 Control` 基类创建图例组件，当然你也可以实现一个独立的图例 `Dom` 组件。

`L7` 提供了默认的 `Zoom`，`Scale`，`Logo` 等组件这些组件都基于同一个基类 `Control` 组件，今天我们基于 `Control` 实现自定义图例组件。

1. 引入 `Control` 基类

```javascript
import { Control } from "@antv/l7";
```

2. 初始化基类

```javascript
const legend = new Control({
  position: "bottomright"
});
```

3. 设置 `Control` 展示内容

通过扩展 `Control` 的 `onAdd` 方法我们自由定制 `Control` 需要展示内容和交互。

```javascript
legend.onAdd = function () {
  var el = document.createElement("div");
  el.className = "infolegend legend";
  var grades = [0, 10, 20, 50, 100, 200, 500];
  for (var i = 0; i < grades.length; i++) {
    el.innerHTML +=
      '<i style="background:' + color[i] + '"></i> ' + grades[i] +
      (grades[i + 1] ? "–" + grades[i + 1] + "<br>" : "+");
  }
  return el;
};
```

4. 添加到地图

```javascript
scene.addControl(legend)
```
![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*7VNfRodZ_8AAAAAAAAAAAAAAARQnAQ)

[查看示例](https://codesandbox.io/s/tuli-keov0?file=/index.js)

这里我们介绍了，如何通过自己定义 `Control` 的方式实现图例，通过自定义 `Control` 我们很多地图组件，如全屏组件，定位组件，很多业务上需要的组件，有幸运的同学们可以动手尝试一下了。
### 时序变化图

上面我们可视化的是一个静态数据，但是很多时候我们的数据是随时间变化的，如何进行时序数据的可视化，这里我们介绍两种时序数据可视化方法。

#### 准备数据

地理数据：[美国各州行政区划数据](https://gw.alipayobjects.com/os/basement_prod/d36ad90e-3902-4742-b8a2-d93f7e5dafa2.json)
属性数据：[0908-1008近30天的美国各州新冠确诊数据](https://gw.alipayobjects.com/os/bmw-prod/bed5e504-04d5-4d96-a335-163e038dc65a.csv)。

#### 更新数据

随着时间的变化，数据肯定发生变化，因此最简单的方式我每个时间更新一下数据即可.

```javascript
chinaPolygonLayer.setData(newData);
```
[完整示例](https://codesandbox.io/s/shujugengxin-kgwy0?file=/index.js)

#### 更新颜色

时序数据的更新很大一部分场景是属性数据的更新，比如各省不同年份的 `GDP` 数据，空间数据本身没有发生变化（没有增加或者减少也没有更新边界）这种情况对面图层来说可能只需要根据新的数据更新一下就可以实现。当然通过 `setData` 也可以实现。`L7` 内部实现机制来看 更新 `color` 的效率要比 `setData` 效率高的多。

通过更新颜色映射字段，实现数据显示的更新。

```javascript
const setColor = (d) => {
      return d > 100000
        ? color[7]
        : d > 80000
        ? color[6]
        : d > 40000
        ? color[5]
        : d > 20000
        ? color[4]
        : d > 10000
        ? color[3]
        : d > 5000
        ? color[2]
        : d > 1000
        ? color[1]
        : color[0];
    }

chinaPolygonLayer.color('2020-09-01', setColor)
chinaPolygonLayer.color('2020-09-02', setColor)
```
注意更新颜色生效，需要调用 `Scene.render();`。

[查看示例](https://codesandbox.io/s/shujugengxin-forked-0zul8?file=/index.js)

### 添加地图标注

`L7`  基础 `WebGL` 实现绘制简单的点、线、面，比较简单，如果要实现比较复杂的地图标注就比较困难，为了解决这个问题 `L7` 添加了 `Marker` 组件，你可以基于 `DOM` 实现各种复杂的标注。

```javascript
import { Marker } from '@antv/l7';
 const el = document.createElement('label');
 el.className = 'labelclass';
el.textContent = nodes[i].v + '℃';
el.style.background = 'red';
el.style.borderColor = '#fff;
const marker = new Marker({ element: el})
  .setLnglat({ lng: 112, lat: 30});
scene.addMarker(marker);
```

![image.png](https://gw.alipayobjects.com/mdn/rms_5e897d/afts/img/A*8X9uRZPI3-oAAAAAAAAAAAAAARQnAQ)

[查看完整代码](https://codesandbox.io/s/nifty-yonath-k6zor?file=/index.html)

### 添加地图组件

除了地图可视化层之外我们可能需要添加辅助性的地图工具 比如放大缩小，比例尺，图层列表等组件。

```javascript
import {  Scale,  Zoom } from '@antv/l7';
const zoomControl = new Zoom({ position: 'topright' });
const scaleControl = new Scale({ position: 'bottomright'});
// 添加到地图场景
scene.addControl(zoomControl);
scene.addControl(scaleControl);
```

#### 自定义组件

上面介绍的图例就是一个自定义组件，同样我们可以任意组件内容，也可以为组件添加地图交互。
更多使用方式我们参考 `L7` 提供默认组件的[源码](https://github.com/antvis/L7/tree/master/packages/component/src/control)


## 不同项目使用模板

不同项目模板在 `CodeSandbox` 你可以预览，也可以下载到本地。

### React

[地址](https://codesandbox.io/s/l720react-jfwyz)

### Vue

[地址](https://codesandbox.io/s/l720vue-uef1x)

### Angular

[地址](https://codesandbox.io/s/angulartest-chpff)

### HTML CDN
[地址](https://codesandbox.io/s/l7cdndemo-gfg9m)
---
title: Develop
order: 5
---

<embed src="@/docs/common/style.md"></embed>

The developers here refer to developers who develop L7 and have the ability to fix bugs, improve documentation, upgrade functions, and develop new functions for L7.

### Fork warehouse

Fork the L7 repository into its own space.

### Download the code after Fork

```bash
git clone https://github.com/antvis/L7  --depth=1
```

### Install dependencies

node version recommended v16.20.2

```bash
yarn install
```

### Start Demo

If you need function debugging

```bash
yarn run dev
```

Open`http://localhost:6006/`：

### Start official website

If you need to update the API or write documentation or demo, use this command

```bash
yarn start
```

Open`http://localhost:8000/`：

### Run a single test

Run unit tests:

```bash
yarn test // run in full

yarn test ../tes.spec.ts // single file
```

## Submit code

Commits can be templated using yarn commit:

```bash
yarn commit
```

## Development tasks

L7 Issues and Features are operated and managed through open source communities, allowing for completely open exploration and exchange of technical solutions. development tasks,[Claim View](https://github.com/orgs/antvis/projects/16)

For L7 developers, we have formulated a growth plan to help everyone move from junior to advanced visualization engine developers in the GIS field. If you are interested, you can add WeChat "antv2030" and indicate "Participate in L7 R\&D". We look forward to your joining and learning together.
---
title: 开发者教程
order: 5
---

<embed src="@/docs/common/style.md"></embed>

这里的开发者，是指开发 L7 的开发者，为 L7 修复 bug、完善文档、升级功能、新功能开发等能力。

### Fork 仓库

Fork L7 仓库 到自己的空间。


### 下载 Fork 后的代码

```bash

git clone https://github.com/antvis/L7  --depth=1

```

### 安装依赖

node 版本推荐  v16.20.2

```bash
yarn install 

```

### 启动 Demo

如需功能调试

```bash

yarn run dev

```
打开 `http://localhost:6006/`：

### 启动 官网

如需更新 API 或者 写文档、demo,使用该命令

```bash

yarn start 

```

打开 `http://localhost:8000/`：

### 运行单测


运行单元测试：

```bash
yarn test // 全量跑

yarn test ../tes.spec.ts // 单个文件

```

## 提交代码

可以使用 yarn commit 模板化提交：

```bash
yarn commit

```

## 开发任务

L7 Issue 和 Feature 通过开源社区的方式运作管理，可以完全的开放的探索、交流技术方案。开发任务，[认领查看](https://github.com/orgs/antvis/projects/16)

针对 L7 开发者 我们制定了成长计划，帮助大家从初级走向高级 GIS 领域 可视化引擎开发者。如有兴趣可以加 微信 "antv2030",注明  “参与L7研发”，期待你加入，一起学习。


### Tile source attribute

#### tileSet

Tile data set, which can obtain tile information and tile status within the current field of view

```ts
const source = layer1.getSource();
const tileSet = source.tileset;
```

##### Attributes

###### isLoaded

Whether the tiles are loaded

###### currentTiles

Current tile object

###### currentZoom

The current tile level; where once is not equal to the zoom level of the map

##### event

###### tiles-load-start

Map dragging, triggered when new tiles need to be loaded

```ts
tileSet.on('tiles-load-start',()=>{
            console.log('tile start');
        })
```

###### tiles-load-finished

Triggered after all tile resources that need to be loaded are loaded.

```ts
tileSet.on('tiles-load-finished',()=>{
            console.log('tile finished');
        })
```

### Tile source method

#### reloadAllTile

Reloading the tile will re-request the data, which is suitable for dynamic tile scenarios, such as the tile data is updated, or the data of the tile Join is updated.

```ts pure
source.reloadAllTile();
```

#### reloadTilebyId

Reload a specific tile

parameter

* z zoom level
* x tile x coordinate
* y tile has coordinates

```ts pure
source.reloadTileById(z,x,y);
```

#### reloadTileByExtent

Update tiles based on latitude and longitude range

parameter

* extent: latitude and longitude range \[minLng,minLat,maxLng,maxLat]
* zoom: zoom level

#### reloadTileByLnglat

Update tiles based on longitude and latitude, convert longitude and latitude coordinates into tile coordinates and update

* lng longitude
* latitude
* zoom zoom level

```tsx pure
source.reloadTileByLnglat(112,30,10);
```
### 瓦片source 属性

#### tileSet 
 瓦片数据集，可以获取当前视野内的瓦片信息, 瓦片状态

 ```ts
 const source = layer1.getSource();
 const tileSet = source.tileset;
 ```
 ##### 属性
 
###### isLoaded 

瓦片是否加载完成

###### currentTiles
当前瓦片对象

###### currentZoom

当前瓦片层级；这里的曾经和map 的缩放层级不相等

 ##### 事件

 ###### tiles-load-start

地图拖动，需要加载新的瓦片时触发

```ts
     
        tileSet.on('tiles-load-start',()=>{
            console.log('tile start');
        })
      
 ```
  

###### tiles-load-finished

所有需要加载的瓦片资源加载完成后触发

```ts
      tileSet.on('tiles-load-finished',()=>{
            console.log('tile finished');
        })
```

### 瓦片source 方法

#### reloadAllTile

重新加载瓦片，会重新请求数据，适用与动态瓦片场景，如瓦片数据发生了更新，或者瓦片Join 的数据发生了更新

``` ts pure
source.reloadAllTile();
```

#### reloadTilebyId

重新加载特定瓦片的 

参数
- z  缩放等级
- x  瓦片 x 坐标
- y  瓦片有坐标

```ts  pure
source.reloadTileById(z,x,y);
```

#### reloadTileByExtent

根据经纬度范围更新瓦片

参数

- extent: 经纬范围 [minLng,minLat,maxLng,maxLat]
- zoom: 缩放等级

#### reloadTileByLnglat

根据经纬度更新瓦片，经纬度坐标转换成瓦片坐标更新

- lng 经度
- lat  纬度
- zoom 缩放等级


```tsx pure

source.reloadTileByLnglat(112,30,10);
```### data

Multi-band supports two data methods. The raster data coordinate system only supports 3857 projected rasters.

* Single file multiple bands
* Multiple single-band files form multi-band

#### Single file multiple bands

data is unparsed tiff arraybuffer data, which is standardized by format in parser

```ts
const url1 = 'https://gw.alipayobjects.com/zos/raptor/1667832825992/LC08_3857_clip_2.tif';
  async function getTiffData(url: string) {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  return arrayBuffer;
  }
}
layer.source(
    [
    {
        data: tiffdata,
        bands: [6, 5, 2].map((v) => v - 1),
    },
    ],
    {
    parser: {
        type: 'rasterRgb',
        format: async (data, bands) => {
        const tiff = await GeoTIFF.fromArrayBuffer(data);
        const image1 = await tiff.getImage();
        const value = await image1.readRasters();
        return bands.map((band) => {
            return {
            rasterData: value[band],
            width: value.width,
            height: value.height,
            };
        });
        },
        operation: {
        type: 'rgb',
        },
        extent: [
        130.39565357746957, 46.905730725742366, 130.73364094187343,
        47.10217234153133,
        ],
    },
    },
)
```

### parser

* type: raster
* extent: the latitude and longitude range of the raster \[minlng, minlat,maxLng, maxLat]

Add raster data to the map based on its latitude and longitude range.

```javascript
layer.source(rasterData, {
  parser: {
    type: 'raster',
    extent: [121.168, 30.2828, 121.384, 30.4219],
  },
});
```

Users can directly pass in the binary data of the raster file.

* Supports transferring data from multiple files.
* Supports specifying the bands to be extracted from a raster file.

```js
interface IBandsData {
  data: ArrayBuffer; // Request the binary data of the loaded raster file
  bands?: number[]; // Specify the bands to load the raster file
}
//Load the data of band 0 by default
const source = new Source({ data: tiffData });
//Specify to load the data of tiffData 0 band
//Specify to load the data of band 0 and 1 of tiffData2
const source2 = new Source([
  { data: tiffData, bands: [0] },
  { data: tiffData2, bands: [0, 1] },
]);
```

#### parser

<description> *IParser* **required** </description>

Provides the necessary parameters and methods for working with raster data.

```js
interface IParser {
  type: string;
  format: IRasterFormat;
  operation: IOperation;
  extent: number[];
}
```

##### type

<description> *string* **required** </description>

* When the output result is single-channel data, the value is raster
* When the output result is multi-channel color, the value is rasterRgb.

##### format: IRasterFormat

<description> *IFormat* **required** </description>

`format`Method used to extract band data from the incoming raster file binary data.

* The first parameter is the raster file binary data.
* The second parameter is the band that should be extracted from the raster file specified by the first parameter. The method parameter is what we pass`source`parameters passed`data`numerical value.
* `format`Is a`async`method.

```js
interface IRasterData {
  rasterData: HTMLImageElement | Uint8Array | ImageBitmap | null | undefined;
  width: number;
  height: number;
}
type IRasterFormat = (
  data: ArrayBuffer,
  bands: number[],
) => Promise<IRasterData | IRasterData[]>;

const source = new Source(data, {
  parser: {
    format: async (data, bands) => {
      ...
      return {
        rasterData: bandData,
        width: 256;
        height: 256;
      }
    }
  }
})
```

1. `format`The return value of the method is raster data (`rasterData`) and the size`width`、`height`parameter.
2. `format`The method can return multiple copies of data, indicating that multiple band data are extracted from the current raster file.

##### operation: IOperation

<description> *IOperation* **Optional** </description>

When loading multi-band data we can pass`operation`Configure the operation of band data.

🌟 We don’t need to configure it`operation`, the first band data extracted from the first raster file is used by default.

1. `operation`can be a function,`allbands`is the collection of all band data we extracted from all raster files.

```js
const parser = {
  operation: (allBands) => {
    // operation can be a function, allbands is the collection of all band data we extract from all raster files,
    // When setting up allbands, it is [band0]
    //The return value of the function is pure band data. Here we directly return the first band data.
    return allBands[0].rasterData;
  },
};
```

2. `operation`Can be a calculation expression in the form of an array.

```js
//The following expression can be paraphrased as band1 * 0.5, which means multiplying the values ​​of band 1 by 0.5 and returning
const parser = {
  operation: ['*', ['band', 1], 0.5],
};
```

3. `operation`Can be used nested:`['+', ['*', ['band', 0], 0.2], ['band', 1]]]`, the return result is:`band0 * 0.2 + band1`。

4. `operation`The result can be specified directly:`['band', 0]`。

5. `operation`The following mathematical operations are supported.

```js
/** Mathematical operations Perform mathematical operations based on calculation expressions
 * * * Math operators:
 * `['*', value1, value2]` returns `value1 * value2`
 * `['/', value1, value2]` returns `value1 / value2`
 * `['+', value1, value2]` returns `value1 + value2`
 * `['-', value1, value2]` returns `value2 - value1`
 * `['%', value1, value2]` returns `value1 % value2`
 * `['^', value1, value2]` returns `value1 ^ value2`
 * `['abs', value1]` returns `Math.abs(value1)`
 * `['floor', value1]` returns `Math.floor(value1)`
 * `['round', value1]` returns `Math.round(value1)`
 * `['ceil', value1]` returns `Math.ceil(value1)`
 * `['sin', value1]` returns `Math.sin(value1)`
 * `['cos', value1]` returns `Math.cos(value1)`
 * `['atan', value1, value2]` returns `n1===-1?Math.atan(n1): Math.atan2(n1, n2)`
 */
```

##### extent

<description> *number\[]* **required** </description>

`extent`It describes the geographical interval covered by the raster data, and the numerical value specifies the longitude and latitude interval (lower left corner and upper right corner) of the area.

### Loading multi-channel (color) images

When using multi-band data, we support drawing color remote sensing images based on multi-band data, such as the false color image below.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*jO7kTpuDiOQAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

#### data: IBandsData\[] | IBandsData

When drawing multi-channel images, multi-band data needs to be loaded

#### parser

Provides necessary parameters and methods for using raster data, specific uses and multi-band rasters.`parser`be consistent.

##### type

<description> *string* **required** </description>

* When the output result is multi-channel color, the value is`rasterRgb`。

##### format: IRasterFormat

<description> *IFormat* **required** </description>

When drawing multi-channel images, use the general`format`function.

##### operation: IOperation

<description> *IOperation* **required** </description>

In order to draw multi-channel images, we must provide`operation`Configure specified multi-channel data.

1. When rendering a color multi-channel raster, you need to use an additional parser. At the same time, the color raster layer no longer supports parameters such as domain and rampColor. The rendering result is directly controlled by the numerical results of the r, g, and b channels calculated by the band.

2. Colored rasters are no longer compatible with the old data value transfer method (pass in the parsed raster data directly.

```js
const source = new Source(data, { // Colored rasters and single-channel rasters use the same rules
  parser: {
    type: 'rasterRgb', // use independent type type
    format: async (data, bands) {...}, // Colored rasters and single-channel rasters use the same format
    // operation is an object, specifying calculation expressions for the three rgb channels respectively.
    // operation must be configured
    operation: {
      r: ['*', ['band', 1], 0.5],
      g: ['band', 1],
      b: undefined // The channel of the default configuration expression will take the value of band 0 by default
    }
  }
```
### data

多波段支持两种数据方式，栅格数据坐标系只支持 3857 投影的栅格

- 单文件多波段
- 多个单波段文件组成多波段

#### 单文件多波段

data 为未解析过 tiff arraybuffer 数据，在 parser 中 通过 format 进行数据标准化

```ts
  const url1 = 'https://gw.alipayobjects.com/zos/raptor/1667832825992/LC08_3857_clip_2.tif';
  async function getTiffData(url: string) {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  return arrayBuffer;
  }
}
layer.source(
    [
    {
        data: tiffdata,
        bands: [6, 5, 2].map((v) => v - 1),
    },
    ],
    {
    parser: {
        type: 'rasterRgb',
        format: async (data, bands) => {
        const tiff = await GeoTIFF.fromArrayBuffer(data);
        const image1 = await tiff.getImage();
        const value = await image1.readRasters();
        return bands.map((band) => {
            return {
            rasterData: value[band],
            width: value.width,
            height: value.height,
            };
        });
        },
        operation: {
        type: 'rgb',
        },
        extent: [
        130.39565357746957, 46.905730725742366, 130.73364094187343,
        47.10217234153133,
        ],
    },
    },
)

```

### parser

- type: raster
- extent: 栅格的经纬度范围 [minlng, minlat,maxLng, maxLat]


根据栅格数据的经纬度范围，将其添加到地图上。

```javascript
layer.source(rasterData, {
  parser: {
    type: 'raster',
    extent: [121.168, 30.2828, 121.384, 30.4219],
  },
});
```

用户可以直接传入栅格文件的二进制数据。

- 支持传入多文件的数据。
- 支持指定某个栅格文件要提取的波段。

```js
interface IBandsData {
  data: ArrayBuffer; // 请求加载的栅格文件的二进制数据
  bands?: number[]; // 指定加载该栅格文件的波段
}
// 默认加载 0 波段的数据
const source = new Source({ data: tiffData });
// 指定加载 tiffData 0 波段的数据
// 指定加载 tiffData2 0、1 波段的数据
const source2 = new Source([
  { data: tiffData, bands: [0] },
  { data: tiffData2, bands: [0, 1] },
]);
```

#### parser

<description> _IParser_ **必选** </description>

为使用栅格数据的使用提供必要的参数和方法。

```js
interface IParser {
  type: string;
  format: IRasterFormat;
  operation: IOperation;
  extent: number[];
}
```

##### type

<description> _string_ **必选** </description>

- 输出结果为单通道数据的时候值为 raster
- 输出结果为多通道彩色的时候值为 rasterRgb

##### format: IRasterFormat

<description> _IFormat_ **必选** </description>

`format` 方法用于从传入的栅格文件二进制数据中提取波段数据。

- 第一个参数是栅格文件二进制数据。
- 第二个参数是第一个参数指定的栅格文件中应该提取的波段，方法参数是我们通过 `source` 参数传递的 `data` 数值。
- `format` 是一个 `async` 方法。

```js
interface IRasterData {
  rasterData: HTMLImageElement | Uint8Array | ImageBitmap | null | undefined;
  width: number;
  height: number;
}
type IRasterFormat = (
  data: ArrayBuffer,
  bands: number[],
) => Promise<IRasterData | IRasterData[]>;

const source = new Source(data, {
  parser: {
    format: async (data, bands) => {
      ...
      return {
        rasterData: bandData,
        width: 256;
        height: 256;
      }
    }
  }
})
```

1. `format` 方法的返回值为栅格数据（`rasterData`）以及表示大小的 `width`、`height` 参数。
2. `format` 方法可以返回多份数据，表示从当前栅格文件中提取多份波段的数据。

##### operation: IOperation

<description> _IOperation_ **可选** </description>

在加载多波段数据的时候我们可以通过 `operation` 配置波段数据的运算。

🌟 我们可以不配置 `operation`，此时默认使用第一个栅格文件提取的第一个波段数据

1. `operation` 可以是一个函数，`allbands` 是我们从所有栅格文件中提取的所有波段数据的集合。

```js
const parser = {
  operation: (allBands) => {
    // operation 可以是一个函数，allbands 是我们从所有栅格文件中提取的所有波段数据的集合，
    // 在设立 allbands 就是 [band0]
    // 函数的返回值是单纯的波段数据，在这里我们直接返回第一个波段的数据
    return allBands[0].rasterData;
  },
};
```

2. `operation` 可以是以数组形式存在的计算表达式.

```js
// 下面表达式可以转述为 band1 * 0.5，表示将波段1 的值都乘上 0.5 并返回
const parser = {
  operation: ['*', ['band', 1], 0.5],
};
```

3. `operation` 可以嵌套使用：`['+', ['*', ['band', 0], 0.2], ['band', 1]]]`，返回结果为：`band0 * 0.2 + band1`。

4. `operation` 可以直接指定结果：`['band', 0]`。

5. `operation` 支持以下的数学运算。

```js
/** 数学运算 根据计算表达式进行数学运算
 * * * Math operators:
 * `['*', value1, value2]` 返回  `value1 * value2`
 * `['/', value1, value2]` 返回 `value1 / value2`
 * `['+', value1, value2]` 返回 `value1 + value2`
 * `['-', value1, value2]` 返回 `value2 - value1`
 * `['%', value1, value2]` 返回 `value1 % value2`
 * `['^', value1, value2]` 返回  `value1 ^ value2`
 * `['abs', value1]`       返回  `Math.abs(value1)`
 * `['floor', value1]`     返回  `Math.floor(value1)`
 * `['round', value1]`     返回  `Math.round(value1)`
 * `['ceil', value1]`      返回  `Math.ceil(value1)`
 * `['sin', value1]`       返回  `Math.sin(value1)`
 * `['cos', value1]`       返回  `Math.cos(value1)`
 * `['atan', value1, value2]` 返回  `n1===-1?Math.atan(n1): Math.atan2(n1, n2)`
 */
```

##### extent

<description> _number[]_ **必选** </description>

`extent` 描述的是栅格数据覆盖的地理区间，数值指定的是区域的经纬度区间（左下角和右上角）。

### 加载多通道（彩色）影像

我们在使用多波段数据的时候支持根据多波段数据绘制彩色遥感影像，如下图的假彩色影像。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*jO7kTpuDiOQAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

#### data: IBandsData[] | IBandsData

绘制多通道影像的时候，需要加载多波段数据

#### parser

使用栅格数据的使用提供必要的参数和方法， 具体使用和多波段栅格的 `parser` 保持一致。

##### type

<description> _string_ **必选** </description>

- 输出结果为多通道彩色的时候值为 `rasterRgb`。

##### format: IRasterFormat

<description> _IFormat_ **必选** </description>

绘制多通道影像的时候，使用通用的 `format`函数。

##### operation: IOperation

<description> _IOperation_ **必选** </description>

为了绘制多通道影像，我们必须要提供 `operation` 配置指定多通道数据。

1. 在渲染彩色多通道栅格的时候需要额外使用 parser，同时彩色栅格图层不再支持 domain、rampColor 等参数，渲染的结果直接由波段计算出的 r、g、b 通道的数值结果控制。

2. 彩色栅格不再兼容旧的数据传值方式（直接传入解析完的栅格数据。

```js
const source = new Source(data, { // 彩色栅格和单通道栅格使用相同的规则
  parser: {
    type: 'rasterRgb', // 使用独立的 type 类型
    format: async (data, bands) {...}, // 彩色栅格和单通道栅格 format 使用相同
    // operation 为对象，分别为 rgb 三通道指定计算表达式
    // operation 必须要配置
    operation: {
      r: ['*', ['band', 1], 0.5],
      g: ['band', 1],
      b: undefined // 缺省配置表达式的通道会默认取 0 号波段的值
    }
  }
```
### data

多波段支持两种数据方式，栅格数据坐标系只支持 3857 投影的栅格，多波段情况 data 为数组类型

- 单文件多波段
- 多个单波段文件组成多波段

```ts
[
    {
        data: tiffdata, // arraybuffer 类型栅格源数据
        bands: [6, 5, 2].map((v) => v - 1),// 单文件多波段可以不传，format 函数使用
    },
    ],

```

#### 单文件多波段

data 为未解析过 tiff arraybuffer 数据，在 parser 中 通过 format 进行数据标准化，

```ts
  const url1 = 'https://gw.alipayobjects.com/zos/raptor/1667832825992/LC08_3857_clip_2.tif';
  async function getTiffData(url: string) {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  return arrayBuffer;
  }
}
layer.source(
    [
    {
        data: tiffdata,
        bands: [6, 5, 2].map((v) => v - 1),
    },
    ],
    {
    parser: {
        type: 'rasterRgb',
        format: async (data, bands) => {
        const tiff = await GeoTIFF.fromArrayBuffer(data);
        const image1 = await tiff.getImage();
        const value = await image1.readRasters();
        return bands.map((band) => {
            return {
            rasterData: value[band],
            width: value.width,
            height: value.height,
            };
        });
        },
        operation: {
        type: 'rgb',
        },
        extent: [
        130.39565357746957, 46.905730725742366, 130.73364094187343,
        47.10217234153133,
        ],
    },
    },
)

```
#### 多文件多波段

```ts

const urls = [
  {
    url: 'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',
    bands: [0]
  },
  {
    url: 'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff'
  },
  ...
]
const tileSource = new Source(urls, {...});
```

### parser

#### type: `rasterRgb`
  多波段数据影像合成
####  extent: 栅格的经纬度范围 [minlng, minlat,maxLng, maxLat]

####  operation 合成方式
 rgb 会自动根据最大值最小值进行拉伸处理

  - type `rgb`

#### format 数据处理方法，栅格数据解析方式
  
  - 入参数：
  - data: source 传入参数
  - bands 波段序号

-  返回参数：
    返回数据为数组类型
  ```ts
      [{
          rasterData: value[band],// 解析后的数据
          width: value.width, // 栅格宽度
          height: value.height, // 栅格高度
          };
        ]
  ```


#### 示例
```ts
layer.source(
    [
    {
        data: tiffdata,
        bands: [6, 5, 2].map((v) => v - 1),
    },
    ],
    {
    parser: {
        type: 'rasterRgb',
        format: async (data, bands) => {
        const tiff = await GeoTIFF.fromArrayBuffer(data);
        const image1 = await tiff.getImage();
        const value = await image1.readRasters();
        return bands.map((band) => {
            return {
            rasterData: value[band],
            width: value.width,
            height: value.height,
            };
        });
        },
        operation: {
        type: 'rgb',
        },
        extent: [
        130.39565357746957, 46.905730725742366, 130.73364094187343,
        47.10217234153133,
        ],
    },
    },
)
```### data

Multi-band supports two data methods. The raster data coordinate system only supports 3857 projected raster. In the case of multi-band, data is an array type.

* Single file multiple bands
* Multiple single-band files form multi-band

```ts
[
    {
        data: tiffdata, // arraybuffer type raster source data
        bands: [6, 5, 2].map((v) => v - 1),//Single file with multiple bands does not need to be transmitted, the format function is used
    },
    ],
```

#### Single file multiple bands

data is unparsed tiff arraybuffer data, which is standardized by format in parser.

```ts
const url1 = 'https://gw.alipayobjects.com/zos/raptor/1667832825992/LC08_3857_clip_2.tif';
  async function getTiffData(url: string) {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  return arrayBuffer;
  }
}
layer.source(
    [
    {
        data: tiffdata,
        bands: [6, 5, 2].map((v) => v - 1),
    },
    ],
    {
    parser: {
        type: 'rasterRgb',
        format: async (data, bands) => {
        const tiff = await GeoTIFF.fromArrayBuffer(data);
        const image1 = await tiff.getImage();
        const value = await image1.readRasters();
        return bands.map((band) => {
            return {
            rasterData: value[band],
            width: value.width,
            height: value.height,
            };
        });
        },
        operation: {
        type: 'rgb',
        },
        extent: [
        130.39565357746957, 46.905730725742366, 130.73364094187343,
        47.10217234153133,
        ],
    },
    },
)
```

#### Multiple files and multiple bands

```ts
const urls = [
  {
    url: 'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',
    bands: [0]
  },
  {
    url: 'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff'
  },
  ...
]
const tileSource = new Source(urls, {...});
```

### parser

#### type:`rasterRgb`

Multi-band data image synthesis

#### extent: the latitude and longitude range of the raster \[minlng, minlat,maxLng, maxLat]

#### operation synthesis method

rgb will automatically stretch based on the maximum and minimum values

* type `rgb`

#### format data processing method, raster data parsing method

* Input parameters:

* data: source passed in parameters

* bands band number

* Return parameters:
  Return data is array type

```ts
[{
        rasterData: value[band],//parsed data
        width: value.width, // Grid width
        height: value.height, // grid height
        };
      ]
```

#### Example

```ts
layer.source(
    [
    {
        data: tiffdata,
        bands: [6, 5, 2].map((v) => v - 1),
    },
    ],
    {
    parser: {
        type: 'rasterRgb',
        format: async (data, bands) => {
        const tiff = await GeoTIFF.fromArrayBuffer(data);
        const image1 = await tiff.getImage();
        const value = await image1.readRasters();
        return bands.map((band) => {
            return {
            rasterData: value[band],
            width: value.width,
            height: value.height,
            };
        });
        },
        operation: {
        type: 'rgb',
        },
        extent: [
        130.39565357746957, 46.905730725742366, 130.73364094187343,
        47.10217234153133,
        ],
    },
    },
)
```
### data

data 解析后的数据，为数组

以 geotiff 为例需要先将数据解析出来，作为 data 输入给 source

```tsx
import * as GeoTIFF from 'geotiff';

async function getTiffData() {
  async function getTiffData() {
    const response = await fetch(
      'https://gw.alipayobjects.com/zos/antvdemo/assets/light_clip/lightF182013.tiff',
    );
    const arrayBuffer = await response.arrayBuffer();
    const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
    const image = await tiff.getImage();
    const width = image.getWidth();
    const height = image.getHeight();
    const values = await image.readRasters();
    return {
      data: values[0],
      width,
      height,
    };
  }
}
const tiffdata = await getTiffData();
layer.source(tiffdata.data, {
  parser: {
    type: 'raster',
    width: tiffdata.width,
    height: tiffdata.height,
    extent: [
      73.4821902409999979, 3.8150178409999995, 135.1066187319999869,
      57.6300459959999998,
    ],
  },
});
```

### parser

- type: raster
- extent: 栅格的经纬度范围 [minlng, minlat,maxLng, maxLat]
- width 数据宽度
- height 数据高度

根据栅格数据的经纬度范围，将其添加到地图上。

```javascript
layer.source(rasterData, {
  parser: {
    type: 'raster',
    extent: [121.168, 30.2828, 121.384, 30.4219],
  },
});
```
### data


### parser

#### format

`format` 方法用于从传入的栅格文件二进制数据中提取波段数据。

- 第一个参数是栅格文件二进制数据

- 第二个参数是第一个参数指定的栅格文件中应该提取的波段

- `format` 是一个 `async` 方法。

#### operation 快捷计算
 归一化指数

 ```ts
 {
    type:'nd'
 }
 ```

#### operation 表达式

- 示例一 

```ts
// band1 * 0.5
{
  operation: ['*', ['band', 1], 0.5],
};
```

- 示例二 嵌套使用

```ts
// band0 * 0.2 + band1
{
  operation:['+', ['*', ['band', 0], 0.2], ['band', 1]]]
};
```

- 示例三 归一化指数

```ts
// 植被指数计算
{
  operation:['/',
    ['-', ['band', 1], ['band', 0]], // R > NIR
    ['+', ['band', 1], ['band', 0]]
  ]
};
```

- operation 表达式类型

    - *`['*', value1, value2]` 返回  `value1 * value2`
    - / `['/', value1, value2]` 返回 `value1 / value2`
    - +`['+', value1, value2]` 返回 `value1 + value2`
    - -`['-', value1, value2]` 返回 `value2 - value1`
    - % `['%', value1, value2]` 返回 `value1 % value2`
    - ^ `['^', value1, value2]` 返回  `value1 ^ value2`
    - abs`['abs', value1]`       返回  `Math.abs(value1)`
    - floor `['floor', value1]`     返回  `Math.floor(value1)`
    - round `['round', value1]`     返回  `Math.round(value1)`
    - ceil `['ceil', value1]`      返回  `Math.ceil(value1)`
    - sin `['sin', value1]`       返回  `Math.sin(value1)`
    - cos `['cos', value1]`       返回  `Math.cos(value1)`
    - atan `['atan', value1, value2]` 返回  `n1===-1?Math.atan(n1): 

  

### data

### parser

#### format

`format`Method used to extract band data from the incoming raster file binary data.

* The first parameter is the raster file binary data

* The second parameter is the band that should be extracted from the raster file specified by the first parameter.

* `format`Is a`async`method.

#### operation quick calculation

normalized index

```ts
{
   type:'nd'
}
```

#### operation expression

* Example 1

```ts
// band1 * 0.5
{
  operation: ['*', ['band', 1], 0.5],
};
```

* Example 2 Nested use

```ts
// band0 * 0.2 + band1
{
  operation:['+', ['*', ['band', 0], 0.2], ['band', 1]]]
};
```

* Example 3 Normalized Index

```ts
// Vegetation index calculation
{
  operation:['/',
    ['-', ['band', 1], ['band', 0]], // R > NIR
    ['+', ['band', 1], ['band', 0]]
  ]
};
```

* operation expression type

  * \*`['*', value1, value2]`return`value1 * value2`

  * /`['/', value1, value2]`return`value1 / value2`

  * +`['+', value1, value2]`return`value1 + value2`

  * -`['-', value1, value2]`return`value2 - value1`

  * %`['%', value1, value2]`return`value1 % value2`

  * ^`['^', value1, value2]`return`value1 ^ value2`

  * abs`['abs', value1]`return`Math.abs(value1)`

  * floor `['floor', value1]`return`Math.floor(value1)`

  * round `['round', value1]`return`Math.round(value1)`

  * ceil `['ceil', value1]`return`Math.ceil(value1)`

  * sin `['sin', value1]`return`Math.sin(value1)`

  * cos `['cos', value1]`return`Math.cos(value1)`

  * atan `['atan', value1, value2]`Return \`n1===-1?Math.atan(n1):
### data

data The parsed data, which is an array

Taking geotiff as an example, the data needs to be parsed first and input to the source as data.

```tsx
import * as GeoTIFF from 'geotiff';

async function getTiffData() {
  async function getTiffData() {
    const response = await fetch(
      'https://gw.alipayobjects.com/zos/antvdemo/assets/light_clip/lightF182013.tiff',
    );
    const arrayBuffer = await response.arrayBuffer();
    const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
    const image = await tiff.getImage();
    const width = image.getWidth();
    const height = image.getHeight();
    const values = await image.readRasters();
    return {
      data: values[0],
      width,
      height,
    };
  }
}
const tiffdata = await getTiffData();
layer.source(tiffdata.data, {
  parser: {
    type: 'raster',
    width: tiffdata.width,
    height: tiffdata.height,
    extent: [
      73.4821902409999979, 3.8150178409999995, 135.1066187319999869,
      57.6300459959999998,
    ],
  },
});
```

### parser

* type: raster
* extent: the latitude and longitude range of the raster \[minlng, minlat,maxLng, maxLat]
* width data width
* height data height

Add raster data to the map based on its latitude and longitude range.

```javascript
layer.source(rasterData, {
  parser: {
    type: 'raster',
    extent: [121.168, 30.2828, 121.384, 30.4219],
  },
});
```
### animate

#### Turn on and off animation

```javascript
layer.animate(true);
layer.animate(false);
```

#### Set animation parameters

* duration animation time unit (s) seconds
* interval trajectory interval, value range 0 - 1
* trailLength trail length value range 0 - 1

```javascript
layer.animate({
  duration: 4,
  interval: 0.2,
  trailLength: 0.1,
});
```

##### Introduction to parameter animation

L7 The current animation parameters are relative units, and our default length of a line segment is 1![L7 动画参数](https://gw.alipayobjects.com/mdn/rms_855bab/afts/img/A*IBBfSIkb51cAAAAAAAAAAABkARQnAQ)

If interval = 0.2, a trajectory will be divided into 5 segments, if interval = 0.5, it will be two segments.

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*mo_7Q6sTqOIAAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/gallery/animate#plane_animate2)
### animate

#### 开启关闭动画

```javascript
layer.animate(true);
layer.animate(false);
```

#### 设置动画参数

- duration 动画时间 单位(s)秒
- interval 轨迹间隔, 取值区间 0 - 1
- trailLength 轨迹长度 取值区间 0 - 1

```javascript
layer.animate({
  duration: 4,
  interval: 0.2,
  trailLength: 0.1,
});
```

##### 参数动画介绍

L7 目前动画参数为相对单位，我们默认一条线段的长度为 1
![L7 动画参数](https://gw.alipayobjects.com/mdn/rms_855bab/afts/img/A*IBBfSIkb51cAAAAAAAAAAABkARQnAQ)

如果 interval = 0.2,则一条轨迹将会分成 5 段，如果 interval = 0.5 则为两段。


<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*mo_7Q6sTqOIAAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/gallery/animate#plane_animate2)

#### border

线图层支持在 style 中设置边框的宽度和颜色

```javascript
const layer = new LineLayer({})
  .source(data, {
    parser: {
      type: 'csv',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(1)
  .shape('arc')
  .color('#8C1EB2')
  .style({
    borderWidth: 0.35,   // 默认文 0，最大有效值为 0.5
    borderColor: '#888', // 默认为 #ccc
  });
```

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*PsbNRpboEKEAAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/gallery/animate#animate_path_texture)
#### linearColor

线图层通过在 style 中设置起始颜色和终点颜色来设置颜色渐变，渐变色的优先级比 color 方法设置的颜色更高

```javascript
const layer = new LineLayer({})
  .source(data, {
    parser: {
      type: 'csv',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(1)
  .shape('arc')
  .color('#8C1EB2')
  .style({
    sourceColor: '#f00', // 起点颜色
    targetColor: '#0f0', // 终点颜色
  });
```

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*8DYQTZeQyZ4AAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/line/arc#trip_arc_dark_linear)
#### linearColor

The line layer sets the color gradient by setting the start color and end color in style. The gradient color has a higher priority than the color set by the color method.

```javascript
const layer = new LineLayer({})
  .source(data, {
    parser: {
      type: 'csv',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(1)
  .shape('arc')
  .color('#8C1EB2')
  .style({
    sourceColor: '#f00', // starting point color
    targetColor: '#0f0', //End color
  });
```

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*8DYQTZeQyZ4AAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/line/arc#trip_arc_dark_linear)
#### border

The line layer supports setting the width and color of the border in style

```javascript
const layer = new LineLayer({})
  .source(data, {
    parser: {
      type: 'csv',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(1)
  .shape('arc')
  .color('#8C1EB2')
  .style({
    borderWidth: 0.35, //The default value is 0, the maximum valid value is 0.5
    borderColor: '#888', // Default is #ccc
  });
```

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*PsbNRpboEKEAAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/gallery/animate#animate_path_texture)
The line layer supports texture mapping and various expression forms, through`scene.addImage`Methods are added to global resources using`texture`Method specifies the texture.

```javascript
scene.addImage('02', 'https://gw.alipayobjects.com/zos/bmw-prod/ce83fc30-701f-415b-9750-4b146f4b3dd6.svg');
const layer = new LineLayer()
    .source(data)
    .size(4)
    .shape('line')
    .texture('02')
    .color('#25d8b7')
    .animate({
        interval: 1, // interval
        duration: 1, // duration, delay
        trailLength: 2 // streamline length
    }).style({
        lineTexture: true, // Enable line mapping function
        iconStep: 20 //Set the spacing of the texture
    });
```

<div>
  <div style="width:40%;float:right; margin-left: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*KEupSZ_p0pYAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

* lineTexture specifies whether to enable texture mapping capabilities
* iconStep specifies the interval at which the texture is arranged on the line layer

[Online case](/examples/gallery/animate/#animate_path_texture)

#### texture advance

✨ animate\
Current line layer (`shape`for`arc`/`arc3d`) When animation mode is turned on, the distribution of textures on the line layer will also be consistent with`animate`parameters related.

The number of textures arranged on a line layer is roughly duration/interval

```javascript
.animate({
    duration: 1,
    interval: 0.2,
    trailLength: 0.1
});

// At this time, the number of texture maps is duration / interval = 5
```

✨ textureBlend parameters\
By controlling the textureBlend parameter in the style method, we can control the blending of texture layers and line layers.

* normal
* replace

```javascript
.style({
    lineTexture: true, // Enable line mapping function
    iconStep: 30, // Set the spacing of the texture
    textureBlend: 'replace', //Set the texture blending method. The default value is normal. The optional values ​​are normal/replace.
  });
```

[Online case](zh/examples/line/animate#plane_animate2)
线图层支持纹理贴图和多种表现形式，通过 `scene.addImage` 方法添加到全局的资源，使用 `texture` 方法指定贴图。

```javascript
scene.addImage('02', 'https://gw.alipayobjects.com/zos/bmw-prod/ce83fc30-701f-415b-9750-4b146f4b3dd6.svg');
const layer = new LineLayer()
    .source(data)
    .size(4)
    .shape('line')
    .texture('02')
    .color('#25d8b7')
    .animate({
        interval: 1, // 间隔
        duration: 1, // 持续时间，延时
        trailLength: 2 // 流线长度
    }).style({
        lineTexture: true, // 开启线的贴图功能
        iconStep: 20 // 设置贴图纹理的间距
    });
```

<div>
  <div style="width:40%;float:right; margin-left: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*KEupSZ_p0pYAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

- lineTexture   指定是否开启纹理贴图能力
- iconStep      指定贴图在线图层上面排布的间隔

[在线案例](/examples/gallery/animate/#animate_path_texture)

#### texture advance

✨ animate  
当线图层 (`shape` 为 `arc`/`arc3d`) 开启动画模式的时候，纹理在线图层上的分布还会和 `animate` 的参数相关.        

线图层上排列的纹理的数量大致为 duration/interval

```javascript
.animate({
    duration: 1,
    interval: 0.2,
    trailLength: 0.1
});

// 此时 纹理贴图数量为  duration / interval = 5
```

✨ textureBlend 参数    
通过控制 style 方法中的 textureBlend 参数，我们可以控制纹理图层和线图层的混合情况  

- normal
- replace

```javascript
.style({
    lineTexture: true, // 开启线的贴图功能
    iconStep: 30, // 设置贴图纹理的间距
    textureBlend: 'replace', // 设置纹理混合方式，默认值为 normal，可选值有 normal/replace 两种
  });

```

[在线案例](zh/examples/line/animate#plane_animate2)

#### segmentNumber

The default arc segment number of the arc layer is 30. However, sometimes users do not need so many segments. Appropriately reducing the number of segments can improve performance while ensuring the effect.

```javascript
const layer = new LineLayer({})
  .source(data, {
    parser: {
      type: 'csv',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(1)
  .shape('arc')
  .color('#8C1EB2')
  .style({
    segmentNumber: 15,
  });
```
#### segmentNumber

arc 图层的弧线默认分段数是 30，然而有有些时候用户并不需要这么多的分段数，适当降低分段数量可以在保证效果的情况下提高性能。

```javascript
const layer = new LineLayer({})
  .source(data, {
    parser: {
      type: 'csv',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(1)
  .shape('arc')
  .color('#8C1EB2')
  .style({
    segmentNumber: 15,
  });
```

#### vertex height

The line layer supports assigning a height value to each vertex and allows users to set the height scale through the vertexHeightScale property in the style method.

```javascript
const layer = new LineLayer({})
  .source(data)
  .size(1)
  .shape('line')
  .style({
    vertexHeightScale: 30,
  })
  .color('#ccc');

scene.addLayer(layer);
```

Data with height values

```javascript
{
"type": "FeatureCollection",
"name": "tw",
"crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },
"features": [
  {
    "type": "Feature",
    "properties": { },
    "geometry": {
      "type": "LineString", "coordinates":
      [
        [ 121.519153647, 25.288692533, 41.0 ],
        [ 121.529153646999987, 25.288692533, 35.0 ],
        [ 121.539153647, 25.288692533, 27.0 ],
        [ 121.549153647, 25.288692533, 66.0 ],
        [ 121.559153646999988, 25.288692533, 83.0 ],
        [ 121.569153647, 25.288692533, 88.0 ]
      ]
    }
  },
...
}
```

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*8TXwR7XbeLIAAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/line/isoline#height)
#### vertex height

线图层支持给每个顶点赋予高度值，同时允许用户在 style 方法中通过 vertexHeightScale 属性设置高度比例。

```javascript
const layer = new LineLayer({})
  .source(data)
  .size(1)
  .shape('line')
  .style({
    vertexHeightScale: 30,
  })
  .color('#ccc');

scene.addLayer(layer);
```

带有高度值的数据

```javascript
{
"type": "FeatureCollection",
"name": "tw",
"crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },
"features": [
  {
    "type": "Feature",
    "properties": { },
    "geometry": {
      "type": "LineString", "coordinates":
      [
        [ 121.519153647, 25.288692533, 41.0 ],
        [ 121.529153646999987, 25.288692533, 35.0 ],
        [ 121.539153647, 25.288692533, 27.0 ],
        [ 121.549153647, 25.288692533, 66.0 ],
        [ 121.559153646999988, 25.288692533, 83.0 ],
        [ 121.569153647, 25.288692533, 88.0 ]
      ]
    }
  },
...
}

```

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*8TXwR7XbeLIAAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/line/isoline#height)
#### thetaOffset

thetaOffset parameter represents the arc arc arc, the default value is 0.314

```javascript
const layer = new LineLayer({})
  .source(data, {
    parser: {
      type: 'csv',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(1)
  .shape('arc')
  .color('#8C1EB2')
  .style({
    thetaOffset: 0.35,
  });
```

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*qRFaR7Ko274AAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/gallery/animate#route_line)
#### thetaOffset

thetaOffset 参数 表示 arc 弧线的弧度，默认值是 0.314

```javascript
const layer = new LineLayer({})
  .source(data, {
    parser: {
      type: 'csv',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(1)
  .shape('arc')
  .color('#8C1EB2')
  .style({
    thetaOffset: 0.35,
  });
```
<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*qRFaR7Ko274AAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/gallery/animate#route_line)
#### dash

The line layer sets the line type in style and specifies the dotted line part and the solid line part at the same time.

```javascript
const layer = new LineLayer({})
.source(data)
.size(1.5)
.shape('line')
.color('标准名称', ['#5B8FF9', '#5CCEA1', '#F6BD16'])
.active(true)
.style({
  lineType: 'dash',
  dashArray: [5, 5],
});
scene.addLayer(layer);
```

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*pb3FRZnaa0AAAAAAAAAAAAAAARQnAQ'>

* lineType
  The default is solid, which represents a solid line, and dash represents a dotted line.
* dashArray\[len1: number, len2: number]
  len1 solid line length
  len2 interval length

[Online case](/examples/line/arc#trip_arc_dark_linear)
#### dash

线图层通过在 style 中设置线的类型，同时指定虚线部分和实线部分

```javascript
const layer = new LineLayer({})
.source(data)
.size(1.5)
.shape('line')
.color('标准名称', ['#5B8FF9', '#5CCEA1', '#F6BD16'])
.active(true)
.style({
  lineType: 'dash',
  dashArray: [5, 5],
});
scene.addLayer(layer);
```

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*pb3FRZnaa0AAAAAAAAAAAAAAARQnAQ'>

- lineType
默认为 solid，表示实线，dash 表示虚线
- dashArray[len1: number, len2: number]
len1 实线长度
len2 间隔长度

[在线案例](/examples/line/arc#trip_arc_dark_linear)
⚠️ The use of mask and maskfence is not recommended. After configuring 2.14.x, the version will take effect.

Template layer: a layer used as a template. PointLayer, LineLayer, and PolygonLayer can all be used as templates.
Mask layer: the layer cut by the template

### maskLayers

Mask layer takes effect

<description> *array Layer* **optional** *default:*\[]</description>

### enableMask

Mask layer takes effect

Whether to enable the mask. It is enabled by default. It will take effect when maskLayers is not empty.

<description> *bool* **optional** *default:* true</description>

### maskInside

```
Mask layer takes effect
```

<description> *boolean* **optional** *default:* true</description>

Used to describe the content of the current layer and mask boundary display.

* `true`Show inside the mask
* `false`Show outside mask

### maskOpetation mask method

Template layer takes effect<description> *enumerate* **optional** *default:* and</description>It is invalid when there are multiple maskLayers and needs to be set on the template layer.

* or intersection
* and union

Usage example

```ts
const polygonLayer = new Polygon();
 const rasterLayer = new Raster({ // Raster layer uses polygon mask
    maskLayers:[polygonLayer],
    enableMask:true,
    maskInside: true,
 
 });
```
#### style data mapping

The default style configuration is a constant value. Some configurations also support data mapping. The mapping definition is the same as the color and size parameters.

* field: mapping field
* value: mapping interval or custom callback function

like:

```ts
layer.style({
    opacity:{
        field:'name'
        value:[0.1,0.5,1],

    }
})
```



⚠️ mask、maskfence 不推荐使用，一下配置 2.14.x 之后版本生效

模板图层：用做模板的图层，PointLayer、LineLayer、PolygonLayer 都可以作为模板
掩膜图层：被模板切割的图层

### maskLayers

   掩膜图层生效

  <description> _array Layer_ **optional** _default:_ []</description>



 ### enableMask
    
掩膜图层生效

 是否开启掩膜，默认开启 maskLayers 不为空时生效

 <description> _bool_ **optional** _default:_ true</description>

 ### maskInside
    掩膜图层生效

<description> _boolean_ **optional** _default:_ true</description>

用来描述当前图层的内容与掩模边界显示。

- `true` 在掩模内部显示
- `false` 在掩模外部显示

### maskOpetation 掩膜方式

模板图层生效
<description> _枚举_ **optional** _default:_ and</description>
 maskLayers 为多个时失效，需要在模板图层设置

- or 交集
- and 并集

使用示例

```ts

 const polygonLayer = new Polygon();
 const rasterLayer = new Raster({ // 栅格图层使用polygon 掩膜
    maskLayers:[polygonLayer],
    enableMask:true,
    maskInside: true,
 
 });#### 样式数据映射
默认样式配置为常量值，某些配置也支持数据映射，映射定义同 color、size参数一致。

- field: 映射字段
- value： 映射区间或者自定义回调函数

如：

```ts
layer.style({
    opacity:{
        field:'name'
        value:[0.1,0.5,1],

    }
})
```
## options

<embed src="@/docs/common/layer/options.zh.md"></embed>

## 数据方法

<embed src="@/docs/common/layer/layer_encode.zh.md"></embed>

<embed src="@/docs/common/layer/layer_style.zh.md"></embed>

<embed src="@/docs/common/layer/layer_texture.zh.md"></embed>

<embed src="@/docs/common/layer/layer_update.zh.md"></embed>

<embed src="@/docs/common/layer/layer_ctr.zh.md"></embed>

<embed src="@/docs/common/layer/layer_interaction.zh.md"></embed>

<embed src="@/docs/common/layer/mask_method.zh.md"></embed>

<embed src="@/docs/common/layer/mouse_event.zh.md"></embed>

<embed src="@/docs/common/layer/layer_event.zh.md"></embed>
## options

<embed src="@/docs/common/layer/options.en.md"></embed>

## data method

<embed src="@/docs/common/layer/layer_encode.en.md"></embed>

<embed src="@/docs/common/layer/layer_style.en.md"></embed>

<embed src="@/docs/common/layer/layer_texture.en.md"></embed>

<embed src="@/docs/common/layer/layer_update.en.md"></embed>

<embed src="@/docs/common/layer/layer_ctr.en.md"></embed>

<embed src="@/docs/common/layer/layer_interaction.en.md"></embed>

<embed src="@/docs/common/layer/mask_method.en.md"></embed>

<embed src="@/docs/common/layer/mouse_event.en.md"></embed>

<embed src="@/docs/common/layer/layer_event.en.md"></embed>
## 图层事件

### inited

参数 option

- target 当前 layer
- type 事件类型

图层初始化完成后触发

```javascript
layer.on('inited', (option) => {});
```

### add

图层添加到 scene

参数 option

- target 当前 layer
- type 事件类型

```javascript
layer.on('add', (type) => console.log(type));
```

### remove

图层移除时触发

参数 option

- target 当前 layer
- type 事件类型

```javascript
layer.on('remove', (type) => console.log(type));
```

### legend
数据映射更新，图例发生变化,主要color、size

参数 option

- type 映射通道、图例类型
- attr 映射实例


```js
layer.on('legend', (ev) => console.log(ev));

```

### legend:color

数据映射更新，图例发生变化,color 颜色改变
参数 option
- type 映射通道、图例类型
- attr 映射实例

```js
layer.on('legend:color', (ev) => console.log(ev));

```

### legend:size

数据映射更新，图例发生变化,size 大小改变
参数 option
- type 映射通道、图例类型
- attr 映射实例

```js
layer.on('legend:size', (ev) => console.log(ev));

```

## 图层框选

### boxSelect

参数 option

- box [x1: number, y1: number, x2: number, y2: number] 相较于
- cb (...args: any[]) => void 传入的回调方法，返回框选内部的 feature

```javascript
layer.boxSelect(box, cb);
// (x1, y1), (x2, y2) 框选的方框左上角和右下角相对于地图左上角的像素坐标
// cb 是传入的回调函数，回调函数返回的参数是选中的 feature 对象数组，对象的字段和用户传入的数据相关
```## layer mask method

### addMask

```
Add Mask layer
```

```ts
const polygonLayer = new Polygon();
 layer.addMask(polygonLayer);
 scene.render()
```

### removeMask

```ts
const polygonLayer = new Polygon();
 layer.removeMask(polygonLayer);
 scene.render()
```

### disableMask

```ts
layer.disableMask();
 scene.render()
```

### enableMask

```ts
layer.disableMask();
 scene.render()
```
## layer events

### inited

Parameter option

* target current layer
* type event type

Triggered after layer initialization is completed

```javascript
layer.on('inited', (option) => {});
```

### add

Add layer to scene

Parameter option

* target current layer
* type event type

```javascript
layer.on('add', (type) => console.log(type));
```

### remove

Fires when a layer is removed

Parameter option

* target current layer
* type event type

```javascript
layer.on('remove', (type) => console.log(type));
```

### legend

Data mapping is updated, the legend changes, mainly color and size

Parameter option

* type mapping channel, legend type
* attr mapping example

```js
layer.on('legend', (ev) => console.log(ev));
```

### legend:color

The data mapping is updated, the legend changes, and the color changes
Parameter option

* type mapping channel, legend type
* attr mapping example

```js
layer.on('legend:color', (ev) => console.log(ev));
```

### legend:size

The data mapping is updated, the legend changes, and the size changes
Parameter option

* type mapping channel, legend type
* attr mapping example

```js
layer.on('legend:size', (ev) => console.log(ev));
```

## Layer selection

### boxSelect

Parameter option

* box \[x1: number, y1: number, x2: number, y2: number] compared to
* cb (...args: any\[]) => void callback method passed in, returns the feature inside the box selection

```javascript
layer.boxSelect(box, cb);
// (x1, y1), (x2, y2) The pixel coordinates of the upper left corner and lower right corner of the selected box relative to the upper left corner of the map
//cb is the callback function passed in. The parameter returned by the callback function is the selected feature object array. The fields of the object are related to the data passed in by the user.
```
## 图层掩膜方法

### addMask
    添加 Mask 图层
```ts
 const polygonLayer = new Polygon();
 layer.addMask(polygonLayer);
 scene.render()
```
### removeMask

```ts
 const polygonLayer = new Polygon();
 layer.removeMask(polygonLayer);
 scene.render()

```
### disableMask
```ts

 layer.disableMask();
 scene.render()

```
### enableMask

```ts
 layer.disableMask();
 scene.render()
```


## Layer interaction methods

### active(activeOption | boolean)

* Turn on or off mousehover element highlighting effect
* `activeOption`
  * `color`: Highlight color
  * `mix`: Optional parameter, the default is 0, which means the highlight color is the specified solid color. The maximum valid value is 1, which means the highlight color is all the background color.

```javascript
activeOption: {
  color: '#f00';
  mix: 0.6
}
```

```javascript
// Turn on Active and use the default highlight color
layer.active(true);

// Turn on Active custom highlight color

layer.active({
  color: 'red',
  mix: .6
});

//Turn off the highlight effect
layer.active(false);
```

### setActive(featured: in)

Set hover highlight of specified element based on element ID

🌟 Specifying element highlighting is not equal to layer highlighting. A layer contains multiple elements. Generally, a layer has as many elements as there are single pieces of data in the data array passed to source.

```javascript
layer.setActive(featureId);
```

### select(selectOption | boolean)

* Turn on or off mouseclick element selection highlighting effect
* selectOption
  * `color`: Select highlight color
  * `mix`: Optional parameter, the default is 0, which means that the selected highlight color is the specified solid color. The maximum effective value is 1, which means that all the selected highlight colors are background colors.

```javascript
selectOption: {
  color: '#f00';
  mix: .6
}
```

```javascript
// Turn on Active and use the default highlight color
layer.select(true);

// Turn on Active custom highlight color

layer.select({
  color: 'red',
  mix: .6
});

//Turn off the highlight effect
layer.select(false);
```

### setSelect(featureId: int)

Set the specified element according to the element ID click to select and highlight

🌟 Specifying element highlighting is not equal to layer highlighting. A layer contains multiple elements. Generally, a layer has as many elements as there are single pieces of data in the data array passed to source.

```javascript
layer.setSelect(featureId);
```

### setAutoFit(autoFit: boolean)

Allows users to actively set the autoFit parameters of layers\
🌟 After setting this method, it will take effect when the layer is updated, such as triggered after setData

```javascript
// Instructions
layer.setAutoFit(true);
// Internal implementation
public setAutoFit(autoFit: boolean): ILayer {
    this.updateLayerConfig({
      autoFit,
    });
    return this;
  }
```

### getScale(attr: string)

Supports separately obtaining the value of a graphic after scale calculation to meet the user's need to obtain certain feature values ​​of the layer.

* attribute value of attr scale

```javascript
const data = [
  {lng: 120, lat: 30, name: 'n1'},
  {lng: 120, lat: 30, name: 'n2'}
]
const layer = new PointLayer()
.source(data, {
parser: {
    x: 'lng',
      y: 'lat',
      type: 'json'
    }
  })
.shape('circle')
.color('name', ['#f00', '#ff0'])
.size('name', [20, 40])

scene.addLayer(layer)


// Draw two points on the scene at this time
// A point with a color of yellow and a size of 40, corresponding to name n1
// A point with a color of red and a size of 20, corresponding to name n2

const colorScale = layer.getScale('color'); // Get the scale generated by the color method
const color1 = colorScale('n1'); // '#ff0'
const color1 = colorScale('n2'); // '#f00'

const sizeScale = layer.getScale('size'); // Get the scale generated by the size method
const size1 = sizeScale('n1'); // 40
const size2 = sizeScale('n2'); // 20
```

### getLegendItems(type: string)

Get legend configuration

* type legend type
* index optional default

```javascript
layer.getLegendItems('color');

layer.getLegendItems('size');
```

### getLegend(type: string)

Get the legend getLegendItems enhanced version returns more information

return value

* type legend type
* field mapping field
* items legend items

```javascript
layer.getLegend('color');

layer.getLegend('size');
```
## 图层交互方法

### active(activeOption | boolean)

- 开启或者关闭 mousehover 元素高亮效果
- `activeOption`
  - `color`: 高亮颜色
  - `mix`: 可选参数，默认为 0，表示高亮颜色是指定纯色，最大有效值是1，表示高亮色全部是底色

```javascript
activeOption: {
  color: '#f00';
  mix: 0.6
}
```

```javascript
// 开启 Active  使用默认高亮颜色
layer.active(true);

//  开启 Active  自定义高亮颜色

layer.active({
  color: 'red',
  mix: .6
});

// 关闭高亮效果
layer.active(false);
```

### setActive(featureId: int)

根据元素 ID 设置指定元素 hover 高亮

🌟 指定元素高亮不等于图层高亮，一个图层包含多个元素，一般传入 source 的数据数组中有多少单条数据，一个图层就有多少元素

```javascript
layer.setActive(featureId);
```

### select(selectOption | boolean)

- 开启或者关闭 mouseclick 元素选中高亮效果
- selectOption
  - `color`: 选中高亮颜色
  - `mix`: 可选参数，默认为 0，表示选中高亮颜色是指定纯色，最大有效值是1，表示选中高亮色全部是底色

```javascript
selectOption: {
  color: '#f00';
  mix: .6
}
```

```javascript
// 开启 Active  使用默认高亮颜色
layer.select(true);

//  开启 Active  自定义高亮颜色

layer.select({
  color: 'red',
  mix: .6
});

// 关闭高亮效果
layer.select(false);
```

### setSelect(featureId: int)

根据元素 ID 设置指定元素 click 选中 高亮

🌟 指定元素高亮不等于图层高亮，一个图层包含多个元素，一般传入 source 的数据数组中有多少单条数据，一个图层就有多少元素

```javascript
layer.setSelect(featureId);
```

### setAutoFit(autoFit: boolean)
让用户可以主动设置图层的 autoFit 参数   
🌟 设置完该方法后会在图层发生更新的时候生效，如在 setData 之后触发    

```javascript
// 使用方法
layer.setAutoFit(true);
// 内部实现
public setAutoFit(autoFit: boolean): ILayer {
    this.updateLayerConfig({
      autoFit,
    });
    return this;
  }
```

### getScale(attr: string)
支持单独获取某个图形经过 scale 计算后的值，  满足用户获取图层某些 feature 值的需求。
- attr scale 的属性值   

```javascript
const data = [
  {lng: 120, lat: 30, name: 'n1'},
  {lng: 120, lat: 30, name: 'n2'}
]
const layer = new PointLayer()
	.source(data, {
		parser: {
    	x: 'lng',
      y: 'lat',
      type: 'json'
    }
  })
	.shape('circle')
	.color('name', ['#f00', '#ff0'])
	.size('name', [20, 40])

scene.addLayer(layer)


// 此时在 scene 上绘制两个点
// 一个颜色为黄色，大小为 40 的点，对应 name 为 n1
// 一个颜色为红色，大小为 20 的点，对应 name 为 n2

const colorScale = layer.getScale('color'); // 获取 color 方法产生的 scale
const color1 = colorScale('n1'); // '#ff0'
const color1 = colorScale('n2'); // '#f00'

const sizeScale = layer.getScale('size'); // 获取 size 方法产生的 scale
const size1 = sizeScale('n1'); // 40
const size2 = sizeScale('n2'); // 20
```
### getLegendItems(type: string)

获取图例配置

- type 图例类型
- index 可选 默认

```javascript
layer.getLegendItems('color');

layer.getLegendItems('size');
```

### getLegend(type: string)
获取图例 getLegendItems 加强版返回更多信息

返回值
- type 图例类型
- field 映射字段
- items 图例项


```javascript
layer.getLegend('color');

layer.getLegend('size');
```


`scale` 方法设置数据字段映射方法，用于设将地图数据值（数字、日期、类别等数据）转成视觉值（颜色、大小、形状）。尺度 Scale 是数据可视化的基本组成部分，因为它们决定了视觉编码的性质。   


### scale(field: string, scaleConfig: IScaleConfig)

- `field` 指定 source 中传入的数据中用于映射的字段名
- `scaleConfig` 列定义配置，对象类型

```javascript
interface IScaleConfig {
  type: ScaleTypeName;
  domain?: any[];
  ...
}

layer.color('id', ['#f00', '#ff0'])
.size('mag', [1, 80])
.scale('mag', {
  type: 'linear',
  domain: [ 1, 50]
})；
```

### ScaleTypeName
`scale` 的类型可以分为 `3` 类 `11` 种，不同 `Scale` 的差异在于 `domain->range` 的转换方法的不同。    
`range` 和 `domain` 是 `Scale` 中非常重要的两个参数。

- domain: 地图数据值的定义区间
- range：视觉值的区间定义

|  数据类型   | 度量类型  |
|  --------  | ------- |
| 连续        | linear、log、pow、time、sequential、quantize、quantile、threshold |
| 分类        | cat、time |
| 常量        | identity  |


#### Cat

Cat 指枚举类型，用于展示分类数据，比如农作物种植区分布图，水稻、玉米、大豆等不同类别需要映射为不同的颜色。

```js
// 三种作物会分别转成对应的颜色
// domain = ['corn','rice', 'soybean'];
// range = ['red','white','blue'];
const data = [
  { lng: 120, lat: 30, t: 'corn' },
  { lng: 121, lat: 30, t: 'rice' },
  { lng: 122, lat: 30, t: 'soybean' },
];
layer.source(data, {
  parser: {
    type: 'type',
    x: 'lng',
    y: 'lat'
  }
});
layer.scale('t', { type: 'cat' });
layer.color('t', ['red', 'white', 'blue']);

```


#### identify

常量度量 某个字段是不变的常量。

#### linear

线性是连续数据的映射方法，数据和视觉值是通过线性方法换算的。如数据值 1-100 线性映射到红到蓝的线下渐变色每个数字对应一个颜色

#### quantize 

相等间隔会将属性值的范围划分为若干个大小相等的子范围。相等间隔最适用于常见的数据范围，如百分比和温度。这种方法强调的是某个属性值相对于其他值的量

#### quantile

每个类都含有相等数量的要素。分位数分类非常适用于呈线性分布的数据。分位数为每个类分配数量相等的数据值。不存在空类，也不存在值过多或过少的类。
由于使用“分位数”分类将要素以同等数量分组到每个类中，因此得到的地图往往具有误导性。可能会将相似的要素置于相邻的类中，或将值差异较大的要素置于相同类中。可通过增加类的数量将这种失真降至最低。

#### threshold 

他允许将域的任意子集（非统一段）映射到范围内的离散值。输入域仍然是连续的，并根据提供给域属性的一组阈值划分为多个切片。 range 属性必须有 N+1 个元素，其中 N 是域中提供的阈值边界数

手动设置间隔 Manual interval 手动设置分级分类区间，某些数据会有相应的业界标准，或者需要进行某种特殊的显示。如空气质量数据有严格数据分段标准

```
-1   => "red"
0    => "white"
0.5  => "white"
1.0  => "blue"
1000 => "blue

```
#### diverging || Sequential
用于返回给定的颜色数组的统一非有理 B-spline 插值器函数，该数组将转换为RGB颜色。

```js
const scaleColors = d3interpolate.interpolateRgbBasis(colors);
```

### IScaleConfig

```js
interface IScaleConfig {
  type: ScaleTypeName;
  domain?: any[];
  range?: any[];
  neutral?: number;
  field?: string;
  unknown?: string;
  ticks?: any[];
  nice?: boolean;
  clamp?: boolean;
  format?: () => any;
}
```

------

`scale`Method sets the data field mapping method, which is used to convert map data values ​​(numbers, dates, categories, etc.) into visual values ​​(color, size, shape). Scales Scales are a fundamental component of data visualization because they determine the nature of the visual encoding.

### scale(field: string, scaleConfig: IScaleConfig)

* `field`Specify the field name used for mapping in the data passed in source
* `scaleConfig`Column definition configuration, object type

```javascript
interface IScaleConfig {
  type: ScaleTypeName;
  domain?: any[];
  ...
}

layer.color('id', ['#f00', '#ff0'])
.size('mag', [1, 80])
.scale('mag', {
  type: 'linear',
  domain: [ 1, 50]
})；
```

### ScaleTypeName

`scale`The types can be divided into`3`kind`11`species, different`Scale`The difference is that`domain->range`The conversion method is different.\
`range`and`domain`yes`Scale`two very important parameters.

* domain: definition interval of map data values
* range: interval definition of visual value

| type of data   | Measurement type                                           |
| -------------- | ---------------------------------------------------------- |
| continuous     | linear、log、pow、time、sequential、quantize、quantile、threshold |
| Classification | cat、time                                                   |
| constant       | identity                                                   |

#### Cat

Cat refers to the enumeration type, which is used to display categorical data, such as the distribution of crop planting areas. Different categories such as rice, corn, and soybeans need to be mapped to different colors.

```js
// The three crops will be converted into corresponding colors respectively.
// domain = ['corn','rice', 'soybean'];
// range = ['red','white','blue'];
const data = [
  { lng: 120, lat: 30, t: 'corn' },
  { lng: 121, lat: 30, t: 'rice' },
  { lng: 122, lat: 30, t: 'soybean' },
];
layer.source(data, {
  parser: {
    type: 'type',
    x: 'lng',
    y: 'lat'
  }
});
layer.scale('t', { type: 'cat' });
layer.color('t', ['red', 'white', 'blue']);
```

#### identify

Constant measure A field is a constant that does not change.

#### linear

Linear is a mapping method for continuous data. Data and visual values ​​are converted using linear methods. For example, the data value 1-100 is linearly mapped to an offline gradient color from red to blue. Each number corresponds to a color.

#### quantize

Equal intervals divide the range of attribute values ​​into several equally sized subranges. Equal intervals work best with common data ranges, such as percentages and temperatures. This method emphasizes the amount of a certain attribute value relative to other values.

#### quantile

Each class contains an equal number of features. Quantile classification is well suited for linearly distributed data. Quantiles assign an equal number of data values ​​to each class. There is no empty class, nor a class with too many or too few values.
Because "quantile" classification is used to group features into each class in equal numbers, the resulting map is often misleading. You might place similar features into adjacent classes, or place features with widely different values ​​into the same class. This distortion can be minimized by increasing the number of classes.

#### threshold

It allows mapping any subset (non-uniform segment) of the domain to a range of discrete values. The input domain remains continuous and divided into slices based on a set of thresholds provided to the domain attributes. The range attribute must have N+1 elements, where N is the number of threshold boundaries provided in the domain

Manual interval Manual interval Manually set the classification interval. Some data will have corresponding industry standards or require some special display. For example, air quality data has strict data segmentation standards

```
-1   => "red"
0    => "white"
0.5  => "white"
1.0  => "blue"
1000 => "blue
```

#### diverging || Sequential

A uniform non-rational B-spline interpolator function that returns the given array of colors to be converted to RGB colors.

```js
const scaleColors = d3interpolate.interpolateRgbBasis(colors);
```

### IScaleConfig

```js
interface IScaleConfig {
  type: ScaleTypeName;
  domain?: any[];
  range?: any[];
  neutral?: number;
  field?: string;
  unknown?: string;
  ticks?: any[];
  nice?: boolean;
  clamp?: boolean;
  format?: () => any;
}
```

`color` 方法用于设置图形的颜色。

### IColor: string

`color` 类型的字符串。

- color 类型可以为 rgb 的写法 `rgb(200, 100, 100)`、`rgba(255, 0, 0, 1)`
- color 类型可以为十六进制的写法 `#ffffff`、`#000`
- color 类型可以是颜色名称的写法 `red`、`yellow`


### color(color: IColor)

图层可以直接设置颜色值。

```js
layer.color('#f00');
```

### color(field: string)

图层的颜色可以根据图层接受的数据值进行映射，接受传入数据的字段作为参数。

```js
layer.source([
  {
    lng: 120,
    lat: 30,
    c: '#f00',
  },
]);
layer.color('c');
```

### color(field: string, domain: IColor[])

`color` 方法支持简单的值映射，将根据 `field` 从传入图层的数据中提取的值映射到 `domain` 值域中。

```js
layer.color('type', ['#f00', '#0f0', '#00f']);
```

### color(field: string, callback: () => IColor )

`color` 方法支持回调函数的写法，将根据 `field` 作为 `callback` 方法的参数，`callback` 方法的返回值作为图层实际的颜色。

```js
layer.color('type', (value) => {
  switch (value) {
    case 'water':
      return '#f00';
    case 'wood':
      return '#0f0';
  }
});
```
`color`Method used to set the color of the graphic.

### IColor: string

`color`type string.

* The color type can be written in rgb`rgb(200, 100, 100)`、`rgba(255, 0, 0, 1)`
* The color type can be written in hexadecimal`#ffffff`、`#000`
* The color type can be the writing method of color name`red`、`yellow`

### color(color: IColor)

Layers can set color values ​​directly.

```js
layer.color('#f00');
```

### color(field: string)

The colors of a layer can be mapped based on the data values ​​accepted by the layer, accepting fields of incoming data as parameters.

```js
layer.source([
  {
    lng: 120,
    lat: 30,
    c: '#f00',
  },
]);
layer.color('c');
```

### color(field: string, domain: IColor\[])

`color`Method supports simple value mapping and will be based on`field`The values ​​extracted from the data passed into the layer are mapped to`domain`in the value range.

```js
layer.color('type', ['#f00', '#0f0', '#00f']);
```

### color(field: string, callback: () => IColor )

`color`The method supports the writing method of callback function, which will be based on`field`as`callback`method parameters,`callback`The return value of the method is the actual color of the layer.

```js
layer.color('type', (value) => {
  switch (value) {
    case 'water':
      return '#f00';
    case 'wood':
      return '#0f0';
  }
});
```

### name

<description> _string_ **optional** _default:_ 自动数字编号</description>

设置图层名称,可根据 name 获取 layer

```javascript
scene.getLayerByName(name);
```

### visible

<description> _bool_ **optional** _default:_ true</description>

图层是否可见

### zIndex

<description> _int_ **optional** _default:_ 0</description>

图层绘制顺序，数值大绘制在上层，可以控制图层绘制的上下层级

L7 采用队列渲染的机制，所有的图层在内部保存在一个数组中，每一帧的渲染会将图层数组按照 zIndex 的值进行排序，然后遍历数组，将符合条件的图层渲染到场景中

### minZoom

<description> _number_ **optional** _default:_ Mapbox （0-24） 高德 （2-19)</description>

图层显示最小缩放等级

### maxZoom

<description> _number_ **optional** _default:_ Mapbox （0-24） 高德 （2-19)</description>

图层显示最大缩放等级

### autoFit

<description> _bool_ **optional** _default:_ false</description>

layer 初始化完成之后，地图是否自动缩放到图层范围

### pickingBuffer

<description> _bool_ **optional** _default:_ 0</description>

图层拾取缓存机制，如 1px 宽度的线鼠标很难拾取(点击)到, 通过设置该参数可扩大拾取的范围（放大图层对象的尺寸）

### blend

<description> _string_ **optional** _default:_ 'normal'</description>

图层元素混合效果

- normal 正常效果 默认 发生遮挡的时候，只会显示前面的图层的颜色
- additive 叠加模式 发生遮挡的时候，显示前后图层颜色的叠加
- subtractive 相减模式 发生遮挡的时候，显示前后图层颜色的相减
- max 最大值 发生遮挡的时候，显示图层颜色 rgb 的最大值

### enablePropagation

<description> _boolean_ **optional** _default:_ 'false'</description>
图层事件，默认只响应最上层图层，设置为true 将允许事件透传


<embed src="@/docs/common/layer/mask_options.zh.md"></embed>









图层数据使用经纬度格式，数据源支持 JSON、GeoJSON、CSV 三种数据格式。

- [GeoJSON](/api/source/geojson/#point)
- [CSV](/api/source/csv/#parser)
- [JSON](/api/source/json/#点数据)

🌟 通常每种数据都需要相应的 parser 解析数据

## Layer update method

If a layer has been added and you need to modify the layer display style, you can call the graphics mapping method again, and then call`scene.render()`Just update the rendering

### scale update

Recall the scale method

```tsx
layer.scale('value',{
    type:'quantile'
})
scene.render();
```

### data mapping

Recall color/size/filter/shape and other methods

```javascript
layer.color('blue');
layer.size(10);

scene.render();
```

### layer.style

```javascript
layer.style({
    opacity:1
    
});

scene.render();
```

### setData(data, option?: {})

Update Source data

parameter:

* data data
* option defaults to the same as the initial configuration item. If the data format is the same, it does not need to be set.

Calling the setData method will automatically update the layer rendering

```javascript
layer.setData(data);
```

### setBlend(type: string)

Set layer overlay method
parameter:

* type blend 类型 normal ｜ additive ｜ subtractive ｜ max
The layer data uses the latitude and longitude format, and the data source supports three data formats: JSON, GeoJSON, and CSV.

* [GeoJSON](/api/source/geojson/#point)
* [CSV](/api/source/csv/#parser)
* [JSON](</api/source/json/#Point data>)

🌟 Usually each type of data requires a corresponding parser to parse the data
## 图层更新方法

如果已经添加了图层，需要修改图层显示样式可以再次调用图形映射方法，然后调用 `scene.render()`更新渲染即可

### scale 更新

重新调用scale 方法

```tsx
layer.scale('value',{
    type:'quantile'
})
scene.render();
```

### 数据映射

重新调用 color/size/filter/shape等方法

```javascript
layer.color('blue');
layer.size(10);

scene.render();
```


### layer.style

```javascript
layer.style({
    opacity:1
    
});

scene.render();
```

### setData(data, option?: {})

更新 Source 数据

参数:

- data 数据
- option 默认和初始配置项一致，如果数据格式相同可不设置

调用 setData 方法会自动更新图层渲染

```javascript
layer.setData(data);
```

### setBlend(type: string)

设置图层叠加方法
参数：

- type blend 类型 normal ｜ additive ｜ subtractive ｜ max### name

<description> *string* **optional** *default:*automatic numbering</description>

Set the layer name, you can get the layer based on name

```javascript
scene.getLayerByName(name);
```

### visible

<description> *bool* **optional** *default:* true</description>

Is the layer visible?

### zIndex

<description> *int* **optional** *default:*0</description>

Layer drawing order, larger values ​​are drawn on the upper layer, and you can control the upper and lower levels of layer drawing.

L7 uses a queue rendering mechanism. All layers are stored in an array internally. The rendering of each frame will sort the layer array according to the zIndex value, and then traverse the array to render the qualified layers to the scene. middle

### minZoom

<description> *number* **optional** *default:*Mapbox (0-24) Gaode (2-19)</description>

Layer shows minimum zoom level

### maxZoom

<description> *number* **optional** *default:*Mapbox (0-24) Gaode (2-19)</description>

Layer shows maximum zoom level

### autoFit

<description> *bool* **optional** *default:* false</description>

After layer initialization is completed, whether the map will automatically zoom to the layer range.

### pickingBuffer

<description> *bool* **optional** *default:*0</description>

The layer picking cache mechanism, for example, a 1px width line is difficult to pick up (click) with the mouse. By setting this parameter, you can expand the picking range (enlarge the size of the layer object)

### blend

<description> *string* **optional** *default:*'normal'</description>

Layer element blending effects

* normal Normal effect Default When occlusion occurs, only the color of the previous layer will be displayed.
* Additive overlay mode displays the superposition of the colors of the front and rear layers when occlusion occurs.
* subtractive subtraction mode: when occlusion occurs, the subtraction of the colors of the front and rear layers is displayed.
* max maximum value When occlusion occurs, the maximum value of the layer color rgb is displayed.

### enablePropagation

<description> *boolean* **optional** *default:*'false'</description>Layer events, by default only respond to the top layer, setting to true will allow events to be transmitted transparently

<embed src="@/docs/common/layer/mask_options.en.md"></embed>
## mouse events

Mouse event callback parameter target

```javascript
layer.on(eventName, (target) => console.log(target));
```

* x: number x coordinate of the mouse at the map location
* y: number The y coordinate of the mouse's position on the map
* type: string mouse event type
* lngLat: longitude object {lng:number, lat: number}; the latitude and longitude of the mouse location
* feature: any; geographical feature information selected by the data
* featureId: number | null; ID of the geographical feature selected in the data

### click

click event

```javascript
layer.on('click', (e) => console.log(e));
```

### dblclick

double click

```javascript
layer.on('dblclick', (e) => console.log(e));
```

### mousemove

mouse move event

```javascript
layer.on('mousemove', (e) => console.log(e));
```

### mouseout

mouse removal

```javascript
layer.on('mouseout', (e) => console.log(e));
```

### mouseup

mouse raised

```javascript
layer.on('mouseup', (e) => console.log(e));
```

### mousedown

mouse pressed

```javascript
layer.on('mousedown', (e) => console.log(e));
```

### contextmenu

right click

```javascript
layer.on('contextmenu', (e) => console.log(e));
```

### dblclick

Double click to pick element

```javascript
layer.on('dblclick', (e) => console.log(e));
```

### unclick

No element was picked up by clicking

```javascript
layer.on('unclick', (e) => console.log(e));
```

### unmousemove

Element not picked up by mouse movement

```javascript
layer.on('unmousemove', (e) => console.log(e));
```

### unmouseup

The element is not picked up when the mouse is raised

```javascript
layer.on('unmouseup', (e) => console.log(e));
```

### unmousedown

The element is not picked up when the mouse is pressed

```javascript
layer.on('unmousedown', (e) => console.log(e));
```

### uncontextmenu

Select the element with the right mouse button

```javascript
layer.on('uncontextmenu', (e) => console.log(e));
```

### unpick

All mouse events are not picked up

```javascript
layer.on('unpick', (e) => console.log(e));
```

Usage example

```javascript
layer.on('click', (ev) => {}); // Left mouse button click event on layer
layer.on('mouseenter', (ev) => {}); // The mouse enters the layer element
layer.on('mousemove', (ev) => {}); // Triggered when the mouse moves on the layer
layer.on('mouseout', (ev) => {}); // Triggered when the mouse moves out of the layer element
layer.on('mouseup', (ev) => {}); // Triggered when the mouse is clicked and raised on the layer
layer.on('mousedown', (ev) => {}); // Triggered when the mouse is clicked on the layer
layer.on('contextmenu', (ev) => {}); // Right-click menu of layer elements

//Events when the mouse is outside the layer
layer.on('unclick', (ev) => {}); // Click outside the layer
layer.on('unmousemove', (ev) => {}); // Move outside the layer
layer.on('unmouseup', (ev) => {}); // Mouse up outside the layer
layer.on('unmousedown', (ev) => {}); // Triggered when clicked outside the layer
layer.on('uncontextmenu', (ev) => {}); // Right-click outside the layer
layer.on('unpick', (ev) => {}); // All events for operations outside the layer
```
## 鼠标事件

鼠标事件回调参数 target

```javascript
layer.on(eventName, (target) => console.log(target));
```

- x: number 鼠标  在地图位置 x 坐标
- y: number 鼠标  在地图位置 y 坐标
- type: string 鼠标事件类型
- lngLat: 经度度对象 {lng:number, lat: number }; 鼠标所在位置经纬度
- feature: any; 数据选中的地理要素信息
- featureId: number | null; 数据选中的地理要素的 ID

### click

点击事件

```javascript
layer.on('click', (e) => console.log(e));
```
### dblclick

双击

```javascript
layer.on('dblclick', (e) => console.log(e));
```

### mousemove

鼠标移动事件

```javascript
layer.on('mousemove', (e) => console.log(e));
```

### mouseout

鼠标移除

```javascript
layer.on('mouseout', (e) => console.log(e));
```

### mouseup

鼠标抬起

```javascript
layer.on('mouseup', (e) => console.log(e));
```

### mousedown

鼠标按下

```javascript
layer.on('mousedown', (e) => console.log(e));
```

### contextmenu

鼠标右键

```javascript
layer.on('contextmenu', (e) => console.log(e));
```

### dblclick

双击拾取元素

```javascript
layer.on('dblclick', (e) => console.log(e));
```

### unclick

点击未拾取到元素

```javascript
layer.on('unclick', (e) => console.log(e));
```

### unmousemove

鼠标移动未拾取到元素

```javascript
layer.on('unmousemove', (e) => console.log(e));
```

### unmouseup

鼠标抬起未拾取到元素

```javascript
layer.on('unmouseup', (e) => console.log(e));
```

### unmousedown

鼠标按下未拾取到元素

```javascript
layer.on('unmousedown', (e) => console.log(e));
```

### uncontextmenu

鼠标右键位拾取到元素

```javascript
layer.on('uncontextmenu', (e) => console.log(e));
```

### unpick

所有鼠标事件未拾取到

```javascript
layer.on('unpick', (e) => console.log(e));
```

使用示例

```javascript
layer.on('click', (ev) => {}); // 鼠标左键点击图层事件
layer.on('mouseenter', (ev) => {}); // 鼠标进入图层要素
layer.on('mousemove', (ev) => {}); // 鼠标在图层上移动时触发
layer.on('mouseout', (ev) => {}); // 鼠标移出图层要素时触发
layer.on('mouseup', (ev) => {}); // 鼠标在图层上单击抬起时触发
layer.on('mousedown', (ev) => {}); // 鼠标在图层上单击按下时触发
layer.on('contextmenu', (ev) => {}); // 图层要素点击右键菜单

// 鼠标在图层外的事件
layer.on('unclick', (ev) => {}); // 图层外点击
layer.on('unmousemove', (ev) => {}); // 图层外移动
layer.on('unmouseup', (ev) => {}); // 图层外鼠标抬起
layer.on('unmousedown', (ev) => {}); // 图层外单击按下时触发
layer.on('uncontextmenu', (ev) => {}); // 图层外点击右键
layer.on('unpick', (ev) => {}); // 图层外的操作的所有事件
```------

### style

The style method is usually used to describe the specific style of a layer. Most layers will support some more general properties, such as the opacity property. At the same time, each layer will also have properties that are only supported by this layer, such as only
The windowColor attribute supported by CityBuildingLayer. Please check the detailed documentation of each layer for how to configure the attribute for each layer.

* opacity sets transparency, supported by most layers

* stroke line fill color only supported by point layer

* strokeWidth The width of the line. Only supported by point layers.

```javascript
layer.style({
  opacity: 0.8,
  stroke: 'white',
});
```

* Style data mapping🌟\
  Under normal circumstances, the style parameters will apply to all graphics on a layer. For example, if there are ten points in a PointLayer, we set opacity = 0.5, so that the transparency of the ten points is 0.5.\
  In special cases, we may need to set a transparency for each point. In this case, directly setting the opacity value of the style method in the original way cannot meet the needs. For this reason, we need to provide a special assignment method.\
  Usually we will set separate values ​​for each graphic of the layer based on the data passed into the layer, so we call it "style data mapping".\
  We support several ways of setting parameters in style to dynamically obtain values ​​from source data.

```javascript
//Set the transparency of each point of the point layer based on the value of the v field in the data
const data = [
  {
    lng: 120,
    lat: 30,
    v: 0.5
  },
  ...
]
const layer = new PointLayer()
  .source(data, {
    parser: {
      x: 'lng',
      y: 'lat'
    }
  })
  .shape('circle')
  .color('#f00')
  .size({
    // The first way to write is to get the value directly from data based on the field.
    opacity: 'v'// opacity = 0.5
  });
scene.addLayer(layer);
```

[Online case](/examples/point/text#stylemap)

from`L7 2.5`Starting from the beginning, each layer style will gradually support style data mapping. Currently, all layer styles support style data mapping.`style`The parameters are as follows:

| layer type/shape        | Supported style fields                           | Remark                                             |
| ----------------------- | ------------------------------------------------ | -------------------------------------------------- |
| pointLayer/fill         | opacity、strokeOpacity、strokeWidth、stroke、offsets | shape circle、triangle...                           |
| pointLayer/image        | opacity、offsets                                  | offsets latitude and longitude offsets             |
| pointLayer/normal       | opacity、offsets                                  |                                                    |
| pointLayer/text         | opacity、strokeWidth、stroke、textOffset            | textOffset offset relative to text canvas position |
| pointLayer/extrude      | opacity                                          |                                                    |
| polygonLayer/fill       | opacity                                          |                                                    |
| polygonLayer/extrude    | opacity                                          |                                                    |
| lineLayer/line          | opacity                                          |                                                    |
| lineLayer/arc           | opacity、thetaOffset                              | thetaOffset the curvature of the arc               |
| lineLayer/arc3d         | opacity                                          |                                                    |
| lineLayer/great\_circle | opacity                                          |                                                    |

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*iz3ERZdg2SkAAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/point/scatter#scatterstylemap)
### style

style 方法通常用于描述图层具体的样式，大多数图层会支持一些比较通用的属性， 如 opacity 属性，同时每个图层也会有仅限本图层支持的属性，如只有
CityBuildingLayer 支持的 windowColor 属性，每个图层具体要如何配置属性请查看每个图层的详细文档。

- opacity 设置透明度 大部分图层都支持

- stroke 线填充颜色 仅点图层支持

- strokeWidth 线的宽度 仅点图层支持

```javascript
layer.style({
  opacity: 0.8,
  stroke: 'white',
});
```

- 样式数据映射🌟  
  在正常情况下，style 的参数会作用到一个图层上的所有图形，如一个 PointLayer 中有十个点，我们设置 opacity = 0.5， 这样十个点的透明度都是 0.5。   
  而在特殊情况下，我们可能需要为每个点分别设置一个透明度，这时候按照原来的方式直接设置 style 方法的 opacity 的值就无法满足需求了，为此我们需要提供特殊的赋值方式。    
  通常我们会根据传入图层的数据为图层的每个图形设置单独的值，因此我们称之为“样式数据映射”。      
  我们支持几种设置 style 中的参数从 source 数据中动态取值的写法。   

```javascript
// 根据数据中的 v 字段的值设置点图层各个点的透明度
const data = [
  {
    lng: 120,
    lat: 30,
    v: 0.5
  },
  ...
]
const layer = new PointLayer()
  .source(data, {
    parser: {
      x: 'lng',
      y: 'lat'
    }
  })
  .shape('circle')
  .color('#f00')
  .size({
    // 第一种写法 根据字段从 data 中直接取值
    opacity: 'v'// opacity = 0.5
  }); 
scene.addLayer(layer);
```

[在线案例](/examples/point/text#stylemap)

从 `L7 2.5` 开始，各图层样式将逐步支持样式数据映射，目前支持样式数据映射的 `style` 参数如下：

| layer 类型/shape       | 支持的样式字段                                       | 备注                              |
| ---------------------- | ---------------------------------------------------- | --------------------------------- |
| pointLayer/fill        | opacity、strokeOpacity、strokeWidth、stroke、offsets | shape circle、triangle...         |
| pointLayer/image       | opacity、offsets                                     | offsets 经纬度偏移                |
| pointLayer/normal      | opacity、offsets                                     |                                   |
| pointLayer/text        | opacity、strokeWidth、stroke、textOffset             | textOffset 相对文字画布位置的偏移 |
| pointLayer/extrude     | opacity                                              |                                   |
| polygonLayer/fill      | opacity                                              |                                   |
| polygonLayer/extrude   | opacity                                              |                                   |
| lineLayer/line         | opacity                                              |                                   |
| lineLayer/arc          | opacity、thetaOffset                                 | thetaOffset 弧线的弯曲弧度        |
| lineLayer/arc3d        | opacity                                              |                                   |
| lineLayer/great_circle | opacity                                              |                                   |

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*iz3ERZdg2SkAAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/point/scatter#scatterstylemap)
### source 数据

设置图层数据以及解析配置 `source(data, config)`。

- data { geojson | json | csv }
- config   可选   数据源配置项
  - parser 数据解析，默认是解析层 geojson
  - transforms [transform，transform ]  数据处理转换可设置多个

`parser` 和  `transforms` [见 source 文档](/api/source/source)。

```javascript
layer.source(data, {
  parser: {
    type: 'csv',
    x: 'lng',
    y: 'lat',
  },
  transforms: [
    {
      type: 'map',
      callback: function(item) {
        const [x, y] = item.coordinates;
        item.lat = item.lat * 1;
        item.lng = item.lng * 1;
        item.v = item.v * 1;
        item.coordinates = [x * 1, y * 1];
        return item;
      },
    },
    {
      type: 'hexagon',
      size: 6000,
      field: 'v',
      method: 'sum',
    },
  ],
});
```
### cluster

我们在使用 `cluster` 配置聚合图之后就可以使用一些聚合方法来获取对应参数。
#### getClusters(zoom: number): IFeatureCollection

获取指定缩放等级的聚合数据

- `zoom` 缩放等级

#### getClustersLeaves(id: string): IFeatureCollection

根据 `id` 获取聚合节点的数据，每个聚合节点会有一个唯一 `ID`。

- `id` 聚合节点的 `id`


```ts
const source = layer.getSource();
source.getClustersLeaves(id);
layer.on('click', (e) => {
  console.log(source.getClustersLeaves(e.feature.cluster_id));
});

```


## scale 数据度量

Scale 度量是将地图数据值（数字、日期、类别等数据）转成视觉值（颜色、大小、形状）。尺度 Scale 是数据可视化的基本组成部分，因为它们决定了视觉编码的性质。 L7 目前支持连续、离散、枚举类型数据的Scale，并支持位置、形状、大小和颜色编码的映射。

在使用 L7 过程中，默认情况下不需要进行 Scale 的配置，因为 L7 会根据数据类型对 scale 推断，推断过程如下：

查看用户是否设置了 Scale，如果没有:

判断字段的第一条数据的字段类型，如果数据中不存在对应的字段：

认为是常量为固定值

如果是数字则为 'linear';

如果是字符串类型 'cat';


### scale

[Scale 详细介绍](https://mp.weixin.qq.com/s/QyD1_ypu0PDwMxEz45v6Jg)

参数： (field: string, scaleOptions: IscaleOptions)
- `field` 指定 source 中传入的数据中用于映射的字段名
- `scaleOptions` 列定义配置，对象类型
  - type scale 类型
  - unknown 未匹配颜色 可选  默认透明
  - domain 值域 可选


```javascript
interface IscaleOptions {
  type: ScaleTypeName;
  domain?: any[];
  ...
}

layer.color('id', ['#f00', '#ff0'])
.size('mag', [1, 80])
.scale('mag', {
  type: 'linear',
  domain: [ 1, 50]
})；
```

#### 类型


Range 和 domain 是 Scale 中非常重要的两个参数

domain: 地图数据值的定义区间
range：视觉值的区间
不同Scale 的差异在于 domain->range 的转换方法的不同

- domain: 地图数据值的定义区间
- range：视觉值的区间定义

|数据类|度量类型|
|-----|------|
| 连续 | linear、log、pow |
| 连续分类 | quantize quantile,threshold,diverging |
| 分类 枚举 | cat |


#### Cat

Cat 指枚举类型，用于展示分类数据，比如农作物种植区分布图，水稻、玉米、大豆等不同类别需要映射为不同的颜色。

```js
// 三种作物会分别转成对应的颜色
// domain = ['corn','rice', 'soybean'];
// range = ['red','white','blue'];
const data = [
  { lng: 120, lat: 30, t: 'corn' },
  { lng: 121, lat: 30, t: 'rice' },
  { lng: 122, lat: 30, t: 'soybean' },
];
layer.source(data, {
  parser: {
    type: 'type',
    x: 'lng',
    y: 'lat'
  }
});
layer.scale('t', { type: 'cat' });
layer.color('t', ['red', 'white', 'blue']);

```


#### identify

数据值和映射值相同
比如数据中value 字段记录了每个要素的颜色，数值既为要映射的结果值s

```
// 设置为 identify
layer.scale('value', { type: 'identify' });

// 或者 

layer.scale('value'); // L7  能够自动推断为  identify

```

#### linear

线性是连续数据的映射方法，数据和视觉值是通过线性方法换算的。如数据值 1-100 线性映射到红到蓝的线下渐变色每个数字对应一个颜色

#### quantize 

相等间隔会将属性值的范围划分为若干个大小相等的子范围。相等间隔最适用于常见的数据范围，如百分比和温度。这种方法强调的是某个属性值相对于其他值的量

#### quantile

每个类都含有相等数量的要素。分位数分类非常适用于呈线性分布的数据。分位数为每个类分配数量相等的数据值。不存在空类，也不存在值过多或过少的类。
由于使用“分位数”分类将要素以同等数量分组到每个类中，因此得到的地图往往具有误导性。可能会将相似的要素置于相邻的类中，或将值差异较大的要素置于相同类中。可通过增加类的数量将这种失真降至最低。

#### threshold 

他允许将域的任意子集（非统一段）映射到范围内的离散值。输入域仍然是连续的，并根据提供给域属性的一组阈值划分为多个切片。 range 属性必须有 N+1 个元素，其中 N 是域中提供的阈值边界数

手动设置间隔 Manual interval 手动设置分级分类区间，某些数据会有相应的业界标准，或者需要进行某种特殊的显示。如空气质量数据有严格数据分段标准

```
-1   => "red"
0    => "white"
0.5  => "white"
1.0  => "blue"
1000 => "blue

```
#### diverging

离散分类通常与两种相反的色调一起使用，以显示从负值到中心到正值的变化。这些类型的地图显示了彼此相关的值的大小。



### getScale(scaleName:string)

根据视觉通道名称获取 scale 实例,调用之前确保 layer 已经初始化完成


```ts
const scale = layer.getScale('color')
const color = scale(1)// 将数值转换成颜色
```
更多是方法 
<a  target="_blank" href='https://github.com/antvis/L7/blob/master/packages/layers/src/core/BaseLayer.ts#L1176'>scale 示例使用</a>

## 视觉编码方法

可视化编码是将数据转换为可视形式的过程，L7 目前支持形状，大小，颜色 3 种视觉通道，你可以指定数据字段，为不同要素设置不同的图形属性。

<img width="100%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*PzoTRJnY-fIAAAAAAAAAAAAAARQnAQ'>

### filter

数据过滤方法,支持回调函数，将数据映射为true | false, 结果为true 时可见

```ts 

pointLayer.filter('type', (type) => {
  // 回调函数
  if (type === 'a') {
    return false;
  }
  return true ;
});
```


### size

将数据值映射到图形的大小上的方法，size 方法具体的参数使用可以查看对应图层的详细文档

```javascript
pointLayer.size(10); // 常量
pointLayer.size('type'); // 使用字段映射到大小
pointLayer.size('type', [0, 10]); // 使用字段映射到大小，并指定最大值和最小值
pointLayer.size('type', (type) => {
  // 回调函数
  if (type === 'a') {
    return 10;
  }
  return 5;
});
```

#### size(value）

传入数字常量，如  `pointLayer.size(20)`

#### size(field)

根据 field 字段的值映射大小，使用默认的`最大值 max:10`  和`最小值 min: 1`。

#### size(field, callback)

使用回调函数控制图形大小。

- `callback`: function 回调函数。

```javascript
pointLayer.size('age', (value) => {
  if (value === 1) {
    return 5;
  }
  return 10;
});
```

### color

将数据值映射到图形的颜色上的方法。

```javascript
layer.color('red'); // 常量颜色
layer.color('type'); // 对 type 字段进行映射，使用内置的颜色
layer.color('type', ['red', 'blue']); // 指定颜色
layer.color('type', (type) => {
  // 通过回调函数
  if (type === 'a') {
    return 'red';
  }
  return 'blue';
});
layer.color('type*value', (type, value) => {
  //多个参数，通过回调函数
  if (type === 'a' && value > 100) {
    return 'red';
  }
  return 'blue';
});
```

#### color(value)

参数：`value` ：string

只支持接收一个参数，value 可以是：

- 映射至颜色属性的数据源字段名，如果数据源中不存在这个字段名的话，则按照常量进行解析，这个时候会使用 L7 默认提供的颜色。

- 也可以直接指定某一个具体的颜色值 color，如 '#fff', 'white','rgba(255,0,0,0.5)' ,rgb(255,0,1) 等。

如果数据为映射到颜色，默认为透明色不显示，如果需要设置该颜色，需要在scale 中设置


示例

```javascript
layer.color('name'); // 映射数据字段
layer.color('white'); // 指定颜色
```

#### color(field, colors)

参数：

- `field`: stringfield 为映射至颜色属性的数据源字段名，也支持指定多个参数。

- `colors`: string | array | function

colors 的参数有以下情况：  如果为空，即未指定颜色的数组，那么使用内置的全局的颜色；如果需要指定颜色，则需要以数组格式传入，那么分类的颜色按照数组中的颜色确定。

```javascript
layer.scale('name',{
  type:'quantile'
  unknown:'#ccc' // 设置无效颜色
})
layer.color('name'); // 使用identity 
layer.color('name', ['red', 'blue']); // 使用传入的指定颜色
```

- colors 如果是回调函数，则该回调函数的参数为对应字段的数值，具体使用如下，当 color 映射为多个字段时，参数按照字段声明的顺序传入：

```javascript
layer.color('gender', (value) => {
  if (value === 1) {
    return 'red';
  }
  return 'blue';
});
layer.color('gender*age', (gender, age) => {
  if (age === 20 && gender == ' 男') {
    return 'red';
  }
  return 'blue';
});
```

### shape

通常一种图层可以有多种表现形式，shape 方法用于指定图层具体的表现形式，以 PointLayer 的 shape 为例：

```javascript
shape('circle'); // 圆形
shape('triangle'); // 三角形
shape('cylinder'); // 圆柱
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*iN0nTYRDd3AAAAAAAAAAAABkARQnAQ'>

**shape(shape)**

参数 `shape` string

- 只支持接收一个参数，指定几何图像对象绘制的形状。下表列出了不同的 图层 几何图形对象支持的 shape 形状

| layer 类型 | shape 类型                                                                             | 备注 |
| ---------- | -------------------------------------------------------------------------------------- | ---- |
| point      | 2d:point,circle, square, triangle,hexagon,image,text 3d:circle,triangle,hexagon,square |      |
| line       | line,arc, arc3d, greatcircle                                                           |      |
| polygon    | fill,line, extrude                                                                     |      |

**shape(field, shapes)**

- shape 根据字段指定行形状，比如根据字段指定 PointLayer/imageLayer 的 icon 类型

```javascript
scene.addImage(
  '00',
  'https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg',
);
scene.addImage(
  '01',
  'https://gw.alipayobjects.com/zos/basement_prod/30580bc9-506f-4438-8c1a-744e082054ec.svg',
);
scene.addImage(
  '02',
  'https://gw.alipayobjects.com/zos/basement_prod/7aa1f460-9f9f-499f-afdf-13424aa26bbf.svg',
);
const imageLayer = new PointLayer()
  .source(data, {
    parser: {
      type: 'json',
      x: 'longitude',
      y: 'latitude',
    },
  })
  .shape('name', ['00', '01', '02'])
  .size(20);
scene.addLayer(imageLayer);
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*oVyHT5S3sv0AAAAAAAAAAABkARQnAQ'>

[在线案例](/examples/point/image#image)

**shape(field, callback)**

- shape 也支持回调函数的写法

```javascript
.shape('key', value => {
  if(value > 10) {
    return 'circle';
  } else {
    return 'triangle';
  }
}
```

`style` 方法用于配制图层的样式，
- 单通道 绘制结果由是单一的数值控制，如灰度图，数值对应的颜色可以通过表示配置 `rampColors` 色带控制。

```js
layer.style({
  opacity: 0.5,
});
```

### 配置

| style       | 类型               | 描述                                        | 默认值        |
| ----------- | ------------------ | ------------------------------------------- | ------------- |
| opacity     | `number`           | 图形的透明度                                | `1`           |
| clampLow    | `boolean`          | 设置为 `true`，低于 `domain` 的数据将不显示 | `false`       |
| clampHigh   | `boolean`          | 设置为 `true`，高于 `domain` 的数据将不显示 | `false`       |
| domain      | `[number, number]` | 数据映射区间                                | `[ 0, 8000 ]` |
| noDataValue | `number`           | 不会显示的值                                | `-9999999`    |
| rampColors  | `IRampColors`      | 值域映射颜色的色带                          | `/`           |


<embed src="@/docs/common/layer/raster/rampcolors.zh.md"></embed>------

`style`Method is used to configure the style of the layer,

* The single-channel drawing result is controlled by a single numerical value, such as a grayscale image. The color corresponding to the numerical value can be configured by expressing`rampColors`Ribbon control.

```js
layer.style({
  opacity: 0.5,
});
```

### Configuration

| style       | type               | describe                                                    | default value |
| ----------- | ------------------ | ----------------------------------------------------------- | ------------- |
| opacity     | `number`           | Graphic transparency                                        | `1`           |
| clampLow    | `boolean`          | Set as`true`, lower than`domain`data will not be displayed  | `false`       |
| clampHigh   | `boolean`          | Set as`true`, higher than`domain`data will not be displayed | `false`       |
| domain      | `[number, number]` | Data mapping interval                                       | `[ 0, 8000 ]` |
| noDataValue | `number`           | Values ​​that will not be displayed                         | `-9999999`    |
| rampColors  | `IRampColors`      | The color ramp for the range mapping color                  | `/`           |

<embed src="@/docs/common/layer/raster/rampcolors.en.md"></embed>
- 单通道 绘制结果由是单一的数值控制，如灰度图，数值对应的颜色可以通过表示配置 `rampColors` 色带控制。

```js
layer.style({
  opacity: 0.5,
});
```

### options

| style       | 类型               | 描述                                        | 默认值        |
| ----------- | ------------------ | ------------------------------------------- | ------------- |
| opacity     | `number`           | 图形的透明度                                | `1`           |
| clampLow    | `boolean`          | 设置为 `true`，低于 `domain` 的数据将不显示 | `false`       |
| clampHigh   | `boolean`          | 设置为 `true`，高于 `domain` 的数据将不显示 | `false`       |
| domain      | `[number, number]` | 数据映射区间                                | `[ 0, 8000 ]` |
| noDataValue | `number`           | 不会显示的值                                | `-9999999`    |
| rampColors  | `IRampColors`      | 值域映射颜色的色带                          | `/`           |

<embed src="@/docs/common/layer/raster/rampcolors.zh.md"></embed>
------

* The single-channel drawing result is controlled by a single numerical value, such as a grayscale image. The color corresponding to the numerical value can be configured by expressing`rampColors`Ribbon control.

```js
layer.style({
  opacity: 0.5,
});
```

### options

| style       | type               | describe                                                    | default value |
| ----------- | ------------------ | ----------------------------------------------------------- | ------------- |
| opacity     | `number`           | Graphic transparency                                        | `1`           |
| clampLow    | `boolean`          | Set as`true`, lower than`domain`data will not be displayed  | `false`       |
| clampHigh   | `boolean`          | Set as`true`, higher than`domain`data will not be displayed | `false`       |
| domain      | `[number, number]` | Data mapping interval                                       | `[ 0, 8000 ]` |
| noDataValue | `number`           | Values ​​that will not be displayed                         | `-9999999`    |
| rampColors  | `IRampColors`      | The color ramp for the range mapping color                  | `/`           |

<embed src="@/docs/common/layer/raster/rampcolors.en.md"></embed>
### rampColors color ramps

- type type supports \`linear','quantize','custom','cat'
- colors color array
- positions data segmentation interval, optional, quantize does not need to set position, position is the original data value

⚠️ 2.13 new features

#### cat enumeration type ribbon

The enumeration type ribbon only supports integer types from 0 to 255, and positions are used to set the enumeration.

```tsx
{
  type:'cat',
  colors:['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00'],
  positions:[1,20,101,102,200],
}
```

#### quantize equally spaced classification ribbons

Equally spaced segments are evenly divided only according to the interval domain of the data, such as domain \[0,10000]. If it is divided into 5 segments, the distance between each segment is 2000.
There is no need to set positions for equal spacing. You only need to set colors. Set the number of segments according to the length of colors.

```tsx
rampColors: {
  type:'quantize',
  colors: ['#f0f9e8','#bae4bc','#7bccc4','#43a2ca','#0868ac']
}
```

#### linear linear continuous ribbon

linear is an enhanced version of the existing continuous type. Positions supports setting source data without converting it to 0-1.

```tsx
rampColors: {
  type:'linear',
  colors: ['#f0f9e8','#bae4bc','#7bccc4','#43a2ca','#0868ac'],
  positions [0,200,1000,4000,8000]
}

⚠️ Compatible with versions before 2.13.0. When type is not set, the position value range is 0-1.
```

#### custom custom segmented ribbon

Customized segmented ribbons distinguish equal-spaced ribbons, and user-defined segment intervals.
The length of custom positions needs to be 1 more than the length of colors, and positions

```tsx
rampColors: {
  type:'custom',
  colors: ['#f0f9e8','#bae4bc','#7bccc4','#43a2ca','#0868ac'],
  positions [0,200,1000,4000,8000,10000]
}
```
### rampColors 颜色色带
- type 类型 支持 `linear','quantize','custom','cat'
- colors  颜色数组
- positions 数据分段区间，可选，quantize 不需要设置 position，position 为原始数据值

⚠️ 2.13 新增特性

#### cat 枚举类型色带

枚举类型色带只支持 0 -255 的整数类型，positions 用来设置枚举
```tsx
{
  type:'cat',
  colors:['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00'],
  positions:[1,20,101,102,200],
}
```

#### quantize 等间距分类色带

等间距只根据数据的区间 domain 进行均匀分段，如 domain [0,10000]，如果分 5 段，每段间距 2000。
等间距不需要设置 positions，只需要设置colors，根据colors 的长度设置分段数

```tsx
rampColors: {
  type:'quantize',
  colors: ['#f0f9e8','#bae4bc','#7bccc4','#43a2ca','#0868ac']
}
```
#### linear 线性连续色带

linear 为现有连续类型的加强版，positions 支持设置源数据，不需要转换成 0-1

```tsx
rampColors: {
  type:'linear',
  colors: ['#f0f9e8','#bae4bc','#7bccc4','#43a2ca','#0868ac'],
  positions [0,200,1000,4000,8000]
}

⚠️ 兼容 2.13.0 之前版本，未设置type 时，position 值域为 0-1。



```

#### custom 自定义分段色带

自定义分段色带区别等间距色带，用户自定义分段间隔。
自定义 positions 的长度需要比 colors 的长度多1个，同时poisitions 

```tsx
rampColors: {
  type:'custom',
  colors: ['#f0f9e8','#bae4bc','#7bccc4','#43a2ca','#0868ac'],
  positions [0,200,1000,4000,8000,10000]
}
```

### texture

Currently, texture methods are only supported on line layers.

* The texture method supports passing in global icon texture resources added by the scene.addImage method.

```javascript
// First load image resources globally
scene.addImage(
  'plane',
  'https://gw.alipayobjects.com/zos/bmw-prod/0ca1668e-38c2-4010-8568-b57cb33839b9.svg',
);

const layer = new LineLayer({
  blend: 'normal',
})
  .source(data, {
    parser: {
      type: 'json',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(25)
  .shape('arc')
  .texture('plane') // Bind texture to layer
  .color('#8C1EB2')
  .style({
    lineTexture: true, // Enable line mapping function
    iconStep: 30, // Set the spacing of the texture
    textureBlend: 'replace', //Set the texture blending method. The default value is normal. The optional values ​​are normal/replace.
  });
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*KEupSZ_p0pYAAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/line/animate#plane_animate2)
-----|---

### source data

Set layer data and parsing configuration`source(data, config)`。

* data { geojson | json | csv }
* config optional data source configuration items
  * parser data analysis, the default is the parsing layer geojson
  * transforms \[transform, transform ] Multiple data processing transformations can be set

`parser`and  `transforms` [See source documentation](/api/source/source)。

```javascript
layer.source(data, {
  parser: {
    type: 'csv',
    x: 'lng',
    y: 'lat',
  },
  transforms: [
    {
      type: 'map',
      callback: function(item) {
        const [x, y] = item.coordinates;
        item.lat = item.lat * 1;
        item.lng = item.lng * 1;
        item.v = item.v * 1;
        item.coordinates = [x * 1, y * 1];
        return item;
      },
    },
    {
      type: 'hexagon',
      size: 6000,
      field: 'v',
      method: 'sum',
    },
  ],
});
```

### cluster

we are using`cluster`After configuring the aggregation graph, you can use some aggregation methods to obtain the corresponding parameters.

#### getClusters(zoom: number): IFeatureCollection

Get aggregated data for a specified zoom level

* `zoom`Zoom level

#### getClustersLeaves(id: string): IFeatureCollection

according to`id`Get the data of the aggregation node. Each aggregation node will have a unique`ID`。

* `id`aggregation node`id`

```ts
const source = layer.getSource();
source.getClustersLeaves(id);
layer.on('click', (e) => {
  console.log(source.getClustersLeaves(e.feature.cluster_id));
});
```

## scale data measure

Scale measures convert map data values ​​(numbers, dates, categories, etc.) into visual values ​​(color, size, shape). Scales Scales are a fundamental component of data visualization because they determine the nature of the visual encoding. L7 currently supports Scale for continuous, discrete, and enumerated type data, and supports mapping of position, shape, size, and color coding.

When using L7, there is no need to configure Scale by default because L7 will infer scale based on the data type. The inference process is as follows:

Check whether the user has set Scale, if not:

Determine the field type of the first data of the field, if the corresponding field does not exist in the data:

Consider a constant as a fixed value

'linear' if numeric;

If it is string type 'cat';

### scale

[Scale details](https://mp.weixin.qq.com/s/QyD1_ypu0PDwMxEz45v6Jg)

参数： (field: string, scaleOptions: IscaleOptions)

* `field`Specify the field name used for mapping in the data passed in source
* `scaleOptions`Column definition configuration, object type
  * type scale type
  * unknown unmatched color optional default transparent
  * domain value range optional

```javascript
interface IscaleOptions {
  type: ScaleTypeName;
  domain?: any[];
  ...
}

layer.color('id', ['#f00', '#ff0'])
.size('mag', [1, 80])
.scale('mag', {
  type: 'linear',
  domain: [ 1, 50]
})；
```

#### type

Range and domain are two very important parameters in Scale

domain: definition interval of map data values
range: range of visual values
The difference between different Scales lies in the different conversion methods of domain->range

* domain: definition interval of map data values
* range: interval definition of visual value

|Data Class|Measurement Type|
\|---|
\| Continuous | linear, log, pow |
\| Continuous classification | quantize quantile,threshold,diverging |
\| Classification Enumeration | cat |

#### Cat

Cat refers to the enumeration type, which is used to display categorical data, such as the distribution of crop planting areas. Different categories such as rice, corn, and soybeans need to be mapped to different colors.

```js
// The three crops will be converted into corresponding colors respectively.
// domain = ['corn','rice', 'soybean'];
// range = ['red','white','blue'];
const data = [
  { lng: 120, lat: 30, t: 'corn' },
  { lng: 121, lat: 30, t: 'rice' },
  { lng: 122, lat: 30, t: 'soybean' },
];
layer.source(data, {
  parser: {
    type: 'type',
    x: 'lng',
    y: 'lat'
  }
});
layer.scale('t', { type: 'cat' });
layer.color('t', ['red', 'white', 'blue']);
```

#### identify

The data value and the mapped value are the same
For example, the value field in the data records the color of each element, and the value is the result value s to be mapped.

```
// Set to identify
layer.scale('value', { type: 'identify' });

// or 

layer.scale('value'); // L7 can be automatically inferred as identify
```

#### linear

Linear is a mapping method for continuous data. Data and visual values ​​are converted using linear methods. For example, the data value 1-100 is linearly mapped to an offline gradient color from red to blue. Each number corresponds to a color.

#### quantize

Equal intervals divide the range of attribute values ​​into several equally sized subranges. Equal intervals work best with common data ranges, such as percentages and temperatures. This method emphasizes the amount of a certain attribute value relative to other values.

#### quantile

Each class contains an equal number of features. Quantile classification is well suited for linearly distributed data. Quantiles assign an equal number of data values ​​to each class. There is no empty class, nor a class with too many or too few values.
Because "quantile" classification is used to group features into each class in equal numbers, the resulting map is often misleading. You might place similar features into adjacent classes, or place features with widely different values ​​into the same class. This distortion can be minimized by increasing the number of classes.

#### threshold

It allows mapping any subset (non-uniform segment) of the domain to a range of discrete values. The input domain remains continuous and divided into slices based on a set of thresholds provided to the domain attributes. The range attribute must have N+1 elements, where N is the number of threshold boundaries provided in the domain

Manual interval Manual interval Manually set the classification interval. Some data will have corresponding industry standards or require some special display. For example, air quality data has strict data segmentation standards

```
-1   => "red"
0    => "white"
0.5  => "white"
1.0  => "blue"
1000 => "blue
```

#### diverging

Discrete classification is often used with two opposite hues to show the change from negative values ​​to center to positive values. These types of maps show the magnitude of values ​​in relation to each other.

### getScale(scaleName:string)

Get the scale instance based on the visual channel name. Make sure the layer has been initialized before calling.

```ts
const scale = layer.getScale('color')
const color = scale(1)//Convert numerical value to color
```

More of a method<a  target="_blank" href='https://github.com/antvis/L7/blob/master/packages/layers/src/core/BaseLayer.ts#L1176'>scale example usage</a>

## visual coding methods

Visual coding is the process of converting data into visual form. L7 currently supports three visual channels: shape, size, and color. You can specify data fields and set different graphic attributes for different elements.

<img width="100%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*PzoTRJnY-fIAAAAAAAAAAAAAARQnAQ'>

### filter

Data filtering method, supports callback function, maps data to true | false, visible when the result is true

```ts
pointLayer.filter('type', (type) => {
  // Callback
  if (type === 'a') {
    return false;
  }
  return true ;
});
```

### size

A method for mapping data values ​​to the size of graphics. For specific parameters of the size method, you can view the detailed documentation of the corresponding layer.

```javascript
pointLayer.size(10); // constant
pointLayer.size('type'); // Use fields to map to sizes
pointLayer.size('type', [0, 10]); // Use fields to map to sizes and specify maximum and minimum values
pointLayer.size('type', (type) => {
  // Callback
  if (type === 'a') {
    return 10;
  }
  return 5;
});
```

#### size(value）

Pass in a numeric constant, such as`pointLayer.size(20)`

#### size(field)

Map the size according to the value of the field field, using the default`最大值 max:10`  and`最小值 min: 1`。

#### size(field, callback)

Use callback functions to control graph size.

* `callback`: function callback function.

```javascript
pointLayer.size('age', (value) => {
  if (value === 1) {
    return 5;
  }
  return 10;
});
```

### color

A method for mapping data values ​​to the colors of a graph.

```javascript
layer.color('red'); // constant color
layer.color('type'); //Map the type field and use the built-in color
layer.color('type', ['red', 'blue']); // Specify color
layer.color('type', (type) => {
  // through callback function
  if (type === 'a') {
    return 'red';
  }
  return 'blue';
});
layer.color('type*value', (type, value) => {
  //Multiple parameters, through callback function
  if (type === 'a' && value > 100) {
    return 'red';
  }
  return 'blue';
});
```

#### color(value)

parameter:`value`：string

Only supports receiving one parameter, value can be:

* The data source field name mapped to the color attribute. If this field name does not exist in the data source, it will be parsed according to constants. In this case, the color provided by L7 by default will be used.

* You can also directly specify a specific color value, such as '#fff', 'white', 'rgba(255,0,0,0.5)', rgb(255,0,1), etc.

If the data is mapped to color, the transparent color will not be displayed by default. If you need to set the color, you need to set it in scale.

Example

```javascript
layer.color('name'); // Mapping data fields
layer.color('white'); //Specify color
```

#### color(field, colors)

parameter:

* `field`: stringfield is the name of the data source field mapped to the color attribute. It also supports specifying multiple parameters.

* `colors`: string | array | function

The parameters of colors have the following conditions: If it is empty, that is, an array of colors is not specified, then the built-in global color is used; if a color needs to be specified, it needs to be passed in in array format, then the color of the classification is determined according to the color in the array.

```javascript
layer.scale('name',{
  type: 'quantile'
  unknown:'#ccc' // Set invalid color
})
layer.color('name'); // use identity
layer.color('name', ['red', 'blue']); // Use the specified color passed in
```

* If colors is a callback function, the parameters of the callback function are the values ​​of the corresponding fields. The specific usage is as follows. When color is mapped to multiple fields, the parameters are passed in in the order in which the fields are declared:

```javascript
layer.color('gender', (value) => {
  if (value === 1) {
    return 'red';
  }
  return 'blue';
});
layer.color('gender*age', (gender, age) => {
  if (age === 20 && gender == ' 男') {
    return 'red';
  }
  return 'blue';
});
```

### shape

Usually a layer can have multiple representations. The shape method is used to specify the specific representation of the layer. Take the shape of PointLayer as an example:

```javascript
shape('circle'); // circle
shape('triangle'); // triangle
shape('cylinder'); // cylinder
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*iN0nTYRDd3AAAAAAAAAAAABkARQnAQ'>

**shape(shape)**

parameter`shape` string

* Only supports receiving one parameter, specifying the shape drawn by the geometric image object. The following table lists the shapes supported by the different layer geometry objects.

| layer type | shape type                                                                             | Remark |
| ---------- | -------------------------------------------------------------------------------------- | ------ |
| point      | 2d:point,circle, square, triangle,hexagon,image,text 3d:circle,triangle,hexagon,square |        |
| line       | line,arc, arc3d, greatcircle                                                           |        |
| polygon    | fill,line, extrude                                                                     |        |

**shape(field, shapes)**

* shape specifies the row shape based on the field, such as specifying the icon type of PointLayer/imageLayer based on the field.

```javascript
scene.addImage(
  '00',
  'https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg',
);
scene.addImage(
  '01',
  'https://gw.alipayobjects.com/zos/basement_prod/30580bc9-506f-4438-8c1a-744e082054ec.svg',
);
scene.addImage(
  '02',
  'https://gw.alipayobjects.com/zos/basement_prod/7aa1f460-9f9f-499f-afdf-13424aa26bbf.svg',
);
const imageLayer = new PointLayer()
  .source(data, {
    parser: {
      type: 'json',
      x: 'longitude',
      y: 'latitude',
    },
  })
  .shape('name', ['00', '01', '02'])
  .size(20);
scene.addLayer(imageLayer);
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*oVyHT5S3sv0AAAAAAAAAAABkARQnAQ'>

[Online case](/examples/point/image#image)

**shape(field, callback)**

* Shape also supports writing callback functions

```javascript
.shape('key', value => {
  if(value > 10) {
    return 'circle';
  } else {
    return 'triangle';
  }
}
```
### texture

目前只在线图层上支持了纹理方法

- texture 方法支持传入由 scene.addImage 方法添加的全局 icon 贴图资源

```javascript
// 首先在全局加载图片资源
scene.addImage(
  'plane',
  'https://gw.alipayobjects.com/zos/bmw-prod/0ca1668e-38c2-4010-8568-b57cb33839b9.svg',
);

const layer = new LineLayer({
  blend: 'normal',
})
  .source(data, {
    parser: {
      type: 'json',
      x: 'lng1',
      y: 'lat1',
      x1: 'lng2',
      y1: 'lat2',
    },
  })
  .size(25)
  .shape('arc')
  .texture('plane') // 为图层绑定纹理
  .color('#8C1EB2')
  .style({
    lineTexture: true, // 开启线的贴图功能
    iconStep: 30, // 设置贴图纹理的间距
    textureBlend: 'replace', // 设置纹理混合方式，默认值为 normal，可选值有 normal/replace 两种
  });
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*KEupSZ_p0pYAAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/line/animate#plane_animate2)## Layer control methods

### show()

Layer display

```javascript
layer.show();
```

### hide()

Layer hidden

```javascript
layer.hide();
```

### isVisible(): boolean

Is the layer visible?

```javascript
layer.isVisible();
```

### setIndex(zIndex: int)

Set layer drawing order

```javascript
layer.setIndex(1);
```

### fitBounds()

Zoom to layer extents

```javascript
layer.fitBounds();
```

### setMinZoom(zoom: number)

Set the minimum zoom level of the layer

```javascript
layer.setMinZoom(zoom);
```

### setMaxZoom(zoom: number)

Set the maximum zoom level of the layer

```javascript
layer.setMinZoom(zoom);
```

Set the maximum zoom level of the layer

parameter

* zoom {number}

```javascript
layer.setMinZoom(zoom);
```
## 图层控制方法

### show()

图层显示

```javascript
layer.show();
```

### hide()

图层隐藏

```javascript
layer.hide();
```

### isVisible(): boolean

图层是否可见

```javascript
layer.isVisible();
```

### setIndex(zIndex: int)

设置图层绘制顺序

```javascript
layer.setIndex(1);
```

### fitBounds()

缩放到图层范围

```javascript
layer.fitBounds();
```

### setMinZoom(zoom: number)

设置图层最小缩放等级

```javascript
layer.setMinZoom(zoom);
```

### setMaxZoom(zoom: number)

设置图层最大缩放等级

```javascript
layer.setMinZoom(zoom);
```

设置图层最大缩放等级

参数

- zoom {number}

```javascript
layer.setMinZoom(zoom);
```<style>
 h3 { color: #873bf4; border-bottom: 1px solid #f0f0f0; margin: 1.2em 0 0.4em; } p { margin: 0.6em 0; } h4 { border-bottom: 1px solid #f0f0f0; }h4::before { content: '> '; opacity: 0.5; } </style>
------

| name       | illustrate                        | type             |
| ---------- | --------------------------------- | ---------------- |
| popperShow | Callback when bubble is displayed | `(this) => void` |
| popperHide | Callback when bubble is hidden    | `(this) => void` |
------

| name         | illustrate                                                                                                  | type                                   |
| ------------ | ----------------------------------------------------------------------------------------------------------- | -------------------------------------- |
| setOptions   | Update configuration, parameters need to refer to the corresponding component[Configuration](Configuration) | `(newOption: Partial<Option>) => void` |
| getOptions   | Get current[Configuration](Configuration)                                                                   | `() => Option`                         |
| show         | display component                                                                                           | `() => void`                           |
| hide         | Hidden component                                                                                            | `() => void`                           |
| getContainer | Get the information corresponding to the current control`DOM`container                                      | `() => HTMLElement`                    |
| 名称         | 说明                                          | 类型                                   |
| ------------ | --------------------------------------------- | -------------------------------------- |
| setOptions   | 更新配置，参数需要参考对应组件的[配置](#配置) | `(newOption: Partial<Option>) => void` |
| getOptions   | 获取当前[配置](#配置)                         | `() => Option`                         |
| show         | 显示组件                                      | `() => void`                           |
| hide         | 隐藏组件                                      | `() => void`                           |
| getContainer | 获取当前控件对应的 `DOM` 容器                 | `() => HTMLElement`                    |
| 名称       | 说明             | 类型             |
| ---------- | ---------------- | ---------------- |
| popperShow | 气泡显示时的回调 | `(this) => void` |
| popperHide | 气泡隐藏时的回调 | `(this) => void` |
------

| name      | illustrate                                                                                                                              | type                  |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |
| position  | The location and arrangement of controls when they are added to the map, see details[control slot](/api/component/control/control#slot) | [Position](#position) |
| className | Custom style name                                                                                                                       | `string`              |
| style     | Custom style                                                                                                                            | `string`              |

### Position

```ts
export type Position =
  | 'topleft' // ↖ upper left corner, vertical arrangement
  | 'lefttop' // ↖ Upper left corner, arranged horizontally
  | 'topright' // ↗ Upper right corner, vertical arrangement
  | 'righttop' // ↗ Upper right corner, arranged horizontally
  | 'bottomleft' // ↙ lower left corner, arranged vertically
  | 'leftbottom' // ↙ lower left corner, arranged horizontally
  | 'bottomright' // ↘ Lower right corner, arranged vertically
  | 'rightbottom' // ↘ Lower right corner, arranged horizontally
  | 'topcenter' // ↑ top center, arranged horizontally
  | 'bottomcenter' // ↓ bottom center, arranged horizontally
  | 'leftcenter' // ← left center, arranged vertically
  | 'rightcenter' // → middle right, arranged vertically
  | Element; // Pass in DOM as the container of the current control
```
| 名称      | 说明                                                                                           | 类型                  |
| --------- | ---------------------------------------------------------------------------------------------- | --------------------- |
| position  | 控件被添加到地图中的位置以及排列方式，详情可见 [控件插槽](/api/component/control/control#插槽) | [Position](#position) |
| className | 自定义样式名                                                                                   | `string`              |
| style     | 自定义样式                                                                                     | `string`              |

### Position

```ts
export type Position =
  | 'topleft'       // ↖ 左上角，纵向排列
  | 'lefttop'       // ↖ 左上角，横向排列
  | 'topright'      // ↗ 右上角，纵向排列
  | 'righttop'      // ↗ 右上角，横向排列
  | 'bottomleft'    // ↙ 左下角，纵向排列
  | 'leftbottom'    // ↙ 左下角，横向排列
  | 'bottomright'   // ↘ 右下角，纵向排列
  | 'rightbottom'   // ↘ 右下角，横向排列
  | 'topcenter'     // ↑ 上方中央，横向排列
  | 'bottomcenter'  // ↓ 下方中间，横向排列
  | 'leftcenter'    // ← 左边中间，纵向排列
  | 'rightcenter'   // → 右边中间，纵向排列
  | Element;        // 传入 DOM 作为当前控件的容器
```
| 名称     | 说明                                                    | 类型                              |
| -------- | ------------------------------------------------------- | --------------------------------- |
| btnIcon  | 按钮图标                                                | `HTMLElement` \| `SVGElement` |
| btnText  | 按钮内容文本                                            | `string`                          |
| title    | 按钮的 `title` 属性                                     | `string`                          |
| vertical | 在 btnIcon 有值的情况下，按钮内的图标和文案是否纵向排列 | `boolean`                         |
------

| name     | illustrate                                                                                 | type                        |
| -------- | ------------------------------------------------------------------------------------------ | --------------------------- |
| btnIcon  | button icon                                                                                | `HTMLElement`\|`SVGElement` |
| btnText  | Button content text                                                                        | `string`                    |
| title    | button`title`Attributes                                                                    | `string`                    |
| vertical | When btnIcon has a value, whether the icons and text in the button are arranged vertically | `boolean`                   |
------

\| Name | Description | Type |
\| | ------------------ | ---------------- |
\| add | Event when component is added |`(this) => void`|
\| remove | Event when component is removed |`(this) => void`|
\| show | Events when the component is displayed |`(this) => void`|
\| hide | Event when component is hidden |`(this) => void`|
| 名称   | 说明               | 类型             |
| ------ | ------------------ | ---------------- |
| add    | 组件被添加时的事件 | `(this) => void` |
| remove | 组件被移除时的事件 | `(this) => void` |
| show   | 组件显示时的事件   | `(this) => void` |
| hide   | 组件隐藏时的事件   | `(this) => void` |
| 名称            | 说明                 | 类型                                |
| --------------- | -------------------- | ----------------------------------- |
| popperPlacement | 气泡相对于按钮的位置 | [PopperPlacement](#PopperPlacement) |
| popperTrigger   | 气泡弹出的触发方式   | `'click'` \| `'hover'`          |
| popperClassName | 气泡容器自定义样式名 | `string`                            |

### PopperPlacement

```ts
export type PopperPlacement =
  | 'top-start'
  | 'top'
  | 'top-end'
  | 'left-start'
  | 'left'
  | 'left-end'
  | 'bottom-start'
  | 'bottom'
  | 'bottom-end'
  | 'right-start'
  | 'right'
  | 'right-end';
```
| 名称         | 说明                   | 类型                          |
| ------------ | ---------------------- | ----------------------------- |
| selectChange | 当所选值发生改变时触发 | `(string | string[]) => void` |
------

| name         | illustrate                            | type      |                      |
| ------------ | ------------------------------------- | --------- | -------------------- |
| selectChange | Fires when the selected value changes | \`(string | string\[]) => void\` |
------

| name            | illustrate                                        | type                                |
| --------------- | ------------------------------------------------- | ----------------------------------- |
| popperPlacement | The position of the bubble relative to the button | [PopperPlacement](#PopperPlacement) |
| popperTrigger   | How to trigger bubble pop-up                      | `'click'`\|`'hover'`                |
| popperClassName | Bubble container custom style name                | `string`                            |

### PopperPlacement

```ts
export type PopperPlacement =
  | 'top-start'
  | 'top'
  | 'top-end'
  | 'left-start'
  | 'left'
  | 'left-end'
  | 'bottom-start'
  | 'bottom'
  | 'bottom-end'
  | 'right-start'
  | 'right'
  | 'right-end';
```
### popup 信息窗口

  - enable 是否开启 `boolean`
  - triggerEvent 触发事件 例如 'mousemove' | 'click';
  - Html popup html字符串，支持回调函数  (properties: any) => string;
## Usage

1. 按图表方式，[在线示例](https://l7plot.antv.antgroup.com/zh/examples/choropleth/administrative#china-map)

```js
import { Choropleth } from '@antv/l7plot';

const choropleth = new Choropleth('container', options);
```

2. 按场景方式，[在线示例](/examples/choropleth/administrative#china-map)

```js
import { Scene, Mapbox } from '@antv/l7';
import { Choropleth } from '@antv/l7plot';

const scene = new Scene({
  id: 'container',
  map: new Mapbox({
    style: 'light',
    center: [102.447303, 37.753574],
    zoom: 5,
  }),
});

const choropleth = new Choropleth(options);

scene.on('loaded', () => {
  choropleth.addToScene(scene);
});
```

## API

Choropleth 具体 API 文档移步 [L7Plot 官网](https://l7plot.antv.antgroup.com/zh/docs/api/plots/choropleth)。
### label 标注配置项
  文本标注配置项，目前只支持常量配置，不支持数据映射
  - enable `boolean` 是否显示标注
      - color
         标注字体颜色 常量
      - field 
        标注字段 常量
      - size 
        标注大小 常量
      - stroke 
        文字描边颜色
      - strokeWidth 
        文字描边宽度
      - textAllowOverlap
         是否允许文字压盖
      - opacity
         标注透明度
      - spacing: 
         `number` 文本间隔
      - strokeOpacity 
      `number` 描边透明度
      - fontWeight 
      `string` 字体粗细
      - fontFamily 
      `string` 字号
      - textOffset 
      `[number, number]` 文本偏移量
### fill  填充图样式
  - color 图层填充颜色，支持常量和数据映射
      常量：统一设置成一样的颜色
      数据映射
      - field 填充映射字段
      - values  映射值，同color方法第二个参数数组，回调函数
  - filter 图层过滤方法，支持常量和数据映射 同layer.filter方法
      数据映射
          - field 填充映射字段
          - values  回调函数 `false` 返回值将会被过滤掉
  - style 同 polygonLayer的style方法
  - activeColor 鼠标滑过高亮颜色,  `string | boolean` 如果设置为 `false`取消高亮
### bubble 气泡配置项
  - enable
   `boolean` 是否显示气泡 `true`
  - shape: 
   AttributeType; 气泡形状支持数据映射
  - size:
    AttributeType; 气泡大小支持数据映射
  - color: 
    AttributeType; 气泡颜色支持数据映射
  - scale: { // 数字度量
    field: string; 度量字段
    type: ScaleTypeName; 度量字段
  };
  - style: {
    opacity: number; 透明度
    stroke: string; 填充色
    strokeWidth: number; 填充宽度
  };
#### layerOption 图片配置

 下钻各个层级的配置项，可以独立配置，每一层级的样式，不设置和上一层就保持一致
  - joinBy: [string, string];
  - label: Partial<ILabelOption>;
  - bubble: Partial<IBubbleOption>;
  - fill: Partial<IFillOptions>;
   ⛔中国地图视角设置，省界，海岸线，宽度通过以下属性
  - chinaNationalStroke 中国国界线颜色 
  - chinaNationalWidth 中国国界线宽度 
  - coastlineStroke 海岸线颜色 
  - coastlineWidth 海岸线宽度 
  - nationalWidth 国界线 
  - nationalStroke 国界线 
  - provinceStroke 省界颜色 
  - provinceStrokeWidth 省界宽度 
### 事件
---
title: Shape
order: 3
---

<embed src="@/docs/common/style.md"></embed>

`shape` 方法用于指定点图层绘制什么样的图形，如绘制三角形或者是正方形，还是文字、图标之类的。

### shape(fillShape: IFillShape)

点图层的贴地的几何图形，如圆形、正方形、三角形等。

🌟 若是使用简单的圆点图层，建议使用 `simple` 代替 `circle` 以获得更好的性能。

<div>
  <div style="width:40%;float:right; margin-left: 16px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*iN0nTYRDd3AAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

```js
// shape 支持的各种形状
type IFillShape =
  | 'circle'
  | 'square'
  | 'hexagon'
  | 'triangle'
  | 'pentagon'
  | 'octogon'
  | 'hexagram'
  | 'rhombus'
  | 'vesica';

layer.shape('circle');
```

### shape(column: IColumn)

点的类型为垂直地图的柱子。

<div>
  <div style="width:40%;float:right; margin-left: 16px;">
    <img width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*tvpvQZLv_xYAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

```js
type IColumn = 'cylinder' | 'triangleColumn' | 'hexagonColumn' | 'squareColumn';

layer.shape('cylinder');

layer.shape('triangleColumn');

layer.shape('hexagonColumn');

layer.shape('squareColumn');
```

### shape('simple')

`simple` 点精灵是特殊的点图层，始终面向相机，且大小受到设备的限制。

```js
layer.shape('simple');
```

### shape('dot')

`dot` 点精灵是特殊的点图层，始终面向相机，且大小受到设备的限制。

```js
layer.shape('dot');
```

### shape(field: string, 'text')

绘制文字，第一个参数为数值中的字段，第二个参数固定为 `text`。

```js
const point = new PointLayer()
  .source([{ lng: 120, lat: 30, name: 'test' }], {
    parser: 'json',
    x: 'lng',
    y: 'lat',
  })
  .shape('test', 'text');
```

### shape(iconName: string)

`shape` 的值为 `scene.addImage` 全局添加的图片资源的名称。

```js
scene.addImage(
  '00',
  'https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg',
);
scene.addImage(
  '01',
  'https://gw.alipayobjects.com/zos/basement_prod/30580bc9-506f-4438-8c1a-744e082054ec.svg',
);
scene.addImage(
  '02',
  'https://gw.alipayobjects.com/zos/basement_prod/7aa1f460-9f9f-499f-afdf-13424aa26bbf.svg',
);
const imageLayer = new PointLayer()
  .source(
    [
      {
        longitude: 120,
        latitude: 30,
        name: 'name',
      },
    ],
    {
      parser: {
        type: 'json',
        x: 'longitude',
        y: 'latitude',
      },
    },
  )
  .shape('name', ['00', '01', '02']) // shape 支持映射写法
  .size(25);
scene.addLayer(imageLayer);

const imageLayer2 = new PointLayer()
  .source(
    [
      {
        longitude: 122,
        latitude: 30,
        name: 'name',
      },
    ],
    {
      parser: {
        type: 'json',
        x: 'longitude',
        y: 'latitude',
      },
    },
  )
  .shape('00') // shape 直接传值
  .size(25);
scene.addLayer(imageLayer2);
```

### shape('radar')

```js
const layer = new PointLayer()
  .source(
    [
      {
        lng: 120,
        lat: 30,
      },
    ],
    {
      parser: {
        type: 'json',
        x: 'lng',
        y: 'lat',
      },
    },
  )
  .size(25)
  .color('#f00')
  .shape('radar')
  .animate(true);
```

🌟 雷达图需要设置 `animate` 为 `true`
---
title: Size
order: 5
---

<embed src="@/docs/common/style.md"></embed>

`size`Method used to set the size of point layer graphics.

### IPointSize: number ｜\[number, number] | \[number, number, number]

* If the size type is number, it represents the radius of point
* The size type can be \[number, number]|\[number, number, number] indicating the radius and height of the column

```javascript
pointLayer.size(1);
pointLayer.size([2, 10]); // The radius of the pillar is 2x2. The height is 10
pointLayer.size([2, 4, 10]); // The column radius is 2x4 and the height is 10
```

### size(width: IPointSize)

Point layers can set the radius directly. All points in the layer use one width.

```js
layer.size(2);
```

### size(field: string)

The width of a point layer can be mapped based on the data values ​​accepted by the layer, accepting fields of incoming data as arguments.

```js
layer.source([
  {
    lng: 120,
    lat: 30,
    r: 2,
  },
]);
layer.size('r');
```

### size(field: string, domain: IPointSize\[])

`size`Method supports simple value mapping and will be based on`field`The values ​​extracted from the data passed into the layer are mapped to`domain`in the value range.

```js
layer.size('type', [1, 2, 3]);
```

### size(field: string, callback: () => IPointSize )

`size`The method supports the writing method of callback function, which will be based on`field`as`callback`method parameters,`callback`The return value of the method is the actual radius of the point layer.

```js
layer.size('type', (value) => {
  switch (value) {
    case 'path':
      return 1;
    case 'road':
      return 2;
  }
});
```
---
title: Shape
order: 3
---

<embed src="@/docs/common/style.md"></embed>

`shape`The method is used to specify what kind of graphics the point layer draws, such as drawing triangles or squares, text, icons, etc.

### shape(fillShape: IFillShape)

Point layer's ground-mounted geometric shapes, such as circles, squares, triangles, etc.

🌟 If you are using a simple dot layer, it is recommended to use`simple`replace`circle`for better performance.

<div>
  <div style="width:40%;float:right; margin-left: 16px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*iN0nTYRDd3AAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

```js
// Various shapes supported by shape
type IFillShape =
  | 'circle'
  | 'square'
  | 'hexagon'
  | 'triangle'
  | 'pentagon'
  | 'octogon'
  | 'hexagram'
  | 'rhombus'
  | 'vesica';

layer.shape('circle');
```

### shape(column: IColumn)

The point type is a vertical map pillar.

<div>
  <div style="width:40%;float:right; margin-left: 16px;">
    <img width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*tvpvQZLv_xYAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

```js
type IColumn = 'cylinder' | 'triangleColumn' | 'hexagonColumn' | 'squareColumn';

layer.shape('cylinder');

layer.shape('triangleColumn');

layer.shape('hexagonColumn');

layer.shape('squareColumn');
```

### shape('simple')

`simple`Point sprites are special point layers that always face the camera and are limited in size by the device.

```js
layer.shape('simple');
```

### shape('dot')

`dot`Point sprites are special point layers that always face the camera and are limited in size by the device.

```js
layer.shape('dot');
```

### shape(field: string, 'text')

To draw text, the first parameter is the field in the value, and the second parameter is fixed to`text`。

```js
const point = new PointLayer()
  .source([{ lng: 120, lat: 30, name: 'test' }], {
    parser: 'json',
    x: 'lng',
    y: 'lat',
  })
  .shape('test', 'text');
```

### shape(iconName: string)

`shape`The value is`scene.addImage`The name of the globally added image resource.

```js
scene.addImage(
  '00',
  'https://gw.alipayobjects.com/zos/basement_prod/604b5e7f-309e-40db-b95b-4fac746c5153.svg',
);
scene.addImage(
  '01',
  'https://gw.alipayobjects.com/zos/basement_prod/30580bc9-506f-4438-8c1a-744e082054ec.svg',
);
scene.addImage(
  '02',
  'https://gw.alipayobjects.com/zos/basement_prod/7aa1f460-9f9f-499f-afdf-13424aa26bbf.svg',
);
const imageLayer = new PointLayer()
  .source(
    [
      {
        longitude: 120,
        latitude: 30,
        name: 'name',
      },
    ],
    {
      parser: {
        type: 'json',
        x: 'longitude',
        y: 'latitude',
      },
    },
  )
  .shape('name', ['00', '01', '02']) // shape 支持映射写法
  .size(25);
scene.addLayer(imageLayer);

const imageLayer2 = new PointLayer()
  .source(
    [
      {
        longitude: 122,
        latitude: 30,
        name: 'name',
      },
    ],
    {
      parser: {
        type: 'json',
        x: 'longitude',
        y: 'latitude',
      },
    },
  )
  .shape('00') // shape 直接传值
  .size(25);
scene.addLayer(imageLayer2);
```

### shape('radar')

```js
const layer = new PointLayer()
  .source(
    [
      {
        lng: 120,
        lat: 30,
      },
    ],
    {
      parser: {
        type: 'json',
        x: 'lng',
        y: 'lat',
      },
    },
  )
  .size(25)
  .color('#f00')
  .shape('radar')
  .animate(true);
```

🌟 Radar chart needs to be set up`animate`for`true`
---
title: Size
order: 5
---

<embed src="@/docs/common/style.md"></embed>

`size` 方法用于设置点图层图形的大小。

### IPointSize: number ｜[number, number] | [number, number, number]

- size 类型为 number 则表示 point 的半径
- size 类型可以为 [number, number]｜[number, number, number] 表示柱子的半径和高度

```javascript
pointLayer.size(1);
pointLayer.size([2, 10]); // 柱子半径为 2x2.高为 10
pointLayer.size([2, 4, 10]); // 柱子半径为 2x4，高为 10
```

### size(width: IPointSize)

点图层可以直接设置半径。图层中所有的点使用一个宽度。

```js
layer.size(2);
```

### size(field: string)

点图层的宽度可以根据图层接受的数据值进行映射，接受传入数据的字段作为参数。

```js
layer.source([
  {
    lng: 120,
    lat: 30,
    r: 2,
  },
]);
layer.size('r');
```

### size(field: string, domain: IPointSize[])

`size` 方法支持简单的值映射，将根据 `field` 从传入图层的数据中提取的值映射到 `domain` 值域中。

```js
layer.size('type', [1, 2, 3]);
```

### size(field: string, callback: () => IPointSize )

`size` 方法支持回调函数的写法，将根据 `field` 作为 `callback` 方法的参数，`callback` 方法的返回值作为点图层实际的半径。

```js
layer.size('type', (value) => {
  switch (value) {
    case 'path':
      return 1;
    case 'road':
      return 2;
  }
});
```
---
title: Style
order: 4
---

<embed src="@/docs/common/style.md"></embed>

`style` 方法用于配制图层的样式，相同图层拥有不同的 `shape` 图形，不同 `shape` 的图层 `style` 方法接受不同的参数。

```js
layer.style({
  opacity: 0.5,
});
```

### common

通用 `style` 参数，所有图形都支持的参数。

| style   | 类型     | 描述         | 默认值 |
| ------- | -------- | ------------ | ------ |
| opacity | `number` | 图形的透明度 | `1`    |

<embed src="@/docs/common/layer/style_encode.zh.md"></embed>


### 2D shape

`shape` 为平面图形、如三角形、正方等。

- [IFillShape](/api/point_layer/shape#shapefillshape-ifillshape)

| style         | 类型              |是否支持数据映射 | 描述                       | 默认值   |
| ------------- | ------------------|--------------- | -------------------------- | -------- |
| stroke        | `string`           |是 | 图形边框颜色               | `#fff`   |
| strokeWidth   | `number`           |否 | 图形边框宽度               | `0`      |
| strokeOpacity | `number`           |否 | 图形边框透明度             | `1`      |
| blur          | `number`           |否 | 图形模糊半径               | `0`      |
| offsets       | `[number, number]` |是 | 点偏移                     | `[0, 0]` |
|rotation|`number`   | 旋转角度 | 是| `0` |
| raisingHeight | `number`           |否 | 抬升高度                   | `0`      |
| heightfixed   | `boolean`          |否 | 点大小单位                 | `pixel`  |


#### unit

- pixel 默认值
- meter 单位为米

```js
type IUnit = 'pixel' | 'meter';
```

点图层支持等面积点，点大小的单位是米，同样通过 size 方法设置大小

```javascript
import { PointLayer } from '@antv/l7';

const layer = PointLayer()
  .source(data)
  .shape('circle')
  .size(100)
  .color('#f00')
  .style({
    unit: 'meter',
  });
```

🌟 从 v2.7.9 版本开始支持高德地图、高德地图 2.0、Mapbox 地图

### 3D column

`shape` 为 3D 柱图。

- [IColumn](/api/point_layer/shape#shapecolumn-icolumn)

| style       | 类型      | 描述                 | 默认值  |
| ----------- | --------- | -------------------- | ------- |
| depth       | `boolean` | 图形是否开启深度检测 | `true`  |
| pickLight   | `boolean` | 拾取高亮是否计算光照 | `false` |
| lightEnable | `boolean` | 颜色是否参与光照计算 | `true`  |
| heightfixed | `boolean` | 是否是固定高度       | `false` |

### 3D column linear

柱图支持配置渐变色，在配置渐变效果后会覆盖 `layer.color` 方法设置的颜色。

| style         | 类型            | 描述             | 默认值 |
| ------------- | --------------- | ---------------- | ------ |
| sourceColor   | `color`         | 柱子底部颜色     | `/`    |
| targetColor   | `color`         | 柱子顶部颜色     | `/`    |
| opacityLinear | `IOpcityLinear` | 柱子的透明度渐变 | `/`    |

#### color

```js
const color = `rgb(200, 100, 50)`;
const color2 = '#ff0';
```

#### opacityLinear

```js
type IDir = 'up' | 'down';
interface IOpcityLinear = {
  enable: boolean;
  dir: IDir;
}
```

### text

`shape` 为文字。

- [text](/api/point_layer/shape#shapefield-string-text)

| style            | 类型                                            | 描述                       |  是否支持数据映射     | 默认值       |
| ---------------- | ----------------------------------------------- | --------------------------| --------- | ------------ |
| opacity           | `number`                                        | 透明度               | 是 |`#fff`       |
| stroke           | `string`                                        | 图形边框颜色               | 是 |`#fff`       |
| strokeWidth      | `number`                                        | 图形边框颜色               | 否  |`0`          |
| textOffset       | `[number, number]`                              | 文字的偏移                 | 是 |`[0, 0]`     |
| textAnchor       | [anchorType](/api/point_layer/style#anchortype) | 文字对齐锚点 `text`        | 是 |`center`     |
| spacing          | `number`                                        | 文字间隔                   | 否|`2`          |
|rotation|`number`   | 旋转角度 | 是| `0`|
| padding          | `number`                                        | 文字内边框宽度             | 否|`2`          |
| halo             | `number`                                        | 文字边缘光晕宽度           | 否|`0.5`        |
| gamma            | `number`                                        | 文字的颜色参数             | 否|`2`          |
| fontWeight       | `string`                                        | 文字的大小                 | 否|`400`        |
| fontFamily       | [font](/api/point_layer/style#font)             | 字体                       |否 |`sans-serif` |
| textAllowOverlap | `boolean`                                       | 文字是否允许覆盖           |否 |`false`      |
| raisingHeight    | `number`                                        | 抬升高度                   | 否|`0`          |
| heightfixed      | `boolean`                                       | 抬升高度是否随 `zoom` 变化 |否 |`false`      |



#### anchorType

文字对齐锚点

```javascript
export enum anchorType {
  'CENTER' = 'center',
  'TOP' = 'top',
  'TOP-LEFT' = 'top-left',
  'TOP-RIGHT' = 'top-right',
  'BOTTOM' = 'bottom',
  'BOTTOM-LEFT' = 'bottom-left',
  'LEFT' = 'left',
  'RIGHT' = 'right',
}
```

#### font

css fontFamily。

```js
const font = 'sans-serif';
const font2 = 'Times New Roman';
```

### simple

`shape` 为简单点图形（精灵)。

- [simple](/api/point_layer/shape#shapesimple)

| style         | 类型               | 描述         | 默认值   |
| ------------- | ------------------ | ------------ | -------- |
| stroke        | `string`           | 图形边框颜色 | `#fff`   |
| strokeWidth   | `number`           | 图形边框颜色 | `0`      |
| strokeOpacity | `number`           | 图形边框宽度 | `1`      |
| offsets       | `[number, number]` | 点偏移       | `[0, 0]` |

### icon

`shape` 为图标类型。

- [icon](/api/point_layer/shape#shapeiconname-string)

| style         | 类型               | 描述                       |数据映射| 默认值   |
| ------------- | ------------------ | -------------------------- |---- | -------- |
| offsets       | `[number, number]` | 点偏移                     |否| `[0, 0]` |
| raisingHeight | `number`           | 抬升高度                   | 否|`0`      |
| heightfixed   | `boolean`          | 抬升高度是否随 `zoom` 变化 | 否|`false`  |
|rotation|`number`   | 旋转角度 | 是| `0`|

#### rotation

图标的旋转角度。

```js
const imageLayer = new PointLayer({ layerType: 'fillImage' })
  .source(data)
  .shape('wind', (wind) => {
    if (wind === 'up') {
      return 'arrBlue';
    }
    return 'arrRed';
  })
  .size(15)
  .style({
    rotation: 0,
  });
```

### radar

`shape` 为雷达图。

- [radar](/api/point_layer/shape#shaperadar)

| style | 类型     | 描述             | 默认值 |
| ----- | -------- | ---------------- | ------ |
| speed | `number` | 雷达图旋转的速度 | `1`    |
---
title: Style
order: 4
---

<embed src="@/docs/common/style.md"></embed>

`style`The method is used to configure the style of the layer. The same layer has different`shape`graphics, different`shape`layer`style`Methods accept different parameters.

```js
layer.style({
  opacity: 0.5,
});
```

### common

Universal`style`Parameters, parameters supported by all graphics.

| style   | type     | describe             | default value |
| ------- | -------- | -------------------- | ------------- |
| opacity | `number` | Graphic transparency | `1`           |

<embed src="@/docs/common/layer/style_encode.en.md"></embed>

### 2D shape

`shape`For plane figures, such as triangles, squares, etc.

* [IFillShape](/api/point_layer/shape#shapefillshape-ifillshape)

| style         | type               | Whether to support data mapping | describe                    | default value |
| ------------- | ------------------ | ------------------------------- | --------------------------- | ------------- |
| stroke        | `string`           | yes                             | Graphic border color        | `#fff`        |
| strokeWidth   | `number`           | no                              | Graphic border width        | `0`           |
| strokeOpacity | `number`           | no                              | Graphic border transparency | `1`           |
| blur          | `number`           | no                              | Graphic blur radius         | `0`           |
| offsets       | `[number, number]` | yes                             | point offset                | `[0, 0]`      |
| rotation      | `number`           | Rotation angle                  | yes                         | `0`           |
| raisingHeight | `number`           | no                              | Lifting height              | `0`           |
| heightfixed   | `boolean`          | no                              | Point size unit             | `pixel`       |

#### unit

* pixel default value
* meter unit is meter

```js
type IUnit = 'pixel' | 'meter';
```

The point layer supports equal-area points. The unit of point size is meters. The size is also set through the size method.

```javascript
import { PointLayer } from '@antv/l7';

const layer = PointLayer()
  .source(data)
  .shape('circle')
  .size(100)
  .color('#f00')
  .style({
    unit: 'meter',
  });
```

🌟 Starting from version v2.7.9, Amap, Amap 2.0, and Mapbox maps are supported

### 3D column

`shape`is a 3D column chart.

* [IColumn](/api/point_layer/shape#shapecolumn-icolumn)

| style       | type      | describe                                              | default value |
| ----------- | --------- | ----------------------------------------------------- | ------------- |
| depth       | `boolean` | Whether depth detection is enabled for graphics       | `true`        |
| pickLight   | `boolean` | Whether to calculate lighting when picking highlights | `false`       |
| lightEnable | `boolean` | Whether color participates in lighting calculations   | `true`        |
| heightfixed | `boolean` | Is it a fixed height?                                 | `false`       |

### 3D column linear

The column chart supports configuring gradient colors, which will be overwritten after configuring the gradient effect.`layer.color`Method to set the color.

| style         | type            | describe                         | default value |
| ------------- | --------------- | -------------------------------- | ------------- |
| sourceColor   | `color`         | Column bottom color              | `/`           |
| targetColor   | `color`         | Column top color                 | `/`           |
| opacityLinear | `IOpcityLinear` | Transparency gradient of pillars | `/`           |

#### color

```js
const color = `rgb(200, 100, 50)`;
const color2 = '#ff0';
```

#### opacityLinear

```js
type IDir = 'up' | 'down';
interface IOpcityLinear = {
  enable: boolean;
  dir: IDir;
}
```

### text

`shape`for text.

* [text](/api/point_layer/shape#shapefield-string-text)

| style            | type                                            | describe                                   | Whether to support data mapping | default value |
| ---------------- | ----------------------------------------------- | ------------------------------------------ | ------------------------------- | ------------- |
| opacity          | `number`                                        | transparency                               | yes                             | `#fff`        |
| stroke           | `string`                                        | Graphic border color                       | yes                             | `#fff`        |
| strokeWidth      | `number`                                        | Graphic border color                       | no                              | `0`           |
| textOffset       | `[number, number]`                              | text offset                                | yes                             | `[0, 0]`      |
| textAnchor       | [anchorType](/api/point_layer/style#anchortype) | text alignment anchor`text`                | yes                             | `center`      |
| spacing          | `number`                                        | text spacing                               | no                              | `2`           |
| rotation         | `number`                                        | Rotation angle                             | yes                             | `0`           |
| padding          | `number`                                        | Text inner border width                    | no                              | `2`           |
| halo             | `number`                                        | Text edge glow width                       | no                              | `0.5`         |
| gamma            | `number`                                        | Text color parameters                      | no                              | `2`           |
| fontWeight       | `string`                                        | text size                                  | no                              | `400`         |
| fontFamily       | [font](/api/point_layer/style#font)             | font                                       | no                              | `sans-serif`  |
| textAllowOverlap | `boolean`                                       | Whether text is allowed to be overwritten  | no                              | `false`       |
| raisingHeight    | `number`                                        | Lifting height                             | no                              | `0`           |
| heightfixed      | `boolean`                                       | Does the lifting height vary?`zoom`Variety | no                              | `false`       |

#### anchorType

text alignment anchor

```javascript
export enum anchorType {
  'CENTER' = 'center',
  'TOP' = 'top',
  'TOP-LEFT' = 'top-left',
  'TOP-RIGHT' = 'top-right',
  'BOTTOM' = 'bottom',
  'BOTTOM-LEFT' = 'bottom-left',
  'LEFT' = 'left',
  'RIGHT' = 'right',
}
```

#### font

css font Family。

```js
const font = 'sans-serif';
const font2 = 'Times New Roman';
```

### simple

`shape`For simple point graphics (elves).

* [simple](/api/point_layer/shape#shapesimple)

| style         | type               | describe             | default value |
| ------------- | ------------------ | -------------------- | ------------- |
| stroke        | `string`           | Graphic border color | `#fff`        |
| strokeWidth   | `number`           | Graphic border color | `0`           |
| strokeOpacity | `number`           | Graphic border width | `1`           |
| offsets       | `[number, number]` | point offset         | `[0, 0]`      |

### icon

`shape`is the icon type.

* [icon](/api/point_layer/shape#shapeiconname-string)

| style         | type               | describe                                   | data mapping | default value |
| ------------- | ------------------ | ------------------------------------------ | ------------ | ------------- |
| offsets       | `[number, number]` | point offset                               | no           | `[0, 0]`      |
| raisingHeight | `number`           | Lifting height                             | no           | `0`           |
| heightfixed   | `boolean`          | Does the lifting height vary?`zoom`Variety | no           | `false`       |
| rotation      | `number`           | Rotation angle                             | yes          | `0`           |

#### rotation

The rotation angle of the icon.

```js
const imageLayer = new PointLayer({ layerType: 'fillImage' })
  .source(data)
  .shape('wind', (wind) => {
    if (wind === 'up') {
      return 'arrBlue';
    }
    return 'arrRed';
  })
  .size(15)
  .style({
    rotation: 0,
  });
```

### radar

`shape`is a radar chart.

* [radar](/api/point_layer/shape#shaperadar)

| style | type     | describe                                   | default value |
| ----- | -------- | ------------------------------------------ | ------------- |
| speed | `number` | The speed at which the radar chart rotates | `1`           |
---
title: PointLayer
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## 简介

点图层一组经纬度数据来描述一系列点在地图上的位置，这些点可以是普通的圆点，也可以是文字、图标、柱子等。  
用户可以通过配置 `shape` 参数来选择点的类型，同时通过 `style`、`size`、`color` 方法调整点的样式。

```javascript
import { PointLayer } from '@antv/l7';

const layer = PointLayer({
  zIndex: 2,
})
  .source(data.list, {
    type: 'array',
    x: 'j',
    y: 'w',
  })
  .shape('cylinder')
  .size('t', (level) => {
    return [4, 4, level + 40];
  })
  .color('t', [
    '#002466',
    '#105CB3',
    '#2894E0',
    '#CFF6FF',
    '#FFF5B8',
    '#FFAB5C',
    '#F27049',
    '#730D1C',
  ]);
```
---
title: Animate
order: 7
---

<embed src="@/docs/common/style.md"></embed>

Click on the layer to turn it on`animate`The basis points after the method are`2D`Point is still`3D`Points support two different animations: water wave points and growth animation.
Click on the layer to turn it on`animate`After the method, a special water wave pattern will be obtained. The layer is made up of rings that spread outward.

<div>
  <div style="width:80%;float:left; margin: 16px;">
    <img style="float:left;" width="50%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*pcp3RKnNK1oAAAAAAAAAAAAAARQnAQ'>
    <img style="float:left;" width="50%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*l-SUQ5nU6n8AAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### water wave point

#### animate(boolean | IAnimateOption)

`animate`The method supports Boolean and object passing values.

```javascript
layer.animate(true);

layer.animate({
  enable: true,
});
```

#### IAnimateOption

```javascript
interface IAnimateOption {
  enable: boolean;
  speed: number;
  rings: number;
}
```

### growth animation

#### animate(boolean | IAnimateOption)

`animate`The method supports Boolean and object passing values.

```javascript
animate(true)
animate(false)

animate(animateOptions)

interface IAnimateOptions: {
  enable: boolean;
  speed?: number = 0.01;
  repeat?: number = 1;
}
```

```
#### IAnimateOptions



Parameters of `animate` method:

- `enable` Whether to enable animation, Boolean value, default is `false`.
- `speed` Growth speed, numerical value, default is `0.01`.
- `repeat` The number of times to play the growth animation, numerical value, the default is `1`.
```
---
title: Animate
order: 7
---

<embed src="@/docs/common/style.md"></embed>

点图层在开启 `animate` 方法后根据点是 `2D` 点还是 `3D` 点支持两种不同的动画：水波点和生长动画。
点图层在开启 `animate` 方法后会得到特殊的水波图形。图层由一圈圈向外扩散的圆环构成。

<div>
  <div style="width:80%;float:left; margin: 16px;">
    <img style="float:left;" width="50%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*pcp3RKnNK1oAAAAAAAAAAAAAARQnAQ'>
    <img style="float:left;" width="50%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*l-SUQ5nU6n8AAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### 水波点

#### animate(boolean | IAnimateOption)

`animate` 方法支持布尔值和对象传值。

```javascript
layer.animate(true);

layer.animate({
  enable: true,
});
```

#### IAnimateOption

```javascript
interface IAnimateOption {
  enable: boolean;
  speed: number;
  rings: number;
}
```

### 生长动画

#### animate(boolean | IAnimateOption)

`animate` 方法支持布尔值和对象传值。

```javascript
animate(true)
animate(false)

animate(animateOptions)

interface IAnimateOptions: {
  enable: boolean;
  speed?: number = 0.01;
  repeat?: number = 1;
}
```

```
#### IAnimateOptions



`animate` 方法的参数：

- `enable` 是否开启动画，布尔值，默认为 `false`。
- `speed` 生长速度，数值，默认为 `0.01`。
- `repeat` 生长动画的播放次数，数值，默认为 `1`。
```
---
title: PointLayer
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

The point layer is a set of longitude and latitude data to describe the location of a series of points on the map. These points can be ordinary dots, or text, icons, pillars, etc.\
Users can configure`shape`parameters to select the type of point, and pass`style`、`size`、`color`Method to adjust the point style.

```javascript
import { PointLayer } from '@antv/l7';

const layer = PointLayer({
  zIndex: 2,
})
  .source(data.list, {
    type: 'array',
    x: 'j',
    y: 'w',
  })
  .shape('cylinder')
  .size('t', (level) => {
    return [4, 4, level + 40];
  })
  .color('t', [
    '#002466',
    '#105CB3',
    '#2894E0',
    '#CFF6FF',
    '#FFF5B8',
    '#FFAB5C',
    '#F27049',
    '#730D1C',
  ]);
```
---
title: Scale
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/scale.zh.md"></embed>
---
title: Scale
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/scale.en.md"></embed>
---
title: Color
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/color.zh.md"></embed>
---
title: Color
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/color.en.md"></embed>
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/options.zh.md"></embed>
---
title: Source
order: 2
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/source.zh.md"></embed>

### GeoJSON

```js
// 传入 GeoJSON 类型数据 *** L7 默认支持，不需要 parser 解析
var data = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'Polygon',
            coordinates: [
              [120, 30],
              ...
            ]
          },
        },
      ],
    };

var layer = new PointLayer()
.source(data)
```

### CSV

```js
// 传入 txt 类型数据
var data = `from,to,value,type,lng1,lat1,lng2,lat2
鎷夎惃,娴疯タ,6.91,move_out,91.111891,29.662557,97.342625,37.373799
鎷夎惃,鎴愰兘,4.79,move_out,91.111891,29.662557,104.067923,30.679943
鎷夎惃,閲嶅簡,2.41,move_out,91.111891,29.662557,106.530635,29.544606
鎷夎惃,鍖椾含,2.05,move_out,91.111891,29.662557,116.395645,39.929986
...`;

var layer = new PointLayer().source(data, {
  parser: {
    type: 'csv',
    x: 'lng1',
    y: 'lat1',
  },
});
```

### JSON

```js
// 传入 JSON 类型的数据
var data = [
  {
    lng: 120,
    lat: 30
  },
  ...
]

var layer = new PointLayer()
.source(data, {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat',
  }
})
```
---
title: Source
order: 2
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/source.en.md"></embed>

### GeoJSON

```js
// Pass in GeoJSON type data *** L7 supports it by default and does not require parser analysis
var data = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'Polygon',
            coordinates: [
              [120, 30],
              ...
            ]
          },
        },
      ],
    };

var layer = new PointLayer()
.source(data)
```

### CSV

```js
// Pass in txt type data
var data = `from,to,value,type,lng1,lat1,lng2,lat2
鎷夎惃,仙魔タ,6.91,move_out,91.111891,29.662557,97.342625,37.373799
鎷厎惃,鎴愰嘘,4.79,move_out,91.111891,29.662557,104.067923,30.679943
鎷厎惃,玷夎惃,月充经,2.41,move_out,91.111891,29.662557,106.530635,29.544606
鎷厎惃,鍖椾han,2.05,move_out,91.111891,29.662557,116.395645,39.929986
...`;

var layer = new PointLayer().source(data, {
  parser: {
    type: 'csv',
    x: 'lng1',
    y: 'lat1',
  },
});
```

### JSON

```js
// Pass in JSON type data
var data = [
  {
    lng: 120,
    lat: 30
  },
  ...
]

var layer = new PointLayer()
.source(data, {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat',
  }
})
```
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/options.en.md"></embed>
---
title: Shape
order: 3
---

<embed src="@/docs/common/style.md"></embed>

`shape` 方法用于指定线图层绘制什么样的线。

### shape('line')

绘制路径图。

`line` 路径是最普通的线图层，支持配置宽度和高度，支持配置纹理和动画。

```js
layer.shape('line');
```

### shape('arc')

`arc` 弧线通过贝塞尔曲线算法计算出弧线的的路径，支持配置纹理和动画。

```js
layer.shape('arc');
```

### shape('arc3d')

`arc3d` 3d 弧线是在垂直地图两点之间的弧线，具有高度，支持配置纹理和动画。

```js
layer.shape('arc3d');
```

### shape('greatcircle')

`greatcircle` 大圆航线是地图两个点最近距离的连线，支持配置纹理和动画。

```js
layer.shape('greatcircle');
```

### shape('wall')

`wall` 是垂直地图的围墙，支持配置高度，纹理和动画。

```js
layer.shape('wall');
```

### shape('simple')

`simple` 线图层，宽度始终为 `1px`。

```js
layer.shape('simple');
```

### shape('flowline')

`flowline` 流向图, 2.17 版本新增---
title: Size
order: 5
---

<embed src="@/docs/common/style.md"></embed>

line layer`size`Method can set the width and height of the line.

### ILineSize: number | \[number, number]

* If the size type is number, it represents the width of the line
* The size type is \[number, number] representing width and height respectively.

```javascript
lineLayer.size(1); // The width of the line is 1
lineLayer.size([1, 2]); // Width is 1, height is 2
```

### size(width: ILineSize)

The width value of the line layer can be set directly. All lines in the layer use one width.

```js
layer.size(2);
```

### size(field: string)

The width of the line layer can be mapped based on the data values ​​accepted by the layer, accepting fields of incoming data as arguments.

```js
layer.source({
  type: 'Feature',
  properties: {
    lineSize: 2,
  },
  geometry: {
    type: 'LineString',
    coordinates: [
      [119.988511, 30.269614],
      [119.9851, 30.269323],
      [119.99271, 30.22088],
    ],
  },
});
layer.size('lineSize');
```

### size(field: string, domain: ILineSize\[])

`size`Method supports simple value mapping and will be based on`field`The values ​​extracted from the data passed into the layer are mapped to`domain`in the value range.

```js
layer.size('type', [1, 2, 3]);
```

### size(field: string, callback: () => ILineSize )

`size`The method supports the writing method of callback function, which will be based on`field`as`callback`method parameters,`callback`The return value of the method is the actual width and height of the line layer.

```js
layer.size('type', (value) => {
  switch (value) {
    case 'path':
      return 1;
    case 'road':
      return 2;
  }
});
```
---
title: Shape
order: 3
---

<embed src="@/docs/common/style.md"></embed>

`shape`Method used to specify what kind of lines the line layer draws.

### shape('line')

Draw a path map.

`line`Path is the most common line layer, supporting configuration of width and height, texture and animation.

```js
layer.shape('line');
```

### shape('arc')

`arc`The arc calculates the path of the arc through the Bezier curve algorithm and supports configuring textures and animations.

```js
layer.shape('arc');
```

### shape('arc3d')

`arc3d`A 3d arc is an arc between two vertical map points, has a height, and supports configurable textures and animations.

```js
layer.shape('arc3d');
```

### shape('greatcircle')

`greatcircle`The great circle route is the closest connection between two points on the map, and supports the configuration of textures and animations.

```js
layer.shape('greatcircle');
```

### shape('wall')

`wall`It is a vertical map wall that supports configuration of height, texture and animation.

```js
layer.shape('wall');
```

### shape('simple')

`simple`Line layer, width is always`1px`。

```js
layer.shape('simple');
```

### shape('flowline')

`flowline`Flow diagram, new in version 2.17
---
title: Size
order: 5
---

<embed src="@/docs/common/style.md"></embed>

线图层的 `size` 方法可以设置线的宽度和高度。

### ILineSize: number | [number, number]

- size 类型为 number 则表示 line 的宽度
- size 类型为 [number , number] 分别表示宽度和高度

```javascript
lineLayer.size(1); // 线的宽度为 1
lineLayer.size([1, 2]); // 宽度为1，高度2
```

### size(width: ILineSize)

线图层可以直接设置宽度值。图层中所有的线使用一个宽度。

```js
layer.size(2);
```

### size(field: string)

线图层的宽度可以根据图层接受的数据值进行映射，接受传入数据的字段作为参数。

```js
layer.source({
  type: 'Feature',
  properties: {
    lineSize: 2,
  },
  geometry: {
    type: 'LineString',
    coordinates: [
      [119.988511, 30.269614],
      [119.9851, 30.269323],
      [119.99271, 30.22088],
    ],
  },
});
layer.size('lineSize');
```

### size(field: string, domain: ILineSize[])

`size` 方法支持简单的值映射，将根据 `field` 从传入图层的数据中提取的值映射到 `domain` 值域中。

```js
layer.size('type', [1, 2, 3]);
```

### size(field: string, callback: () => ILineSize )

`size` 方法支持回调函数的写法，将根据 `field` 作为 `callback` 方法的参数，`callback` 方法的返回值作为线图层实际的宽高。

```js
layer.size('type', (value) => {
  switch (value) {
    case 'path':
      return 1;
    case 'road':
      return 2;
  }
});
```
---
title: Style
order: 8
---

<embed src="@/docs/common/style.md"></embed>

`style` 方法用于配制图层的样式，相同图层拥有不同的 `shape` 图形，不同 `shape` 的图层 `style` 方法接受不同的参数。

```js
layer.style({
  opacity: 0.5,
});
```

### common

通用 `style` 参数，所有图形都支持的参数。

| style   | 类型     | 描述      | 数据映射  | 默认值 |
| ------- | -------- | ---------|--- | ------ |
| opacity | `number` | 图形的透明度| 支持 | `1`    |

### line

`shape` 为 `line` 的普通线图层。

- [line](/api/line_layer/shape#shapeline)
- [支持渐变](/api/line_layer/style#linear)
- [支持纹理](/api/line_layer/style#texture)
- [支持虚线](/api/line_layer/style#dash)

| style         | 类型                       | 描述          |支持数据映射             | 默认值      |
| ------------- | -------------------------- | ---------------|----------- | ----------- |
| stroke   | `string`                   | 图形边框颜色          |   是  | `#fff`      |
| strokeWidth   | `number`                   | 图形边框半径      |   否      | `0`         |
| blur          | `[number, number, number]` | 图形模糊分布        |   否       | `[1, 1, 1]` |
| raisingHeight | `number`                   | 抬升高度            |    否      | `0`         |
| heightfixed   | `boolean`                  | 抬升高度是否随 `zoom` 变化 | 否  | `false`     |

### arc

`shape` 为 `arc` 平面的弧线。

- [arc](/api/line_layer/shape#shapearc)
- [支持渐变](/api/line_layer/style#linear)
- [支持纹理](/api/line_layer/style#texture)
- [支持虚线](/api/line_layer/style#dash)

| style         | 类型     | 描述             |支持数据映射| 默认值  |
| ------------- | -------- | -----------------|----------------- | ------- |
| segmentNumber | `number` | 弧线分段，分段越多越平滑，消耗越大 |否| `30`    |
| opacity | `number` | 透明度，支持数据映射 |是| `1`   |
| thetaOffset   | `number` | 弧线的弧度参数            |   是   | `0.314` |

### arc3d

`shape` 为 `arc3d` 的弧线图层。

- [arc3d](/api/line_layer/shape#shapearc3d)
- [支持渐变](/api/line_layer/style#linear)
- [支持纹理](/api/line_layer/style#texture)
- [支持虚线](/api/line_layer/style#dash)

| style         | 类型     | 描述                  |支持数据映射             | 默认值 |
| ------------- | -------- | ---------------------|------------- | ------ |
| opacity | `number` | 透明度，支持数据映射 |是| `1`   |
| segmentNumber | `number` | 弧线分段，分段越多越平滑，消耗越大|否 | `30`   |
| thetaOffset   | `number` | 弧线的弧度参数            |   是   | `1` |

### greatcircle

`shape` 为大圆弧线图层。

- [greatcircle](/api/line_layer/shape#shapegreatcircle)
- [支持渐变](/api/line_layer/style#linear)
- [支持纹理](/api/line_layer/style#texture)
- [支持虚线](/api/line_layer/style#dash)

| style         | 类型     | 描述           |      支持数据映射              | 默认值 |
| ------------- | -------- | ---------------|------------------- | ------ |
| opacity | `number` | 透明度，支持数据映射 |是| `1`   |
| segmentNumber | `number` | 弧线分段，分段越多越平滑，消耗越大|否 | `30`   |

### flowline

| style         | 类型     | 描述           |支持数据映射                      | 默认值 |
| ------------- | -------- | -------------|--------------------- | ------ |
| opacity | `number` | 透明度，支持数据映射 |是| `1`   |
| strokeOpacity | `number` |描边透明度 |否| `30`   |
| stroke | `number` | 弧线分段，分段越多越平滑，消耗越大 |是| `#000`   |
| strokeWidth | `number` | 描边宽度 | `1` |否  |
| gapWidth | `number` | 不同方向两条线间距 | `2` |否  |
| offsets | `[number,number]` | 两端偏移量，支持数据映射 |是| `[0,0]`   |

flowline opacity 和 offsets 支持数据映射，数据驱动设置数据大小

#### opacity
```ts
layer.style({
  opacity: {
    field: 'count', // 映射字段
    value: [0.2,0.4,0.6,0.8], // 映射值,支持回调函数，支持设置scale
  }

// field 和 value  等同于 layer.color('count',[0.2,0.4,0.6,0.8])
```
#### offsets

```ts
layer.style({
  offsets:{
     field: 'count',
     values:() => {
      return [10 + Math.random()*20, 10 + Math.random()*20]
     }
})

```

### wall

`shape` 为 `wall` 地理围栏弧线图层。

- [wall](/api/line_layer/shape#shapewall)
- [支持渐变](/api/line_layer/style#linear)
- [支持纹理](/api/line_layer/style#texture)

### simple

`shape` 为 `simple` 简单线图层。

- [simple](/api/line_layer/shape#shapesimple)
- [支持渐变](/api/line_layer/style#linear)


### linear

- line、arc、arc3d、greatcircle、wall、simple

线图层支持配置渐变效果，在配置渐变效果后会覆盖 `layer.color` 方法设置的颜色。

| style       | 类型         | 描述       | 默认值     |
| ----------- | ------------ | ---------- | ---------- |
| sourceColor | `IColor`     | 线起始颜色 | `/`        |
| targetColor | `IColor`     | 线结尾颜色 | `/`        |
| linearDir   | `ILinearDir` | 线渐变方向 | `vertical` |

#### IColor

```js
const color = `rgb(200, 100, 50)`;
const color2 = '#ff0';
```

#### ILinearDir

- vertical 纵向（沿线方向）
- horizontal 横向

```js
type ILinearDir = 'vertical' | 'horizontal';
```

### texture

- line、arc、arc3d、greatcircle

线图层支持纹理以及纹理动画，纹理样式有自己的参数。

| style        | 类型            | 描述                           | 默认值   |
| ------------ | --------------- | ------------------------------ | -------- |
| lineTexture  | `boolean`       | 时候开启纹理能力               | `false`  |
| textureBlend | `ITextureBlend` | 纹理混合方式                   | `normal` |
| iconStep     | `number`        | 纹理贴图在线图层上面排布的间隔 | `100`    |

#### ITextureBlend

线图层的纹理在和线本身的颜色进行融合的时候支持两种，`normal` 和 `replace`。

- normal 纹理和线颜色混合
- replace 使用纹理替换线颜色

```js
type ITextureBlend = 'normal' | 'replace';
```

#### texture advance

✨ animate  
当线图层 (shape 为 arc/arc3d) 开启动画模式的时候，纹理在线图层上的分布还会和 animate 的参数相关

线图层上排列的纹理的数量大致为 duration/interval

```javascript
.animate({
    duration: 1,
    interval: 0.2,
    trailLength: 0.1
});

// 此时 纹理贴图数量为  duration / interval = 5
```

✨ textureBlend 参数  
通过控制 style 方法中的 textureBlend 参数，我们可以控制纹理图层和线图层的混合情况

- normal
- replace

```javascript
.style({
    lineTexture: true, // 开启线的贴图功能
    iconStep: 30, // 设置贴图纹理的间距
    textureBlend: 'replace', // 设置纹理混合方式，默认值为 normal，可选值有 normal/replace 两种
  });

```

### dash

- line、arc、arc3d、greatcircle

线图层支持配置虚线，虚线有自己额外的样式参数。

```js
layer.style({
    lineType: 'dash'
    dashArray: [5, 5]
})
```

| style     | 类型         | 描述       | 默认值  |
| --------- | ------------ | ---------- | ------- |
| lineType  | `ILineType`  | 线的类别   | `solid` |
| dashArray | `IDashArray` | 虚线的间隔 | `/`     |

#### ILineType

- solid 实线
- dash 虚线

#### IDashArray

`dashArray` 只有在 `ILineType` 为 `solid` 的时候才会生效。

```js
// len1 实线长度 len2 间隔长度
type IDashArray = [len1: number, len2: number]
```
---
title: Style
order: 8
---

<embed src="@/docs/common/style.md"></embed>

`style`The method is used to configure the style of the layer. The same layer has different`shape`graphics, different`shape`layer`style`Methods accept different parameters.

```js
layer.style({
  opacity: 0.5,
});
```

### common

Universal`style`Parameters, parameters supported by all graphics.

| style   | type     | describe             | default value |
| ------- | -------- | -------------------- | ------------- |
| opacity | `number` | Graphic transparency | `1`           |

### line

`shape`for`line`normal line layer.

* [line](/api/line_layer/shape#shapeline)
* [Support gradient](/api/line_layer/style#linear)
* [Supports textures](/api/line_layer/style#texture)
* [Support dashed lines](/api/line_layer/style#dash)
* [Support arrows](/api/line_layer/style#arrow)

| style         | type                       | describe                                   | default value |
| ------------- | -------------------------- | ------------------------------------------ | ------------- |
| borderColor   | `string`                   | Graphic border color                       | `#fff`        |
| borderWidth   | `number`                   | Graphic border radius                      | `0`           |
| blur          | `[number, number, number]` | Graphic fuzzy distribution                 | `[1, 1, 1]`   |
| raisingHeight | `number`                   | Lifting height                             | `0`           |
| heightfixed   | `boolean`                  | Does the lifting height vary?`zoom`Variety | `false`       |

### arc

`shape`for`arc`Plane arc.

* [arc](/api/line_layer/shape#shapearc)
* [Support gradient](/api/line_layer/style#linear)
* [Supports textures](/api/line_layer/style#texture)
* [Support dashed lines](/api/line_layer/style#dash)

| style         | type     | describe                                                                           | default value |
| ------------- | -------- | ---------------------------------------------------------------------------------- | ------------- |
| segmentNumber | `number` | Arc segmentation, the more segments, the smoother and the greater the consumption. | `30`          |
| thetaOffset   | `number` | The radian parameter of the arc                                                    | `0.314`       |

### arc3d

`shape`for`arc3d`arc layer.

* [arc3d](/api/line_layer/shape#shapearc3d)
* [Support gradient](/api/line_layer/style#linear)
* [Supports textures](/api/line_layer/style#texture)
* [Support dashed lines](/api/line_layer/style#dash)

| style         | type     | describe                                                                           | default value |
| ------------- | -------- | ---------------------------------------------------------------------------------- | ------------- |
| segmentNumber | `number` | Arc segmentation, the more segments, the smoother and the greater the consumption. | `30`          |

### greatcircle

`shape`It is a large arc layer.

* [greatcircle](/api/line_layer/shape#shapegreatcircle)
* [Support gradient](/api/line_layer/style#linear)
* [Supports textures](/api/line_layer/style#texture)
* [Support dashed lines](/api/line_layer/style#dash)

| style         | type     | describe                                                                           | default value |
| ------------- | -------- | ---------------------------------------------------------------------------------- | ------------- |
| segmentNumber | `number` | Arc segmentation, the more segments, the smoother and the greater the consumption. | `30`          |

### flowline

| style         | type              | describe                                                                           | default value |
| ------------- | ----------------- | ---------------------------------------------------------------------------------- | ------------- |
| opacity       | `number`          | Transparency, supports data mapping                                                | `1`           |
| strokeOpacity | `number`          | stroke transparency                                                                | `30`          |
| stroke        | `number`          | Arc segmentation, the more segments, the smoother and the greater the consumption. | `#000`        |
| strokeWidth   | `number`          | stroke width                                                                       | `1`           |
| gapWidth      | `number`          | The distance between two lines in different directions                             | `2`           |
| offsets       | `[number,number]` | Offsets at both ends, supporting data mapping                                      | `[0,0]`       |

flowline opacity and offsets support data mapping, data-driven setting of data size

#### opacity

```ts
layer.style({
  opacity: {
    field: 'count', // map field
    value: [0.2,0.4,0.6,0.8], // Mapping value, supports callback function, supports setting scale
  }

// field and value are equivalent to layer.color('count',[0.2,0.4,0.6,0.8])
```

#### offsets

```ts
layer.style({
  offsets:{
     field: 'count',
     values:() => {
      return [10 + Math.random()*20, 10 + Math.random()*20]
     }
})
```

### wall

`shape`for`wall`Geofence arc layer.

* [wall](/api/line_layer/shape#shapewall)
* [Support gradient](/api/line_layer/style#linear)
* [Supports textures](/api/line_layer/style#texture)

### simple

`shape`for`simple`Simple line layer.

* [simple](/api/line_layer/shape#shapesimple)
* [Support gradient](/api/line_layer/style#linear)

### arrow

* [line](/api/line_layer/shape#shapeline)

Line layers support configuring arrows, which have additional styles.

```js
layer.style({
  arrow: {
    enable: true,
    arrowWidth: 2,
    arrowHeight: 3,
    tailWidth: 1,
  },
});
```

| style       | type           | describe         | default value |
| ----------- | -------------- | ---------------- | ------------- |
| arrow       | `IArrowOption` | Arrow style      | `/`           |
| arrowWidth  | `number`       | Arrow width      | `2`           |
| arrowHeight | `number`       | length of arrow  | `3`           |
| tailWidth   | `number`       | Arrow tail width | `1`           |

### linear

* line、arc、arc3d、greatcircle、wall、simple

The line layer supports configuring gradient effects, which will be overwritten after configuring the gradient effect.`layer.color`Method to set the color.

| style       | type         | describe                | default value |
| ----------- | ------------ | ----------------------- | ------------- |
| sourceColor | `IColor`     | Line start color        | `/`           |
| targetColor | `IColor`     | Line end color          | `/`           |
| linearDir   | `ILinearDir` | Line gradient direction | `vertical`    |

#### IColor

```js
const color = `rgb(200, 100, 50)`;
const color2 = '#ff0';
```

#### ILinearDir

* vertical vertical (along the direction)
* horizontal

```js
type ILinearDir = 'vertical' | 'horizontal';
```

### texture

* line、arc、arc3d、greatcircle

Line layers support textures and texture animations, and texture styles have their own parameters.

| style        | type            | describe                                                       | default value |
| ------------ | --------------- | -------------------------------------------------------------- | ------------- |
| lineTexture  | `boolean`       | When to turn on texture capabilities                           | `false`       |
| textureBlend | `ITextureBlend` | Texture blending method                                        | `normal`      |
| iconStep     | `number`        | The spacing between texture maps arranged above the line layer | `100`         |

#### ITextureBlend

The texture of the line layer supports two types when blended with the color of the line itself.`normal`and`replace`。

* normal texture and line color blending
* replace Replace line color using texture

```js
type ITextureBlend = 'normal' | 'replace';
```

#### texture advance

✨ animate\
When the line layer (shape is arc/arc3d) turns on the animation mode, the distribution of the texture on the line layer will also be related to the parameters of animate

The number of textures arranged on a line layer is roughly duration/interval

```javascript
.animate({
    duration: 1,
    interval: 0.2,
    trailLength: 0.1
});

// At this time, the number of texture maps is duration / interval = 5
```

✨ textureBlend parameters\
By controlling the textureBlend parameter in the style method, we can control the blending of texture layers and line layers.

* normal
* replace

```javascript
.style({
    lineTexture: true, // Enable line mapping function
    iconStep: 30, // Set the spacing of the texture
    textureBlend: 'replace', //Set the texture blending method. The default value is normal. The optional values ​​are normal/replace.
  });
```

### dash

* line、arc、arc3d、greatcircle

The line layer supports configuring dashed lines, which have their own additional style parameters.

```js
layer.style({
    lineType: 'dash'
    dashArray: [5, 5]
})
```

| style     | type         | describe             | default value |
| --------- | ------------ | -------------------- | ------------- |
| lineType  | `ILineType`  | Line category        | `solid`       |
| dashArray | `IDashArray` | dotted line interval | `/`           |

#### ILineType

* solid solid line
* dash dashed line

#### IDashArray

`dashArray`only at`ILineType`for`solid`will take effect.

```js
// len1 solid line length len2 interval length
type IDashArray = [len1: number, len2: number]
```
---
title: Animate
order: 7
---

<embed src="@/docs/common/style.md"></embed>

The line layer is on`animate`After the method, you will get the line animation along the line direction.

<div>
  <div style="width:40%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*mo_7Q6sTqOIAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### animate(boolean | IAnimateOption)

`animate`The method supports Boolean and object passing values.

```javascript
layer.animate(true);

layer.animate({
  enable: true,
});
```

### IAnimateOption

```javascript
interface IAnimateOption {
  enable: boolean;
  speed: number;
  rings: number;
}
```

<embed src="@/docs/common/features/animate.en.md"></embed>
---
title: Animate
order: 7
---

<embed src="@/docs/common/style.md"></embed>

线图层图层在开启 `animate` 方法后会得到沿线方向的线动画。

<div>
  <div style="width:40%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*mo_7Q6sTqOIAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### animate(boolean | IAnimateOption)

`animate` 方法支持布尔值和对象传值。

```javascript
layer.animate(true);

layer.animate({
  enable: true,
});
```

### IAnimateOption

```javascript
interface IAnimateOption {
  enable: boolean;
  speed: number;
  rings: number;
}
```

<embed src="@/docs/common/features/animate.zh.md"></embed>
---
title: Scale
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/scale.zh.md"></embed>
---
title: Scale
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/scale.en.md"></embed>
---
title: Texture
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/features/texture.en.md"></embed>
---
title: Color
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/color.zh.md"></embed>
---
title: Color
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/color.en.md"></embed>
---
title: Texture
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/features/texture.zh.md"></embed>
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/options.zh.md"></embed>---
title: Source
order: 2
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/source.zh.md"></embed>

### GeoJSON

```js
// 传入 GeoJSON 类型数据 *** L7 默认支持，不需要 parser 解析
const data = {
  type: 'FeatureCollection',
  features: [
    {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'LineString',
        coordinates: [
          [106.5234375, 57.51582286553883],
          [136.40625, 61.77312286453146],
        ],
      },
    },
  ],
};

const layer = new LineLayer().source(data);
```

### CSV

```js
// 传入 txt 类型数据
var data = `from,to,value,type,lng1,lat1,lng2,lat2
鎷夎惃,娴疯タ,6.91,move_out,91.111891,29.662557,97.342625,37.373799
鎷夎惃,鎴愰兘,4.79,move_out,91.111891,29.662557,104.067923,30.679943
鎷夎惃,閲嶅簡,2.41,move_out,91.111891,29.662557,106.530635,29.544606
鎷夎惃,鍖椾含,2.05,move_out,91.111891,29.662557,116.395645,39.929986
...`;

new LineLayer().source(data, {
  parser: {
    type: 'csv',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng2',
    y1: 'lat2',
  },
});
```

### JSON

```js
// 传入 JSON 类型的数据
var data = [
  {
    lng: 120,
    lat: 30,
    lng1: 125,
    lat1: 30
  },
  ...
]

var layer = new LineLayer()
.source(data, {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat',
    x1: 'lng1',
    y1: 'lat1'
  }
})
```
---
title: Source
order: 2
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/source.en.md"></embed>

### GeoJSON

```js
// Pass in GeoJSON type data *** L7 supports it by default and does not require parser analysis
const data = {
  type: 'FeatureCollection',
  features: [
    {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'LineString',
        coordinates: [
          [106.5234375, 57.51582286553883],
          [136.40625, 61.77312286453146],
        ],
      },
    },
  ],
};

const layer = new LineLayer().source(data);
```

### CSV

```js
// Pass in txt type data
var data = `from,to,value,type,lng1,lat1,lng2,lat2
鎷夎惃,仙魔タ,6.91,move_out,91.111891,29.662557,97.342625,37.373799
鎷厎惃,鎴愰嘘,4.79,move_out,91.111891,29.662557,104.067923,30.679943
鎷厎惃,玷夎惃,月充经,2.41,move_out,91.111891,29.662557,106.530635,29.544606
鎷厎惃,鍖椾han,2.05,move_out,91.111891,29.662557,116.395645,39.929986
...`;

new LineLayer().source(data, {
  parser: {
    type: 'csv',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng2',
    y1: 'lat2',
  },
});
```

### JSON

```js
// Pass in JSON type data
var data = [
  {
    lng: 120,
    lat: 30,
    lng1: 125,
    lat1: 30
  },
  ...
]

var layer = new LineLayer()
.source(data, {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat',
    x1: 'lng1',
    y1: 'lat1'
  }
})
```
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/options.en.md"></embed>
---
title: LineLayer
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## 简介

线图层通过一组经纬度数据组来描述地图上的一条或者多条路径。通过路径的类型，将其区分为路径、弧线、3D 弧线以及其他的类型。  
用户可以通过配置 `shape` 参数来选择点的类型，同时通过 `style`、`size`、`color` 方法调整点的样式。

<div>
  <div style="width:40%;float:right; margin-left: 16px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*MxnRTrzcawcAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

```js
const layer = new LineLayer()
  .source([{ lng: 120, lat: 30, lng1: 125, lat1: 30 }], {
    parser: {
      type: 'json',
      x: 'lng',
      y: 'lat',
      x1: 'lng1',
      y1: 'lat1',
    },
  })
  .shape('line')
  .size(2)
  .color('#f00');
```
---
title: LineLayer
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

The line layer describes one or more paths on the map through a set of longitude and latitude data sets. By the type of path, it is divided into path, arc, 3D arc and other types.\
Users can configure`shape`parameters to select the type of point, and pass`style`、`size`、`color`Method to adjust the point style.

<div>
  <div style="width:40%;float:right; margin-left: 16px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*MxnRTrzcawcAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

```js
const layer = new LineLayer()
  .source([{ lng: 120, lat: 30, lng1: 125, lat1: 30 }], {
    parser: {
      type: 'json',
      x: 'lng',
      y: 'lat',
      x1: 'lng1',
      y1: 'lat1',
    },
  })
  .shape('line')
  .size(2)
  .color('#f00');
```
---
title: L7Mini 小程序模块教程
order: 3
---

<embed src="@/docs/common/style.md"></embed>

## 简介

通过引入 L7Mini 模块，能让用户在小程序环境中使用 L7 地图可视化的能力，增强原生地图组件的可视化能力。

✨ 目前 L7Mini 兼容支付宝小程序，尚不支持微信小程序。  
✨ 目前 L7Mini 只支持无底图模式，即只展示可视化层。  
✨ L7Mini 模块的使用，除了画布获取和和事件注册因为小程序环境的原因需要用户额外处理，其余部分和普通 L7 的使用保持一致。

下面将介绍如何在支付宝小程序中使用 L7Mini 模块。

## 安装

目前 L7 在小程序开发中使用的能力全部来自 L7Mini 模块，用户只需要执行一次安装即可。

```javascript
npm install @antv/l7-mini --save
```

## 地图引用

在小程序环境中，用户无法引用高德地图和 Mapbox 地图， 只能引用小程序版本的地图类型。  
在 .ts/.js 页面脚本文件中引用

```javascript
import {
  Map, // 其他地图类型不兼容小程序环境
  Scene,
  PointLayer,
  dispatchTouchStart,
  dispatchTouchMove,
  dispatchTouchEnd,
} from '@antv/l7-mini';
```

地图小程序环境的使用和普通 H5 环境的使用保持一致。

```javascript
const miniMap = new Map({
  center: [0, 0],
  zoom: -0.5,
  pitch: 0,
});
```

## 节点注册

由于小程序限制，我们无法动态创建新的节点，因此我们需要事先在 .axml 文件中创建 canvas 画布节点

```javascript
<canvas onReady="onCanvasReady" type="webgl" id="canvas" />
```

注册完的节点会在脚本文件中获取使用。

✨ 我们需要完成 onCanvasReady 事件的注册，以便明确获取节点的时机。

## 事件注册

由于小程序环境的限制，我们无法动态注册事件，所以需要用户自己完成事件代理，下面将会说明如何完成事件的代理。

✨ 如果不进行事件的注册和转发，用户将无法对地图进行操作。

1. 在 .axml 文件中绑定基础事件

✨ 事件需要绑定在 canvas 节点上或是 canvas 的父节点上

```javascript
<view id="box" class="wrap"
  onTouchStart="onTouchStart"  // 绑定基础事件
  onTouchMove="onTouchMove"
  onTouchEnd="onTouchEnd"
  >
  <canvas onReady="onCanvasReady" type="webgl" id="canvas" />
  <view class="populationWrap">
    <view class="populationIcons">
      人口/千万:
    </view>
    <view class="populationIcons" a:for="{{population}}">
      <view> {{item.count}}  </view>
      <view class="colorLine" style="background:{{item.color}}"></view>
    </view>
  </view>
</view>
```

2. .ts/.js 文件中完成事件的代理转发

引入代理方法

```javascript
import {
  Map,
  Scene,
  PointLayer,
  dispatchTouchStart, // L7Mini 封装的代理方法
  dispatchTouchMove,
  dispatchTouchEnd,
} from '@antv/l7-mini';
```

在 page 对象中注册方法

```javascript
page({
  ...
  onTouchStart(e) {
    dispatchTouchStart(e);
  },
  onTouchMove(e) {
    dispatchTouchMove(e);
  },
  onTouchEnd(e) {
    dispatchTouchEnd(e);
  },
  ...
})

```

我们只需要完成基础方法的注册（touchstart/touchmove/touchend），L7Mini 会完成复合方法、手势的判断。

## 画布的获取与使用

在小程序中，我们需要使用小程序提供的方法来获取页面节点。

我们通过在 .axml 在 canvas 画布组件上注册的 onCanvasReady 方法来判断获取画布的时机。

```javascript
page({
  ...
  onCanvasReady() {
    handleCanvas(my, canvas => {
      ...
      // 正常开发 L7 代码
      ...
    })
  }
  ...
})
```

下面提供了获取画布节点通用方法，同时对画布进行一些处理方便后续使用。

```javascript
function handleCanvas(my, callback) {
  const selector = my.createSelectorQuery();
  const domSelector = selector.select('#canvas');
  domSelector
    .fields(
      {
        node: true,
        context: false,
        rect: true,
        computedStyle: ['height', 'width'],
      },
      function (res) {
        // 内部计算使用 （必须设置）
        res.node.left = res.left;
        res.node.top = res.top;

        // 设置画布的 DPR （必须设置）
        const DPR = my.getSystemInfoSync().pixelRatio;
        res.node.width *= DPR;
        res.node.height *= DPR;

        // 返回 canvas 画布节点
        callback(res.node);
      },
    )
    .exec();
}
```

我们在获取到画布对象后需要传递给 scene 使用。

```javascript
const miniScene = new Scene({
  id: 'canvas',
  canvas, // canvas 是我们从小程序页面上获取到的实际节点
  map: miniMap,
});
```

## 销毁

为了保证小程序的良好体验，在页面关闭时记得及时将 L7 内容进行销毁。

```javascript
  page({
    ...
    onHide() {
      miniScene.destroy();
    },
    onUnload() {
      miniScene.destroy();
    },
    ...
  })
```

## 限制

目前 L7Mini 尚不支持 marker/popup 等需要动态创建页面节点的能力，用户若是需要可以自己单独创建。
---
title: L7Mini
order: 3
---

<embed src="@/docs/api/mini/mini.zh.md"></embed>
---
title: L7Mini 飞线
order: 4
---

<embed src="@/docs/common/style.md"></embed>

## 案例
<img width="200px" alt="飞线" src='https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*GyYeRp1uOIAAAAAAAAAAAAAAARQnAQ'>

### 飞线

index.axml 页面结构代码
```javascript
<view class="isLoading" style="height: 100vh" a:if="{{isLoading}}">
  <view class="loadItem" a:for="{{10}}">
  </view>
</view>

<view id="box" class="wrap" 
  onTouchStart="onTouchStart" 
  onTouchMove="onTouchMove"
  onTouchEnd="onTouchEnd"
  >
  <canvas onReady="onCanvasReady" type="webgl" id="canvas" />
</view>
<image class="antvl7" mode="scaleToFill" src="{{antvl7}}" />

```
index.less 样式代码
```less
.wrap {
  height: 100vh;
  #canvas {
    height: 100%;
    width: 100%;
  }
}
```

index.ts 脚本代码
```javascript
import {
  Map,
  Scene,
  LineLayer,
  dispatchTouchStart,
  dispatchTouchMove,
  dispatchTouchEnd,
  PointLayer,
} from '@antv/l7-mini';
import { getJSON } from '../../request';
import { antvl7, flydata, pointData, worldJSON } from '../../mockData';
import { handleCanvas, LayerCounter } from '../../utils';

let miniScene;
let counter;

Page({
  data: {
    isLoading: true,
    antvl7,
  },
  onLoad() {
    counter = new LayerCounter(3, my, this);
    my.showLoading();
  },
  onTouchStart(e) {
    dispatchTouchStart(e);
  },
  onTouchMove(e) {
    dispatchTouchMove(e);
  },
  onTouchEnd(e) {
    dispatchTouchEnd(e);
  },
  onCanvasReady() {
    handleCanvas(this, my, (canvas) => {
      const miniMap = new Map({
        center: [0, 0],
        zoom: 0,
        pitch: 40,
      });
      miniScene = new Scene({
        id: 'canvas',
        canvas,
        map: miniMap,
        hasBaseMap: false,
      });

      miniScene.setBgColor('#222');

      getJSON(worldJSON, function (result, data) {
        if (result) {
          const lineLayer = new LineLayer()
            .source(data)
            .shape('line')
            .size(0.8)
            .color('#41fc9d')

            .style({
              opacity: 0.4,
            });
          miniScene.addLayer(lineLayer);
          counter.loadLayer();
        }
      });

      const flyLine = new LineLayer({ blend: 'normal', zIndex: 2 })
        .source(flydata, {
          parser: {
            type: 'json',
            coordinates: 'coord',
          },
        })
        .color('#b97feb')
        .shape('arc3d')
        .size(2)
        .active(true)
        .animate({
          interval: 2,
          trailLength: 2,
          duration: 1,
        })
        .style({
          opacity: 0.8,
          sourceColor: '#f00',
          targetColor: '#0f0',
        });

      const pointLayer = new PointLayer();
      pointLayer
        .source(pointData, {
          parser: {
            type: 'json',
            x: 'lng',
            y: 'lat',
          },
        })
        .shape('circle')
        .color('#ffed11')
        .animate(true)
        .size(40)
        .style({
          opacity: 1.0,
        });

      miniScene.on('loaded', () => {
        miniScene.addLayer(flyLine);
        counter.loadLayer();
        miniScene.addLayer(pointLayer);
        counter.loadLayer();
      });
    });
  },
  onUnload() {
    // 页面被关闭
    miniScene.destroy();
  },
});

```
方法代码
```javascript
function getJSON(url, callback) {
  my.request({
    url,
    method: 'GET',
    data: {
      from: '支付宝',
      production: 'AlipayJSAPI',
    },
    headers: {
      'content-type': 'application/json', // 默认值
    },
    dataType: 'json',
    fail() {
      callback(false, null);
    },
    complete(res) {
      callback(true, res.data);
    },
  });
}

function handleCanvas(_that, my, callback) {
  const selector = my.createSelectorQuery();
  const domSelector = selector.select('#canvas');
  domSelector
    .fields(
      {
        node: true,
        context: false,
        rect: true,
        computedStyle: ['height', 'width'],
      },
      function (res) {
        res.node.left = res.left;
        res.node.top = res.top;

        const DPR = my.getSystemInfoSync().pixelRatio;
        res.node.width *= DPR;
        res.node.height *= DPR;

        callback(res.node);
      },
    )
    .exec();
}

class LayerCounter {
  private loadedLayer = 0;

  private totalLayers: number;

  private my: any;

  private context: any;

  constructor(totalLayers: number, my: any, context: any) {
    this.totalLayers = totalLayers;
    this.my = my;
    this.context = context;
  }

  loadLayer() {
    this.loadedLayer++;
    const that = this;
    if (this.loadedLayer >= this.totalLayers) {
      this.my.hideLoading({
        page: that, // 防止执行时已经切换到其它页面，page 指向不准确
      });
      this.context.setData({
        isLoading: false,
      });
    }
  }
}
```---
title: L7Mini flyline
order: 4
---

<embed src="@/docs/api/mini/demos/flyline.zh.md"></embed>
---
title: L7Mini chinaPopulation
order: 4
---

<embed src="@/docs/api/mini/demos/chinaPopulation.zh.md"></embed>
---
title: L7Mini 中国人口分布地图
order: 4
---

<embed src="@/docs/common/style.md"></embed>

## 案例

<img width="200px" alt="中国人口地图" src='https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/
A*65N9Sbw7f1AAAAAAAAAAAAAAARQnAQ'>

### 中国人口地图

index.axml 页面结构代码
```javascript

<view class="isLoading" style="height: 100vh" a:if="{{isLoading}}">
  <view class="loadItem" a:for="{{10}}">
  </view>
</view>

<view id="box" class="wrap" 
  onTouchStart="onTouchStart" 
  onTouchMove="onTouchMove"
  onTouchEnd="onTouchEnd"
  >
  <canvas onReady="onCanvasReady" type="webgl" id="canvas" />
  <view class="populationWrap">
    <view class="populationIcons">
      人口/千万:
    </view>
    <view class="populationIcons" a:for="{{population}}">
      <view> {{item.count}}  </view>
      <view class="colorLine" style="background:{{item.color}}"></view>
    </view>
  </view>
</view>
<image class="antvl7" mode="scaleToFill" src="{{antvl7}}" />

```
index.less 样式代码
```less
.wrap {
  height: 100vh;
  #canvas {
    height: 100%;
    width: 100%;
  }
}
```

index.ts 脚本代码
```javascript
import {
  Map,
  Scene,
  PolygonLayer,
  LineLayer,
  dispatchTouchStart,
  dispatchTouchMove,
  dispatchTouchEnd,
  PointLayer,
} from '@antv/l7-mini';
import { getJSON } from '../../request';
import { antvl7, chinaJSON, chinaBorderLine, population, provinceCenter } from '../../mockData';
import { handleCanvas, LayerCounter } from '../../utils';

let miniScene;
let counter;

Page({
  data: {
    isLoading: true,
    antvl7,
    population: [
      { count: '> 9', color: '#662506' },
      { count: '> 7', color: '#993404' },
      { count: '> 6', color: '#cc4c02' },
      { count: '> 5', color: '#ec7014' },
      { count: '> 3', color: '#fe9929' },
      { count: '> 2', color: '#fec44f' },
      { count: '<= 2', color: '#fee391' },
    ],
  },
  onLoad() {
    counter = new LayerCounter(4, my, this);
    my.showLoading();
  },
  onTouchStart(e) {
    dispatchTouchStart(e);
  },
  onTouchMove(e) {
    dispatchTouchMove(e);
  },
  onTouchEnd(e) {
    dispatchTouchEnd(e);
  },
  onCanvasReady() {
    handleCanvas(this, my, (canvas) => {
      const miniMap = new Map({
        center: [105, 30.279383],
        zoom: 2,
        pitch: 0,
      });
      miniScene = new Scene({
        id: 'canvas',
        canvas,
        map: miniMap,
        hasBaseMap: false,
      });
      getJSON(chinaJSON, function (result, data) {
        if (result) {
          const polygonLayer = new PolygonLayer({})
            .source(data)
            .size('name', [0, 10000, 50000, 30000, 100000])
            .color('name', (name) => {
              const count = population[name];
              if (count && count > 90000000) {
                return '#662506';
              } else if (count && count > 70000000) {
                return '#993404';
              } else if (count && count > 65000000) {
                return '#cc4c02';
              } else if (count && count > 50000000) {
                return '#ec7014';
              } else if (count && count > 30000000) {
                return '#fe9929';
              } else if (count && count > 20000000) {
                return '#fec44f';
              } else {
                return '#fee391';
              }
            })
            .shape('fill')
            .style({
              opacity: 0.8,
            });

          miniScene.addLayer(polygonLayer);
          counter.loadLayer();

          const provinceLine = new PolygonLayer({})
            .source(data)
            .size(0.4)
            .color('#fff')
            .shape('line')
            .style({
              opacity: 0.8,
            });

          miniScene.addLayer(provinceLine);
          counter.loadLayer();
        }
      });

      getJSON(chinaBorderLine, function (result, data) {
        if (result) {
          const borderlineLayer = new LineLayer({ zIndex: 2 })
            .source(data)
            .shape('line')
            .size(0.6)
            .color('rgb(93,112,146)')
            .style({
              opacity: 0.8,
            });
          miniScene.addLayer(borderlineLayer);
          counter.loadLayer();
        }
      });

      const provinceName = new PointLayer({ zIndex: 1 })
        .source(provinceCenter, {
          parser: {
            type: 'json',
            x: 'lng',
            y: 'lat',
          },
        })
        .shape('n', 'text')
        .size(12)
        .color('#000')
        .style({
          stroke: '#fff',
          strokeWidth: 1,
          opacity: 0.8,
          textAllowOverlap: true,
        });

      miniScene.on('loaded', function () {
        miniScene.addLayer(provinceName);
        counter.loadLayer();
      });
    });
  },
  onUnload() {
    // 页面被关闭
    miniScene.destroy();
  },
});
```
方法代码
```javascript
function getJSON(url, callback) {
  my.request({
    url,
    method: 'GET',
    data: {
      from: '支付宝',
      production: 'AlipayJSAPI',
    },
    headers: {
      'content-type': 'application/json', // 默认值
    },
    dataType: 'json',
    fail() {
      callback(false, null);
    },
    complete(res) {
      callback(true, res.data);
    },
  });
}

function handleCanvas(_that, my, callback) {
  const selector = my.createSelectorQuery();
  const domSelector = selector.select('#canvas');
  domSelector
    .fields(
      {
        node: true,
        context: false,
        rect: true,
        computedStyle: ['height', 'width'],
      },
      function (res) {
        res.node.left = res.left;
        res.node.top = res.top;

        const DPR = my.getSystemInfoSync().pixelRatio;
        res.node.width *= DPR;
        res.node.height *= DPR;

        callback(res.node);
      },
    )
    .exec();
}

class LayerCounter {
  private loadedLayer = 0;

  private totalLayers: number;

  private my: any;

  private context: any;

  constructor(totalLayers: number, my: any, context: any) {
    this.totalLayers = totalLayers;
    this.my = my;
    this.context = context;
  }

  loadLayer() {
    this.loadedLayer++;
    const that = this;
    if (this.loadedLayer >= this.totalLayers) {
      this.my.hideLoading({
        page: that, // 防止执行时已经切换到其它页面，page 指向不准确
      });
      this.context.setData({
        isLoading: false,
      });
    }
  }
}
```---
title: L7Mini 经典热力
order: 4
---

<embed src="@/docs/common/style.md"></embed>

## 案例
<img width="200px" alt="经典热力" src='https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*LgBfTbhEgzEAAAAAAAAAAAAAARQnAQ'>

### 经典热力

index.axml 页面结构代码
```javascript

<view class="isLoading" style="height: 100vh" a:if="{{isLoading}}">
  <view class="loadItem" a:for="{{10}}">
  </view>
</view>

<view id="box" class="wrap" 
  onTouchStart="onTouchStart" 
  onTouchMove="onTouchMove"
  onTouchEnd="onTouchEnd"
  >
  <canvas onReady="onCanvasReady" type="webgl" id="canvas" />
  <view class="populationWrap">
    <view class="populationIcons">
      人口/千万:
    </view>
    <view class="populationIcons" a:for="{{population}}">
      <view> {{item.count}}  </view>
      <view class="colorLine" style="background:{{item.color}}"></view>
    </view>
  </view>
</view>
<image class="antvl7" mode="scaleToFill" src="{{antvl7}}" />

```
index.less 样式代码
```less
.wrap {
  height: 100vh;
  #canvas {
    height: 100%;
    width: 100%;
  }
}
```

index.ts 脚本代码
```javascript
import {
  Map,
  Scene,
  PolygonLayer,
  LineLayer,
  dispatchTouchStart,
  dispatchTouchMove,
  dispatchTouchEnd,
  PointLayer,
} from '@antv/l7-mini';
import { getJSON } from '../../request';
import { antvl7, chinaJSON, chinaBorderLine, population, provinceCenter } from '../../mockData';
import { handleCanvas, LayerCounter } from '../../utils';

let miniScene;
let counter;

Page({
  data: {
    isLoading: true,
    antvl7,
    population: [
      { count: '> 9', color: '#662506' },
      { count: '> 7', color: '#993404' },
      { count: '> 6', color: '#cc4c02' },
      { count: '> 5', color: '#ec7014' },
      { count: '> 3', color: '#fe9929' },
      { count: '> 2', color: '#fec44f' },
      { count: '<= 2', color: '#fee391' },
    ],
  },
  onLoad() {
    counter = new LayerCounter(4, my, this);
    my.showLoading();
  },
  onTouchStart(e) {
    dispatchTouchStart(e);
  },
  onTouchMove(e) {
    dispatchTouchMove(e);
  },
  onTouchEnd(e) {
    dispatchTouchEnd(e);
  },
  onCanvasReady() {
    handleCanvas(this, my, (canvas) => {
      const miniMap = new Map({
        center: [105, 30.279383],
        zoom: 2,
        pitch: 0,
      });
      miniScene = new Scene({
        id: 'canvas',
        canvas,
        map: miniMap,
        hasBaseMap: false,
      });
      getJSON(chinaJSON, function (result, data) {
        if (result) {
          const polygonLayer = new PolygonLayer({})
            .source(data)
            .size('name', [0, 10000, 50000, 30000, 100000])
            .color('name', (name) => {
              const count = population[name];
              if (count && count > 90000000) {
                return '#662506';
              } else if (count && count > 70000000) {
                return '#993404';
              } else if (count && count > 65000000) {
                return '#cc4c02';
              } else if (count && count > 50000000) {
                return '#ec7014';
              } else if (count && count > 30000000) {
                return '#fe9929';
              } else if (count && count > 20000000) {
                return '#fec44f';
              } else {
                return '#fee391';
              }
            })
            .shape('fill')
            .style({
              opacity: 0.8,
            });

          miniScene.addLayer(polygonLayer);
          counter.loadLayer();

          const provinceLine = new PolygonLayer({})
            .source(data)
            .size(0.4)
            .color('#fff')
            .shape('line')
            .style({
              opacity: 0.8,
            });

          miniScene.addLayer(provinceLine);
          counter.loadLayer();
        }
      });

      getJSON(chinaBorderLine, function (result, data) {
        if (result) {
          const borderlineLayer = new LineLayer({ zIndex: 2 })
            .source(data)
            .shape('line')
            .size(0.6)
            .color('rgb(93,112,146)')
            .style({
              opacity: 0.8,
            });
          miniScene.addLayer(borderlineLayer);
          counter.loadLayer();
        }
      });

      const provinceName = new PointLayer({ zIndex: 1 })
        .source(provinceCenter, {
          parser: {
            type: 'json',
            x: 'lng',
            y: 'lat',
          },
        })
        .shape('n', 'text')
        .size(12)
        .color('#000')
        .style({
          stroke: '#fff',
          strokeWidth: 1,
          opacity: 0.8,
          textAllowOverlap: true,
        });

      miniScene.on('loaded', function () {
        miniScene.addLayer(provinceName);
        counter.loadLayer();
      });
    });
  },
  onUnload() {
    // 页面被关闭
    miniScene.destroy();
  },
});
```
方法代码
```javascript
function getJSON(url, callback) {
  my.request({
    url,
    method: 'GET',
    data: {
      from: '支付宝',
      production: 'AlipayJSAPI',
    },
    headers: {
      'content-type': 'application/json', // 默认值
    },
    dataType: 'json',
    fail() {
      callback(false, null);
    },
    complete(res) {
      callback(true, res.data);
    },
  });
}

function handleCanvas(_that, my, callback) {
  const selector = my.createSelectorQuery();
  const domSelector = selector.select('#canvas');
  domSelector
    .fields(
      {
        node: true,
        context: false,
        rect: true,
        computedStyle: ['height', 'width'],
      },
      function (res) {
        res.node.left = res.left;
        res.node.top = res.top;

        const DPR = my.getSystemInfoSync().pixelRatio;
        res.node.width *= DPR;
        res.node.height *= DPR;

        callback(res.node);
      },
    )
    .exec();
}

class LayerCounter {
  private loadedLayer = 0;

  private totalLayers: number;

  private my: any;

  private context: any;

  constructor(totalLayers: number, my: any, context: any) {
    this.totalLayers = totalLayers;
    this.my = my;
    this.context = context;
  }

  loadLayer() {
    this.loadedLayer++;
    const that = this;
    if (this.loadedLayer >= this.totalLayers) {
      this.my.hideLoading({
        page: that, // 防止执行时已经切换到其它页面，page 指向不准确
      });
      this.context.setData({
        isLoading: false,
      });
    }
  }
}
```---
title: L7Mini heat
order: 4
---

<embed src="@/docs/api/mini/demos/heat.zh.md"></embed>
---
title: L7Mini highLine
order: 4
---

<embed src="@/docs/api/mini/demos/high-line.zh.md"></embed>
---
title: L7Mini 等高线
order: 4
---

<embed src="@/docs/common/style.md"></embed>

## 案例

<img width="200px" alt="等高线" src='https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*19PATJwDBWYAAAAAAAAAAAAAARQnAQ'>

### 中国人口地图

index.axml 页面结构代码
```javascript

<view class="isLoading" style="height: 100vh" a:if="{{isLoading}}">
  <view class="loadItem" a:for="{{10}}">
  </view>
</view>

<view id="box" class="wrap" 
  onTouchStart="onTouchStart" 
  onTouchMove="onTouchMove"
  onTouchEnd="onTouchEnd"
  >
  <canvas onReady="onCanvasReady" type="webgl" id="canvas" />
  <view class="populationWrap">
    <view class="populationIcons">
      人口/千万:
    </view>
    <view class="populationIcons" a:for="{{population}}">
      <view> {{item.count}}  </view>
      <view class="colorLine" style="background:{{item.color}}"></view>
    </view>
  </view>
</view>
<image class="antvl7" mode="scaleToFill" src="{{antvl7}}" />

```
index.less 样式代码
```less
.wrap {
  height: 100vh;
  #canvas {
    height: 100%;
    width: 100%;
  }
}
```

index.ts 脚本代码
```javascript
import {
  Map,
  Scene,
  PolygonLayer,
  LineLayer,
  dispatchTouchStart,
  dispatchTouchMove,
  dispatchTouchEnd,
  PointLayer,
} from '@antv/l7-mini';
import { getJSON } from '../../request';
import { antvl7, chinaJSON, chinaBorderLine, population, provinceCenter } from '../../mockData';
import { handleCanvas, LayerCounter } from '../../utils';

let miniScene;
let counter;

Page({
  data: {
    isLoading: true,
    antvl7,
    population: [
      { count: '> 9', color: '#662506' },
      { count: '> 7', color: '#993404' },
      { count: '> 6', color: '#cc4c02' },
      { count: '> 5', color: '#ec7014' },
      { count: '> 3', color: '#fe9929' },
      { count: '> 2', color: '#fec44f' },
      { count: '<= 2', color: '#fee391' },
    ],
  },
  onLoad() {
    counter = new LayerCounter(4, my, this);
    my.showLoading();
  },
  onTouchStart(e) {
    dispatchTouchStart(e);
  },
  onTouchMove(e) {
    dispatchTouchMove(e);
  },
  onTouchEnd(e) {
    dispatchTouchEnd(e);
  },
  onCanvasReady() {
    handleCanvas(this, my, (canvas) => {
      const miniMap = new Map({
        center: [105, 30.279383],
        zoom: 2,
        pitch: 0,
      });
      miniScene = new Scene({
        id: 'canvas',
        canvas,
        map: miniMap,
        hasBaseMap: false,
      });
      getJSON(chinaJSON, function (result, data) {
        if (result) {
          const polygonLayer = new PolygonLayer({})
            .source(data)
            .size('name', [0, 10000, 50000, 30000, 100000])
            .color('name', (name) => {
              const count = population[name];
              if (count && count > 90000000) {
                return '#662506';
              } else if (count && count > 70000000) {
                return '#993404';
              } else if (count && count > 65000000) {
                return '#cc4c02';
              } else if (count && count > 50000000) {
                return '#ec7014';
              } else if (count && count > 30000000) {
                return '#fe9929';
              } else if (count && count > 20000000) {
                return '#fec44f';
              } else {
                return '#fee391';
              }
            })
            .shape('fill')
            .style({
              opacity: 0.8,
            });

          miniScene.addLayer(polygonLayer);
          counter.loadLayer();

          const provinceLine = new PolygonLayer({})
            .source(data)
            .size(0.4)
            .color('#fff')
            .shape('line')
            .style({
              opacity: 0.8,
            });

          miniScene.addLayer(provinceLine);
          counter.loadLayer();
        }
      });

      getJSON(chinaBorderLine, function (result, data) {
        if (result) {
          const borderlineLayer = new LineLayer({ zIndex: 2 })
            .source(data)
            .shape('line')
            .size(0.6)
            .color('rgb(93,112,146)')
            .style({
              opacity: 0.8,
            });
          miniScene.addLayer(borderlineLayer);
          counter.loadLayer();
        }
      });

      const provinceName = new PointLayer({ zIndex: 1 })
        .source(provinceCenter, {
          parser: {
            type: 'json',
            x: 'lng',
            y: 'lat',
          },
        })
        .shape('n', 'text')
        .size(12)
        .color('#000')
        .style({
          stroke: '#fff',
          strokeWidth: 1,
          opacity: 0.8,
          textAllowOverlap: true,
        });

      miniScene.on('loaded', function () {
        miniScene.addLayer(provinceName);
        counter.loadLayer();
      });
    });
  },
  onUnload() {
    // 页面被关闭
    miniScene.destroy();
  },
});
```
方法代码
```javascript
function getJSON(url, callback) {
  my.request({
    url,
    method: 'GET',
    data: {
      from: '支付宝',
      production: 'AlipayJSAPI',
    },
    headers: {
      'content-type': 'application/json', // 默认值
    },
    dataType: 'json',
    fail() {
      callback(false, null);
    },
    complete(res) {
      callback(true, res.data);
    },
  });
}

function handleCanvas(_that, my, callback) {
  const selector = my.createSelectorQuery();
  const domSelector = selector.select('#canvas');
  domSelector
    .fields(
      {
        node: true,
        context: false,
        rect: true,
        computedStyle: ['height', 'width'],
      },
      function (res) {
        res.node.left = res.left;
        res.node.top = res.top;

        const DPR = my.getSystemInfoSync().pixelRatio;
        res.node.width *= DPR;
        res.node.height *= DPR;

        callback(res.node);
      },
    )
    .exec();
}

class LayerCounter {
  private loadedLayer = 0;

  private totalLayers: number;

  private my: any;

  private context: any;

  constructor(totalLayers: number, my: any, context: any) {
    this.totalLayers = totalLayers;
    this.my = my;
    this.context = context;
  }

  loadLayer() {
    this.loadedLayer++;
    const that = this;
    if (this.loadedLayer >= this.totalLayers) {
      this.my.hideLoading({
        page: that, // 防止执行时已经切换到其它页面，page 指向不准确
      });
      this.context.setData({
        isLoading: false,
      });
    }
  }
}
```---
title: L7Mini hexagon
order: 4
---

<embed src="@/docs/api/mini/demos/hexagon.zh.md"></embed>
---
title: L7Mini 网格热力
order: 4
---

<embed src="@/docs/common/style.md"></embed>

## 案例
<img width="200px" alt="网格热力" src='https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*7VR6To9TiwsAAAAAAAAAAAAAARQnAQ'>

### 网格热力

index.axml 页面结构代码
```javascript
<view class="isLoading" style="height: 100vh" a:if="{{isLoading}}">
  <view class="loadItem" a:for="{{10}}">
  </view>
</view>

<view id="box" class="wrap" 
  onTouchStart="onTouchStart" 
  onTouchMove="onTouchMove"
  onTouchEnd="onTouchEnd"
  >
  <canvas onReady="onCanvasReady" type="webgl" id="canvas" />

    <view class="populationWrap">
    <view class="populationIcons">
      热力值:
    </view>
    <view class="populationIcons" a:for="{{population}}">
      <view> {{item.count}}  </view>
      <view class="colorLine" style="background:{{item.color}}"></view>
    </view>
  </view>
  
</view>
<image class="antvl7" mode="scaleToFill" src="{{antvl7}}" />

```
index.less 样式代码
```less
.wrap {
  height: 100vh;
  #canvas {
    height: 100%;
    width: 100%;
  }
}

.populationWrap {
  position: absolute;
  bottom: 32px;
  font-size: 0.6em;
  .populationIcons {
    float: left;
    margin-left: 10px;
    .colorLine {
      height: 5px;
      border-radius: 2px;
    }
  }
}
```

index.ts 脚本代码
```javascript
import {
  Map,
  Scene,
  HeatmapLayer,
  dispatchTouchStart,
  dispatchTouchMove,
  dispatchTouchEnd,
  ImageLayer,
} from '@antv/l7-mini';
import { getJSON } from '../../request';
import { antvl7, hexagonData } from '../../mockData';
import { handleCanvas, LayerCounter } from '../../utils';

let miniScene;
let counter;

Page({
  data: {
    isLoading: true,
    antvl7,
    population: [
      { count: '0.1', color: '#CEF8D6' },
      { count: '0.2', color: '#A1EDB8' },
      { count: '0.3', color: '#7BE39E' },
      { count: '0.4', color: '#5FD3A6' },
      { count: '0.5', color: '#4AC5AF' },
      { count: '0.6', color: '#34B6B7' },
      { count: '0.7', color: '#289899' },
      { count: '0.8', color: '#1D7F7E' },
    ],
  },
  onLoad() {
    counter = new LayerCounter(1, my, this);
    my.showLoading();
  },
  onTouchStart(e) {
    dispatchTouchStart(e);
  },
  onTouchMove(e) {
    dispatchTouchMove(e);
  },
  onTouchEnd(e) {
    dispatchTouchEnd(e);
  },
  onCanvasReady() {
    handleCanvas(this, my, (canvas) => {
      const miniMap = new Map({
        pitch: 56.499,
        center: [114.06, 22.53],
        rotation: 39.19,
        zoom: 13,
      });
      miniScene = new Scene({
        id: 'canvas',
        canvas,
        map: miniMap,
        hasBaseMap: false,
      });
      miniScene.setBgColor('rgb(240, 243, 246)');

      const w = 0.125;
      const h = w * 0.5;
      const lng = 114.06;
      const lat = 22.53;
      const imageLayer = new ImageLayer();
      imageLayer.source(
        'https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*EbL4QIQ3zKoAAAAAAAAAAAAAARQnAQ',
        {
          parser: {
            type: 'image',
            extent: [lng - w, lat - h, lng + w, lat + h],
          },
        },
      );

      getJSON(hexagonData, function (result, data) {
        if (result) {
          const layer = new HeatmapLayer({ zIndex: 1 })
            .source(data, {
              transforms: [
                {
                  type: 'hexagon',
                  size: 100,
                  field: 'h12',
                  method: 'sum',
                },
              ],
            })
            .size('sum', [0, 600])
            .shape('hexagonColumn')
            .style({
              coverage: 0.8,
              angle: 0,
              opacity: 1.0,
            })
            .color(
              'sum',
              [
                '#1D7F7E',
                '#289899',
                '#34B6B7',
                '#4AC5AF',
                '#5FD3A6',
                '#7BE39E',
                '#A1EDB8',
                '#CEF8D6',
              ].reverse(),
            );
          miniScene.addLayer(layer);
          counter.loadLayer();
        }
      });

      miniScene.on('loaded', function () {
        miniScene.addLayer(imageLayer);
        counter.loadLayer();
      });
    });
  },
  onUnload() {
    // 页面被关闭
    miniScene.destroy();
  },
});

```
方法代码
```javascript
function getJSON(url, callback) {
  my.request({
    url,
    method: 'GET',
    data: {
      from: '支付宝',
      production: 'AlipayJSAPI',
    },
    headers: {
      'content-type': 'application/json', // 默认值
    },
    dataType: 'json',
    fail() {
      callback(false, null);
    },
    complete(res) {
      callback(true, res.data);
    },
  });
}

function handleCanvas(_that, my, callback) {
  const selector = my.createSelectorQuery();
  const domSelector = selector.select('#canvas');
  domSelector
    .fields(
      {
        node: true,
        context: false,
        rect: true,
        computedStyle: ['height', 'width'],
      },
      function (res) {
        res.node.left = res.left;
        res.node.top = res.top;

        const DPR = my.getSystemInfoSync().pixelRatio;
        res.node.width *= DPR;
        res.node.height *= DPR;

        callback(res.node);
      },
    )
    .exec();
}

class LayerCounter {
  private loadedLayer = 0;

  private totalLayers: number;

  private my: any;

  private context: any;

  constructor(totalLayers: number, my: any, context: any) {
    this.totalLayers = totalLayers;
    this.my = my;
    this.context = context;
  }

  loadLayer() {
    this.loadedLayer++;
    const that = this;
    if (this.loadedLayer >= this.totalLayers) {
      this.my.hideLoading({
        page: that, // 防止执行时已经切换到其它页面，page 指向不准确
      });
      this.context.setData({
        isLoading: false,
      });
    }
  }
}
```---
title: 图层基类 BaseLayer
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## 简介

L7 Layer 接口设计遵循图形语法，所有图层都继承于基类（baseLayer）。

语法示例

```javascript
const layer = new BaseLayer(option) // option - 传入构造函数的参数对象，提供 layer 的初始状态
  .source(...)    // 传入图层需要的数据以及相关的解析器
  .filter()       // 数据过滤方法
  .shape(...)     // 为图层指定具体的形状，如：circle/triangle 等
  .color(...)     // 指定图层的颜色配置
  .texture(...)   // 指定图层引用的纹理
  .size(...)      // 设置图层元素的大小
  .animate(...)   // 设置图层元素的动画模式
  .active(...)    // 指定图层元素是否支持划过选中
  .select(...)    // 指定图层元素是否支持点击选中
  .style(...);    // 指定图层自定义样式的配置

scene.addLayer(layer);
```

<embed src="@/docs/common/layer/base.zh.md"></embed>
---
title: BaseLayer
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

The L7 Layer interface design follows graphics syntax, and all layers inherit from the base class (baseLayer).

Syntax example

```javascript
const layer = new BaseLayer(option) // option - the parameter object passed into the constructor, providing the initial state of the layer
  .source(...) // Pass in the data required by the layer and related parsers
  .filter() //data filtering method
  .shape(...) // Specify a specific shape for the layer, such as: circle/triangle, etc.
  .color(...) //Specify the color configuration of the layer
  .texture(...) //Specify the texture referenced by the layer
  .size(...) //Set the size of layer elements
  .animate(...) //Set the animation mode of layer elements
  .active(...) //Specify whether the layer element supports swipe selection
  .select(...) //Specify whether the layer element supports click selection
  .style(...); // Specify the configuration of the layer's custom style

scene.addLayer(layer);
```

<embed src="@/docs/common/layer/base.en.md"></embed>
---
title: Shape
order: 3
---

<embed src="@/docs/common/style.md"></embed>

`shape` 方法用于指定面图层绘制图形的类型，如填充图，填充线，挤出集合体等。

### shape('fill')

`shape` 为 `fill` 几何图层用于绘制平面的几何图形。

```js
layer.shape('fill');
```

### shape('extrude')

`shape` 为 `extrude` 几何图层用于绘制 3D 的几何体。

```js
layer.shape('extrude');
```

### extrusion

extrude 图层的升级版, 支持 extrusionBase（基础高度）数据映射

```js
layer.shape('extrusion');

```






### shape('water')

`shape` 为 `water` 几何图层用于绘制平面水体。

```js
layer.shape('water');
```

### shape('ocean')

`shape` 为 `ocean` 几何图层用于绘制平面海洋水体。

```js
layer.shape('ocean');
```

### shape('line')

`shape` 为 `line` 几何图层用于绘制线。

```js
layer.shape('line');
```

### shape('point_fill')

`shape` 为 `point_fill` 几何图层用于绘制填充点。

```js
layer.shape('point_fill');
```

### shape('point_image')

`shape` 为 `point_image` 几何图层用于绘制点图标。

```js
layer.shape('point_image');
```

### shape('point_extrude')

`shape` 为 `point_extrude` 几何图层用于绘制柱子。

```js
layer.shape('point_extrude');
```

### shape('text')

`shape` 为 `text` 几何图层用于绘制文字。

```js
layer.shape('text');
```
---
title: Size
order: 5
---

<embed src="@/docs/common/style.md"></embed>

`size`Method used to set the height of the Polygon

### IPointSize: number ｜\[number, number] | \[number, number, number]

* The size type is number, which represents the height of the Polygon.

```javascript
pointLayer.size(1);
```

### size(width: IPointSize)

The radius can be set directly on the polygon layer. All points in the layer use a height.

```js
layer.size(2);
```

### size(field: string)

The height of a polygon layer can be mapped based on the data values ​​accepted by the layer, accepting fields of incoming data as parameters.

```js
layer.source([
  {
    lng: 120,
    lat: 30,
    r: 2,
  },
]);
layer.size('r');
```

### size(field: string, domain: IPointSize\[])

`size`Method supports simple value mapping and will be based on`field`The values ​​extracted from the data passed into the layer are mapped to`domain`in the value range.

```js
layer.size('type', [1, 2, 3]);
```

### size(field: string, callback: () => IPointSize )

`size`The method supports the writing method of callback function, which will be based on`field`as`callback`method parameters,`callback`The return value of the method is the actual height of the polygon layer.

```js
layer.size('type', (value) => {
  switch (value) {
    case 'path':
      return 1;
    case 'road':
      return 2;
  }
});
```
---
title: Shape
order: 3
---

<embed src="@/docs/common/style.md"></embed>

`shape`The method is used to specify the type of graphics drawn on the surface layer, such as filled graphics, filled lines, extruded aggregates, etc.

### shape('fill')

`shape`for`fill`Geometry layers are used to draw plane geometry.

```js
layer.shape('fill');
```

### shape('extrude')

`shape`for`extrude`Geometry layers are used to draw 3D geometry.

```js
layer.shape('extrude');
```

### extrusion

An upgraded version of the extrude layer, supporting extrusionBase (base height) data mapping

```js
layer.shape('extrusion');
```

### shape('water')

`shape`for`water`Geometry layers are used to draw flat water bodies.

```js
layer.shape('water');
```

### shape('ocean')

`shape`for`ocean`Geometry layers are used to draw flat ocean water bodies.

```js
layer.shape('ocean');
```

### shape('line')

`shape`for`line`Geometry layers are used to draw lines.

```js
layer.shape('line');
```

### shape('point\_fill')

`shape`for`point_fill`Geometry layers are used to draw fill points.

```js
layer.shape('point_fill');
```

### shape('point\_image')

`shape`for`point_image`Geometry layers are used to draw point icons.

```js
layer.shape('point_image');
```

### shape('point\_extrude')

`shape`for`point_extrude`The geometry layer is used to draw the columns.

```js
layer.shape('point_extrude');
```

### shape('text')

`shape`for`text`Geometry layers are used to draw text.

```js
layer.shape('text');
```
---
title: Size
order: 5
---

<embed src="@/docs/common/style.md"></embed>

`size` 方法用于设置 Polygon 的高度

### IPointSize: number ｜[number, number] | [number, number, number]

- size 类型为 number 则表示 Polygon 的高度


```javascript
pointLayer.size(1);

```

### size(width: IPointSize)

面图层可以直接设置半径。图层中所有的点使用一个高度。

```js
layer.size(2);
```

### size(field: string)

面图层的高度可以根据图层接受的数据值进行映射，接受传入数据的字段作为参数。

```js
layer.source([
  {
    lng: 120,
    lat: 30,
    r: 2,
  },
]);
layer.size('r');
```

### size(field: string, domain: IPointSize[])

`size` 方法支持简单的值映射，将根据 `field` 从传入图层的数据中提取的值映射到 `domain` 值域中。

```js
layer.size('type', [1, 2, 3]);
```

### size(field: string, callback: () => IPointSize )

`size` 方法支持回调函数的写法，将根据 `field` 作为 `callback` 方法的参数，`callback` 方法的返回值作为面图层实际高度。

```js
layer.size('type', (value) => {
  switch (value) {
    case 'path':
      return 1;
    case 'road':
      return 2;
  }
});
```
---
title: Style
order: 4
---

<embed src="@/docs/common/style.md"></embed>

`style` 方法用于配制图层的样式，相同图层拥有不同的 `shape` 图形，不同 `shape` 的图层 `style` 方法接受不同的参数。

```js
layer.style({
  opacity: 0.5,
});
```

### common

通用 `style` 参数，所有图形都支持的参数。

| style   | 类型     | 描述         | 默认值 |
| ------- | -------- | ------------ | ------ |
| opacity | `number` | 图形的透明度 | `1`    |

### fill

`shape` 为平面填充几何体。

- [fill](/api/polygon_layer/shape#shapefill)

| style         | 类型             | 描述     | 默认值 |
| ------------- | ---------------- | -------- | ------ |
| raisingHeight | `number`         | 抬升高度 | `0`    |
| opacityLinear | `IOpacityLinear` | 透明渐变 | `/`    |

#### opacityLinear

```js
type IDir = 'in' | 'out';

interface IOpacityLinear {
  enable: false;
  dir: IDir;
}
```

### extrude

`shape` 为挤出几何体。

- [extrude](/api/polygon_layer/shape#shapeextrude)

| style         | 类型      | 描述                       | 默认值  |
| ------------- | --------- | -------------------------- | ------- |
| raisingHeight | `number`  | 抬升高度                   | `0`     |
| heightfixed   | `boolean` | 抬升高度是否随 `zoom` 变化 | `false` |
| topsurface    | `boolean` | 顶部是否显示               | `true`  |
| sidesurface   | `boolean` | 侧面是否显示               | `true`  |
| sourceColor   | `IColor`  | 侧面底部颜色               | `/`     |
| targetColor   | `IColor`  | 侧面顶部颜色               | `/`     |

### extrusion
`shape` 为挤出几何体。

- [extrusion](/api/polygon_layer/shape#extrusion)

| style         | 类型      | 描述       |  是否支持数据映射               | 默认值  |
| ------------- | --------- | -----------| --------------- | ------- |
| extrusionBase | `number`  | 基础高度，单位米     | 支持           | `0`     |


#### linear

几何体图层支持配置渐变效果（sourceColor、targetColor），在配置渐变效果后会覆盖 `layer.color` 方法设置的颜色。

### water

`shape` 为水体表面几何体。

- [water](/api/polygon_layer/shape#shapewater)

| style        | 类型     | 描述     | 默认值 |
| ------------ | -------- | -------- | ------ |
| speed        | `number` | 水波速度 | `0.5`  |
| waterTexture | `string` | 水面贴图 | `0`    |

`waterTexture` 默认值为 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ'

### ocean

`shape` 为海洋表面几何体。

- [ocean](/api/polygon_layer/shape#shapeocean)

| style       | 类型     | 描述     | 默认值    |
| ----------- | -------- | -------- | --------- |
| watercolor  | `IColor` | 水面颜色 | `#6D99A8` |
| watercolor2 | `IColor` | 水面颜色 | `#0F121C` |

### other

几何体图层支持的其他 `shape` 都有对应的图层，可以参考对应图层的样式参数。
---
title: Style
order: 4
---

<embed src="@/docs/common/style.md"></embed>

`style`The method is used to configure the style of the layer. The same layer has different`shape`graphics, different`shape`layer`style`Methods accept different parameters.

```js
layer.style({
  opacity: 0.5,
});
```

### common

Universal`style`Parameters, parameters supported by all graphics.

| style   | type     | describe             | default value |
| ------- | -------- | -------------------- | ------------- |
| opacity | `number` | Graphic transparency | `1`           |

### fill

`shape`Fills the plane with geometry.

* [fill](/api/polygon_layer/shape#shapefill)

| style         | type             | describe             | default value |
| ------------- | ---------------- | -------------------- | ------------- |
| raisingHeight | `number`         | Lifting height       | `0`           |
| opacityLinear | `IOpacityLinear` | transparent gradient | `/`           |

#### opacityLinear

```js
type IDir = 'in' | 'out';

interface IOpacityLinear {
  enable: false;
  dir: IDir;
}
```

### extrude

`shape`for extruded geometry.

* [extrude](/api/polygon_layer/shape#shapeextrude)

| style         | type      | describe                                   | default value |
| ------------- | --------- | ------------------------------------------ | ------------- |
| raisingHeight | `number`  | Lifting height                             | `0`           |
| heightfixed   | `boolean` | Does the lifting height vary?`zoom`Variety | `false`       |
| topsurface    | `boolean` | Whether to display the top                 | `true`        |
| sidesurface   | `boolean` | Whether to display on the side             | `true`        |
| sourceColor   | `IColor`  | Side bottom color                          | `/`           |
| targetColor   | `IColor`  | side top color                             | `/`           |

### extrusion

`shape`for extruded geometry.

* [extrusion](/api/polygon_layer/shape#extrusion)

| style         | type     | describe              | Whether to support data mapping | default value |
| ------------- | -------- | --------------------- | ------------------------------- | ------------- |
| extrusionBase | `number` | Base height in meters | support                         | `0`           |

#### linear

The geometry layer supports configuring gradient effects (sourceColor, targetColor), which will be overwritten after configuring the gradient effect.`layer.color`Method to set the color.

### water

`shape`is the water surface geometry.

* [water](/api/polygon_layer/shape#shapewater)

| style        | type     | describe              | default value |
| ------------ | -------- | --------------------- | ------------- |
| speed        | `number` | water wave speed      | `0.5`         |
| waterTexture | `string` | water surface texture | `0`           |

`waterTexture`The default value is '<https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ>'

### ocean

`shape`is the ocean surface geometry.

* [ocean](/api/polygon_layer/shape#shapeocean)

| style       | type     | describe    | default value |
| ----------- | -------- | ----------- | ------------- |
| watercolor  | `IColor` | water color | `#6D99A8`     |
| watercolor2 | `IColor` | water color | `#0F121C`     |

### other

Others supported by geometry layers`shape`There are corresponding layers. You can refer to the style parameters of the corresponding layers.
---
title: Animate
order: 7
---

<embed src="@/docs/common/style.md"></embed>

The geometry layer is`shape`for`water`or`ocean`When you will get a flowing water surface, at this time we need to use`animate`Method to enable animation.

<div>
  <div style="width:40%;float:left; margin: 16px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BiawTbtX-CYAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### animate(boolean)

`animate`The method supports Boolean and object passing values.

```javascript
layer.animate(true);

layer.animate({
  enable: true,
});
```
---
title: Animate
order: 7
---

<embed src="@/docs/common/style.md"></embed>

几何体图层在 `shape` 为 `water` 或 `ocean` 的时候会得到流动的水面，此时我们需要使用 `animate` 方法开启动画。

<div>
  <div style="width:40%;float:left; margin: 16px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BiawTbtX-CYAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

### animate(boolean)

`animate` 方法支持布尔值和对象传值。

```javascript
layer.animate(true);

layer.animate({
  enable: true,
});
```
---
title: Scale
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/scale.zh.md"></embed>
---
title: Scale
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/scale.en.md"></embed>
---
title: Color
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/color.zh.md"></embed>
---
title: Color
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/color.en.md"></embed>
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/options.zh.md"></embed>
---
title: Source
order: 2
---

<embed src="@/docs/common/style.md"></embed>

几何体图层数据推荐使用 GeoJSON 格式的数据。

- [GeoJSON](/api/source/geojson/#point)

### GeoJSON

```js
// 传入 GeoJSON 类型数据 *** L7 默认支持，不需要 parser 解析
const data = {
  type: 'FeatureCollection',
  features: [
    {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'Polygon',
        coordinates: [
          [
            [104.4140625, 35.460669951495305],
            [98.7890625, 24.206889622398023],
            [111.796875, 27.371767300523047],
            [104.4140625, 35.460669951495305],
          ],
        ],
      },
    },
  ],
};

const layer = new PolygonLayer().source(data);
```
---
title: Source
order: 2
---

<embed src="@/docs/common/style.md"></embed>

It is recommended to use GeoJSON format data for geometry layer data.

* [GeoJSON](/api/source/geojson/#point)

### GeoJSON

```js
// Pass in GeoJSON type data *** L7 supports it by default and does not require parser analysis
const data = {
  type: 'FeatureCollection',
  features: [
    {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'Polygon',
        coordinates: [
          [
            [104.4140625, 35.460669951495305],
            [98.7890625, 24.206889622398023],
            [111.796875, 27.371767300523047],
            [104.4140625, 35.460669951495305],
          ],
        ],
      },
    },
  ],
};

const layer = new PolygonLayer().source(data);
```
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/options.en.md"></embed>
---
title: PolygonLayer
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

Draws 2D polygons and 3D shapes stretched along the Z axis.

## use

```javascript
import { PolygonLayer } from '@antv/l7';
const layer = new PolygonLayer()
  .source({
    type: 'FeatureCollection',
    features: [
      {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'Polygon',
          coordinates: [
            [
              [104.4140625, 35.460669951495305],
              [98.7890625, 24.206889622398023],
              [111.796875, 27.371767300523047],
              [104.4140625, 35.460669951495305],
            ],
          ],
        },
      },
    ],
  })
  .shape('fill')
  .color('#f00')
  .style({
    opacity: 0.6,
  });
```
---
title: PolygonLayer
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## 简介

绘制 2D 多边形以及沿 Z 轴拉伸后的 3D 图形。

## 使用

```javascript
import { PolygonLayer } from '@antv/l7';
const layer = new PolygonLayer()
  .source({
    type: 'FeatureCollection',
    features: [
      {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'Polygon',
          coordinates: [
            [
              [104.4140625, 35.460669951495305],
              [98.7890625, 24.206889622398023],
              [111.796875, 27.371767300523047],
              [104.4140625, 35.460669951495305],
            ],
          ],
        },
      },
    ],
  })
  .shape('fill')
  .color('#f00')
  .style({
    opacity: 0.6,
  });
```
---
title: RasterTile 栅格瓦片
order: 7
---

<embed src="@/docs/common/style.md"></embed>

When L7 loads the raster tile map, it needs to be`source`Parse the tile service and configure the request parameters of the tile service.

## data

Tile URL, only supports EPSG 3857 coordinate system, supports TMS, WMS, WMTS protocols

### TMS

Pass parameters through url template, required to participate`{}`

* 1-4 server encoding {1-4}
* z zoom level
* x tile x coordinate
* y tile y coordinate

```js
const url =
  'http://webst0{1-4}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}';
```

### WMS

url template parameters

* 1-x server encoding {1-4}
* bbox tile range template BBOXSR only supports 4326, IMAGESR only supports 3857

Example

```js
const url =
  'https://pnr.sz.gov.cn/d-suplicmap/dynamap_1/rest/services/LAND_CERTAIN/MapServer/export?F=image&FORMAT=PNG32&TRANSPARENT=true&layers=show:1&SIZE=256,256&BBOX={bbox}&BBOXSR=4326&IMAGESR=3857&DPI=90';
```

### WMTS

url template parameters

* 1-4 server encoding {1-4}

WMTS two ways

* The usage is similar to TMS, you can splice url strings
* Set service parameters through parser parameter wmtsOptions

```js
const url1 =
  'https://t0.tianditu.gov.cn/img_w/wmts?tk=b72aa81ac2b3cae941d1eb213499e15e&';
const layer1 = new RasterLayer({
  zIndex: 1,
}).source(url1, {
  parser: {
    type: 'rasterTile',
    tileSize: 256,
    wmtsOptions: {
      layer: 'img',
      tileMatrixset: 'w',
      format: 'tiles',
    },
  },
});
```

## parser

### type

<description> *string* **required** *default:* rasterTile</description>The fixed value is`rasterTile`

### tileSize `number`

<description> *number* **Optional** *default:* 256</description>Request tile size optional

### zoomOffset

<description> number **Optional** *default:*0</description>Tile request tile level offset

### maxZoom

<description> *number* **Optional** *default:*0</description>

Maximum tile zoom level`20`

### minZoom tile minimum zoom, etc.

<description> *number* **Optional** *default:* 2-</description>

### extent `[number, number, number, number]`Map display range

<description> *number\[]* **Optional**not limited:\_</description>

### dataType

<description> *string* **Optional** *default:* image</description>

Tile data type

* image image type
* arraybuffer data type such as geotiff

### format function,

<description> *func* **Optional**\_default:</description>

Used when data raster is used to format raster data into standard data and customize data processing functions

### wmtsOptions wmsts configuration

<description> *Object* **Optional** *default:* null</description>

#### layer

<description> *string* **required** *default:* img</description>Layers

#### tileMatrixset

<description> *string* **required** *default:* w</description>

#### format

<description> *string* **required** *default:* tiles</description>Service type

```javascript
const rasterSource = new Source(
  'http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
  {
    parser: {
      type: 'rasterTile',
      tileSize: 256,
      zoomOffset: 0,
      extent: [-180, -85.051129, 179, 85.051129],
    },
  },
);
```

<embed src="@/docs/common/source/tile/method.en.md"></embed>
---
title: RasterTile 栅格瓦片
order: 7
---

<embed src="@/docs/common/style.md"></embed>

L7 加载栅格瓦片地图的时候需要在 `source` 中对瓦片服务进行解析，同时配置瓦片服务的请求参数。

## data

瓦片 URL,仅支持 EPSG 3857 的坐标系，支持 TMS、WMS、WMTS 协议

### TMS

通过 url 模板传参，参与需要使用 `{}`

- 1-4 服务器编码 {1-4}
- z 缩放等级
- x 瓦片 x 坐标
- y 瓦片 y 坐标

```js
const url =
  'http://webst0{1-4}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}';
```

### WMS

url 模板参数

- 1-x 服务器编码 {1-4}
- bbox 瓦片范围模板 BBOXSR 只支持 4326,IMAGESR 只支持 3857

示例

```js
const url =
  'https://pnr.sz.gov.cn/d-suplicmap/dynamap_1/rest/services/LAND_CERTAIN/MapServer/export?F=image&FORMAT=PNG32&TRANSPARENT=true&layers=show:1&SIZE=256,256&BBOX={bbox}&BBOXSR=4326&IMAGESR=3857&DPI=90';
```

### WMTS

url 模板参数

- 1-4 服务器编码 {1-4}

WMTS 两种方式

- 使用方式和 TMS 相似，可以拼接 url 字符串
- 通过 parser 参数 wmtsOptions 设置服务参数

```js
const url1 =
  'https://t0.tianditu.gov.cn/img_w/wmts?tk=b72aa81ac2b3cae941d1eb213499e15e&';
const layer1 = new RasterLayer({
  zIndex: 1,
}).source(url1, {
  parser: {
    type: 'rasterTile',
    tileSize: 256,
    wmtsOptions: {
      layer: 'img',
      tileMatrixset: 'w',
      format: 'tiles',
    },
  },
});
```

## parser

### type

<description> _string_ **必选** _default:_ rasterTile</description>
固定值为 `rasterTile`

### tileSize `number`

<description> _number_ **可选** _default:_ 256</description>
请求瓦片的大小 optional

### zoomOffset

<description> number **可选** _default:_ 0</description>
瓦片请求瓦片层级的偏移

### maxZoom

<description> _number_ **可选** _default:_ 0</description>

瓦片最大缩放等级 `20`

### minZoom 瓦片最小缩放等

<description> _number_ **可选** _default:_ 2-</description>

### extent `[number, number, number, number]` 地图显示范围

<description> _number[]_ **可选** 不限制:\_ </description>

### dataType

<description> _string_ **可选** _default:_ image</description>

瓦片数据类型

- image 图像类型
- arraybuffer 数据类型如 geotiff

### format func,

<description> _func_ **可选** \_default:</description>

数据栅格时使用,用于将栅格数据格式化为标准数据,自定义数据处理函数

### wmtsOptions wmsts 配置

<description> _Object_ **可选** _default:_ null</description>

#### layer

<description> _string_ **必选** _default:_ img</description>
图层

#### tileMatrixset

<description> _string_ **必选** _default:_ w</description>

#### format

<description> _string_ **必选** _default:_ tiles</description>
服务类型

```javascript
const rasterSource = new Source(
  'http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
  {
    parser: {
      type: 'rasterTile',
      tileSize: 256,
      zoomOffset: 0,
      extent: [-180, -85.051129, 179, 85.051129],
    },
  },
);
```
<embed src="@/docs/common/source/tile/method.zh.md"></embed>
---
title: GeoJSON
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## 简介

GeoJSON 是一种对各种地理数据结构进行编码的格式。GeoJSON 对象可以表示几何、特征或者特征集合。GeoJSON 支持下面几何类型：点、线、面、多点、多线、多面和几何集合。GeoJSON 里的特征包含一个几何对象和其他属性，特征集合表示一系列特征。
[The GeoJSON Format](https://tools.ietf.org/html/draft-butler-geojson-06)

L7 数据 source 支持   传入 Geometry 集合 FeatureCollection

### Feature Collection Object

一个 feature Colletion 由对个 feature 组成

```json
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {
        "name": "tom"
      },
      "geometry": {
        "type": "Polygon",
        "coordinates": [
          [
            [-2.8125, 34.59704151614417],
            [65.390625, 34.59704151614417],
            [65.390625, 61.10078883158897],
            [-2.8125, 61.10078883158897],
            [-2.8125, 34.59704151614417]
          ]
        ]
      }
    }
  ]
}
```

### Feature Object

一个 feature 有 geometry 空间信息，properties 属性信息，其中 geometry 是必须字段

```json
{
  "type": "Feature",
  "properties": {},
  "geometry": {}
}
```

### Gemetry Object

支持 Gemetry Object 类型

#### Point

```json
{
  "type": "Point",
  "coordinates": [100.0, 0.0]
}
```

#### MultiPoint

```json
{
  "type": "MultiPoint",
  "coordinates": [
    [100.0, 0.0],
    [101.0, 1.0]
  ]
}
```

Line

#### LineSring

```json
{
  "type": "LineString",
  "coordinates": [
    [100.0, 0.0],
    [101.0, 1.0]
  ]
}
```

#### MultiLineString

```json
{
  "type": "MultiLineString",
  "coordinates": [
    [
      [100.0, 0.0],
      [101.0, 1.0]
    ],
    [
      [102.0, 2.0],
      [103.0, 3.0]
    ]
  ]
}
```

Polygon

#### Polygon

```json
{
  "type": "Polygon",
  "coordinates": [
    [
      [100.0, 0.0],
      [101.0, 0.0],
      [101.0, 1.0],
      [100.0, 1.0],
      [100.0, 0.0]
    ]
  ]
}
```

With holes:

```json
{
  "type": "Polygon",
  "coordinates": [
    [
      [-170.0, 10.0],
      [170.0, 10.0],
      [170.0, -10.0],
      [-170.0, -10.0],
      [-170.0, 10.0]
    ],
    [
      [175.0, 5.0],
      [-175.0, 5.0],
      [-175.0, -5.0],
      [175.0, -5.0],
      [175.0, 5.0]
    ]
  ]
}
```

#### MultiPolygon

```json
{
  "type": "MultiPolygon",
  "coordinates": [
    [
      [
        [102.0, 2.0],
        [103.0, 2.0],
        [103.0, 3.0],
        [102.0, 3.0],
        [102.0, 2.0]
      ]
    ],
    [
      [
        [100.0, 0.0],
        [101.0, 0.0],
        [101.0, 1.0],
        [100.0, 1.0],
        [100.0, 0.0]
      ],
      [
        [100.2, 0.2],
        [100.8, 0.2],
        [100.8, 0.8],
        [100.2, 0.8],
        [100.2, 0.2]
      ]
    ]
  ]
}
```

[geojson 详细文档]()

## Geojson 相关的 JS 库

### 地理统计分析工具

[turfjs](http://turfjs.org/):   地理数据计算，处理，统计，分析的 Javascript 库

### 在线工具：

[http://geojson.io/](http://geojson.io/)     可以在线查看，绘制，修改 GeoJSON 数据

[https://mapshaper.org/](https://mapshaper.org/) 可以查看较大的 geojson，还能够简化 GeoJSON 数据
---
title: GeoJSON
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

GeoJSON is a format for encoding various geographic data structures. GeoJSON objects can represent geometries, features, or collections of features. GeoJSON supports the following geometry types: point, line, polygon, multipoint, multiline, polygon, and geometry collection. A feature in GeoJSON contains a geometric object and other attributes, and a feature collection represents a series of features.[The GeoJSON Format](https://tools.ietf.org/html/draft-butler-geojson-06)

L7 data source supports passing in the Geometry collection FeatureCollection

### Feature Collection Object

A feature Collection consists of pairs of features

```json
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {
        "name": "tom"
      },
      "geometry": {
        "type": "Polygon",
        "coordinates": [
          [
            [-2.8125, 34.59704151614417],
            [65.390625, 34.59704151614417],
            [65.390625, 61.10078883158897],
            [-2.8125, 61.10078883158897],
            [-2.8125, 34.59704151614417]
          ]
        ]
      }
    }
  ]
}
```

### Feature Object

A feature has geometry spatial information and properties attribute information, where geometry is a required field.

```json
{
  "type": "Feature",
  "properties": {},
  "geometry": {}
}
```

### Gemetry Object

Supports Gemetry Object type

#### Point

```json
{
  "type": "Point",
  "coordinates": [100.0, 0.0]
}
```

#### MultiPoint

```json
{
  "type": "MultiPoint",
  "coordinates": [
    [100.0, 0.0],
    [101.0, 1.0]
  ]
}
```

Line

#### LineSring

```json
{
  "type": "LineString",
  "coordinates": [
    [100.0, 0.0],
    [101.0, 1.0]
  ]
}
```

#### MultiLineString

```json
{
  "type": "MultiLineString",
  "coordinates": [
    [
      [100.0, 0.0],
      [101.0, 1.0]
    ],
    [
      [102.0, 2.0],
      [103.0, 3.0]
    ]
  ]
}
```

Polygon

#### Polygon

```json
{
  "type": "Polygon",
  "coordinates": [
    [
      [100.0, 0.0],
      [101.0, 0.0],
      [101.0, 1.0],
      [100.0, 1.0],
      [100.0, 0.0]
    ]
  ]
}
```

With holes:

```json
{
  "type": "Polygon",
  "coordinates": [
    [
      [-170.0, 10.0],
      [170.0, 10.0],
      [170.0, -10.0],
      [-170.0, -10.0],
      [-170.0, 10.0]
    ],
    [
      [175.0, 5.0],
      [-175.0, 5.0],
      [-175.0, -5.0],
      [175.0, -5.0],
      [175.0, 5.0]
    ]
  ]
}
```

#### MultiPolygon

```json
{
  "type": "MultiPolygon",
  "coordinates": [
    [
      [
        [102.0, 2.0],
        [103.0, 2.0],
        [103.0, 3.0],
        [102.0, 3.0],
        [102.0, 2.0]
      ]
    ],
    [
      [
        [100.0, 0.0],
        [101.0, 0.0],
        [101.0, 1.0],
        [100.0, 1.0],
        [100.0, 0.0]
      ],
      [
        [100.2, 0.2],
        [100.8, 0.2],
        [100.8, 0.8],
        [100.2, 0.8],
        [100.2, 0.2]
      ]
    ]
  ]
}
```

[geojson detailed documentation]()

## Geojson related JS libraries

### Geostatistical analysis tools

[turfjs](http://turfjs.org/): Javascript library for geographic data calculation, processing, statistics, and analysis

### Online tools:

<http://geojson.io/>You can view, draw and modify GeoJSON data online

<https://mapshaper.org/>Ability to view larger geojson and also simplify GeoJSON data
---
title: Raster RGB
order: 5
---

<embed src="@/docs/common/source/raster/raster_rgb.zh.md"></embed>
---
title: Raster RGB
order: 5
---

<embed src="@/docs/common/source/raster/raster_rgb.en.md"></embed>
---
title: Raster
order: 5
---

<embed src="@/docs/common/style.md"></embed>

Raster 图层主要实现栅格数据的可视化，栅格数据主要来源是卫星遥感数据，如数字高程图，植被分布图，夜光图。

<embed src="@/docs/common/source/raster/raster_single.zh.md"></embed>
---
title: Raster
order: 5
---

<embed src="@/docs/common/style.md"></embed>

The Raster layer mainly realizes the visualization of raster data. The main source of raster data is satellite remote sensing data, such as digital elevation map, vegetation distribution map, and night light map.

<embed src="@/docs/common/source/raster/raster_single.zh.md"></embed>
---
title: Source
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## 简介

source 地理数据处理模块，主要包含数据解析（parser)，和数据处理（transform）。

```js
const source = new Source(data, option);
```

- data
- option
  - cluster **boolean** 是否聚合
  - clusterOptions 聚合配置项
  - parser 数据解析配置
  - transforms 数据处理配置

## data

不同 parser 类型对应不同 data 类型

- 瓦片图层 data 为 url 模板，支持 TMS、WMS、WMTS 数据服务
- 非瓦片图层 data 为数据对象

## option

`source` 通过 `option` 来描述如果处理数据， 其中主要包括 `parser` 和 `transforms`。

### parser

不同数据类型处理成统一数据格式。矢量数据包括 GeoJON， CSV，Json 等不同数据格式，栅格数据，包括 Raster，Image 数据。将来还会支持瓦片格式数据。

空间数据分矢量数据，栅格数据和瓦片三大类

- 矢量数据 支持 csv，geojson，json 三种数据类型
- 栅格数据 支持 image，Raster
- 瓦片服务 支持 mvt、rasterTile、geojsonvt

```js
type IParserType =
  | 'csv'
  | 'json'
  | 'geojson'
  | 'image'
  | 'raster'
  | 'rasterTile'
  | 'mvt'
  | 'geojsonvt';
interface IParser {
  type: IParserType;
  x?: string;
  y?: string;
  x1?: string;
  y1?: string;
  coordinates?: string;
  geometry?: string;
  [key: string]: any;
}
```

#### geojson

[geojson](https://www.yuque.com/antv/l7/dm2zll) 数据为默认数据格式，可以 不设置 parser 参数

```javascript
layer.source(data);
```

### transforms

tranforms 处理的是的标准化之后的数据，进行数据转换，数据统计，网格布局，数据聚合等数据操作，处理完之后返回的也是标准数据。  
标准化之后的数据结构包括 coordinates 地理坐标字段，以及其他属性字段。

```json
[
  {
    "coordinates": [[]], // 地理坐标字段
    "_id": "122", // 标准化之后新增字段
    "name": "test",
    "value": 1
    // ....
  }
]
```

目前支持两种热力图使用的数据处理方法 grid，hexagon transform 配置项

- type 数据处理类型
- tansform cfg  数据处理配置项

#### grid

生成方格网布局，根据数据字段统计，主要在网格热力图中使用

- type: 'grid',
- size: 网格半径
- field: 数据统计字段
- method: 聚合方法  count,max,min,sum,mean 5 个统计维度

```javascript
layer.source(data, {
  transforms: [
    {
      type: 'grid',
      size: 15000,
      field: 'v',
      method: 'sum',
    },
  ],
});
```

#### hexagon

生成六边形网格布局，根据数据字段统计

- type: 'hexagon',
- size: 网格半径
- field: 数据统计字段
- method:聚合方法   count,max,min,sum,mean 5 个统计维度

#### join

数据连接，业务中跟多情况是地理数据和业务数据分开的两套数据，我们可与通过 join 方法将地理数据和业务数据进行关联。

**配置项**

- type: join
- sourceField 需要连接的业务数据字段名称
- data 需要连接的数据源 仅支持 json 格式
- targetField 关联的地理数据字段名称

```javascript
const data = {
  type: 'FeatureCollection',
  features: [
    {
      type: 'Feature',
      properties: {
        city: '北京',
      },
      geometry: {},
    },
  ],
};

const data2 = [
  {
    name: '北京',
    value: 13,
  },
  {
    name: '天津',
    value: 20,
  },
];
// data 是地理数据
// data2 属性数据或者业务数据

// 通过join方法我们就可以将两个数据连接到一起

layer
  .source(data, {
    transforms: [
      {
        type: 'join',
        sourceField: 'name', //data1 对应字段名
        targetField: 'city', // data 对应字段名 绑定到的地理数据
        data: data2,
      },
    ],
  })
  .color('value'); // 可以采用data1的value字段进行数据到颜色的映射
```

### cluster

- cluster: `boolean`

`cluster` 表示是否对数据进行聚合操作， 目前只有点图层支持。

### clusterOption 可选

- radius 聚合半径 **number** default 40
- minZoom: 最小聚合缩放等级 **number** default 0
- maxZoom: 最大聚合缩放等级 **number** default 16

[聚合图使用案例](/examples/point/cluster#cluster)

## 方法

### getClustersLeaves(cluster_id)

聚合图使用，获取聚合节点的原始数据

参数：
id 聚合节点的 cluster_id

```javascript
layer.on('click', (e) => {
  console.log(source.getClustersLeaves(e.feature.cluster_id));
});
```

### setData

更新 source 数据

#### 参数

- data 数据同 source 初始化参数
- option 配置项同 source 初始化参数

### getFeatureById

根据 featurID 获取 feature 要素

#### 参数

- id featureId，L7 内部编码的唯一要素 ID

```tsx
const source = layer.getSource();
source.getFeatureById(1);
```

### updateFeaturePropertiesById

根据 ID 更新 source 的属性数据，会触发从新渲染

#### 参数

- id featureId，L7 内部编码的唯一要素 ID
- Properties 需要更新属性数据，merge 操作

```tsx
const source = layer.getSource();
layer.on('click', (e) => {
  source.updateFeaturePropertiesById(e.featureId, {
    name: Math.random() * 10,
  });
});
```

### getFeatureId

根据属性的 key、value 获取要素 L7 编码 featureId，确保该属性的 value 是唯一值，如存在多个返回第一个。

#### 参数

- key: 属性字段
- value: 对应的值

```tsx
const source = layer.getSource();
source.getFeatureId('name', '张三');
```

## Source 更新

如果数据发生改变，可以需要更新数据。
可以通过调用 `layer` 的 `setData` 方法实现数据的更新。

具体见 [Layer](/api/base_layer/base/#setdata)

```javascript
layer.setData(data);
```
<embed src="@/docs/common/source/tile/method.zh.md"></embed>

### 数据类型

#### JSON

[JSON 数据格式解析](/api/source/json)

#### csv

[CSV 数据格式解析](/api/source/csv)

栅格数据类型

#### image

[Image 数据格式解析](/api/source/image)
---
title: Source
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

The source geographical data processing module mainly includes data analysis (parser) and data processing (transform).

```js
const source = new Source(data, option);
```

* data
* option
  * cluster **boolean**Whether to aggregate
  * clusterOptions aggregation configuration items
  * parser data parsing configuration
  * transforms data processing configuration

## data

Different parser types correspond to different data types

* The tile layer data is a url template and supports TMS, WMS, and WMTS data services.
* Non-tile layer data is a data object

## option

`source`pass`option`to describe how the data is processed, which mainly include`parser`and`transforms`。

### parser

Different data types are processed into a unified data format. Vector data includes different data formats such as GeoJON, CSV, and Json, and raster data includes Raster and Image data. Tile format data will also be supported in the future.

Spatial data is divided into three categories: vector data, raster data and tiles

* Vector data supports three data types: csv, geojson, and json.
* Raster data supports image, Raster
* Tile service supports mvt, rasterTile, geojsonvt

```js
type IParserType =
  | 'csv'
  | 'json'
  | 'geojson'
  | 'image'
  | 'raster'
  | 'rasterTile'
  | 'mvt'
  | 'geojsonvt';
interface IParser {
  type: IParserType;
  x?: string;
  y?: string;
  x1?: string;
  y1?: string;
  coordinates?: string;
  geometry?: string;
  [key: string]: any;
}
```

#### geojson

[geojson](https://www.yuque.com/antv/l7/dm2zll)The data is in the default data format, and the parser parameter does not need to be set.

```javascript
layer.source(data);
```

### transforms

Transforms processes standardized data and performs data operations such as data conversion, data statistics, grid layout, and data aggregation. After processing, standard data is returned.\
The standardized data structure includes coordinates geographical coordinate fields, and other attribute fields.

```json
[
  {
    "coordinates": [[]], // Geographical coordinates field
    "_id": "122", // New fields after standardization
    "name": "test",
    "value": 1
    // ....
  }
]
```

Currently, two data processing methods used in heat maps are supported: grid and hexagon transform configuration items

* type data processing type
* tansform cfg data processing configuration items

#### grid

Generate a square grid layout, based on data field statistics, mainly used in grid heat maps

* type: 'grid',
* size: grid radius
* field: data statistics field
* method: aggregation method count,max,min,sum,mean 5 statistical dimensions

```javascript
layer.source(data, {
  transforms: [
    {
      type: 'grid',
      size: 15000,
      field: 'v',
      method: 'sum',
    },
  ],
});
```

#### hexagon

Generate hexagonal grid layout, statistics based on data fields

* type: 'hexagon',
* size: grid radius
* field: data statistics field
* method: aggregation method count, max, min, sum, mean 5 statistical dimensions

#### join

Data connection, in many cases in business, geographical data and business data are two separate sets of data. We can associate geographical data and business data through the join method.

**Configuration items**

* type: join
* sourceField The name of the business data field that needs to be connected
* data The data source to be connected only supports json format
* targetField associated geographic data field name

```javascript
const data = {
  type: 'FeatureCollection',
  features: [
    {
      type: 'Feature',
      properties: {
        city: 'Beijing',
      },
      geometry: {},
    },
  ],
};

const data2 = [
  {
    name: 'Beijing',
    value: 13,
  },
  {
    name: 'Tianjin',
    value: 20,
  },
];
// data is geographical data
// data2 attribute data or business data

// We can join two data together through the join method

layer
  .source(data, {
    transforms: [
      {
        type: 'join',
        sourceField: 'name', //data1 corresponding field name
        targetField: 'city', // data corresponds to the field name and is bound to the geographical data
        data: data2,
      },
    ],
  })
  .color('value'); // You can use the value field of data1 to map data to color.
```

### cluster

* cluster:`boolean`

`cluster`Indicates whether to aggregate data. Currently, only point layers support it.

### clusterOption optional

* radius aggregate radius**number**default 40
* minZoom: Minimum aggregate zoom level**number**default 0
* maxZoom: Maximum aggregate zoom level**number** default 16

[Aggregation graph use cases](/examples/point/cluster#cluster)

## method

### getClustersLeaves(cluster\_id)

Use the aggregation graph to obtain the original data of the aggregation node

parameter:
id cluster\_id of the aggregation node

```javascript
layer.on('click', (e) => {
  console.log(source.getClustersLeaves(e.feature.cluster_id));
});
```

### setData

Update source data

#### parameter

* data data is the same as source initialization parameter
* option configuration item is the same as source initialization parameter

### getFeatureById

Get feature elements based on featureID

#### parameter

* id featureId, unique feature ID encoded internally by L7

```tsx
const source = layer.getSource();
source.getFeatureById(1);
```

### updateFeaturePropertiesById

Updating source's attribute data based on ID will trigger re-rendering

#### parameter

* id featureId, unique feature ID encoded internally by L7
* Properties needs to update attribute data, merge operation

```tsx
const source = layer.getSource();
layer.on('click', (e) => {
  source.updateFeaturePropertiesById(e.featureId, {
    name: Math.random() * 10,
  });
});
```

### getFeatureId

Obtain the feature L7 encoding featureId based on the key and value of the attribute, and ensure that the value of the attribute is a unique value. If there are multiple, return the first one.

#### parameter

* key: attribute field
* value: corresponding value

```tsx
const source = layer.getSource();
source.getFeatureId('name', '张三');
```

## Source update

If the data changes, the data may need to be updated.
This can be done by calling`layer`of`setData`Method to update data.

For details, see[Layer](/api/base_layer/base/#setdata)

```javascript
layer.setData(data);
```

<embed src="@/docs/common/source/tile/method.zh.md"></embed>

### type of data

#### JSON

[JSON data format parsing](/api/source/json)

#### csv

[CSV data format analysis](/api/source/csv)

Raster data type

#### image

[Image data format analysis](/api/source/image)
---
title: CSV
order: 3
---

<embed src="@/docs/common/style.md"></embed>

L7 supports CSV comma delimited CSV data loading.

CSV is a text data structure and it is difficult to express complex geographic data structures, so CSV only supports two data structures.

* Point data requires specifying longitude and latitude coordinates
* Line segment and arc data need to specify the longitude and latitude coordinates of the starting and ending points

## parser

* type string required json
* x string point data represents longitude
* y string point data represents latitude
* x1 string longitude
* x2 string latitude

### Point data loaded via CSV

```javascript
layer.source(data, {
  parser: {
    type: 'csv',
    x: 'lng',
    y: 'lat',
  },
});
```

[CSV data demo example](/examples/point/bubble#scatter)

### Segment arc data is loaded via CSV

```javascript
layer.source(data, {
  parser: {
    type: 'csv',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng1',
    y1: 'lat2',
  },
});
```

[CSV line segment data demo example](/examples/gallery/basic#arccircle)
---
title: CSV
order: 3
---

<embed src="@/docs/common/style.md"></embed>

L7 支持 CSV 以逗号分隔的 CSV 数据加载。

CSV 是文本数据结构，很难表达复杂的地理数据结构，因此 CSV 仅支持两种数据结构

- 点数据 需要指定经度，纬度坐标
- 线段，弧线数据 需要指定 起止点的 经度，纬度坐标

## parser

- type string 必选 json
- x string 点数据表示 经度
- y string 点数据表示 纬度
- x1 string 经度
- x2 string 纬度

### 点数据通过 CSV 加载

```javascript
layer.source(data, {
  parser: {
    type: 'csv',
    x: 'lng',
    y: 'lat',
  },
});
```

[CSV 数据 demo 示例](/examples/point/bubble#scatter)

### 线段弧线数据通过 CSV 加载

```javascript
layer.source(data, {
  parser: {
    type: 'csv',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng1',
    y1: 'lat2',
  },
});
```

[CSV 线段数据 demo 示例](/examples/gallery/basic#arccircle)
---
title: MVTTile 矢量瓦片
order: 6
---

<embed src="@/docs/common/style.md"></embed>

When L7 loads the vector tile map, it needs to be`source`Parse the tile service and configure the request parameters of the tile service.

## parser

### type

<description> *string* **required** *default:* mvt</description>

### tileSize `number`

<description> *number* **Optional** *default:* 256</description>Request tile size

### zoomOffset

<description> number **Optional** *default:*0</description>Tile request tile level offset

### maxZoom

<description> *number* **Optional** *default:*0</description>Maximum tile zoom level`20`

### minZoom

<description> *number* **Optional** *default:* 2-</description>Tile minimum scaling, etc.

### extent `[number, number, number, number]`

<description> *number\[]* **Optional**not limited:\_</description>Map display range

### getCustomData `(tile: { x: number, y: number, z: number }, callback: (err: any, data: any) => void) => void,`

<description>\_\_**Optional**</description>

callback parameters

* err when data is returned
* data arraybuffer type, pbf

Customize the tile data acquisition method, trial business scenarios require data authentication, or special processing scenarios

<embed src="@/docs/common/source/tile/method.en.md"></embed>

## Example

### Universal

```javascript
const tileSource = new Source(
  'http://localhost:3000/zhejiang.mbtiles/{z}/{x}/{y}.pbf',
  {
    parser: {
      type: 'mvt',
      tileSize: 256,
      zoomOffset: 0,
      maxZoom: 9,
      extent: [-180, -85.051129, 179, 85.051129],
    },
  },
);
```

### Custom method

```javascript
const source = new Source(
  'https://gridwise.alibaba-inc.com/tile/test?z={z}&x={x}&y={y}',
  {
    parser: {
      type: 'mvt',
      tileSize: 256,
      getCustomData: (tile, cb) => {
        const url = `https://gridwise.alibaba-inc.com/tile/test?z=${tile.z}&x=${tile.x}&y=${tile.y}`;
        fetch(url)
          .then((res) => res.arrayBuffer())
          .then((data) => {
            cb(null, data);
          });
      },
    },
  },
);
```
---
title: MVTTile 矢量瓦片
order: 6
---

<embed src="@/docs/common/style.md"></embed>

L7 加载矢量瓦片地图的时候需要在 `source` 中对瓦片服务进行解析，同时配置瓦片服务的请求参数。

## parser

### type

<description> _string_ **必选** _default:_ mvt</description>

### tileSize `number`

<description> _number_ **可选** _default:_ 256</description>
请求瓦片的大小

### zoomOffset

<description> number **可选** _default:_ 0</description>
瓦片请求瓦片层级的偏移

### maxZoom

<description> _number_ **可选** _default:_ 0</description>
瓦片最大缩放等级 `20`

### minZoom

<description> _number_ **可选** _default:_ 2-</description>
瓦片最小缩放等

### extent `[number, number, number, number]`

<description> _number[]_ **可选** 不限制:\_ </description>
地图显示范围

### getCustomData `(tile: { x: number, y: number, z: number }, callback: (err: any, data: any) => void) => void,`

<description> \_\_ **可选**</description>

callback 参数

- err 数据返回时
- data arrarybuffer 类型， pbf

自定义瓦片数据获取方法,试用业务场景需要数据鉴权，或者特殊处理的场景

<embed src="@/docs/common/source/tile/method.zh.md"></embed>

## 示例

### 通用

```javascript
const tileSource = new Source(
  'http://localhost:3000/zhejiang.mbtiles/{z}/{x}/{y}.pbf',
  {
    parser: {
      type: 'mvt',
      tileSize: 256,
      zoomOffset: 0,
      maxZoom: 9,
      extent: [-180, -85.051129, 179, 85.051129],
    },
  },
);
```

### 自定义方法

```javascript
const source = new Source(
  'https://gridwise.alibaba-inc.com/tile/test?z={z}&x={x}&y={y}',
  {
    parser: {
      type: 'mvt',
      tileSize: 256,
      getCustomData: (tile, cb) => {
        const url = `https://gridwise.alibaba-inc.com/tile/test?z=${tile.z}&x=${tile.x}&y=${tile.y}`;
        fetch(url)
          .then((res) => res.arrayBuffer())
          .then((data) => {
            cb(null, data);
          });
      },
    },
  },
);
```


---
title: JSON
order: 2
---

<embed src="@/docs/common/style.md"></embed>

GeoJSON 虽然是通用的的地理数据格式，在具体使用场景中，数据服务人员可能并不熟悉 GeoJON,或者没有生成 GeoJON 的工具， 因此 L7 对数据定义了 Parser 的概念，你的数据可以是任何格式，使用指定数据对应的地理信息字段即可。

## JSON

⚠️ json 不是标准的地理数据结构，因此在使用时务必要设置 Parser

json 数据解析使用对应 JSON parser

## parser

支持两种解析方式

### 简易解析方式

该方式只支持解析的点数据，或者只有两个点的线段，或者弧线数据

- type `string` 必选 `json`
- x `string` 点数据表示 经度
- y `string` 点数据表示 纬度
- x1 `string` 经度
- x2 `string` 纬度

如果数据是点数据，只需要设置 x,y 字段即可

如果是线段，弧线数据，需要知道起止点坐标既，x,y,x1,y1

```javascript
layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat',
  },
});
```

[JOSN 数据 demo 示例](/examples/gallery/animate#animate_path_texture)

### 通用解析方式

可也解析任意复杂的点，线面

- type `string` 必选 `json`
- coordinates `array` 必选，主要用于表达比较复杂的格式，等同于 geojson coordinates 属性

```javascript
layer.source(data, {
  parser: {
    type: 'json',
    coordinates: 'coord',
  },
});
```

## 使用示例

### 点数据

#### 简易解析

- type json
- x: 经度字段
- y: 纬度字段

```javascript
const data = [
  {
    lng: 112.345,
    lat: 30.455,
    value: 10,
  },
  {
    lng: 114.345,
    lat: 31.455,
    value: 10,
  },
];

layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat',
  },
});
```

#### 通用解析

[ 点 coodinates 数据格式](/api/source/geojson##point)

```javascript
const data = [
  {
    coord: [112.345, 30.455],
    value: 10,
  },
  {
    coord: [114.345, 32.455],
    value: 10,
  },
];

layer.source(data, {
  parser: {
    type: 'json',
    coordinates: 'coord',
  },
});
```

### 线数据

#### 简易解析

- type: json
- x `string` 经度
- y `string` 纬度
- x1 `string` 经度
- x2 `string` 纬度

简易解析只支持两个点组成的线段，主要再绘制弧线的时候比较常用，只需指定线段的起止点坐标

```javascript
const data = [
  {
    lng1: 112.345,
    lat1: 30.455,
    lng2: 112.345,
    lat2: 30.455,
    value: 10,
  },
  {
    lng1: 114.345,
    lat1: 31.455,
    lng2: 112.345,
    lat2: 30.455,
    value: 10,
  },
];

layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng1',
    y1: 'lat2',
  },
});
```

#### 通用解析

绘制线段、弧线也支持使用 coordinates 组织数据

coordinates 包含两个坐标，
第一个坐标 对应 x, y
第二个坐标 对应 x1, y1

```javascript
const data = [
  {
    id: '1',
    coord: [
      [101.953125, 50.51342652633956],
      [119.17968749999999, 33.137551192346145],
    ],
  },
];
layer.source(data, {
  parser: {
    type: 'json',
    coordinates: 'coord',
  },
});
```

如果需要使用绘制轨迹数据，需要通过 coodinates 指定线的点序列。

coordinate 格式 geojson 的 coordinate 字段 支持 LineString, MultiLineString

[ 线 coodinates 数据格式](/api/source/geojson#linesring)

```javascript
const data = {
  name: 'path1',
  path: [
    [58.00781249999999, 32.84267363195431],
    [85.78125, 25.16517336866393],
    [101.953125, 41.77131167976407],
    [114.9609375, 39.639537564366684],
    [117.42187500000001, 28.613459424004414],
  ],
};
```

使用时通过 coordinates 指定

```javascript
layer.source(data, {
  parser: {
    type: 'json',
    coordinates: 'path',
  },
});
```

### 面数据

面数据 coordinates 字段比较复杂不支持简易的解析方式

#### 通用解析

需要指定 coordinates 字段, 格式同 GeoJSON 的 coordinates 字段

[面 coodinates 数据格式](/api/source/geojson/#polygon)

**注意面数据 coord  是三层数据结构**

```javascript
[
  {
    type: 'Polygon',
    geometryCoord: [
      [
        [115.1806640625, 30.637912028341123],
        [114.9609375, 29.152161283318915],
        [117.79541015625001, 27.430289738862594],
        [118.740234375, 29.420460341013133],
        [117.46582031249999, 31.50362930577303],
        [115.1806640625, 30.637912028341123],
      ],
    ],
  },
];

layer.source(data, {
  parser: {
    type: 'json',
    coordinates: 'geometryCoord',
  },
});
```
---
title: JSON
order: 2
---

<embed src="@/docs/common/style.md"></embed>

Although GeoJSON is a universal geographical data format, in specific usage scenarios, data service personnel may not be familiar with GeoJON, or do not have the tools to generate GeoJON. Therefore, L7 defines the concept of Parser for data, and your data can be in any format. , just use the geographic information field corresponding to the specified data.

## JSON

⚠️ json is not a standard geographical data structure, so be sure to set Parser when using it

json data parsing uses the corresponding JSON parser

## parser

Supports two parsing methods

### Simple analysis method

This method only supports analytical point data, or line segments with only two points, or arc data.

* type `string`required`json`
* x `string`Point data represents longitude
* y `string`Point data represents latitude
* x1 `string`longitude
* x2 `string`latitude

If the data is point data, you only need to set the x,y fields.

If it is line segment or arc data, you need to know the coordinates of the starting and ending points, x, y, x1, y1

```javascript
layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat',
  },
});
```

[JSON data demo example](/examples/gallery/animate#animate_path_texture)

### Universal parsing method

It can also analyze arbitrarily complex points, lines and surfaces.

* type `string`required`json`
* coordinates `array`Required, mainly used to express more complex formats, equivalent to the geojson coordinates attribute

```javascript
layer.source(data, {
  parser: {
    type: 'json',
    coordinates: 'coord',
  },
});
```

## Usage example

### point data

#### Simple analysis

* type json
* x: longitude field
* y: latitude field

```javascript
const data = [
  {
    lng: 112.345,
    lat: 30.455,
    value: 10,
  },
  {
    lng: 114.345,
    lat: 31.455,
    value: 10,
  },
];

layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat',
  },
});
```

#### general analysis

[Point coodinates data format](/api/source/geojson##point)

```javascript
const data = [
  {
    coord: [112.345, 30.455],
    value: 10,
  },
  {
    coord: [114.345, 32.455],
    value: 10,
  },
];

layer.source(data, {
  parser: {
    type: 'json',
    coordinates: 'coord',
  },
});
```

### line data

#### Simple analysis

* type: json
* x `string`longitude
* y `string`latitude
* x1 `string`longitude
* x2 `string`latitude

Simple analysis only supports line segments composed of two points. It is mainly used when drawing arcs. You only need to specify the starting and ending point coordinates of the line segment.

```javascript
const data = [
  {
    lng1: 112.345,
    lat1: 30.455,
    lng2: 112.345,
    lat2: 30.455,
    value: 10,
  },
  {
    lng1: 114.345,
    lat1: 31.455,
    lng2: 112.345,
    lat2: 30.455,
    value: 10,
  },
];

layer.source(data, {
  parser: {
    type: 'json',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng1',
    y1: 'lat2',
  },
});
```

#### general analysis

Drawing line segments and arcs also supports using coordinates to organize data.

coordinates contains two coordinates,
The first coordinate corresponds to x, y
The second coordinate corresponds to x1, y1

```javascript
const data = [
  {
    id: '1',
    coord: [
      [101.953125, 50.51342652633956],
      [119.17968749999999, 33.137551192346145],
    ],
  },
];
layer.source(data, {
  parser: {
    type: 'json',
    coordinates: 'coord',
  },
});
```

If you need to use drawing trajectory data, you need to specify the point sequence of the line through codinates.

coordinate format The coordinate field of geojson supports LineString, MultiLineString

[Line coodinates data format](/api/source/geojson#linesring)

```javascript
const data = {
  name: 'path1',
  path: [
    [58.00781249999999, 32.84267363195431],
    [85.78125, 25.16517336866393],
    [101.953125, 41.77131167976407],
    [114.9609375, 39.639537564366684],
    [117.42187500000001, 28.613459424004414],
  ],
};
```

Specify by coordinates when using

```javascript
layer.source(data, {
  parser: {
    type: 'json',
    coordinates: 'path',
  },
});
```

### area data

The coordinates field of surface data is relatively complex and does not support simple parsing methods.

#### general analysis

The coordinates field needs to be specified. The format is the same as the coordinates field of GeoJSON.

[Face codinates data format](/api/source/geojson/#polygon)

**Note that surface data coord is a three-layer data structure**

```javascript
[
  {
    type: 'Polygon',
    geometryCoord: [
      [
        [115.1806640625, 30.637912028341123],
        [114.9609375, 29.152161283318915],
        [117.79541015625001, 27.430289738862594],
        [118.740234375, 29.420460341013133],
        [117.46582031249999, 31.50362930577303],
        [115.1806640625, 30.637912028341123],
      ],
    ],
  },
];

layer.source(data, {
  parser: {
    type: 'json',
    coordinates: 'geometryCoord',
  },
});
```
---
title: Image
order: 4
---

<embed src="@/docs/common/style.md"></embed>

Image 数据主要用于在地图根据经纬度范围添加图图片，比如一幅纸制地图扫描版你要放在地图显示。

## parser

- type: image
- extent: 图像的经纬度范围 [minlng, minlat,maxLng, maxLat]

根据图片的经纬度范围，将图片添加到地图上。

```javascript
layer.source(
  'https://gw.alipayobjects.com/zos/rmsportal/FnHFeFklTzKDdUESRNDv.jpg',
  {
    parser: {
      type: 'image',
      extent: [121.168, 30.2828, 121.384, 30.4219],
    },
  },
);
```
---
title: Image
order: 4
---

<embed src="@/docs/common/style.md"></embed>

Image data is mainly used to add images to maps based on longitude and latitude ranges. For example, you want to display a scanned version of a paper map on the map.

## parser

* type: image
* extent: the latitude and longitude range of the image \[minlng, minlat,maxLng, maxLat]

Add the image to the map based on its latitude and longitude range.

```javascript
layer.source(
  'https://gw.alipayobjects.com/zos/rmsportal/FnHFeFklTzKDdUESRNDv.jpg',
  {
    parser: {
      type: 'image',
      extent: [121.168, 30.2828, 121.384, 30.4219],
    },
  },
);
```
---
title: 城市建筑
order: 6
---

<embed src="@/docs/common/style.md"></embed>

## 简介

`CityBuildingLayer` 用于构建城市建筑 3D 模型, 展示城市建筑

## 使用

```javascript
import { CityBuildingLayer } from '@antv/l7';
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_e7e1c6/afts/img/A*LoxeSZHuqXwAAAAAAAAAAAAAARQnAQ'>

### animate

是否开启动画效果, 仅支持`boolean` 或`enable: boolean` 配置项

```javascript
layer.animate(true);

layer.animatte({
  enable: true,
});
```

✨ 在开启 animate 后默认会打开点亮窗户的动画  
🌟 开启 animate 动画是打开扫光动画的前提

### style

- baseColor 楼房颜色,
- windowColor: 窗户颜色,
- brightColor: 点亮窗户颜色
- sweep: 圆形扫光扩散动画相关配置项
  - enable: 是否开启扫光扩散
  - sweepRadius: 扩散半径
  - sweepCenter: 扩散中心店坐标
  - sweepColor: 扩散颜色
  - sweepSpeed: 扩散速度
- baseColor: 开启 sweep 时的基础颜色

其他 style 配置项同

[baselayer#style](/api/base_layer/base#style)

## 自定义动画频率

自定义动画频率需要 关闭默认动画，通过 `setLight` 方法不断更新时间

### setLight(time)

参数
time : 时间 毫秒

```js
import { CityBuildingLayer, Scene } from '@antv/l7';
import { Mapbox } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'dark',
    center: [121.507674, 31.223043],
    pitch: 65.59312320916906,
    zoom: 15.4,
    minZoom: 15,
    maxZoom: 18,
  }),
});
const buildingLayer = new CityBuildingLayer();
buildingLayer.animate(false);

let i = 0;
function step() {
  buildingLayer.setLight(i++);
  scene.render();
  requestAnimationFrame(step);
}

scene.on('loaded', () => {
  step();
});
```

#### demo

```javascript
import { Scene, CityBuildingLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'dark',
    center: [120.173104, 30.244072],
    pitch: 70.41138037735848,
    zoom: 17.18,
    rotation: 2.24, // 358.7459759480504
    minZoom: 14,
  }),
});

scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/rmsportal/ggFwDClGjjvpSMBIrcEx.json')
    .then((res) => res.json())
    .then((data) => {
      const layer = new CityBuildingLayer({
        zIndex: 0,
      });
      layer.source(data);
      scene.addLayer(layer);
    });
});
```

[在线案例](/examples/gallery/animate#build_sweep)
---
title: City Build
order: 6
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

`CityBuildingLayer`Used to build 3D models of urban buildings and display urban buildings

## use

```javascript
import { CityBuildingLayer } from '@antv/l7';
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_e7e1c6/afts/img/A*LoxeSZHuqXwAAAAAAAAAAAAAARQnAQ'>

### animate

Whether to enable animation effects, only supported`boolean`or`enable: boolean`Configuration items

```javascript
layer.animate(true);

layer.animatte({
  enable: true,
});
```

✨ After turning on animate, the animation of lighting up the windows will be turned on by default\
🌟 Turning on animate animation is the prerequisite for turning on sweeping animation.

### style

* baseColor building color,
* windowColor: window color,
* brightColor: brighten window color
* sweep: Configuration items related to circular sweep and diffusion animation
  * enable: whether to enable scanning and diffusion
  * sweepRadius: spread radius
  * sweepCenter: diffusion center store coordinates
  * sweepColor: spread color
  * sweepSpeed: diffusion speed
* baseColor: base color when sweep is enabled

Other style configuration items are the same as

[baselayer#style](/api/base_layer/base#style)

## Custom animation frequency

Custom animation frequency requires turning off the default animation by`setLight`Method keeps updating time

### setLight(time)

parameter
time: time milliseconds

```js
import { CityBuildingLayer, Scene } from '@antv/l7';
import { Mapbox } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'dark',
    center: [121.507674, 31.223043],
    pitch: 65.59312320916906,
    zoom: 15.4,
    minZoom: 15,
    maxZoom: 18,
  }),
});
const buildingLayer = new CityBuildingLayer();
buildingLayer.animate(false);

let i = 0;
function step() {
  buildingLayer.setLight(i++);
  scene.render();
  requestAnimationFrame(step);
}

scene.on('loaded', () => {
  step();
});
```

#### demo

```javascript
import { Scene, CityBuildingLayer } from '@antv/l7';
import { GaodeMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    style: 'dark',
    center: [120.173104, 30.244072],
    pitch: 70.41138037735848,
    zoom: 17.18,
    rotation: 2.24, // 358.7459759480504
    minZoom: 14,
  }),
});

scene.on('loaded', () => {
  fetch('https://gw.alipayobjects.com/os/rmsportal/ggFwDClGjjvpSMBIrcEx.json')
    .then((res) => res.json())
    .then((data) => {
      const layer = new CityBuildingLayer({
        zIndex: 0,
      });
      layer.source(data);
      scene.addLayer(layer);
    });
});
```

[Online case](/examples/gallery/animate#build_sweep)
---
title: PlaneGeometry
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

PlaneGeometry is a general plane geometry graphic provided by L7, which is expressed as a ground-fitting rectangle that can be customized with position, size and number of segments.

### demo

Set a normal rectangle

```javascript
import { Scene, GeometryLayer } from '@antv/l7';

const layer = new GeometryLayer()
  .shape('plane')
  .style({
    opacity: 0.8,
    width: 0.074,
    height: 0.061,
    center: [120.1025, 30.2594],
  })
  .active(true)
  .color('#ff0');
scene.addLayer(layer);
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*7DpqRrE0LM4AAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/geometry/geometry#plane)

Set 3D terrain mode

```javascript
import { Scene, GeometryLayer } from '@antv/l7';

const layer = new GeometryLayer().shape('plane').style({
  width: 0.074,
  height: 0.061,
  center: [120.1025, 30.2594],
  widthSegments: 200,
  heightSegments: 200,
  terrainClipHeight: 1,
  mapTexture:
    'https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*gA0NRbuOF5cAAAAAAAAAAAAAARQnAQ',
  terrainTexture:
    'https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*eYFaRYlnnOUAAAAAAAAAAAAAARQnAQ',
  rgb2height: (r, g, b) => {
    let h =
      -10000.0 +
      (r * 255.0 * 256.0 * 256.0 + g * 255.0 * 256.0 + b * 255.0) * 0.1;
    h = h / 20 - 127600;
    h = Math.max(0, h);
    return h;
  },
});
scene.addLayer(layer);
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*mkPtQJVN8eQAAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/geometry/geometry#terrain)

### source

🌟 PlaneGeometry does not need to set the source, we give its position information through center in style.

### style

PlaneGeometry mainly sets position, size and other properties through the style method.

#### center: \[lng: number, lat: number]

Sets the position of the PlaneGeometry. The positioning is the geometric center of the PlaneGeometry. PlaneGeometry is placed close to the ground.

#### width: number

Sets the width of the PlaneGeometry in longitude.

#### height: number

Sets the height of the PlaneGeometry in latitude.

#### widthSegments: number

Set the number of segments of the PlaneGeometry in the latitude direction.

#### heightSegments: number

Set the number of segments of the PlaneGeometry in the longitude direction.

#### mapTexture: string

PlaneGeometry texture map URL.

#### terrainTexture: string

PlaneGeometry height map URL, when this parameter exists, L7 will automatically parse the elevation information.

#### terrainClipHeight: number

Specifies the clipping height of the 3D terrain. In some cases, we may only need to retain the parts where hills and mountains exist. Through this parameter, we can specify that parts of the terrain whose height is lower than this parameter value are not displayed.

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*-SpgT6R05bcAAAAAAAAAAAAAARQnAQ'>

#### rgb2height: (r: number, g: number, b: number) => number

This is a callback function, and the parameter is the rgb information of the terrain map parsed by L7. Users can use this function to define the calculation logic of the height value (the calculation logic of different terrain maps is different).

🌟 widthSegments/heightSegments specifies the number of segments of planeGeometry. The more segments, the smoother the terrain and the greater the performance consumption.
---
title: PlaneGeometry
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## 简介

PlaneGeometry 是 L7 提供的通用的平面几何体图形，表现为可以自定义为位置，大小和分段数的贴地矩形。

### demo

设置普通矩形

```javascript
import { Scene, GeometryLayer } from '@antv/l7';

const layer = new GeometryLayer()
  .shape('plane')
  .style({
    opacity: 0.8,
    width: 0.074,
    height: 0.061,
    center: [120.1025, 30.2594],
  })
  .active(true)
  .color('#ff0');
scene.addLayer(layer);
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*7DpqRrE0LM4AAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/geometry/geometry#plane)

设置 3D 地形模式

```javascript
import { Scene, GeometryLayer } from '@antv/l7';

const layer = new GeometryLayer().shape('plane').style({
  width: 0.074,
  height: 0.061,
  center: [120.1025, 30.2594],
  widthSegments: 200,
  heightSegments: 200,
  terrainClipHeight: 1,
  mapTexture:
    'https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*gA0NRbuOF5cAAAAAAAAAAAAAARQnAQ',
  terrainTexture:
    'https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*eYFaRYlnnOUAAAAAAAAAAAAAARQnAQ',
  rgb2height: (r, g, b) => {
    let h =
      -10000.0 +
      (r * 255.0 * 256.0 * 256.0 + g * 255.0 * 256.0 + b * 255.0) * 0.1;
    h = h / 20 - 127600;
    h = Math.max(0, h);
    return h;
  },
});
scene.addLayer(layer);
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*mkPtQJVN8eQAAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/geometry/geometry#terrain)

### source

🌟 PlaneGeometry 不需要设置 source，我们在 style 中通过 center 赋予其位置信息。

### style

PlaneGeometry 主要通过 style 方法设置位置、大小以及其他属性。

#### center: [lng: number, lat: number]

设置 PlaneGeometry 的位置，定位是 PlaneGeometry 的几何中心。PlaneGeometry 贴地放置。

#### width: number

设置 PlaneGeometry 的宽度，单位是经度。

#### height: number

设置 PlaneGeometry 的高度，单位是纬度。

#### widthSegments: number

设置 PlaneGeometry 在 纬度方向上的分段数。

#### heightSegments: number

设置 PlaneGeometry 在 经度方向上的分段数。

#### mapTexture: string

PlaneGeometry 纹理贴图 URL。

#### terrainTexture: string

PlaneGeometry 高度贴图 URL，当存在该参数的时候 L7 会自动解析高程信息。

#### terrainClipHeight: number

指定 3D 地形的裁剪高度。在一些情况下我们可能只需要保留存在丘陵山地的部分，通过这个参数我们可以指定地形高度低于这个参数值的部分不显示.

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*-SpgT6R05bcAAAAAAAAAAAAAARQnAQ'>

#### rgb2height: (r: number, g: number, b: number) => number

这是一个回调函数，参数是 L7 解析出的地形贴图的 rgb 信息，用户可以使用该函数定义高度值的计算逻辑（不同的地形贴图计算逻辑不同）。

🌟 widthSegments/heightSegments 指定 planeGeometry 的分段数，分段越多，地形越平滑，同时性能消耗越大。
---
title: SpriteGeometry
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

SpriteGeometry is a universal particle layer provided by L7, which can be used to draw various particle effects.

### demo

Set up a normal particle layer.

```javascript
import { Scene, GeometryLayer } from '@antv/l7';

let layer = new GeometryLayer()
  .shape('sprite')
  .size(10)
  .style({
    opacity: 0.3,
    center: [120, 30],
    spriteCount: 120,
    spriteRadius: 10,
    spriteTop: 2500000,
    spriteUpdate: 20000,
    spriteScale: 0.6,
  });
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*PEd7RasIpiEAAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/geometry/geometry#snow)

### source

🌟 SpriteGeometry does not need to set the source, we give its position information through center in style.

### style

SpriteGeometry mainly sets position, size and other properties through the style method.

#### center: \[lng: number, lat: number]

Sets the position of the SpriteGeometry. Positioning is the center of the SpriteGeometry.

#### mapTexture: string

Set the sprite's texture map.

#### spriteRadius: number

The radius of action of particles, default is 10.\
🌟 Individual particles will be randomly distributed within the radius of the layer position.

#### spriteAnimate: string

The particle's movement defaults to 'down', which means downward movement. Optional values ​​are 'down'/'up'.

#### spriteCount: number

The number of particles generated by the layer, default is 100.

#### spriteTop: number

The height range of particle movement, the default is 5000000.\
🌟 It should be noted that under different map basemaps, the parameter values ​​of spriteTop/spriteUpdate need to be adjusted to achieve better results. The default value is adjusted on the Amap 1.0 map.

#### spriteUpdate: number

The step size of particle motion refresh, expressed as motion speed, default is 10000.\
🌟 It should be noted that under different map basemaps, the parameter values ​​of spriteTop/spriteUpdate need to be adjusted to achieve better results. The default value is adjusted on the Amap 1.0 map.

#### spriteScale: number

Particle size scaling, default is 1.
---
title: SpriteGeometry
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## 简介

SpriteGeometry 是 L7 提供的通用的粒子图层，可以用来绘制各种粒子效果。

### demo

设置普通的粒子图层。

```javascript
import { Scene, GeometryLayer } from '@antv/l7';

let layer = new GeometryLayer()
  .shape('sprite')
  .size(10)
  .style({
    opacity: 0.3,
    center: [120, 30],
    spriteCount: 120,
    spriteRadius: 10,
    spriteTop: 2500000,
    spriteUpdate: 20000,
    spriteScale: 0.6,
  });
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*PEd7RasIpiEAAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/geometry/geometry#snow)

### source

🌟 SpriteGeometry 不需要设置 source，我们在 style 中通过 center 赋予其位置信息。

### style

SpriteGeometry 主要通过 style 方法设置位置、大小以及其他属性。

#### center: [lng: number, lat: number]

设置 SpriteGeometry 的位置，定位是 SpriteGeometry 的中心。

#### mapTexture: string

设置精灵的纹理贴图。

#### spriteRadius: number

粒子的作用半径，默认为 10。  
🌟 单个粒子会在图层位置半径范围内随机分布。

#### spriteAnimate: string

粒子的运动、默认为 'down'，表示向下运动。可选值有 'down'/'up'。

#### spriteCount: number

图层生成的粒子数量，默认为 100。

#### spriteTop: number

粒子运动的高度范围，默认为 5000000.  
🌟 需要注意的是，在不同的地图底图下，spriteTop/spriteUpdate 的参数值需要进行调整，才能得到较好的效果。默认值是在高德 1.0 的地图上调整的。

#### spriteUpdate: number

粒子运动刷新的步长，表现为运动速度、默认为 10000。  
🌟 需要注意的是，在不同的地图底图下，spriteTop/spriteUpdate 的参数值需要进行调整，才能得到较好的效果。默认值是在高德 1.0 的地图上调整的。

#### spriteScale: number

粒子大小缩放、默认为 1。
---
title: Component 组件
order: 0
---

L7 中的 Component 主要包含以下三种类型：

- [Control 控件类型](/api/component/control/control)：指的是悬停在地图四周，可以对地图以及图层等元素进行信息呈现或交互的组件。
- [Popup 气泡类型](/api/component/popup/popup)：用于在地图上指定经纬度位置展示气泡，气泡内容完全交由开发者自定义。
- [Marker 类型](/api/component/marker/marker)：与 Popup 相似，不同的是 Marker 展示的内容不会在气泡内展示，而是完全交由开发者自定义。
---
title: Zoom 缩放
order: 3
---

用于控制地图**放大**和**缩小**的控件，并且当地图达到最大或最小缩放比时，会禁用对应缩放按钮。

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*CJx3Tby-XlEAAAAAAAAAAAAAARQnAQ" width="400"/>

## 使用

[示例](/examples/component/control#zoom)

```ts
import { Scene, Zoom } from '@antv/l7';

const scene = new Scene({
  //...
});

scene.on('loaded', () => {
  const zoom = new Zoom({
    zoomInTitle: '放大',
    zoomOutTitle: '缩小',
  });
  scene.addControl(zoom);
});
```

## 配置

| 名称         | 说明                                         | 类型                  |
| ------------ | -------------------------------------------- | --------------------- |
| zoomInText   | 放大按钮的展示内容                           | `Element` \| `string` |
| zoomInTitle  | 放大按钮的 `title` 属性                      | `string`              |
| zoomOutText  | 缩小按钮的展示内容                           | `Element` \| `string` |
| zoomOutTitle | 缩小按钮的 `title` 属性                      | `string`              |
| showZoom     | 是否展示地图当前实时 zoom 数值，默认向下取整 | `boolean`             |

<embed src="@/docs/common/control/api.zh.md"></embed>

## 方法

| 名称    | 说明     | 类型         |
| ------- | -------- | ------------ |
| zoomIn  | 放大地图 | `() => void` |
| zoomOut | 缩小底图 | `() => void` |

<embed src="@/docs/common/control/method.zh.md"></embed>

## 事件

<embed src="@/docs/common/control/event.zh.md"></embed>
---
title: Zoom
order: 3
---

Used to control the map**enlarge**and**zoom out**control, and when the map reaches the maximum or minimum zoom ratio, the corresponding zoom button is disabled.

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*CJx3Tby-XlEAAAAAAAAAAAAAARQnAQ" width="400"/>

## use

[Example](/examples/component/control#zoom)

```ts
import { Scene, Zoom } from '@antv/l7';

const scene = new Scene({
  //...
});

scene.on('loaded', () => {
  const zoom = new Zoom({
    zoomInTitle: '放大',
    zoomOutTitle: '缩小',
  });
  scene.addControl(zoom);
});
```

## Configuration

| name         | illustrate                                                                              | type                |
| ------------ | --------------------------------------------------------------------------------------- | ------------------- |
| zoomInText   | Enlarge button display content                                                          | `Element`\|`string` |
| zoomInTitle  | magnify button`title`Attributes                                                         | `string`            |
| zoomOutText  | Reduce button display content                                                           | `Element`\|`string` |
| zoomOutTitle | shrink button`title`Attributes                                                          | `string`            |
| showZoom     | Whether to display the current real-time zoom value of the map, rounded down by default | `boolean`           |

<embed src="@/docs/common/control/api.en.md"></embed>

## method

| name    | illustrate     | type         |
| ------- | -------------- | ------------ |
| zoomIn  | Enlarge map    | `() => void` |
| zoomOut | Reduce basemap | `() => void` |

<embed src="@/docs/common/control/method.en.md"></embed>

## event

<embed src="@/docs/common/control/event.en.md"></embed>
---
title: LayerSwitch 图层显隐
order: 8
---

用于控制目标图层组的**显示**和**隐藏**操作。

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*SiQWT5RnMDYAAAAAAAAAAAAAARQnAQ" width="400"/>

## 说明

**注意**： 在控件中展示的图层名称会默认读取图层的 `name` 属性，因此需要用户在初始化图层时传入图层对应的名称。

## 使用

[示例](/examples/component/control#layerswitch)

```ts
import { Scene, LayerSwitch } from '@antv/l7';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  const layer = new PointLayer({
    name: '自定义图层名称',
  });
  scene.addLayer(layer);

  const layerSwitch = new LayerSwitch({
    layers: [layer],
  });
  scene.addControl(layerSwitch);
});
```

## 配置

| 名称   | 说明                                                                                       | 类型                                         |
| ------ | ------------------------------------------------------------------------------------------ | -------------------------------------------- |
| layers | 需要被控制的 `layer` 数组，支持传入图层示例或者图层 id，不传则默认读取当前 L7 中所有的图层 | `Array<ILayer \| string \| LayerSwitchItem>` |

### LayerSwitchItem

| 名称  | 说明                      | 类型                  |
| ----- | ------------------------- | --------------------- |
| layer | 需要被控制的 `layer` 实例 | `ILayer`              |
| name  | 展示的图层名称            | `string \| undefined` |
| img   | 展示的图层图片 `URL`      | `string \| undefined` |

<embed src="@/docs/common/control/popper-api.zh.md"></embed>

<embed src="@/docs/common/control/btn-api.zh.md"></embed>

<embed src="@/docs/common/control/api.zh.md"></embed>

## 方法

<embed src="@/docs/common/control/method.zh.md"></embed>

## 事件

<embed src="@/docs/common/control/event.zh.md"></embed>

<embed src="@/docs/common/control/popper-event.zh.md"></embed>

<embed src="@/docs/common/control/select-event.zh.md"></embed>
---
title: LayerSwitch
order: 8
---

Used to control the target layer group**show**and**hide**operate.

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*SiQWT5RnMDYAAAAAAAAAAAAAARQnAQ" width="400"/>

## illustrate

**Notice**: The layer name displayed in the control will read the layer's name by default.`name`property, so the user needs to pass in the corresponding name of the layer when initializing the layer.

## use

[Example](/examples/component/control#layerswitch)

```ts
import { Scene, LayerSwitch } from '@antv/l7';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  const layer = new PointLayer({
    name: '自定义图层名称',
  });
  scene.addLayer(layer);

  const layerSwitch = new LayerSwitch({
    layers: [layer],
  });
  scene.addControl(layerSwitch);
});
```

## Configuration

| name   | illustrate                                                                                                                                             | type                      |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------- |
| layers | need to be controlled`layer`Array, supports passing in layer example or layer id. If not passed, all layers in the current L7 will be read by default. | `Array<ILayer \| string>` |

<embed src="@/docs/common/control/popper-api.en.md"></embed>

<embed src="@/docs/common/control/btn-api.en.md"></embed>

<embed src="@/docs/common/control/api.en.md"></embed>

## method

<embed src="@/docs/common/control/method.en.md"></embed>

## event

<embed src="@/docs/common/control/event.en.md"></embed>

<embed src="@/docs/common/control/popper-event.en.md"></embed>

<embed src="@/docs/common/control/select-event.en.md"></embed>
---
title: Popup 信息框
order: 0
---

Popup 是用于在地图上指定经纬度位置，展示自定义内容的气泡。

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*N2hWTq-m-8EAAAAAAAAAAAAAARQnAQ" width="300"/>

## 说明

Popup 的锚点位置是由经纬度来表达的，当地图缩放/平移时，Popup 会自动计算相对于当前地图的坐标并且自动位移。换句话说，如果开发者需要在地图的**指定经纬度位置**展示信息气泡，可以考虑使用 Popup 组件来实现对应效果。

开发者可以自定义 Popup 主体展示内容：

- 纯文本可以通过 `text` 配置或者 `setText` 方法控制 Popup 的展示文本。
- 自定义 DOM 可以通过 `html` 配置或者 `setHTML` 方法，支持传入 HTML 字符串或者 DOM 元素或数组的方式控制 Popup 的展示内容。

## 使用

[示例](/examples/component/popup#popup)

```ts
import { Scene, Popup } from '@antv/l7';

const scene = new Scene({
  id: 'map',
  map: new GaodeMapV2({
    // ...
  }),
});

scene.on('loaded', () => {
  const popup = new Popup({
    // 初始锚点经纬度
    lngLat: {
      lng: 120,
      lat: 30,
    },
    // Popup 标题
    title: 'Popup Title',
    // Popup 内容
    html: 'Popup Content',
  });
  scene.addPopup(popup);

  // 更新 Popup 锚点经纬度
  popup.setLngLat({
    lng: 130,
    lat: 40,
  });

  // 更新 Popup 内容
  popup.setHTML('New Popup Content');
});
```

## 配置

| 名称               | 说明                                                                     | 类型                           | 默认值     |
| ------------------ | ------------------------------------------------------------------------ | ------------------------------ | ---------- |
| lngLat             | Popup 所在的经纬度                                                       | `{ lng: number; lat: number }` | -          |
| text               | Popup 内容展示的文本内容                                                 | `string`                       | -          |
| html               | Popup 内容展示的自定义 HTML，可以传 HTML 字符串，也可以传 DOM 对象或数组 | [ElementType](#elementtype)    | -          |
| title              | Popup 标题展示的自定义 HTML，可以传 HTML 字符串，也可以传 DOM 对象或数组 | [ElementType](#elementtype)    | -          |
| closeOnClick       | 点击地图区域时，是否关闭当前 Popup                                       | `boolean`                      | `false`    |
| closeOnEsc         | 点击 Esc 键时，是否关闭当前 Popup                                        | `boolean`                      | `false`    |
| maxWidth           | Popup 的最大宽度                                                         | `string`                       | `240px`    |
| anchor             | Popup 箭头位置，可以控制 Popup 相对于经纬度点的展示位置                  | [AnchorType](#anchortype)      | `'bottom'` |
| offsets            | Popup 相对于锚点的偏移                                                   | `[number, number]`             | `[0, 0]`   |
| autoPan            | 当 Popup 展示或者位置发生变化时，地图是否要自动平移至 Popup 所在位置     | `boolean`                      | `false`    |
| autoClose          | 当有其他 Popup 展示时，是否自动关闭当前气泡                              | `boolean`                      | `true`     |
| followCursor       | Popup 是否跟随光标移动，若设为 `true`，则 `lngLat` 配置无效              | `boolean`                      | `false`    |
| closeButton        | 是否展示关闭 Popup 图标                                                  | `boolean`                      | `true`     |
| closeButtonOffsets | 关闭 Popup 图标的相对偏移                                                | `[number, number]`             | -          |
| stopPropagation    | Popup 上的鼠标事件是否要阻止其冒泡                                       | `boolean`                      | `true`     |

### ElementType

```ts
type ElementType =
  | HTMLElement
  | HTMLElement[]
  | DocumentFragment
  | Text
  | string;
```

### AnchorType

```ts
type AnchorType =
  | 'center'
  | 'top'
  | 'top-left'
  | 'top-right'
  | 'bottom'
  | 'bottom-left'
  | 'bottom-right'
  | 'left'
  | 'right';
```

## 方法

| 名称       | 说明                        | 类型                                                                 |
| ---------- | --------------------------- | -------------------------------------------------------------------- |
| getOptions | 获取当前 Popup 配置         | `() => IPopupOption`                                                 |
| setOptions | 更新当前 Popup 配置         | `(newOption: Partial<IPopupOption>) => this`                         |
| show       | 显示 Popup                  | `() => this`                                                         |
| hide       | 隐藏 Popup                  | `() => this`                                                         |
| getIsShow  | 判断当前气泡是否展示        | `() => boolean`                                                      |
| setTitle   | 设置 Popup 标题展示的 HTML  | `(title: ElementType) => this`                                       |
| setHTML    | 设置 Popup 内容展示的 HTML  | `(html: ElementType) => this`                                        |
| setText    | 设置 Popup 内容展示的文本   | `(text: string) => this`                                             |
| setLngLat  | 设置 Popup 锚点所在经纬度   | `(lngLat: { lng: number; lat: number } \| [number, number]) => this` |
| panToPopup | 将地图平移至当前 Popup 位置 | `() => this`                                                         |

## 事件

| 名称  | 说明               | 类型         |
| ----- | ------------------ | ------------ |
| open  | Popup 被添加时触发 | `() => void` |
| close | Popup 被移除时触发 | `() => void` |
| show  | Popup 显示时触发   | `() => void` |
| hide  | Popup 隐藏时触发   | `() => void` |
---
title: Scale 缩放尺
order: 4
---

该控件用于显示地图上的距离与地面上相应距离的比率。

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*r3iSQI4SekYAAAAAAAAAAAAAARQnAQ" width="400"/>

## 使用

[示例](/examples/component/control#scale)

```ts
import { Scene, Scale } from '@antv/l7';

const scene = new Scene({
  //...
});

scene.on('loaded', () => {
  const scale = new Scale({
    zoomInTitle: '放大',
    zoomOutTitle: '缩小',
  });
  scene.addControl(scale);
});
```

## 配置

| 名称           | 说明                                 | 类型      | 默认值  |
| -------------- | ------------------------------------ | --------- | ------- |
| lockWidth      | 是否固定容器宽度                     | `boolean` | `true`  |
| maxWidth       | 组件的容器最大宽度                   | `number`  | `100`   |
| metric         | 展示**千米**格式的比例尺             | `boolean` | `true`  |
| imperial       | 展示**英里**格式的比例尺             | `boolean` | `false` |
| updateWhenIdle | 是否只在拖拽和缩放结束后才更新比例尺 | `boolean` | `false` |

<embed src="@/docs/common/control/api.zh.md"></embed>

## 方法

<embed src="@/docs/common/control/method.zh.md"></embed>

## 事件

<embed src="@/docs/common/control/event.zh.md"></embed>
---
title: Marker
order: 3
---

<embed src="@/docs/common/style.md"></embed>

Marker 地图标注 目前只支持 2D dom 标注

## 构造函数

Marker

`const Marker = new L7.Marker(option)`

#### option

- color        `string` ![L7 Marker](https://gw.alipayobjects.com/zos/basement_prod/b10e0efd-8379-4b04-bcbb-5cfefaa0327f.svg)设置默认 marker 的颜色
- element    `Dom|string`    自定义 marker Dom 节点，可以是 dom 实例，也可以是 dom id
- anchor     `string`  锚点位置   支持 center, top, top-left, top-right, bottom, bottom-left,bottom-                        right,left, right
- offsets    `Array`  偏移量  [ 0, 0 ] 分别表示 X, Y 的偏移量

### 添加到 Scene

```javascript
scene.addMarker(marker);
```

## 方法

#### setLnglat

设置 marker 经纬度位置

#### remove

移除 marker

#### getElement

获取 marker dom Element

#### getLngLat

获取 marker 经纬度坐标

#### togglePopup

开启或者关闭 marker 弹出框

#### setPopup

为 marker 设置 popup

#### getPopup

获取 marker 弹出框

## 示例代码

#### 默认 Marker

`const marker = new L7.Marker({color:'blue'})`

#### 自定义 Marker

```javascript
var el = document.createElement('label');
el.className = 'labelclass';
el.textContent = data[i].v;
el.style.background = getColor(data[i].v);
new L7.Marker({
  element: el,
}).setLnglat([data[i].x * 1, data[i].y]);
```

#### 设置 popup

```javascript
var popup = new L7.Popup({
  anchor: 'left',
}).setText(item.name);

new L7.Marker({
  element: el,
})
  .setLnglat(item.coordinates)
  .setPopup(popup);
```

[demo1](/examples/tutorial/marker#amap)
---
title: Marker 标注
order: 3
---

<embed src="@/docs/common/style.md"></embed>

Marker 地图标注 目前只支持 2D Dom 标注

## 构造函数

Marker

`const Marker = new L7.Marker(option)`

#### option

- color        `string` 
  ![map-marker.png](https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*BJ6cTpDcuLcAAAAAAAAAAABkARQnAQ)  设置默认 marker 的颜色
- element    `Dom|string`    自定义 marker Dom 节点，可以是 dom 实例，也可以是 dom id
- anchor     `string`  锚点位置   支持 center, top, top-left, top-right, bottom, bottom-left,bottom-right,left, right
- offsets    `Array`  偏移量  [ 0, 0 ] 分别表示 X, Y 的偏移量
- extData 用户自定义属性，支持任意数据类型，存储 marker 属性信息

### 添加到 Scene

```javascript
scene.addMarker(marker);
```

## 方法

#### setLnglat

设置 marker 经纬度位置

#### remove

移除 marker

#### getElement

获取 marker dom Element

### setElement

- element `dom`

设置 element 通过此方法更新 Marker 样式

#### getLngLat

获取 marker 经纬度坐标

#### togglePopup

开启或者关闭 marker 弹出框

#### openPopup

打开 Popup

### closePopup

关闭 popup

#### setPopup

为 marker 设置 popup

#### getPopup

获取 marker 弹出框

#### getExtData()

获取用户自定义数据

#### setExtData(data)

设置用户自定义数据

## 示例代码

#### 默认 Marker

`const marker = new L7.Marker({color:'blue'})`

#### 自定义 Marker

```javascript
var el = document.createElement('label');
el.className = 'labelclass';
el.textContent = data[i].v;
el.style.background = getColor(data[i].v);

const marker = new L7.Marker({
  element: el,
}).setLnglat([data[i].x * 1, data[i].y]);

scene.addMarker(marker);
```

#### 设置 popup

```javascript
var popup = new L7.Popup({
  anchor: 'left',
}).setText(item.name);

new L7.Marker({
  element: el,
})
  .setLnglat(item.coordinates)
  .setPopup(popup);
```

## 事件

### 鼠标事件

- mousemove
- click
- mousedown
- mouseup
- dblclick
- contextmenu
- mouseover
- mouseout

事件返回数据

- target 事件触发源
- data extData 用户自定义数据
- lnglat marker 经纬度

```javascript
marker.on('click', (e) => {});
```

## demo 地址

[demo1](/examples/tutorial/marker#amap)
---
title: Popup
order: 0
---

Popup is a bubble used to specify the latitude and longitude location on the map and display customized content.

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*N2hWTq-m-8EAAAAAAAAAAAAAARQnAQ" width="300"/>

## illustrate

The anchor point position of Popup is expressed by longitude and latitude. When the map is zoomed/panned, Popup will automatically calculate the coordinates relative to the current map and automatically shift. In other words, if a developer needs to**Specify latitude and longitude location**To display information bubbles, you can consider using the Popup component to achieve the corresponding effect.

Developers can customize the main display content of Popup:

* Plain text can pass`text`configure or`setText`Method controls the Popup's display text.
* Custom DOM can be created via`html`configure or`setHTML`Method supports passing in HTML strings or DOM elements or arrays to control the display content of the Popup.

## use

[Example](/examples/component/popup#popup)

```ts
import { Scene, Popup } from '@antv/l7';

const scene = new Scene({
  id: 'map',
  map: new GaodeMapV2({
    // ...
  }),
});

scene.on('loaded', () => {
  const popup = new Popup({
    //Initial anchor point latitude and longitude
    lngLat: {
      lng: 120,
      lat: 30,
    },
    // Popup title
    title: 'Popup Title',
    // Popup content
    html: 'Popup Content',
  });
  scene.addPopup(popup);

  //Update Popup anchor point latitude and longitude
  popup.setLngLat({
    lng: 130,
    lat: 40,
  });

  //Update Popup content
  popup.setHTML('New Popup Content');
});
```

## Configuration

| name               | illustrate                                                                                                                 | type                           | default value |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------- |
| lngLat             | The latitude and longitude where the Popup is located                                                                      | `{ lng: number; lat: number }` | -             |
| text               | Text content displayed by Popup content                                                                                    | `string`                       | -             |
| html               | Custom HTML for Popup content display, you can pass HTML string, DOM object or array                                       | [ElementType](#elementtype)    | -             |
| title              | Custom HTML displayed in the Popup title, you can pass HTML string, DOM object or array                                    | [ElementType](#elementtype)    | -             |
| closeOnClick       | Whether to close the current Popup when clicking on the map area                                                           | `boolean`                      | `false`       |
| closeOnEsc         | Whether to close the current Popup when clicking the Esc key                                                               | `boolean`                      | `false`       |
| maxWidth           | Popup's maximum width                                                                                                      | `string`                       | `240px`       |
| anchor             | The position of the Popup arrow can control the placement of the Popup relative to the latitude and longitude points.      | [AnchorType](#anchortype)      | `'bottom'`    |
| offsets            | Popup offset relative to anchor point                                                                                      | `[number, number]`             | `[0, 0]`      |
| autoPan            | When the Popup is displayed or its location changes, whether the map should automatically pan to the location of the Popup | `boolean`                      | `false`       |
| autoClose          | Whether to automatically close the current bubble when there are other Popups displayed                                    | `boolean`                      | `true`        |
| followCursor       | Whether Popup follows the cursor movement, if set to`true`,but`lngLat`Invalid configuration                                | `boolean`                      | `false`       |
| closeButton        | Whether to display the close Popup icon                                                                                    | `boolean`                      | `true`        |
| closeButtonOffsets | Turn off relative offset of Popup icons                                                                                    | `[number, number]`             | -             |
| stopPropagation    | Whether mouse events on Popup should be prevented from bubbling                                                            | `boolean`                      | `true`        |

### ElementType

```ts
type ElementType =
  | HTMLElement
  | HTMLElement[]
  | DocumentFragment
  | Text
  | string;
```

### AnchorType

```ts
type AnchorType =
  | 'center'
  | 'top'
  | 'top-left'
  | 'top-right'
  | 'bottom'
  | 'bottom-left'
  | 'bottom-right'
  | 'left'
  | 'right';
```

## method

| name       | illustrate                                               | type                                                                 |
| ---------- | -------------------------------------------------------- | -------------------------------------------------------------------- |
| getOptions | Get the current Popup configuration                      | `() => IPopupOption`                                                 |
| setOptions | Update current Popup configuration                       | `(newOption: Partial<IPopupOption>) => this`                         |
| show       | Show Popup                                               | `() => this`                                                         |
| hide       | Hide Popup                                               | `() => this`                                                         |
| getIsShow  | Determine whether the current bubble is displayed        | `() => boolean`                                                      |
| setTitle   | Set the HTML displayed by the Popup title                | `(title: ElementType) => this`                                       |
| setHTML    | Set the HTML for Popup content display                   | `(html: ElementType) => this`                                        |
| setText    | Set the text displayed by Popup content                  | `(text: string) => this`                                             |
| setLngLat  | Set the latitude and longitude of the Popup anchor point | `(lngLat: { lng: number; lat: number } \| [number, number]) => this` |
| panToPopup | Pan the map to the current Popup location                | `() => this`                                                         |

## event

| name  | illustrate                        | type         |
| ----- | --------------------------------- | ------------ |
| open  | Fired when Popup is added         | `() => void` |
| close | Triggered when Popup is removed   | `() => void` |
| show  | Triggered when Popup is displayed | `() => void` |
| hide  | Triggered when Popup is hidden    | `() => void` |
---
title: Scale
order: 4
---

This control displays the ratio of distances on the map to the corresponding distances on the ground.

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*r3iSQI4SekYAAAAAAAAAAAAAARQnAQ" width="400"/>

## use

[Example](/examples/component/control#scale)

```ts
import { Scene, Scale } from '@antv/l7';

const scene = new Scene({
  //...
});

scene.on('loaded', () => {
  const scale = new Scale({
    zoomInTitle: '放大',
    zoomOutTitle: '缩小',
  });
  scene.addControl(scale);
});
```

## Configuration

| name           | illustrate                                                               | type      | default value |
| -------------- | ------------------------------------------------------------------------ | --------- | ------------- |
| lockWidth      | Whether to fix the container width                                       | `boolean` | `true`        |
| maxWidth       | The maximum width of the component's container                           | `number`  | `100`         |
| metric         | exhibit**km**format scale                                                | `boolean` | `true`        |
| imperial       | exhibit**mile**format scale                                              | `boolean` | `false`       |
| updateWhenIdle | Whether to only update the scale after dragging and zooming are complete | `boolean` | `false`       |

<embed src="@/docs/common/control/api.en.md"></embed>

## method

<embed src="@/docs/common/control/method.en.md"></embed>

## event

<embed src="@/docs/common/control/event.en.md"></embed>
---
title: ExportImage
order: 7
---

Take a screenshot of the current map part and generate a picture`Base64`String.

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*Yc78QZaeJWkAAAAAAAAAAAAAARQnAQ" width="400"/>

## illustrate

[Example](/examples/component/control#exportimage)

The captured targets when taking screenshots only include:

* map base map
* Layers (excluding MarkerLayer)

**Note: Since the current map base map corresponds to`Canvas`The buffer is enabled by default, so the basemap portion of the map cannot be captured by default.**

Therefore, if the developer needs the complete screenshot capability, the following parameters should be passed when initializing the map instance to turn it off.`Canvas`buffer.

```ts
new GaodeMapV2({
  WebGLParams: {
    preserveDrawingBuffer: true,
  },
});

new Mapbox({
  preserveDrawingBuffer: true,
});
```

## use

```ts
import { Scene, ExportImage } from '@antv/l7';

const scene = new Scene({
  id: 'map',
  map: new GaodeMapV2({
    // Close the map buffer, otherwise the map part cannot be captured when taking screenshots
    WebGLParams: {
      preserveDrawingBuffer: true,
    },
  }),
});

scene.on('loaded', () => {
  const zoom = new ExportImage({
    onExport: (base64: string) => {
      // download(base64)
    },
  });
  scene.addControl(zoom);
});
```

## Configuration

| name      | illustrate                                                                                                    | type                       |
| --------- | ------------------------------------------------------------------------------------------------------------- | -------------------------- |
| imageType | Screenshot image format                                                                                       | `'png'`\|`'jpeg'`          |
| onExport  | After the screenshot is successfully taken, it is used to receive the picture`Base64`String callback function | `(base64: string) => void` |

<embed src="@/docs/common/control/btn-api.zh.md"></embed>

<embed src="@/docs/common/control/api.zh.md"></embed>

## method

| name     | illustrate                              | type                    |
| -------- | --------------------------------------- | ----------------------- |
| getImage | Get the Base64 string of the screenshot | `() => Promise<string>` |

<embed src="@/docs/common/control/method.en.md"></embed>

## event

<embed src="@/docs/common/control/event.en.md"></embed>
---
title: ExportImage 导出图片
order: 7
---

对当前地图部分进行截图并生成图片的 `Base64` 字符串。

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*Yc78QZaeJWkAAAAAAAAAAAAAARQnAQ" width="400"/>

## 说明

[示例](/examples/component/control#exportimage)

截图时被截取的目标仅包含：

- 地图底图
- 图层（不包含 MarkerLayer）

**注意：由于当前地图底图对应 `Canvas` 默认开启了缓冲区，导致默认情况下无法截取到地图底图部分。**

因此若开发者需要完整的截图能力，则应当在初始化地图实例时传递以下参数以关闭 `Canvas` 缓冲区。

```ts
new GaodeMapV2({
  WebGLParams: {
    preserveDrawingBuffer: true,
  },
});

new Mapbox({
  preserveDrawingBuffer: true,
});
```

## 使用

```ts
import { Scene, ExportImage } from '@antv/l7';

const scene = new Scene({
  id: 'map',
  map: new GaodeMapV2({
    // 关闭地图缓冲区，否则截图时无法截取到地图部分
    WebGLParams: {
      preserveDrawingBuffer: true,
    },
  }),
});

scene.on('loaded', () => {
  const zoom = new ExportImage({
    onExport: (base64: string) => {
      // download(base64)
    },
  });
  scene.addControl(zoom);
});
```

## 配置

| 名称      | 说明                                               | 类型                       |
| --------- | -------------------------------------------------- | -------------------------- |
| imageType | 截图图片的格式                                     | `'png'` \| `'jpeg'`    |
| onExport  | 截图成功后，用于接收图片 `Base64` 字符串的回调函数 | `(base64: string) => void` |

<embed src="@/docs/common/control/btn-api.zh.md"></embed>

<embed src="@/docs/common/control/api.zh.md"></embed>

## 方法

| 名称     | 说明                     | 类型                    |
| -------- | ------------------------ | ----------------------- |
| getImage | 获取截图的 Base64 字符串 | `() => Promise<string>` |

<embed src="@/docs/common/control/method.zh.md"></embed>

## 事件

<embed src="@/docs/common/control/event.zh.md"></embed>
---
title: GeoLocate
order: 6
---

using browser environment`nagigator`of`getlocation`Method, use the browser to turn on the location sensing capability to obtain the longitude and latitude of the current user.

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BOsBRJyYeMEAAAAAAAAAAAAAARQnAQ" width="400"/>

## illustrate

[Example](/examples/component/control#geolocate)

**Notice:**

* When using this capability, the user will be required to authenticate the browser to enable location awareness.
* The coordinates currently obtained by the browser are`WGS84`The geographical coordinate system will be biased when used on the Gaode map, so it can be used`transform`Configure the coordinate system conversion.

## use

```ts
import { Scene, GeoLocate } from '@antv/l7';
import gcoord from 'gcoord';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  const geoLocate = new GeoLocate({
    transform: (position) => {
      //Convert the coordinates obtained based on the WGS84 geographical coordinate system into the GCJ02 coordinate system
      return gcoord.transform(position, gcoord.WGS84, gcoord.GCJ02);
    },
  });
  scene.addControl(geoLocate);
});
```

## Configuration

| name      | illustrate                                                                                                                              | type                                               |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- |
| transform | Format passed`getlocation`The function of the obtained longitude and latitude can be used to convert the geographical coordinate system | `(position: [number, number]) => [number, number]` |

<embed src="@/docs/common/control/btn-api.en.md"></embed>

<embed src="@/docs/common/control/api.en.md"></embed>

## method

| name           | illustrate                                                    | type                              |
| -------------- | ------------------------------------------------------------- | --------------------------------- |
| getGeoLocation | Get the latitude and longitude of the current user's location | `() => Promise<[number, number]>` |

<embed src="@/docs/common/control/method.en.md"></embed>

## event

<embed src="@/docs/common/control/event.en.md"></embed>
---
title: LayerPopup
order: 1
---

LayerPopup is a bubble encapsulated based on Popup and is specifically used to display layer element information.

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*HC6BT6v3YRIAAAAAAAAAAAAAARQnAQ" width="300"/>

## illustrate

LayerPopup is designed to allow developers to quickly generate bubbles for displaying layer information through configuration. Developers can pass in the layers that need to display information bubbles and the fields that need to be displayed.

LayerPopup will listen to the mouse events of the target layer by itself. When the user clicks/hoveres on an element of the target layer, the Popup will automatically open and display the field value of the element.

## use

[Example](/examples/component/popup#layerpopup)[Custom content examples](/zh/examples/component/popup/#customContent)

```ts
import { Scene, LayerPopup, PointLayer } from '@antv/l7';

const scene = new Scene({
  id: 'map',
  map: new GaodeMapV2({
    // ...
  }),
});

scene.on('loaded', () => {
  const pointLayer = new PointLayer();
  pointLayer.source(
    [
      {
        lng: 120,
        lat: 30,
        name: 'Test 1',
      },
    ],
    {
      parser: {
        type: 'json',
        x: 'lng',
        y: 'lat',
      },
    },
  );
  scene.addLayer(pointLayer);
  const layerPopup = new LayerPopup({
    items: [
      {
        layer: pointLayer,
        fields: [
          {
            field: 'name',
            formatValue: (name?: string) => name.trim() ?? '-',
          },
        ],
      },
    ],
    trigger: 'hover',
  });
  scene.addPopup(popup);
});
```

## Configuration

| name    | illustrate                                                                                                                                 | type                          | default value |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------- | ------------- |
| items   | The layer configuration array of Popup needs to be displayed, and each option type is visible[LayerPopupConfigItem](#layerpopupconfigitem) | `Array<LayerPopupConfigItem>` | `[]`          |
| trigger | How the mouse triggers Popup display                                                                                                       | `'hover' \| 'click'`          | `'hover'`     |

### LayerPopupConfigItem

| name          | illustrate                                                                                                                                                                                                     | type                                             |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| layer         | Need to display the Popup's target layer instance, or its`id`or`name`                                                                                                                                          | `BaseLayer`\|`string`                            |
| fields        | Array of fields that need to be displayed, supporting the incoming field key value string, or detailed configuration for the field[LayerField](#layerfield)                                                    | `string`\|`LayerField`                           |
| customContent | Custom bubble content supports two ways of directly passing in custom content or returning custom content through a callback function.`fields`Under coexistence, the configuration is read first and rendered. | `ElementType \| ((feature: any) => ElementType)` |
| title         | Custom bubble title supports two ways of directly passing in custom content or returning custom content through a callback function.                                                                           | `ElementType \| ((feature: any) => ElementType)` |

### LayerField

| name        | illustrate                         | type                                                            |
| ----------- | ---------------------------------- | --------------------------------------------------------------- |
| field       | The key value string of the field  | `string`                                                        |
| formatField | Format the displayed key field     | `ElementType \| ((field: string, feature: any) => ElementType)` |
| formatValue | Format the displayed value value   | `ElementType \| ((value: any, feature: any) => ElementType)`    |
| getValue    | Customize the way to get the value | `(feature: any) => any`                                         |

### ElementType

```ts
type ElementType =
  | HTMLElement
  | HTMLElement[]
  | DocumentFragment
  | Text
  | string;
```

## method

| name       | illustrate                                               | type                                                                 |
| ---------- | -------------------------------------------------------- | -------------------------------------------------------------------- |
| getOptions | Get the current Popup configuration                      | `() => IPopupOption`                                                 |
| setOptions | Update current Popup configuration                       | `(newOption: Partial<IPopupOption>) => this`                         |
| show       | Show Popup                                               | `() => this`                                                         |
| hide       | Hide Popup                                               | `() => this`                                                         |
| setLngLat  | Set the latitude and longitude of the Popup anchor point | `(lngLat: { lng: number; lat: number } \| [number, number]) => this` |
| panToPopup | Pan the map to the current Popup location                | `() => this`                                                         |

## event

| name  | illustrate                        | type         |
| ----- | --------------------------------- | ------------ |
| open  | Fired when Popup is added         | `() => void` |
| close | Triggered when Popup is removed   | `() => void` |
| show  | Triggered when Popup is displayed | `() => void` |
| hide  | Triggered when Popup is hidden    | `() => void` |
---
title: 控件
order: 1
---

地图控件指的是悬停在地图四周，可以对地图以及图层等元素进行**信息呈现**或**交互**的组件。

![](https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*zgFeTocc-_oAAAAAAAAAAAAAARQnAQ)

## 使用

```ts
import { Scene, Zoom } from '@antv/l7';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  // 实例化 Zoom 控件，可以在构造器中传入控件的配置
  const zoom = new Zoom({
    position: 'leftbottom',
    className: 'my-test-class',
  });

  // 将实例化的控件添加至 L7 中
  scene.addControl(zoom);
});
```

## 更新配置

在控件实例化之后，如果需要更新配置，可以调用控件实例的 `setOptions` 方法，同时传入需要更新的配置对象即可。

```ts
const zoom = new Zoom({
  position: 'leftbottom',
});

const onPositionChange = () => {
  // 通过 setOptions 传入需要更新的配置对象
  zoom.setOptions({
    position: 'topright',
  });
};
```

## 插槽

当前 L7 中的控件支持插入到地图的**左上、左下、右上、右下、上、左、下、右**八个位置插槽或者用户自定义的 `DOM` 中，并且在同一地图插槽中，多个控件之间支持**横向**和**纵向**排列。

在初始化所有的控件类时，可以传入 `position` 参数来设置控件对应的插槽以及排列方式。

![](https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BfG1TI231ysAAAAAAAAAAAAAARQnAQ)

## 配置

<embed src="@/docs/common/control/api.zh.md"></embed>

## 方法

<embed src="@/docs/common/control/method.zh.md"></embed>

## 事件

<embed src="@/docs/common/control/event.zh.md"></embed>
---
title: Control
order: 1
---

The map control refers to hovering around the map, and you can perform operations on the map, layers and other elements.**information presentation**or**interaction**s component.

![](https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*zgFeTocc-_oAAAAAAAAAAAAAARQnAQ)

## use

```ts
import { Scene, Zoom } from '@antv/l7';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  //Instantiate the Zoom control, you can pass in the control configuration in the constructor
  const zoom = new Zoom({
    position: 'leftbottom',
    className: 'my-test-class',
  });

  //Add the instantiated control to L7
  scene.addControl(zoom);
});
```

## Update configuration

After the control is instantiated, if you need to update the configuration, you can call the control instance's`setOptions`method, and pass in the configuration object that needs to be updated.

```ts
const zoom = new Zoom({
  position: 'leftbottom',
});

const onPositionChange = () => {
  // Pass in the configuration object that needs to be updated through setOptions
  zoom.setOptions({
    position: 'topright',
  });
};
```

## slot

Currently the controls in L7 support inserting into the map**Upper left, lower left, upper right, lower right, upper, left, lower, right**Eight position slots or user-defined`DOM`, and support between multiple controls in the same map slot**Horizontal**and**portrait**arrangement.

When initializing all control classes, you can pass in`position`Parameters to set the corresponding slot and arrangement of the control.

![](https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BfG1TI231ysAAAAAAAAAAAAAARQnAQ)

## Configuration

<embed src="@/docs/common/control/api.en.md"></embed>

## method

<embed src="@/docs/common/control/method.en.md"></embed>

## event

<embed src="@/docs/common/control/event.en.md"></embed>
---
title: GeoLocate 定位
order: 6
---

使用浏览器环境的 `nagigator` 的 `getlocation` 方法，使用浏览器打开位置感应能力获取当前用户所在经纬度。

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*BOsBRJyYeMEAAAAAAAAAAAAAARQnAQ" width="400"/>

## 说明

[示例](/examples/component/control#geolocate)

**注意：**

- 在使用该能力时，会需要用户对浏览器打开位置感知能力进行鉴权。
- 当前浏览器获取到的坐标是 `WGS84` 地理坐标系，在高德地图上使用会有偏差，可以使用 `transform` 配置进行坐标系的转换。

## 使用

```ts
import { Scene, GeoLocate } from '@antv/l7';
import gcoord from 'gcoord';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  const geoLocate = new GeoLocate({
    transform: (position) => {
      // 将获取到基于 WGS84 地理坐标系 的坐标转成 GCJ02 坐标系
      return gcoord.transform(position, gcoord.WGS84, gcoord.GCJ02);
    },
  });
  scene.addControl(geoLocate);
});
```

## 配置

| 名称      | 说明                                                                    | 类型                                               |
| --------- | ----------------------------------------------------------------------- | -------------------------------------------------- |
| transform | 格式化通过 `getlocation` 获取到的经纬度的函数，可以用于地理坐标系的转换 | `(position: [number, number]) => [number, number]` |

<embed src="@/docs/common/control/btn-api.zh.md"></embed>

<embed src="@/docs/common/control/api.zh.md"></embed>

## 方法

| 名称           | 说明                   | 类型                                |
| -------------- | ---------------------- |-----------------------------------|
| getGeoLocation | 获取当前用户所在经纬度 | `() => Promise<[number, number]>` |

<embed src="@/docs/common/control/method.zh.md"></embed>

## 事件

<embed src="@/docs/common/control/event.zh.md"></embed>
---
title: LayerPopup 图层信息框
order: 1
---

LayerPopup 基于 Popup 封装的，专门用于展示图层元素信息的气泡。

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*HC6BT6v3YRIAAAAAAAAAAAAAARQnAQ" width="300"/>

## 说明

LayerPopup 是为了让开发者通过配置快速生成用于展示图层信息的气泡，开发者可以传入需要展示信息气泡的图层，以及需要展示的字段。

LayerPopup 会自行对目标图层的鼠标事件进行监听，当用户点击/悬停在目标图层的某一元素上时，会自动打开 Popup 并展示该元素的字段值。

## 使用

[示例](/examples/component/popup#layerpopup)
[自定义内容示例](/zh/examples/component/popup/#customContent)

```ts
import { Scene, LayerPopup, PointLayer } from '@antv/l7';

const scene = new Scene({
  id: 'map',
  map: new GaodeMapV2({
    // ...
  }),
});

scene.on('loaded', () => {
  const pointLayer = new PointLayer();
  pointLayer.source(
    [
      {
        lng: 120,
        lat: 30,
        name: 'Test 1',
      },
    ],
    {
      parser: {
        type: 'json',
        x: 'lng',
        y: 'lat',
      },
    },
  );
  scene.addLayer(pointLayer);
  const layerPopup = new LayerPopup({
    items: [
      {
        layer: pointLayer,
        fields: [
          {
            field: 'name',
            formatValue: (name?: string) => name.trim() ?? '-',
          },
        ],
      },
    ],
    trigger: 'hover',
  });
  scene.addPopup(popup);
});
```

## 配置

| 名称    | 说明                                                                                          | 类型                          | 默认值    |
| ------- | --------------------------------------------------------------------------------------------- | ----------------------------- | --------- |
| items   | 需要展示 Popup 的图层配置数组，每个选项类型可见 [LayerPopupConfigItem](#layerpopupconfigitem) | `Array<LayerPopupConfigItem>` | `[]`      |
| trigger | 鼠标触发 Popup 展示的方式                                                                     | `'hover' \| 'click'`          | `'hover'` |

### LayerPopupConfigItem

| 名称          | 说明                                                                                                                 | 类型                                             |
| ------------- | -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| layer         | 需要展示 Popup 的目标图层实例，或其的 `id` 或 `name`                                                                 | `BaseLayer` \| `string`                          |
| fields        | 需要展示的字段数组，支持传入字段 key 值字符串，或者针对该字段的详细配置 [LayerField](#layerfield)                    | `string` \| `LayerField`                         |
| customContent | 自定义气泡内容，支持直接传入自定义内容或者通过回调函数返回自定义内容两种方式，与 `fields` 共存下优先读取该配置并渲染 | `ElementType \| ((feature: any) => ElementType)` |
| title         | 自定义气泡标题，支持直接传入自定义内容或者通过回调函数返回自定义内容两种方式                                         | `ElementType \| ((feature: any) => ElementType)` |

### LayerField

| 名称        | 说明                        | 类型                                                            |
| ----------- | --------------------------- | --------------------------------------------------------------- |
| field       | 字段的 key 值字符串         | `string`                                                        |
| formatField | 对展示的 key 字段进行格式化 | `ElementType \| ((field: string, feature: any) => ElementType)` |
| formatValue | 对展示的 value 值进行格式化 | `ElementType \| ((value: any, feature: any) => ElementType)`    |
| getValue    | 自定义获取值的方式          | `(feature: any) => any`                                         |

### ElementType

```ts
type ElementType =
  | HTMLElement
  | HTMLElement[]
  | DocumentFragment
  | Text
  | string;
```

## 方法

| 名称       | 说明                        | 类型                                                                 |
| ---------- | --------------------------- | -------------------------------------------------------------------- |
| getOptions | 获取当前 Popup 配置         | `() => IPopupOption`                                                 |
| setOptions | 更新当前 Popup 配置         | `(newOption: Partial<IPopupOption>) => this`                         |
| show       | 显示 Popup                  | `() => this`                                                         |
| hide       | 隐藏 Popup                  | `() => this`                                                         |
| setLngLat  | 设置 Popup 锚点所在经纬度   | `(lngLat: { lng: number; lat: number } \| [number, number]) => this` |
| panToPopup | 将地图平移至当前 Popup 位置 | `() => this`                                                         |

## 事件

| 名称  | 说明               | 类型         |
| ----- | ------------------ | ------------ |
| open  | Popup 被添加时触发 | `() => void` |
| close | Popup 被移除时触发 | `() => void` |
| show  | Popup 显示时触发   | `() => void` |
| hide  | Popup 隐藏时触发   | `() => void` |
---
title: Logo
order: 2
---

A control used to display logo images on the map, and supports click-to-jump hyperlinks.

![](https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*CbdSRLizMLIAAAAAAAAAAAAAARQnAQ)

## illustrate

Currently, L7 will display this control in the lower left corner of the map by default. If it needs to be hidden, it can be configured when the Scene is instantiated:

```ts
import { Scene } from '@antv/l7';

const scene = new Scene({
  // ...

  // Close the default L7 Logo
  logoVisible: false,
});
```

## use

[Example](/examples/component/control#logo)

```ts
import { Scene, Logo } from '@antv/l7';

const scene = new Scene({
  //...
  logoVisible: false,
});

scene.on('loaded', () => {
  const logo = new Logo({
    // 图片 url
    img:
      'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*GRb1TKp4HcMAAAAAAAAAAAAAARQnAQ',
    // 跳转地址
    href: 'https://l7.antv.antgroup.com',
  });
  scene.addControl(logo);
});
```

## Configuration

| name | illustrate                                                                                                           | type     |
| ---- | -------------------------------------------------------------------------------------------------------------------- | -------- |
| img  | Logo display image url                                                                                               | `string` |
| href | Click the logo to jump to the hyperlink. If it is not uploaded, the image will be displayed. Clicking will not jump. | `string` |

<embed src="@/docs/common/control/api.en.md"></embed>

## method

<embed src="@/docs/common/control/method.en.md"></embed>

## event

<embed src="@/docs/common/control/event.en.md"></embed>
---
title: Fullscreen
order: 5
---

Used to control map areas**full screen**and**Exit Full Screen**control button control.

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*CcOXRqK5ARgAAAAAAAAAAAAAARQnAQ" width="400"/>

## use

[Example](/examples/component/control#fullscreen)

```ts
import { Scene, Fullscreen } from '@antv/l7';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  const fullscreen = new Fullscreen({
    btnText: '全屏',
    exitBtnText: '退出全屏',
  });
  scene.addControl(fullscreen);
});
```

## Configuration

<embed src="@/docs/common/control/btn-api.en.md"></embed>

| name        | illustrate                                    | type                        |
| ----------- | --------------------------------------------- | --------------------------- |
| exitBtnIcon | Exit full screen button icon                  | `HTMLElement`\|`SVGElement` |
| exitBtnText | Text for exit full screen button              | `string`                    |
| exitTitle   | Exit full screen button text`title`Attributes | `string`                    |

<embed src="@/docs/common/control/api.en.md"></embed>

## method

| name             | illustrate                                                      | type         |
| ---------------- | --------------------------------------------------------------- | ------------ |
| toggleFullscreen | Enter/exit the full screen state of the full screen map section | `() => void` |

<embed src="@/docs/common/control/method.en.md"></embed>

## event

| name             | illustrate                                   | type                              |
| ---------------- | -------------------------------------------- | --------------------------------- |
| fullscreenChange | Triggered when the full screen state changes | `(isFullscreen: boolean) => void` |

<embed src="@/docs/common/control/event.en.md"></embed>
---
title: Logo 标志
order: 2
---

用于在地图上展示 Logo 图片的控件，并且支持超链接点击跳转。

![](https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*CbdSRLizMLIAAAAAAAAAAAAAARQnAQ)

## 说明

当前 L7 会默认在地图左下角展示该控件，如需隐藏可以在 Scene 实例化时配置：

```ts
import { Scene } from '@antv/l7';

const scene = new Scene({
  // ...

  // 关闭默认 L7 Logo
  logoVisible: false,
});
```

## 使用

[示例](/examples/component/control#logo)

```ts
import { Scene, Logo } from '@antv/l7';

const scene = new Scene({
  //...
  logoVisible: false,
});

scene.on('loaded', () => {
  const logo = new Logo({
    // 图片 url
    img:
      'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*GRb1TKp4HcMAAAAAAAAAAAAAARQnAQ',
    // 跳转地址
    href: 'https://l7.antv.antgroup.com',
  });
  scene.addControl(logo);
});
```

## 配置

| 名称 | 说明                                                 | 类型     |
| ---- | ---------------------------------------------------- | -------- |
| img  | Logo 展示的图片 url                                  | `string` |
| href | 点击 Logo 跳转的超链接，不传则纯展示图片，点击不跳转 | `string` |

<embed src="@/docs/common/control/api.zh.md"></embed>

## 方法

<embed src="@/docs/common/control/method.zh.md"></embed>

## 事件

<embed src="@/docs/common/control/event.zh.md"></embed>
---
title: Fullscreen 全屏
order: 5
---

用于控制地图区域的**全屏**和**退出全屏**的控制按钮控件。

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*CcOXRqK5ARgAAAAAAAAAAAAAARQnAQ" width="400"/>

## 使用

[示例](/examples/component/control#fullscreen)

```ts
import { Scene, Fullscreen } from '@antv/l7';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  const fullscreen = new Fullscreen({
    btnText: '全屏',
    exitBtnText: '退出全屏',
  });
  scene.addControl(fullscreen);
});
```

## 配置

<embed src="@/docs/common/control/btn-api.zh.md"></embed>

| 名称        | 说明                              | 类型                              |
| ----------- | --------------------------------- | --------------------------------- |
| exitBtnIcon | 退出全屏按钮的图标                | `HTMLElement` \| `SVGElement` |
| exitBtnText | 退出全屏按钮的文本                | `string`                          |
| exitTitle   | 退出全屏按钮的文本的 `title` 属性 | `string`                          |

<embed src="@/docs/common/control/api.zh.md"></embed>

## 方法

| 名称             | 说明                            | 类型         |
| ---------------- | ------------------------------- | ------------ |
| toggleFullscreen | 进入/退出全屏地图部分的全屏状态 | `() => void` |

<embed src="@/docs/common/control/method.zh.md"></embed>

## 事件

| 名称             | 说明                     | 类型                              |
| ---------------- | ------------------------ | --------------------------------- |
| fullscreenChange | 当全屏状态发生变化时触发 | `(isFullscreen: boolean) => void` |

<embed src="@/docs/common/control/event.zh.md"></embed>
---
title: Marker 图层
order: 3
---

<embed src="@/docs/common/style.md"></embed>

MarkerLayer 是 Marker 的升级版，Marker 是独立的地图标注，MarkerLayer 则是统一管理大量的 Marker 数据。

**技术差异**

- Marker Dom 绘制一个地图元素
- MarkerLayer 统一管理多个 DomMarker
- PointLayer 通过 WebGL 绘制元素。

**功能差异**

- MarkerLayer 元素的自定义性比较强，任何 HTML+ CSS 的组合都可以绘制在地图上。
- PointLayer 自定义性比较弱，实现成本比较高，优势可以绘制大量的数据，性能比较好。

## 使用

```javascript
import { Marker, MarkerLayer } from '@antv/l7';
```

### 构造函数

```javascript
const markerLayer = new MarkerLayer(option);

// 调用 addMarker方法 将多个Marker添加到Layer

scene.addMarkerLayer(markerLayer);
```

#### option

- cluster 聚合 `boolean` 默认 `false`

- clusterOption 聚合配置

  - field `string` 聚合统计字段
  - method `sum| max| min| mean`
  - element `function` 通过回调函数设置聚合 Marker 的样式，返回 dom 元素
    回调函数包含以下参数
    - point_count 默认 聚合元素个数
    - clusterData `Array` 聚合节点的原始数据
    - point_sum 聚合求和 根据 field 和 method 计算
    - point_max 聚合最大值 根据 field 和 method 计算
    - point_min 聚合最小值 根据 field 和 method 计算
    - point_mean 聚合平均值 根据 field 和 method 计算

### 方法

#### addMarker

参数

- marker `IMarker` 需要添加的 Marker

添加 Marker

通过 Marker 对象实例化一个 Marker

```javascript
const marker = new Marker().setLnglat(); // 添加进Marker必须设置经纬度才能添加
markerLayer.addMarker(marker);
```

为 Marker 添加属性信息,

如果聚合参数设置统计配置项 `field| method`需要为 Marker 添加属性信息

通过 Marker 的 extData[配置项](/api/compnent/marker#option)设置 Marker 属性信息

```javascript
const marker = new Marker({
  extData: nodes.features[i].properties,
}).setLnglat({
  lng: coordinates[0],
  lat: coordinates[1],
});
```

#### removeMarker

从 MarkerLayer 移除 Marker

#### getMarkers

获取 MarkerLayer 中的所有 Marker

#### clear

清除掉所有的 Marker

####

### Scene

#### addMarkerLayer

添加 MarkerLayer

```javascript
scene.addMarkerLayer(layer);
```

#### removeMarkerLayer

移除 MarkerLayer

```javascript
scene.removeMarkerLayer(layer);
```

### demo 地址

[markerLayer ](/examples/point/marker#markerlayer)

[markerLayer 聚合](/examples/point/marker#clustermarker)
---
title: Marker Layer
order: 3
---

<embed src="@/docs/common/style.md"></embed>

MarkerLayer 不同于 PointLayer 图层

**技术差异**

- MarkerLayer 地图元素采用 Dom 元素绘制
- PointLayer 通过 WebGL 绘制元素。

**功能差异**

- MarkerLayer 元素的自定义性比较强，任何 HTML+ CSS 的组合都可可以绘制在地图上。
- PointLayer 自定义性比较弱，实现成本比较高，优势可以绘制大量的数据，性能比交互。

## 使用

```javascript
import { Marker, MarkerLayer } from '@antv/l7';
```

### 构造函数

```javascript
const markerLayer = new MarkerLayer(option);

// 调用 addMarker方法 将多个Marker添加到Layer

scene.addMarkerLayer(markerLayer);
```

#### option

- cluster 聚合 `boolean` 默认 `false`

- clusterOption 聚合配置

  - field `string` 聚合统计字段
  - method `sum| max| min| mean`
  - element `function` 通过回调函数设置聚合 Marker 的样式，返回 dom 元素

    回调函数包含以下参数
    point_count 默认 聚合元素个数
    clusterData `Array` 聚合节点的原始数据
    point_sum 聚合求和 根据 field 和 method 计算
    point_max 聚合最大值 根据 field 和 method 计算
    point_min 聚合最小值 根据 field 和 method 计算
    point_mean 聚合平均值 根据 field 和 method 计算

后续会增加更多配置项目

### 方法

#### addMarker

参数

- marker `IMarker` 需要添加的 Marker

添加 Marker

通过 Marker 对象实例化一个 Marker

```javascript
const marker = new Marker().setLnglat(); // 添加进Marker必须设置经纬度才能添加
markerLayer.addMarker(marker);
```

为 Marker 添加属性信息,

如果聚合参数设置统计配置项 `field| method`需要为 Marker 添加属性信息

通过 Marker 的 extData[配置项](/api/component/marker#option)设置 Marker 属性信息

```javascript
const marker = new Marker({
  extData: nodes.features[i].properties,
}).setLnglat({
  lng: coordinates[0],
  lat: coordinates[1],
});
```

#### removeMarker

从 MarkerLayer 移除 Marker

#### getMarkers

获取 MarkerLayer 中的所有 Marker

#### clear

清除掉所有的 Marker

####

### Scene

#### addMarkerLayer

添加 MarkerLayer

```javascript
scene.addMarkerLayer(layer);
```

#### removeMarkerLayer

移除 MarkerLayer

```javascript
scene.removeMarkerLayer(layer);
```

### demo 地址

[markerLayer ](/examples/point/marker#markerlayer)

[markerLayer 聚合](/examples/point/marker#clustermarker)
---
title: MapTheme
order: 11
---

This control is used to switch the theme style of the map basemap.

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*xb29TawbZDgAAAAAAAAAAAAAARQnAQ" width="400"/>

## illustrate

MapTheme will display the corresponding default theme options by default based on the current map basemap type (such as Mapbox, GaodeMapV2), and you can also pass in custom theme options.

## use

[Example](/examples/component/control#maptheme)

```ts
import { Scene, MapTheme } from '@antv/l7';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  const mapTheme = new MapTheme({});
  scene.addControl(mapTheme);
});
```

## Configuration

| name    | illustrate                                                                                                  | type                        |
| ------- | ----------------------------------------------------------------------------------------------------------- | --------------------------- |
| options | User-defined map theme options, the type of each option is visible[IControlOptionItem](#icontroloptionitem) | `Array<IControlOptionItem>` |

## IControlOptionItem

```ts
export type IControlOptionItem = {
  //The text corresponding to the theme option
  text: string;
  //The theme option corresponds to the key value of the map theme style
  value: string;
  //Theme options correspond to the pictures displayed
  img?: string;
};
```

<embed src="@/docs/common/control/popper-api.zh.md"></embed>

<embed src="@/docs/common/control/btn-api.en.md"></embed>

<embed src="@/docs/common/control/api.en.md"></embed>

## method

<embed src="@/docs/common/control/method.en.md"></embed>

## event

<embed src="@/docs/common/control/event.en.md"></embed>

<embed src="@/docs/common/control/popper-event.en.md"></embed>

<embed src="@/docs/common/control/select-event.en.md"></embed>
---
title: MouseLocation
order: 9
---

Used to display the longitude and latitude corresponding to the current cursor on the map in real time.

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*i4F5QZ4K650AAAAAAAAAAAAAARQnAQ" width="400"/>

## use

[Example](/examples/component/control#mouselocation)

```ts
import { Scene, MouseLocation } from '@antv/l7';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  const mouseLocation = new MouseLocation({
    transform: (position) => {
      return position;
    },
  });
  scene.addControl(mouseLocation);
});
```

## Configuration

| name      | illustrate                                                            | type                                               |
| --------- | --------------------------------------------------------------------- | -------------------------------------------------- |
| transform | Callback function to convert the longitude and latitude of the cursor | `(position: [number, number]) => [number, number]` |

<embed src="@/docs/common/control/api.en.md"></embed>

## method

<embed src="@/docs/common/control/method.en.md"></embed>

## event

| name           | illustrate                                                      | type                                   |
| -------------- | --------------------------------------------------------------- | -------------------------------------- |
| locationChange | Triggered when the longitude and latitude of the cursor changes | `(position: [number, number]) => void` |

<embed src="@/docs/common/control/event.en.md"></embed>
---
title: MouseLocation 光标经纬度
order: 9
---

用于实时展示当前光标在地图上所对应的经纬度。

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*i4F5QZ4K650AAAAAAAAAAAAAARQnAQ" width="400"/>

## 使用

[示例](/examples/component/control#mouselocation)

```ts
import { Scene, MouseLocation } from '@antv/l7';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  const mouseLocation = new MouseLocation({
    transform: (position) => {
      return position;
    },
  });
  scene.addControl(mouseLocation);
});
```

## 配置

| 名称      | 说明                         | 类型                                               |
| --------- | ---------------------------- | -------------------------------------------------- |
| transform | 转换光标所在经纬度的回调函数 | `(position: [number, number]) => [number, number]` |

<embed src="@/docs/common/control/api.zh.md"></embed>

## 方法

<embed src="@/docs/common/control/method.zh.md"></embed>

## 事件

| 名称           | 说明                         | 类型                                   |
| -------------- | ---------------------------- | -------------------------------------- |
| locationChange | 光标所在经纬度发生变化时触发 | `(position: [number, number]) => void` |

<embed src="@/docs/common/control/event.zh.md"></embed>
---
title: MapTheme 地图主题
order: 11
---

该控件用于切换地图底图的主题样式。

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*xb29TawbZDgAAAAAAAAAAAAAARQnAQ" width="400"/>

## 说明

MapTheme 会根据当前地图底图类型（如 Mapbox、GaodeMapV2），默认展示相对应的默认主题选项，用于也可以传入自定义的主题选项

## 使用

[示例](/examples/component/control#maptheme)

```ts
import { Scene, MapTheme } from '@antv/l7';

const scene = new Scene({
  // ...
});

scene.on('loaded', () => {
  const mapTheme = new MapTheme({});
  scene.addControl(mapTheme);
});
```

## 配置

| 名称    | 说明                                                                                   | 类型                        |
| ------- | -------------------------------------------------------------------------------------- | --------------------------- |
| options | 用户自定义的地图主题选项，每个选项的类型可见 [IControlOptionItem](#icontroloptionitem) | `Array<IControlOptionItem>` |

## IControlOptionItem

```ts
export type IControlOptionItem = {
  // 主题选项对应的文本
  text: string;
  // 主题选项对应地图主题 style 的 key 值
  value: string;
  // 主题选项对应展示的图片
  img?: string;
};
```

<embed src="@/docs/common/control/popper-api.zh.md"></embed>

<embed src="@/docs/common/control/btn-api.zh.md"></embed>

<embed src="@/docs/common/control/api.zh.md"></embed>

## 方法

<embed src="@/docs/common/control/method.zh.md"></embed>

## 事件

<embed src="@/docs/common/control/event.zh.md"></embed>

<embed src="@/docs/common/control/popper-event.zh.md"></embed>

<embed src="@/docs/common/control/select-event.zh.md"></embed>
---
title: 瓦片调试图层
order: 4
---
显示瓦片范围和行列号信息，用于测试验证瓦片服务

```
import { Scene, TileDebugLayer } from '@antv/l7';
const debugerLayer = new TileDebugLayer();
scene.addLayer(debugerLayer);

```---
title: 瓦片调试图层
order: 4
---

Display tile range and row and row number information for testing and verifying tile services

```
import { Scene, TileDebugLayer } from '@antv/l7';
const debugerLayer = new TileDebugLayer();
scene.addLayer(debugerLayer);
```
---
title: Vector 矢量瓦片
order: 0
---

<embed src="@/docs/common/style.md"></embed>

### 简介

`L7` 的矢量瓦片图层复用了普通图层的数据可视化能力，支持对图层的样式进行数据映射。目前矢量瓦片支持了点、线、面、掩模等图层

| 分类     | Layer            | parserType                          | 描述                                      |
| -------- | ---------------- | ----------------------------------- | ----------------------------------------- |
| 矢量瓦片 | `PointLayer`     | parser of PointLayer、`geojsonvt`   | 矢量点图层                                |
| 矢量瓦片 | `LineLayer`      | parser of LineLayer、`geojsonvt`    | 矢量线图层                                |
| 矢量瓦片 | `PolygonLayer`   | parser of PolygonLayer、`geojsonvt` | 矢量几何体图层                            |
| 矢量瓦片 | `MaskLayer`      | parser of MaskLayer、`geojsonvt`    | 矢量掩模图层                              |
| 矢量瓦片 | `TileDebugLayer` | `/`                                 | `TileDebugLayer` 不需要执行 `source` 方法 |

瓦片图层其他配置项和基础图层 PointLayer、Linelayer、PolygonLayer 保持一致

### options

<embed src="@/docs/api/tile/common/options.zh.md"></embed>

### source(url: string, option: IOption)

矢量瓦片的数据源需要传入矢量数据的瓦片服务以及对应的配置参数。

#### url

数据服务的路径支持单服务和多服务的写法。

- 单服务器 向一台服务器请求瓦片数据。
- 多服务器 向多台服务器请求同一份服务的瓦片数据。

  - 使用大括号的写法请求设置多服务器，如 `{1-3}`、`{a-c}`。

```js
// 单服务器
const source = new Source('http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}', {...})

// 多服务器
const source = new Source('http://webst0{1-4}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}', {...})
```

#### source option

关于配置参数我们需要关系的是里面 `parser` 字段对应的参数。

```js
const source = new Source(url, {
  parser: {...}
})
```

| 参数           | 类型                               | 默认值                                     | 描述                 |
| -------------- | ---------------------------------- | ------------------------------------------ | -------------------- |
| type           | `string`                           | /                                          | 固定值为 `mvt`       |
| tileSize       | `number`                           | `256`                                      | 请求的瓦片尺寸       |
| minZoom        | `number`                           | `0`                                        | 请求瓦片的最小层级   |
| maxZoom        | `number`                           | `Infinity`                                 | 请求瓦片的最大层级   |
| zoomOffset     | `number`                           | `0`                                        | 请求瓦片层级的偏移量 |
| extent         | `[number, number, number, number]` | `[-Infinity,-Infinity,Infinity,Infinity,]` | 请求瓦片的边界       |
| updateStrategy | `UpdateTileStrategy`               | `replace`                                  | 瓦片的替换策略       |

```js
type UpdateTileStrategy = 'realtime' | 'overlap' | 'replace';
```

🌟 矢量瓦片推荐复用 Source

```js
const vectorSource = new Source(
  'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/rs_l7/{z}/{x}/{y}.pbf',
  {
    parser: {
      type: 'mvt',
      maxZoom: 9,
      extent: [-180, -85.051129, 179, 85.051129],
    },
  },
);
// 复用
layer1.source(vectorSource);
layer2.source(vectorSource);
```
---
title: Vector 矢量瓦片
order: 0
---

<embed src="@/docs/common/style.md"></embed>

### Introduction

`L7`The vector tile layer reuses the data visualization capabilities of ordinary layers and supports data mapping of layer styles. Currently, vector tiles support point, line, surface, mask and other layers.

| Classification | Layer            | parserType                         | describe                                         |
| -------------- | ---------------- | ---------------------------------- | ------------------------------------------------ |
| vector tiles   | `PointLayer`     | parser of PointLayer、`geojsonvt`   | vector point layer                               |
| vector tiles   | `LineLayer`      | parser of LineLayer、`geojsonvt`    | vector line layer                                |
| vector tiles   | `PolygonLayer`   | parser of PolygonLayer、`geojsonvt` | Vector geometry layer                            |
| vector tiles   | `MaskLayer`      | parser of MaskLayer、`geojsonvt`    | Vector mask layer                                |
| vector tiles   | `TileDebugLayer` | `/`                                | `TileDebugLayer`No need to execute`source`method |

Other configuration items of the tile layer are consistent with the basic layers PointLayer, Linelayer, and PolygonLayer.

### options

<embed src="@/docs/api/tile/common/options.en.md"></embed>

### source(url: string, option: IOption)

The data source of vector tiles needs to pass in the tile service of vector data and the corresponding configuration parameters.

#### url

The data service path supports single service and multi-service writing.

* Single server Requests tile data from one server.
* Multiple servers request tile data for the same service from multiple servers.

  * Use braces to request the setting of multiple servers, such as`{1-3}`、`{a-c}`。

```js
// single server
const source = new Source('http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}', {...})

//Multiple servers
const source = new Source('http://webst0{1-4}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}', {...} )
```

#### source option

Regarding the configuration parameters, what we need to relate to is the inside`parser`Parameters corresponding to the field.

```js
const source = new Source(url, {
  parser: {...}
})
```

| parameter      | type                               | default value                              | describe                           |
| -------------- | ---------------------------------- | ------------------------------------------ | ---------------------------------- |
| type           | `string`                           | /                                          | The fixed value is`mvt`            |
| tileSize       | `number`                           | `256`                                      | Requested tile size                |
| minZoom        | `number`                           | `0`                                        | Request the minimum level of tiles |
| maxZoom        | `number`                           | `Infinity`                                 | Request the maximum level of tiles |
| zoomOffset     | `number`                           | `0`                                        | Request tile level offset          |
| extent         | `[number, number, number, number]` | `[-Infinity,-Infinity,Infinity,Infinity,]` | Request the bounds of a tile       |
| updateStrategy | `UpdateTileStrategy`               | `replace`                                  | Tile replacement strategy          |

```js
type UpdateTileStrategy = 'realtime' | 'overlap' | 'replace';
```

🌟 Recommended reuse of vector tiles Source

```js
const vectorSource = new Source(
  'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/rs_l7/{z}/{x}/{y}.pbf',
  {
    parser: {
      type: 'mvt',
      maxZoom: 9,
      extent: [-180, -85.051129, 179, 85.051129],
    },
  },
);
// 复用
layer1.source(vectorSource);
layer2.source(vectorSource);
```
---
title: GeoJsonVT 瓦片
order: 0
---

<embed src="@/docs/common/style.md"></embed>

`L7` 矢量瓦片除了可以时候后端提供的瓦片服务之外，同时提供了 `geojson-vt` 瓦片切分方案，使得前端在没有后端支持的情况下也能使用矢量瓦片。

### 矢量瓦片 - GeoJsonVT

```javascript
import { PolygonLayer } from '@antv/l7';
fetch(
  'https://gw.alipayobjects.com/os/bmw-prod/2b7aae6e-5f40-437f-8047-100e9a0d2808.json',
)
  .then((d) => d.json())
  .then((data) => {
    const source = new Source(data, {
      parser: { type: 'geojsonvt', maxZoom: 9 },
    });
    const polygon = new PolygonLayer({ featureId: 'COLOR' })
      .source(source)
      .color('red');
  });
```

### sourceLayer

在使用前端瓦片切分的时候我们不再需要为瓦片图层指定数据源。

### source(GeoJsonData: string, option: IOption)

在使用前端瓦片切分的矢量瓦片时，`source` 方法接收的不在时数据服务的地址，而是标准的 `GeoJson` 数据。

#### option

在使用前端瓦片切分的时候我们需要将 `source parser` 的类型设置为 `geojsonvt`。

```js
const source = new Source(data, {
  parser: {
    type: 'geojsonvt',
    maxZoom: 9,
    geojsonvtOptions: {},
  },
});
```

`geojsonOptions` 支持如下参数:

| 参数           | 类型        | 默认值   | 描述                                                           |
| -------------- | ----------- | -------- | -------------------------------------------------------------- | 
| maxZoom        | `number`    | `14`     | max zoom to preserve detail on                                 |
| indexMaxZoom   | `number`    | `5`      | max zoom in the tile index                                     |
| indexMaxPoints | `number`    | `100000` | max number of points per tile in the tile index                |
| tolerance      | `number`    | `3`      | simplification tolerance (higher means simpler)                |
| extent         | `number`    | `4096`   | tile extent                                                    |
| buffer         | `number`    | `64`     | tile buffer on each side                                       |
| lineMetrics    | `boolean`   | `false`  | whether to calculate line metrics                              |
| promoteId      | `string     | null`    | `null`                                                         | name of a feature property to be promoted to feature.id |
| generateId     | `boolean`   | `true`   | whether to generate feature ids. Cannot be used with promoteId |
| debug          | `0, 1 or 2` | `0`      | logging level (0, 1 or 2)                                      |
---
title: GeoJsonVT 瓦片
order: 0
---

<embed src="@/docs/common/style.md"></embed>

`L7`In addition to the tile services provided by the backend, vector tiles also provide`geojson-vt`The tile slicing scheme allows the front end to use vector tiles without back-end support.

### Vector Tiles - GeoJsonVT

```javascript
import { PolygonLayer } from '@antv/l7';
fetch(
  'https://gw.alipayobjects.com/os/bmw-prod/2b7aae6e-5f40-437f-8047-100e9a0d2808.json',
)
  .then((d) => d.json())
  .then((data) => {
    const source = new Source(data, {
      parser: { type: 'geojsonvt', maxZoom: 9 },
    });
    const polygon = new PolygonLayer({ featureId: 'COLOR' })
      .source(source)
      .color('red');
  });
```

### sourceLayer

When using front-end tile segmentation, we no longer need to specify a data source for the tile layer.

### source(GeoJsonData: string, option: IOption)

When using vector tiles split by front-end tiles,`source`The method receives not the address of the data service, but the standard`GeoJson`data.

#### option

When using front-end tile segmentation we need to`source parser`The type is set to`geojsonvt`。

```js
const source = new Source(data, {
  parser: {
    type: 'geojsonvt',
    maxZoom: 9,
    geojsonvtOptions: {},
  },
});
```

`geojsonOptions`The following parameters are supported:

| parameter      | type        | default value | describe                                                       |                                                         |
| -------------- | ----------- | ------------- | -------------------------------------------------------------- | ------------------------------------------------------- |
| maxZoom        | `number`    | `14`          | max zoom to preserve detail on                                 |                                                         |
| indexMaxZoom   | `number`    | `5`           | max zoom in the tile index                                     |                                                         |
| indexMaxPoints | `number`    | `100000`      | max number of points per tile in the tile index                |                                                         |
| tolerance      | `number`    | `3`           | simplification tolerance (higher means simpler)                |                                                         |
| extent         | `number`    | `4096`        | tile extent                                                    |                                                         |
| buffer         | `number`    | `64`          | tile buffer on each side                                       |                                                         |
| lineMetrics    | `boolean`   | `false`       | whether to calculate line metrics                              |                                                         |
| promoteId      | \`string    | null\`        | `null`                                                         | name of a feature property to be promoted to feature.id |
| generateId     | `boolean`   | `true`        | whether to generate feature ids. Cannot be used with promoteId |                                                         |
| debug          | `0, 1 or 2` | `0`           | logging level (0, 1 or 2)                                      |                                                         |
---
title: Style
order: 4
---

<embed src="@/docs/common/style.md"></embed>

瓦片图层的 `style` 参数和使用的图层相关。如矢量点图层，`style` 的参数就是对应点图层的参数。

### raster tile

#### domain: [number, number]

设置数据映射的定义域。  
ps：固定值域为 `[0, 1]`，我们将传入的值（domain） 映射到值域 `[0, 1]` 后从 `rampColor` 构建的色带上取颜色，rgb 多通道栅格不支持。

#### clampLow/clampHigh: boolean

`clampLow` 的默认值为 `false`，设置为 `true`，低于 `domain` 的数据将不显示。  
`clampHigh` 的默认值为 `false`，设置为 `true`，高于 `domain` 的数据将不显示。

ps：rgb 多通道栅格不支持

#### rampColors

- colors  颜色数组
- positions 数据区间

配置值域映射颜色的色带，值域的范围为 `[0 - 1]`, 对应的我们需要为每一个 `position` 位置设置一个颜色值。

⚠️ colors, positions 的长度要相同

```javascript
layer.style({
  rampColors: {
    colors: ['#FF4818', '#F7B74A', '#FFF598', '#91EABC', '#2EA9A1', '#206C7C'],
    positions: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
  },
});
```

ps：⚠️ color, position 的长度要相同，rgb 多通道栅格不支持

### vector tile

矢量图层的 `style` 样式和普通图层保持一致。

### event

🌟 数据栅格支持图层事件，目前图片栅格暂时不支持图层事件。

##### 绑定事件

🌟 数据栅格瓦片

```javascript
// 绑定事件的方式和普通图层保持一致
layer.on('click', e => {...})
```

#### 事件参数

🌟 数据栅格瓦片
数据栅格瓦片的事件参数相比于普通图层的事件返回了新的参数。

#### value: number

🌟 数据栅格瓦片
鼠标事件位置的瓦片的实际数值。
---
title: Style
order: 4
---

<embed src="@/docs/common/style.md"></embed>

of tile layer`style`Parameters depend on the layer used. Such as vector point layer,`style`The parameters of are the parameters of the corresponding point layer.

### raster tile

#### domain: \[number, number]

Set the domain of data mapping.\
ps: The fixed value range is`[0, 1]`, we map the incoming value (domain) to the value domain`[0, 1]`Later from`rampColor`The built ribbon picks up colors, and RGB multi-channel rasters are not supported.

#### clampLow/clampHigh: boolean

`clampLow`The default value is`false`,Set as`true`, lower than`domain`The data will not be displayed.\
`clampHigh`The default value is`false`,Set as`true`, higher than`domain`The data will not be displayed.

ps: rgb multi-channel raster is not supported

#### rampColors

* colors color array
* positions data interval

Configure the color band of the value range mapping color. The range of the value range is`[0 - 1]`, correspondingly we need to provide each`position`Position sets a color value.

⚠️ colors, positions must be the same length

```javascript
layer.style({
  rampColors: {
    colors: ['#FF4818', '#F7B74A', '#FFF598', '#91EABC', '#2EA9A1', '#206C7C'],
    positions: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
  },
});
```

ps: ⚠️ The lengths of color and position must be the same, rgb multi-channel raster is not supported

### vector tile

of vector layers`style`The style remains the same as the normal layer.

### event

🌟 Data raster supports layer events, while image raster currently does not support layer events.

##### Binding events

🌟 Data grid tiles

```javascript
// The method of binding events is consistent with that of ordinary layers.
layer.on('click', e => {...})
```

#### event parameters

🌟 Data grid tiles
The event parameters of data grid tiles return new parameters compared to the events of ordinary layers.

#### value: number

🌟 Data grid tiles
The actual value of the tile at the mouse event location.
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

#### sourceLayer

<description> _string_ **required** </description>

只有矢量图层生效，用于设置矢量图层的数据源。

🌟 一般矢量服务返回的数据中存在多个图层的数据，我们需要从中进行选取。

```javascript
const layer = new PointLayer({
  sourceLayer: 'city',
});
```

#### featureId

<description> _string_ **optional** _default:_ 自动数字编号</description>

只有矢量图层生效，用于指定矢量图层的编码 `id`。

🌟 编码 `id` 用于在图层高亮时使用。

```javascript
const layer = new PointLayer({
  featureId: 'id',
});
```---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

#### sourceLayer

<description> *string* **required** </description>

Only valid for vector layers, used to set the data source of vector layers.

🌟 Generally, there are multiple layers of data in the data returned by the vector service, and we need to select from them.

```javascript
const layer = new PointLayer({
  sourceLayer: 'city',
});
```

#### featureId

<description> *string* **optional** *default:*automatic numbering</description>

Only vector layers take effect, used to specify the encoding of vector layers.`id`。

🌟 Encoding`id`Used when a layer is highlighted.

```javascript
const layer = new PointLayer({
  featureId: 'id',
});
```
---
title: Raster 栅格瓦片
order: 0
---

<embed src="@/docs/common/style.md"></embed>

`L7`The raster layer supports loading`TMS`、`WMS`、`WMTS`and other image tiles in various formats, and also supports`Tiff`、`Lerc`Data raster tiles in various formats.

| Classification | Layer         | parserType   | dataType      | describe                          |
| -------------- | ------------- | ------------ | ------------- | --------------------------------- |
| grid tiles     | `RasterLayer` | `rasterTile` | `image`、`/`   | Picture grid                      |
| grid tiles     | `RasterLayer` | `rasterTile` | `arraybuffer` | data grid                         |
| grid tiles     | `RasterLayer` | `rasterTile` | `rgb`         | Color remote sensing image raster |

🌟 Currently only supports 3857 coordinate system

### source(url: string, option: IOption)

The data source of vector tiles needs to pass in the tile service of vector data and the corresponding configuration parameters.

#### url

The path processing of data services supports single service and multi-service writing methods, and also supports simultaneous requests for multiple files.

* Single server Requests tile data from one server.

* Multiple servers request tile data for the same service from multiple servers.

  * Use braces to request the setting of multiple servers, such as`{1-3}`、`{a-c}`。

* Request multiple files. Request tile data from multiple tile services at the same time.
  * Use an array to set up multiple services.
  * Currently, the format for requesting multiple files is only supported by raster tiles.

```js
import { Source } from '@antv/l7'
// single server
const source = new Source('http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}', {...})

//Multiple servers
const source = new Source('http://webst0{1-4}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}', {...} )

//Request multiple files
const urls = [
  'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',
  'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',
]

const urls = [
  {
    url: 'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',
    bands: [0]
  },
  {
    url: 'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff'
  },
  ...
]
const tileSource = new Source(urls, {...});
```

#### source option

via configuration`parser`In the parameters, we can specify different tile types and parameters of the tile service.

```js
const source = new Source(url, {
  parser: {...}
})
```

| parameter      | type                               | default value                              | describe                              |
| -------------- | ---------------------------------- | ------------------------------------------ | ------------------------------------- |
| type           | `string`                           | /                                          | Describe the different types of tiles |
| tileSize       | `number`                           | `256`                                      | Requested tile size                   |
| minZoom        | `number`                           | `0`                                        | Request the minimum level of tiles    |
| maxZoom        | `number`                           | `Infinity`                                 | Request the maximum level of tiles    |
| zoomOffset     | `number`                           | `0`                                        | Request tile level offset             |
| extent         | `[number, number, number, number]` | `[-Infinity,-Infinity,Infinity,Infinity,]` | Request the bounds of a tile          |
| updateStrategy | `UpdateTileStrategy`               | `replace`                                  | Tile replacement strategy             |

```js
type UpdateTileStrategy = 'realtime' | 'overlap' | 'replace';
```

About using different grid tiles`parser`parameter.

| Tile type   | type         | dataType      | describe                    |
| ----------- | ------------ | ------------- | --------------------------- |
| TMS         | `rasterTile` | `image`       | Picture grid                |
| WMS         | `rasterTile` | `image`       | Picture grid                |
| WMTS        | `rasterTile` | `image`       | Picture grid                |
| arraybuffer | `rasterTile` | `arraybuffer` | Data raster, single channel |
| rgb         | `rasterRgb`  | `arraybuffer` | Data raster, multi-channel  |

🌟`WMTS`Format tiles have additional parameters.

| parameter     | type           | value | describe               |
| ------------- | -------------- | ----- | ---------------------- |
| `wmtsOptions` | `IWmtsOptions` | `/`   | Set request parameters |

`IWmtsOptions`The parameters are used for splicing`url`。

```js
interface IWmtsOptions {
  layer: string;
  version?: string;
  style?: string;
  format: string;
  service?: string;
  tileMatrixset: string;
}
```

#### parser parameters

##### type: string

Used to specify the parsing method of the tile service, the value is`rasterTile`and`mvt`。\
`rasterTile`For parsing of raster tiles,`mvt`For parsing of vector tiles.

##### dataType: string

use`dataType`Distinguish between picture raster and data raster, the value is`image`and`arraybuffer`,The default is`image`。

```javascript
//Set the image grid
layer.source({
  'http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
  {
    parser: {
      type: 'rasterTile',
      dataType: 'image',
      ...
    }
  }
})

//Set data grid
layer.source({
  'http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
  {
    parser: {
      type: 'rasterTile',
      dataType: 'arraybuffer',
      ...
    }
  }
})
```

##### minZoom/maxZoom: number

Set the request level for tile data. When the map’s zoom level`zoom`less than`minZoom`after, or`zoom`more than the`maxZoom`No more new tiles will be requested.\
`minZoom`The default value is`-Infinity`。\
`maxZoom`The default value is`Infinity`。

##### tileSize: number

The set value is the tile size returned by the tile service.\
`tileSize`The default value is 256.\
ps: This value is determined when producing tiles, we set`tileSize`It needs to be consistent with what is returned by the tile service.

##### extent: \[number, number, number, number]

Set the boundary of requesting tile data, the format is`[minLng, maxLat, maxLng, minLat]`, only tile data within the range will be requested.

##### zoomOffset: number

The set value is used to change the level of requested tile data. Usually on the mobile terminal, higher-level tiles can be requested for better clarity.`zoomOffset`The default value of is 0

##### format: IRasterFormat

<description> *IFormat* **required** </description>

`format`Method used to extract band data from the incoming raster file binary data.

* The first parameter is the raster file binary data.
* The second parameter is the band that should be extracted from the raster file specified by the first parameter. The method parameter is what we pass`source`parameters passed`data`numerical value.
* `format`Is a`async`method.

```js
interface IRasterData {
  rasterData: HTMLImageElement | Uint8Array | ImageBitmap | null | undefined;
  width: number;
  height: number;
}
type IRasterFormat = (
  data: ArrayBuffer,
  bands: number[],
) => Promise<IRasterData | IRasterData[]>;

const source = new Source(data, {
  parser: {
    format: async (data, bands) => {
      ...
      return {
        rasterData: bandData,
        width: 256;
        height: 256;
      }
    }
  }
})
```

## style

<embed src="@/docs/common/layer/raster/style_single.en.md"></embed>
---
title: Raster 栅格瓦片
order: 0
---

<embed src="@/docs/common/style.md"></embed>

`L7` 的栅格图层支持加载 `TMS`、`WMS`、`WMTS` 等多种格式的图片瓦片，同时也支持 `Tiff`、`Lerc` 等多种格式的数据栅格瓦片。

| 分类     | Layer         | parserType   | dataType      | 描述             |
| -------- | ------------- | ------------ | ------------- | ---------------- |
| 栅格瓦片 | `RasterLayer` | `rasterTile` | `image`、`/`  | 图片栅格         |
| 栅格瓦片 | `RasterLayer` | `rasterTile` | `arraybuffer` | 数据栅格         |
| 栅格瓦片 | `RasterLayer` | `rasterTile` | `rgb`         | 彩色遥感影像栅格 |

🌟 目前只支持 3857 坐标系

### source(url: string, option: IOption)

矢量瓦片的数据源需要传入矢量数据的瓦片服务以及对应的配置参数。

#### url

数据服务的路径处理支持单服务和多服务的写法，还支持同时请求多文件。

- 单服务器 向一台服务器请求瓦片数据。
- 多服务器 向多台服务器请求同一份服务的瓦片数据。

  - 使用大括号的写法请求设置多服务器，如 `{1-3}`、`{a-c}`。

- 请求多文件 同时请求多份瓦片服务的瓦片数据。
  - 使用数组的方式设置多服务。
  - 目前请求多文件的格式只有栅格瓦片支持。

```js
import { Source } from '@antv/l7'
// 单服务器
const source = new Source('http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}', {...})

// 多服务器
const source = new Source('http://webst0{1-4}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}', {...})

// 请求多文件
const urls = [
  'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',
  'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',
]

const urls = [
  {
    url: 'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff',
    bands: [0]
  },
  {
    url: 'https://ganos.oss-cn-hangzhou.aliyuncs.com/m2/l7/tiff_jx/{z}/{x}/{y}.tiff'
  },
  ...
]
const tileSource = new Source(urls, {...});
```

#### source option

通过配置 `parser` 中的参数，我们可以指定不同的瓦片类型以及瓦片服务的参数。

```js
const source = new Source(url, {
  parser: {...}
})
```

| 参数           | 类型                               | 默认值                                     | 描述                 |
| -------------- | ---------------------------------- | ------------------------------------------ | -------------------- |
| type           | `string`                           | /                                          | 描述不同类型的瓦片   |
| tileSize       | `number`                           | `256`                                      | 请求的瓦片尺寸       |
| minZoom        | `number`                           | `0`                                        | 请求瓦片的最小层级   |
| maxZoom        | `number`                           | `Infinity`                                 | 请求瓦片的最大层级   |
| zoomOffset     | `number`                           | `0`                                        | 请求瓦片层级的偏移量 |
| extent         | `[number, number, number, number]` | `[-Infinity,-Infinity,Infinity,Infinity,]` | 请求瓦片的边界       |
| updateStrategy | `UpdateTileStrategy`               | `replace`                                  | 瓦片的替换策略       |

```js
type UpdateTileStrategy = 'realtime' | 'overlap' | 'replace';
```

关于不同的栅格瓦片使用不同的 `parser` 参数。

| 瓦片类型    | type         | dataType      | 描述             |
| ----------- | ------------ | ------------- | ---------------- |
| TMS         | `rasterTile` | `image`       | 图片栅格         |
| WMS         | `rasterTile` | `image`       | 图片栅格         |
| WMTS        | `rasterTile` | `image`       | 图片栅格         |
| arraybuffer | `rasterTile` | `arraybuffer` | 数据栅格，单通道 |
| rgb         | `rasterRgb`  | `arraybuffer` | 数据栅格，多通道 |

🌟 `WMTS` 格式的瓦片有额外的参数。

| 参数          | 类型           | 值  | 描述         |
| ------------- | -------------- | --- | ------------ |
| `wmtsOptions` | `IWmtsOptions` | `/` | 设置请求参数 |

`IWmtsOptions` 的参数用于拼接 `url`。

```js
interface IWmtsOptions {
  layer: string;
  version?: string;
  style?: string;
  format: string;
  service?: string;
  tileMatrixset: string;
}
```

#### parser 参数

##### type: string

用于指定瓦片服务的解析方式，值为 `rasterTile` 和 `mvt`。  
`rasterTile` 用于栅格瓦片的解析，`mvt` 用于矢量瓦片的解析。

##### dataType: string

使用 `dataType` 区分图片栅格和数据栅格，值为 `image` 和 `arraybuffer`，默认为 `image`。

```javascript
// 设置图片栅格
layer.source({
  'http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
  {
    parser: {
      type: 'rasterTile',
      dataType: 'image',
      ...
    }
  }
})

// 设置数据栅格
layer.source({
  'http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
  {
    parser: {
      type: 'rasterTile',
      dataType: 'arraybuffer',
      ...
    }
  }
})
```

##### minZoom/maxZoom: number

设置瓦片数据的请求层级。当地图的缩放层级 `zoom` 小于 `minZoom` 后，或 `zoom` 大于 `maxZoom` 后将不再请求新的瓦片。  
`minZoom` 的默认值为 `-Infinity`。  
`maxZoom` 的默认值为 `Infinity`。

##### tileSize: number

设置的值是瓦片服务返回的瓦片大小。  
`tileSize` 的默认值为 256。  
ps： 该值在生产瓦片的时候确定，我们设置的 `tileSize` 需要和瓦片服务返回的保持一致。

##### extent: [number, number, number, number]

设置请求瓦片数据的边界， 格式是 `[minLng, maxLat, maxLng, minLat]`，只会请求范围内的瓦片数据。

##### zoomOffset: number

设置的值用于改变请求的瓦片数据的层级，通常在移动端可以请求更高一级的瓦片以获取更好的清晰度。
`zoomOffset` 的默认值为 0

##### format: IRasterFormat

<description> _IFormat_ **必选** </description>

`format` 方法用于从传入的栅格文件二进制数据中提取波段数据。

- 第一个参数是栅格文件二进制数据。
- 第二个参数是第一个参数指定的栅格文件中应该提取的波段，方法参数是我们通过 `source` 参数传递的 `data` 数值。
- `format` 是一个 `async` 方法。

```js
interface IRasterData {
  rasterData: HTMLImageElement | Uint8Array | ImageBitmap | null | undefined;
  width: number;
  height: number;
}
type IRasterFormat = (
  data: ArrayBuffer,
  bands: number[],
) => Promise<IRasterData | IRasterData[]>;

const source = new Source(data, {
  parser: {
    format: async (data, bands) => {
      ...
      return {
        rasterData: bandData,
        width: 256;
        height: 256;
      }
    }
  }
})
```

## style

<embed src="@/docs/common/layer/raster/style_single.zh.md"></embed>
---
title: RasterLayer 多波段计算
order: 2
---

<embed src="@/docs/common/style.md"></embed>

## 简介

多波段数据叠加计算着色。

## Option

<embed src="@/docs/common/layer/options.zh.md"></embed>

## source

<embed src="@/docs/common/source/raster/raster_band_calc.zh.md"></embed>

## style

<embed src="@/docs/common/layer/raster/style.zh.md"></embed>
---
title: RasterLayer multi band
order: 2
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

Multi-band data overlay calculation coloring.

## Option

<embed src="@/docs/common/layer/options.en.md"></embed>

## source

<embed src="@/docs/common/source/raster/raster_band_calc.en.md"></embed>

## style

<embed src="@/docs/common/layer/raster/style.en.md"></embed>
---
title: RasterLayer 多波段合成
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## 简介

`RasterLayer` 图层主要实现栅格数据的可视化，栅格数据主要来源是卫星遥感数据，如数字高程图，植被分布图，夜光图。

## Option

<embed src="@/docs/common/layer/options.zh.md"></embed>

## source

<embed src="@/docs/common/source/raster/raster_rgb.zh.md"></embed>

## style

### opacity 透明度

```js
layer.style({
  opacity: 0.5,
});
```
---
title: RasterLayer Composite band
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

`RasterLayer`The layer mainly realizes the visualization of raster data. The main source of raster data is satellite remote sensing data, such as digital elevation map, vegetation distribution map, and night light map.

## Option

<embed src="@/docs/common/layer/options.en.md"></embed>

## source

<embed src="@/docs/common/source/raster/raster_rgb.en.md"></embed>

## style

### opacity transparency

```js
layer.style({
  opacity: 0.5,
});
```
---
title: Raster
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

`RasterLayer`The layer mainly realizes the visualization of raster data. The main source of raster data is satellite remote sensing data, such as digital elevation map, vegetation distribution map, and night light map.

* L7 itself does not provide a raster data format internally. It needs to parse the external raster data file or provide a parsing method to pass it in, such as`tiff`、`lerc`。
* In addition to supporting simple rendering, the raster layer also supports multi-band calculations of raster data, and can be used to draw remote sensing color images.

### Data plotting

We can directly calculate the band data of the raster externally and then pass it to the raster layer for use.

* There is no need to provide additional extraction methods for raster data, and the parsed raster data can be parsed externally.
* This method only supports coloring of single-band data and cannot perform band calculations.

```js
const layer = new RasterLayer({})
  .source(tiffdata.data, {
    parser: {
      type: 'raster',
      width: tiffdata.width,
      height: tiffdata.height,
      min: 0,
      max: 80,
      extent: [73.482190241, 3.82501784112, 135.106618732, 57.6300459963],
    },
  })
  .style({
    opacity: 0.8,
    domain: [0, 2000],
    rampColors: {
      colors: [
        '#FF4818',
        '#F7B74A',
        '#FFF598',
        '#91EABC',
        '#2EA9A1',
        '#206C7C',
      ].reverse(),
      positions: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
    },
  });
```

### Multi-band calculation

We can pass the requested raster file to the raster layer for use.

* Additional parsing methods for raster data need to be provided. Raster files in different formats require corresponding methods, such as`tiff`For files in the format we generally use`geotiff.js`Perform analysis.
* When directly importing one (multiple) raster files, we can read the raster data of all bands contained in the file and support simple mathematical operations on the band data.

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*lmJFT7WONcoAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

#### Calculate NDVI

```javascript
async function getTiffData(url: string) {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  return arrayBuffer;
}
// tiffdata 是请求到的二进制的栅格文件
const tiffdata = await getTiffData('https: // xxx');
const layer = new RasterLayer({})
  .source(
    [
      {
        data: tiffdata,
        bands: [0, 1, 2, 3],
      },
    ],
    {
      parser: {
        type: 'raster',
        format: async (data, bands) => {
          const tiff = await GeoTIFF.fromArrayBuffer(data);
          const imageCount = await tiff.getImageCount();
          const image1 = await tiff.getImage(1);
          const value1 = await image1.readRasters();
          const value = value1;
          return [
            { rasterData: value[2], width: value.width, height: value.height }, // R
            { rasterData: value[3], width: value.width, height: value.height }, // NIR
          ];
        },
        // blue green red nir
        // NDVI = ABS(NIR - R) / (NIR + R) = 近红外与红光之差 / 近红外与红光之和
        operation: [
          '/',
          ['-', ['band', 0], ['band', 1]], // R > NIR
          ['+', ['band', 0], ['band', 1]],
        ],
        extent: [73.482190241, 3.82501784112, 135.106618732, 57.6300459963],
      },
    },
  )
  .style({
    domain: [0, 0.25],
    rampColors: {
      colors: [
        'rgb(166,97,26)',
        'rgb(223,194,125)',
        'rgb(245,245,245)',
        'rgb(128,205,193)',
        'rgb(1,133,113)',
      ],
      positions: [0, 0.25, 0.5, 0.75, 1.0],
    },
  });
```
---
title: Raster 栅格
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## 简介

`RasterLayer` 图层主要实现栅格数据的可视化，栅格数据主要来源是卫星遥感数据，如数字高程图，植被分布图，夜光图。

- L7 本身内部没有提供栅格数据格式, 需要将外部的栅格数据文件解析后或者提供解析方法做传入、如 `tiff`、`lerc`。
- 栅格图层除了支持简单渲染之外还支持栅格数据的多波段计算，可以用于绘制遥感彩色影像。

### 数据绘制

我们可以直接在外部计算出栅格的波段数据后传给栅格图层使用。

- 不需要额外提供栅格数据的提取方法，在外部解析传入解析好的栅格数据。
- 这种方式只支持对单波段数据进行染色，无法进行波段计算。

```js
const layer = new RasterLayer({})
  .source(tiffdata.data, {
    parser: {
      type: 'raster',
      width: tiffdata.width,
      height: tiffdata.height,
      min: 0,
      max: 80,
      extent: [73.482190241, 3.82501784112, 135.106618732, 57.6300459963],
    },
  })
  .style({
    opacity: 0.8,
    domain: [0, 2000],
    rampColors: {
      colors: [
        '#FF4818',
        '#F7B74A',
        '#FFF598',
        '#91EABC',
        '#2EA9A1',
        '#206C7C',
      ].reverse(),
      positions: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
    },
  });
```

### 多波段计算

我们可以将请求得到的栅格文件传给栅格图层使用。

- 需要额外提供栅格数据的解析方法，不同格式的栅格文件有需要对应的方法，如 `tiff` 格式的文件我们一般借助 `geotiff.js` 进行解析。
- 直接传入一（多）个栅格文件的时候，我们可以读取文件中包含的所有波段的栅格数据，同时支持对波段数据进行简单的数学运算。

<div>
  <div style="width:60%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*lmJFT7WONcoAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

#### 计算 NDVI

```javascript
async function getTiffData(url: string) {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  return arrayBuffer;
}
// tiffdata 是请求到的二进制的栅格文件
const tiffdata = await getTiffData('https: // xxx');
const layer = new RasterLayer({})
  .source(
    [
      {
        data: tiffdata,
        bands: [0, 1, 2, 3],
      },
    ],
    {
      parser: {
        type: 'raster',
        format: async (data, bands) => {
          const tiff = await GeoTIFF.fromArrayBuffer(data);
          const imageCount = await tiff.getImageCount();
          const image1 = await tiff.getImage(1);
          const value1 = await image1.readRasters();
          const value = value1;
          return [
            { rasterData: value[2], width: value.width, height: value.height }, // R
            { rasterData: value[3], width: value.width, height: value.height }, // NIR
          ];
        },
        // blue green red nir
        // NDVI = ABS(NIR - R) / (NIR + R) = 近红外与红光之差 / 近红外与红光之和
        operation: [
          '/',
          ['-', ['band', 0], ['band', 1]], // R > NIR
          ['+', ['band', 0], ['band', 1]],
        ],
        extent: [73.482190241, 3.82501784112, 135.106618732, 57.6300459963],
      },
    },
  )
  .style({
    domain: [0, 0.25],
    rampColors: {
      colors: [
        'rgb(166,97,26)',
        'rgb(223,194,125)',
        'rgb(245,245,245)',
        'rgb(128,205,193)',
        'rgb(1,133,113)',
      ],
      positions: [0, 0.25, 0.5, 0.75, 1.0],
    },
  });
```
---
title: RasterLayer data encode
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

Single-band raster data rendering, visual coloring based on raster data

## Option

<embed src="@/docs/common/layer/options.en.md"></embed>

`RasterLayer`The layer mainly realizes the visualization of raster data. The main source of raster data is satellite remote sensing data, such as digital elevation map, vegetation distribution map, and night light map.

## source

<embed src="@/docs/common/source/raster/raster_single.en.md"></embed>

## style

<embed src="@/docs/common/layer/raster/style.en.md"></embed>
---
title: RasterLayer 单波段
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## 简介

单波段栅格数据渲染、根据栅格数据进行可视化着色

## Option

<embed src="@/docs/common/layer/options.zh.md"></embed>

`RasterLayer` 图层主要实现栅格数据的可视化，栅格数据主要来源是卫星遥感数据，如数字高程图，植被分布图，夜光图。

## source

<embed src="@/docs/common/source/raster/raster_single.zh.md"></embed>

## style

<embed src="@/docs/common/layer/raster/style.zh.md"></embed>
---
title: Scene
order: 0
redirect_from:
  - /en/docs/api
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

scene object`scene`It is a global object that contains maps, map controls, components, and loaded resources. It is passed`scene`Scene object, we can get everything we need to operate the map.

<div>
  <div style="width:40%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*3wMCR7vIlCwAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

## options

### id

<description> *string | HTMLElement* **required** </description>

You need to pass in the dom container or container id.

### map

<description> MapInstance **required** </description>

The map instance can be obtained through the scene map attribute.

```javascript
const map = scene.map;
```

In order to unify the interface differences between different basemaps`L7`exist`Scene`layer pair`map`The methods have been unified, so some map operation methods can be passed`Scene`Called so that consistent performance can be ensured when switching between different basemaps.

Sample code

```javascript
const scene = new L7.Scene({
  id: 'map',
  map: new L7.GaodeMap({
    style: 'dark',
    center: [110.770672, 34.159869],
    pitch: 45,
  }),
});
```

### logoPosition

<description> *bottomleft* **Optional** </description>

`L7`provided by default`Logo`The display position can be configured, and the default is the lower left corner.

* bottomright
* topright
* bottomleft
* topleft
* topcenter
* bottomcenter
* leftcenter
* rightcenter

### logoVisible Is the logo visible?

<description> *bottomleft* **Optional** *default: true* </description>

Configuration`L7`of`Logo`Whether to display or not, it is displayed by default.

### antialias Whether to enable anti-aliasing

<description> *boolean* **Optional** *default: true* </description>

Whether to start anti-aliasing before starting.

### stencil whether to enable cutting

<description> *boolean* **Optional** *default: false* </description>

Whether to start cropping.

🌟 Supported from version v2.7.2, layer`Mask`Masking capabilities as well as vector tiles are required to start this configuration.

### preserveDrawingBuffer

<description> *boolean* **Optional** *default: false* </description>

Whether to retain buffer data`boolean` `false`。

## Layer method

### addLayer(layer): void Add layer object

Add the layer to`Scene`in the scene.

Parameters:

* `layer`layer object

```javascript
scene.addLayer(layer);
```

### getLayer(id: string): ILayer gets the corresponding layer object

Get the corresponding layer.

```javascript
scene.getLayer('layerID');
```

### getLayers(): ILayer\[] Get all map layers

Get all map layers.

```javascript
scene.getLayers();
```

### getLayerByName(name: string): ILayer Gets the layer based on the layer name

Get the layer based on its name.

* `name`The layer is configured during initialization.`name`。

```javascript
scene.getLayerByName(name);
```

### removeLayer(layer: ILayer): void remove layer layer

Remove`layer`layers.

```javascript
scene.removeLayer(layer);
```

🌟 The layer will be destroyed when removed.

### removeAllLayer(): void removes all layer objects

Remove all layer objects.

```javascript
scene.removeAllLayer();
```

🌟 The layer will be destroyed when removed.

## Control component methods

### addControl(ctl: IControl): void Add component control

Add component controls.

* `crl`User-created control object.

```javascript
scene.addControl(ctl);
```

### removeControl(ctr: IControl): void Removes the component control added by the user

Remove user-added component controls.

* `ctl`User-created control object.

```javascript
scene.removeControl(ctl);
```

### getControlByName(name: string): IControl gets the control based on its name

Get the control based on its name.

```javascript
const zoomControl = new Zoom({
  // zoom control
  name: 'z1', // The name of the control passed in by the user (or not passed in, the default name of the control is zoom)
  position: 'topright',
});

scene.getControlByName('z1');
```

## bubble method

### addPopup(popup: Popup): void Add bubbles

Add bubble objects to the scene. Bubbles are used to display user-defined information.

```javascript
scene.addPopup(popup);
```

### removePopup(popup: Popup): void removes bubbles

Remove the bubble object from the scene

```javascript
scene.removePopup(popup);
```

## Marking method

### addMarker(maker: IMarker): void Add mark

Add marker objects to the scene,`Marker`Instances are freely controlled by the user`DOM`。

* `maker`User created`Marker`Example.

```javascript
const marker = new Marker({
  element: el,
}).setLnglat({ lng: nodes[i].x * 1, lat: nodes[i].y });
scene.addMarker(marker);
```

### addMarkerLayer(layer: IMarkerLayer): void Add Marker to manage layers uniformly

When the user needs to add many`Marker`Instances can be used to facilitate management`MarkerLayer`Unified management of objects.

* `layer`Mark layer objects.

```javascript
const markerLayer = new MarkerLayer();
scene.addMarkerLayer(markerLayer);
```

### removeMarkerLayer(layer: IMarkerLayer): void removes the label layer

Remove the label layer.

* `layer`Mark layer objects.

```javascript
scene.removeMarkerLayer(markerLayer);
```

### removeAllMarkers(): void removes all label objects in the scene

Removes all label objects from the scene.

```javascript
scene.removeAllMarkers();
```

## static method

Static methods are called through the Scene class, not the scene instance

### addProtocol

Add a custom data protocol and set up a custom load tile function that will be called when data starting with a custom URL pattern is used.

* protocol protocol name
* handler data processing callback function
  * requestParameters: RequestParameters,
    * url tile URL, carrying tile row and column numbers x, y, z
  * callback: ResponseCallback<any>) => Cancelable
    * Cancelable： {
      cancel: () => void;
      };

#### Custom function

```ts
Scene.addProtocol('custom', (params, callback) => {
          fetch(`https://${params.url.split("://")[1]}`)
              .then(t => {
                  if (t.status == 200) {
                      t.arrayBuffer().then(arr => {
                          callback(null, arr, null, null);
                      });
                  } else {
                      callback(new Error(`Tile fetch error: ${t.statusText}`));
                  }
              })
              .catch(e => {
                  callback(new Error(e));
              });
          return { cancel: () => { } };
      });
// the following is an example of a way to return an error when trying to load a tile
    Scene.addProtocol('custom2', (params, callback) => {
        callback(new Error('someErrorMessage'));
        return { cancel: () => { } };
    });
```

#### Load PMTiles

```ts
import * as pmtiles from "pmtiles";
const protocol = new pmtiles.Protocol();
const scene = new Scene({
      id: 'map',
      map: new Map({
        center: [11.2438, 43.7799],
        zoom: 12,
      }),
    });

    scene.addProtocol('pmtiles',protocol.tile);
    const source = new Source('pmtiles://https://mdn.alipayobjects.com/afts/file/A*HYvHSZ-wQmIAAAAAAAAAAAAADrd2AQ/protomaps(vector)ODbL_firenze.bin', {
        parser: {
          type: 'mvt',
          tileSize: 256,
          maxZoom: 14,
          extent: [-180, -85.051129, 179, 85.051129],
        },
      })
```

### removeProtocol

Delete previously added protocols

* name: protocol name

```ts
scene.remove Protocol('mbtiles',protocol.tile);
```

## map method

### getZoom(): number Get the zoom level

Get the current zoom level.

```javascript
scene.getZoom();
```

### getCenter(): ILngLat gets the map center

Get map center point

```javascript
interface ILngLat {
  lng: number;
  lat: number;
}

scene.getCenter();
```

### getSize(): \[number, number] Get the map container size

Get the map container size, width, height.

```javascript
scene.getSize();
```

### getPitch(): number Get the map tilt angle

Get the map elevation angle.

```javascript
scene.getPitch();
```

### getContainer(): HTMLElement | null Get the map container

Get the map container.

```javascript
scene.getContainer();
```

### setMapStyle(style: string): void Set map style

parameter`style`The parameter is a string, and you can select the built-in map style. The specific style format is consistent with the setting method of each base map.

`L7`There are three built-in map styles:`AMAP`and`MapBox`All applicable.

* light
* dark
* normal

Method to set the map basemap style.

```javascript
//Shortcut name setting
scene.setMapStyle('light');

// mapbox theme settings
scene.setMapStyle('mapbox://styles/mapbox/streets-v11');

// AMap
scene.setMapStyle(
  'amap://styles/2a09079c3daac9420ee53b67307a8006?isPublic=true',
);
```

### setCenter(center: ICenter, option?: ICameraOptions): void Set the map center point

Set the map center point coordinates.`L7`provided`setCenter`method, allowing the user to dynamically set the center point of the map, and also allows the optional`options`Property settings offset.

```js
type ICenter = [number, number];
interface ICameraOptions {
  padding:
    | number
    | [number, number, number, number]
    | {
        top?: number,
        bottom?: number,
        right?: number,
        left?: number,
      };
}

scene.setCenter([lng, lat]);
scene.setCenter([lng, lat], {
  padding: {
    top: 100,
  },
});
```

🌟`padding`Parameters support the following three value transfer methods. The unit of the value is`px`, indicating the offset distance between the center point of the map and the edge of the container.

```javascript
export interface ICameraOptions {
  padding:
    | number
    | [number, number, number, number]
    | {
        top?: number,
        bottom?: number,
        right?: number,
        left?: number,
      };
}
```

[Online case](/examples/point/bubble#point)

### setZoomAndCenter(zoom: number, center: ICenter): void Set the map zoom level and center point

Set map level and center.

```javascript
type ICenter = [number, number];
scene.setZoomAndCenter(zoom, center);
```

### setZoom(zoom: number): void Set the map zoom level

Set map zoom level

```javascript
scene.setZoom(10);
```

### setRotation(rotation: number): void Set map rotation

Set the clockwise rotation angle of the map. The rotation origin is the center point of the map container. The value range is \[0-360].

```javascript
scene.setRotation(rotation);
```

### zoomIn(); void Zoom the map one level

The map is zoomed in one level.

```javascript
scene.zoomIn();
```

### zoomOut(): void Zoom out one level of the map

The map shrinks one level.

```javascript
scene.zoomOut();
```

### panTo(lnglat: ILngLat): void map movement

Pan the map to the specified latitude and longitude location.

```javascript
type ILngLat = [number, number];
scene.panTo(LngLat);
```

### panBy(x: number, y: number): void map pan

Moves the map in pixels in the X and Y directions.

* `x`Moving pixels horizontally to the right is the positive direction.
* `y`Move pixels vertically downward in the positive direction.

```javascript
scene.panBy(x, y);
```

### setPitch(pitch: number): void Set the map tilt angle

Set the map tilt angle.

```javascript
scene.setPitch(pitch);
```

### setMapStatus(statusOption: IStatusOptions): void Set map status

Used to set some interactive configurations of the map.

```javascript
interface IStatusOptions {
  showIndoorMap: boolean;
  resizeEnable: boolean;
  dragEnable: boolean;
  keyboardEnable: boolean;
  doubleClickZoom: boolean;
  zoomEnable: boolean;
  rotateEnable: boolean;
}

scene.setMapStatus({ dragEnable: false });
```

### fitBounds(bound: IBounds, options?: IOptions): void Set the map zoom range

The map is zoomed to a certain range.

* `bound`Represents the latitude and longitude range \[\[minlng,minlat],\[maxlng,maxlat]].
* `options`User input, override`animate`Direct configuration, override`Scene`Incoming configuration items.

```javascript
type IBounds = [[number, number], [number, number]];
interface IOptions {
  [key]: any;
  animate: boolean;
}

scene.fitBounds([
  [112, 32],
  [114, 35],
]);
```

### containerToLngLat(point: IPoint): ILngLat canvas coordinates converted to latitude and longitude

Convert canvas coordinates to latitude and longitude coordinates

```javascript
type IPoint = [number, number];
interface ILngLat {
  lng: number;
  lat: number;
}

scene.pixelToLngLat([10, 10]);
```

### lngLatToContainer(lnglat: ILngLat): IPoint latitude and longitude converted to canvas coordinates

Convert latitude and longitude coordinates to canvas coordinates.

```javascript
type ILngLat = [number, number];
interface IPoint {
  x: number;
  y: number;
}

scene.lngLatToPixel([120, 10]);
```

### pixelToLngLat(pixel: IPoint): ILngLat pixel coordinates converted to longitude and latitude

The map pixel coordinates are converted into longitude and latitude coordinates, and the pixel coordinates are the distance between a point on the map and the upper left corner of the container.

```javascript
type IPoint = [number, number];
interface ILngLat {
  lng: number;
  lat: number;
}
scene.pixelToLngLat([10, 10]);
```

### lngLatToPixel(lnglat: ILngLat): IPoint longitude and latitude to pixel coordinates

Convert latitude and longitude coordinates to pixel coordinates.

```javascript
type ILngLat = [number, number];
interface IPoint {
  x: number;
  y: number;
}
scene.lngLatToPixel([120, 10]);
```

### exportMap(type?: IImage): string export

Exporting a map currently only supports the export of visualization layers and does not support the export of basemaps.

```javascript
type IImage = 'png' | 'jpg';
scene.exportMap('png');
```

### destroy(): void scene destruction

`scene`Destroy method, leave the page, call when you don’t need to use the map, after calling`scene`The resources and resources in will be destroyed.

```javascript
scene.destroy();
```

## iconfont mapping support

### addIconFont(name: string, unicode: string): void Add mapping support

Supports processing of data passed in by users`unicode`mapping, which internally maintains a set of names and corresponding`key`key-value pairs.

```javascript
scene.addIconFont('icon1', '');
scene.addIconFont('icon2', '');
scene.addFontFace(fontFamily, fontPath);
const pointIconFontLayer = new PointLayer({})
  .source(
    [
      {
        j: 140,
        w: 34,
        m: 'icon1',
      },
      {
        j: 140,
        w: 36,
        m: 'icon2',
      },
    ],
    {
      parser: {
        type: 'json',
        x: 'j',
        y: 'w',
      },
    },
  )
  .shape('m', 'text')
  .size(12)
  .color('w', ['#f00', '#f00', '#0f0'])
  .style({
    fontFamily,
    iconfont: true,
    textAllowOverlap: true,
  });
```

### addIconFonts(option: IOption): void Pass in multiple sets of name-unicode key-value pairs at the same time

Incoming multiple groups at the same time`name - unicode`key-value pairs.

```javascript
type IKeyValue = [name: string, unicode: string];
type IOption = Array<IKeyValue>;

scene.addIconFonts([
  ['icon1', ''],
  ['icon2', ''],
]);
```

## global resources

### addImage(id: string, img: IImage): void Add global resources

exist`scene`Add globally`L7`The layer object can use the image resources in .

```javascript
type IImage = HTMLImageElement | string | File；

scene.addImage( '02','https://gw.alipayobjects.com/zos/bmw-prod/ce83fc30-701f-415b-9750-4b146f4b3dd6.svg');
```

[Example address](/examples/gallery/animate#animate_path_texture)

### hasImage(id: string): boolean determines global image resources

Determine whether the corresponding image resource has been added globally.

```javascript
scene.hasImage('imageID');
```

### removeImage(id: string): void Globally delete image resources

Delete the corresponding image resource globally.

```javascript
scene.removeImage('imageID');
```

### addFontFace(fontFamily: string, fontPath: string): void Add font file

Add to`iconfont`font file.

* `fontFamily`Font name defined by the user for himself
* `fontPath`Imported file address

```javascript
let fontFamily = 'iconfont';
let fontPath =
  '//at.alicdn.com/t/font_2534097_iiet9d3nekn.woff2?t=1620444089776';
scene.addFontFace(fontFamily, fontPath);
```

## other

### getPointSizeRange(): Float32Array

Get the drawing supported by the current device`WebGL`The size of the point sprite.

## event

### on(eventName: string, handler: function): void

exist`scene`Bind event listener.

* `eventName`Event name.
* `handler`Event callback function.

### off(eventName: string, handler: function): void

remove in`scene`The event listener bound on.

* `eventName`Event name.
* `handler`Event callback function.

### scene event

`scene`Some common scene events will be triggered, and users can monitor them when needed.

#### loaded

`scene`Initialization completion event, we often use`scene`Add after initialization is complete`Layer`。

```javascript
scene.on('loaded', () => {
  scene.addLayer(layer);
});
```

#### resize

Map container change event

```javascript
scene.on('resize', () => {}); // Map container size change event
```

### map events

```javascript
scene.on('loaded', () => {}); //Triggered after map loading is completed
scene.on('mapmove', () => {}); // Event triggered when the map is moved
scene.on('movestart', () => {}); // Triggered when the map pan starts
scene.on('moveend', () => {}); // Triggered after the map movement ends, including translation and zooming when the center point changes. If the map has a dragging and easing effect, it will be triggered after the easing ends.
scene.on('zoomchange', () => {}); // Triggered after the map zoom level changes
scene.on('zoomstart', () => {}); // Triggered when zooming starts
scene.on('zoomend', () => {}); // Triggered when zooming stops
```

For other map events, you can view the event document of the corresponding basemap. Map events can also be viewed through`Scene.map`Make settings.

[Mapbox](https://docs.mapbox.com/mapbox-gl-js/api/#map.event)[Gaode](https://lbs.amap.com/api/javascript-api/reference/map)

### mouse events

```javascript
scene.on('click', (ev) => {}); // Left mouse button click event
scene.on('dblclick', (ev) => {}); // Left mouse button double-click event
scene.on('mousemove', (ev) => {}); // Triggered when the mouse moves on the map
scene.on('mousewheel', (ev) => {}); // Triggered when the mouse wheel starts to zoom the map
scene.on('mouseover', (ev) => {}); // Triggered when the mouse moves into the map container
scene.on('mouseout', (ev) => {}); // Triggered when the mouse moves out of the map container
scene.on('mouseup', (ev) => {}); // Triggered when the mouse is clicked and raised on the map
scene.on('mousedown', (ev) => {}); // Triggered when the mouse is clicked on the map
scene.on('contextmenu', (ev) => {}); // Right mouse click event
scene.on('dragstart', (ev) => {}); //Triggered when you start dragging the map
scene.on('dragging', (ev) => {}); // Triggered during dragging the map
scene.on('dragend', (ev) => {}); //Triggered when stopping dragging the map. If the map has a dragging and easing effect, it will be triggered before dragging stops and easing starts.

scene.on('webglcontextlost', () => {}); // webgl context lost
```

## Experimental parameters

Experimental parameters may be discarded.

### offsetCoordinate: boolean

Applicable to Gaode map, whether to turn off the offset coordinate system, the default is`true`。

```js
const scene = new Scene({
  offsetCoordinate: true,
});
```
---
title: MapBox 地图
order: 1
------
title: 天地图
order: 4
---
---
title: 地图 Map
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## 简介

L7 地理可视化侧重于地理数据的可视化表达，地图层需要依赖第三方地图，第三方地图通过 Scene 统一创建，创建管理
只需要通过 Scene 传入地图配置项即可。

L7 在内部解决了不同地图底图之间差异，同时 L7 层面统一管理地图的操作方法。

目前 L7 支持两种地图底图

- Map 独立地图引擎，不需要底图、或者加载地图瓦片服务，不需要 Token

- 高德地图  GaodeMap 默认指向  [Token](https://lbs.amap.com/api/javascript-api/guide/abc/prepare)

- MapBox 国际业务， 需要注册 [Token]()

### import

```javascript
import { GaodeMap } from '@antv/l7-maps'; // 默认引入高德 2.x 版本 2.11.0 版本开始默认升级为v2
import { GaodeMapV1 } from '@antv/l7-maps'; //  2.11.0 版本之前版本默认升级为v1

import { Mapbox } from '@antv/l7-maps';
import { Map } from '@antv/l7-maps';
```

### 实例化

⚠️ 使用地图申请地图 token，L7 内部设置了默认 token，仅供测试使用

#### 默认 Map 实例化

```js
import { Map } from '@antv/l7-maps';
const scene = new Scene({
  id: 'map',
  map: new Map({
    style: 'dark',
    center: [103, 30],
    pitch: 4,
    zoom: 10,
    rotation: 19,
  }),
});
```

#### 高德地图实例化

高德地图 API 配置参数

- token
  注册高德 [API token](https://lbs.amap.com/api/javascript-api/guide/abc/prepare)

- plugin {array} `['AMap.ElasticMarker','AMap.CircleEditor']`

  加载[高德地图插件](https://lbs.amap.com/api/javascript-api/guide/abc/plugins)

```javascript
const L7AMap = new GaodeMap({
  pitch: 35.210526315789465,
  style: 'dark',
  center: [104.288144, 31.239692],
  zoom: 4.4,
  token: 'xxxx - token',
  plugin: [], // 可以不设置
});
```

#### Mapbox 地图实例化

```javascript
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'dark',
    center: [103.83735604457024, 1.360253881403068],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313,
    token: 'xxxx - token',
  }),
});
```

### 传入外部实例

为了支持已有地图项目快速接入 L7 的能力，L7 提供传入地图实例的方法。如果你是新项目推荐使用 Scene 初始化地图

⚠️ scene id 参数需要地图的 Map 实例是同个容器。

⚠️ 传入地图实例需要自行引入相关地图的 API

⚠️ viewMode 设置为 3D 模式（GaodeMap2.0 支持 2D 模式，可以不设置）

#### 传入高德地图实例

```javascript
const map = new AMap.Map('map', {
  viewMode: '3D',
  resizeEnable: true, // 是否监控地图容器尺寸变化
  zoom: 11, // 初始化地图层级
  center: [116.397428, 39.90923], // 初始化地图中心点
});
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    mapInstance: map,
  }),
});
```

[示例地址](/examples/tutorial/map#amapInstance)
[代码地址](https://github.com/antvis/L7/blob/master/examples/tutorial/map/demo/amapInstance.js)

[示例地址（ 2D ）](/examples/tutorial/map#amapInstance2d)
[代码地址](https://github.com/antvis/L7/blob/master/examples/tutorial/map/demo/amapInstance.js)

#### 传入 Mapbox 地图实例

```javascript
mapboxgl.accessToken = 'xxxx - token';
const map = new mapboxgl.Map({
  container: 'map', // container id
  style: 'mapbox://styles/mapbox/streets-v11', // stylesheet location
  center: [-74.5, 40], // starting position [lng, lat]
  zoom: 9, // starting zoom
});

const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    mapInstance: map,
  }),
});
```

## options

### zoom 初始化缩放等级

<description> _number_ </description>

地图初始显示级别 {number} Mapbox （0-24） 高德 （2-19）

### center 地图中心

地图初始中心经纬度 {Lnglat}

### pitch 地图倾角

地图初始俯仰角度 {number}  default 0

### style 地图图样式

简化地图样式设置，L7 内置了三种主题默认样式 高德，mapbox 都可以使用

- dark
- light
- normal
- blank 无底图

除了内置的样式，你也可以传入自定义的其他属性。

比如高德地图

⚠️ 高德地图样式 增加 `isPublic=true` 参数

```javascript
{
  style: 'amap://styles/2a09079c3daac9420ee53b67307a8006?isPublic=true'; // 设置方法和高德地图一致
}
```

### minZoom 最小缩放等级

地图最小缩放等级 {number}  default 0 Mapbox 0-24） 高德 （2-19）

### maxZoom 最大缩放等级

地图最大缩放等级 {number}  default 22 Mapbox（0-24） 高德 （2-19）

### rotateEnable 是否允许旋转

地图是否可旋转 {Boolean} default true

## 注册使用高德插件

```javascript
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [116.475, 39.99],
    pitch: 0,
    zoom: 13,
    plugin: ['AMap.ToolBar', 'AMap.LineSearch'],
  }),
});
// plugin: ['AMap.ToolBar', 'AMap.LineSearch'],
// 为了使用对应插件的能力，应该首先在 plugin 中注册对应的插件

// 加载的 AMap 会挂载在全局的 window 对象上
scene.on('loaded', () => {
  window.AMap.plugin(['AMap.ToolBar', 'AMap.LineSearch'], () => {
    // add control
    scene.map.addControl(new AMap.ToolBar());

    var linesearch = new AMap.LineSearch({
      pageIndex: 1, //页码，默认值为1
      pageSize: 1, //单页显示结果条数，默认值为20，最大值为50
      city: '北京', //限定查询城市，可以是城市名（中文/中文全拼）、城市编码，默认值为『全国』
      extensions: 'all', //是否返回公交线路详细信息，默认值为『base』
    });

    //执行公交路线关键字查询
    linesearch.search('536', function (status, result) {
      //打印状态信息status和结果信息result
      // ... do something
    });
  });
});
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*ag-nSrIPPEUAAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/amapplugin/bus#busstop)
---
title: Map
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

L7 geographical visualization focuses on the visual expression of geographical data. The map layer needs to rely on third-party maps. The third-party maps are created and managed uniformly through Scene.
Just pass in the map configuration items through Scene.

L7 internally resolves the differences between different map basemaps, and at the same time, L7 manages the operation methods of the map in a unified manner.

Currently L7 supports two map basemaps

* Map is an independent map engine that does not require basemaps or loading map tile services, and does not require Token.

* GaodeMap default direction[Token](https://lbs.amap.com/api/javascript-api/guide/abc/prepare)

* MapBox international business, registration required[Token]()

### import

```javascript
import { GaodeMap } from '@antv/l7-maps'; // Import Gaode 2.x version by default. Starting from version 2.11.0, it will be upgraded to v2 by default.
import { GaodeMapV1 } from '@antv/l7-maps'; // Versions before 2.11.0 are upgraded to v1 by default

import { Mapbox } from '@antv/l7-maps';
import { Map } from '@antv/l7-maps';
```

### Instantiate

⚠️ Use the map to apply for a map token. L7 has a default token set internally for testing purposes only.

#### Default Map instantiation

```js
import { Map } from '@antv/l7-maps';
const scene = new Scene({
  id: 'map',
  map: new Map({
    style: 'dark',
    center: [103, 30],
    pitch: 4,
    zoom: 10,
    rotation: 19,
  }),
});
```

#### Amap instantiation

Amap API configuration parameters

* token
  Register Amap[API token](https://lbs.amap.com/api/javascript-api/guide/abc/prepare)

* plugin {array}`['AMap.ElasticMarker','AMap.CircleEditor']`

  load[Gaode map plug-in](https://lbs.amap.com/api/javascript-api/guide/abc/plugins)

```javascript
const L7AMap = new GaodeMap({
  pitch: 35.210526315789465,
  style: 'dark',
  center: [104.288144, 31.239692],
  zoom: 4.4,
  token: 'xxxx-token',
  plugin: [], // Can not be set
});
```

#### Mapbox map instantiation

```javascript
const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    style: 'dark',
    center: [103.83735604457024, 1.360253881403068],
    pitch: 4.00000000000001,
    zoom: 10.210275860702593,
    rotation: 19.313180925794313,
    token: 'xxxx - token',
  }),
});
```

### Pass in external instance

In order to support the ability of existing map projects to quickly access L7, L7 provides a method for passing in map instances. If you are a new project, it is recommended to use Scene to initialize the map.

⚠️ The scene id parameter requires the Map instances of the map to be in the same container.

⚠️ When passing in a map instance, you need to introduce the API of the relevant map yourself

⚠️ Set viewMode to 3D mode (GaodeMap2.0 supports 2D mode and does not need to be set)

#### Pass in Gaode map instance

```javascript
const map = new AMap.Map('map', {
  viewMode: '3D',
  resizeEnable: true, // Whether to monitor map container size changes
  zoom: 11, // Initialize map level
  center: [116.397428, 39.90923], // Initialize the map center point
});
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    mapInstance: map,
  }),
});
```

[Example address](/examples/tutorial/map#amapInstance)[code address](https://github.com/antvis/L7/blob/master/examples/tutorial/map/demo/amapInstance.js)

[Example address (2D)](/examples/tutorial/map#amapInstance2d)[code address](https://github.com/antvis/L7/blob/master/examples/tutorial/map/demo/amapInstance.js)

#### Pass in a Mapbox map instance

```javascript
mapboxgl.accessToken = 'xxxx - token';
const map = new mapboxgl.Map({
  container: 'map', // container id
  style: 'mapbox://styles/mapbox/streets-v11', // stylesheet location
  center: [-74.5, 40], // starting position [lng, lat]
  zoom: 9, // starting zoom
});

const scene = new Scene({
  id: 'map',
  map: new Mapbox({
    mapInstance: map,
  }),
});
```

## options

### zoom initialize zoom level

<description> *number* </description>

Initial map display level {number} Mapbox (0-24) Amap (2-19)

### center map center

Map initial center latitude and longitude {Lnglat}

### pitch map tilt angle

Map initial pitch angle {number} default 0

### style map style

Simplify the map style setting. L7 has three built-in theme default styles, which can be used by Amap and mapbox.

* dark
* light
* normal
* blank no basemap

In addition to the built-in styles, you can also pass in other custom attributes.

For example, Amap

⚠️ Gaode map style added`isPublic=true`parameter

```javascript
{
  style: 'amap://styles/2a09079c3daac9420ee53b67307a8006?isPublic=true'; // The setting method is the same as AMAP
}
```

### minZoom minimum zoom level

Minimum map zoom level {number} default 0 Mapbox 0-24) Gaode (2-19)

### maxZoom maximum zoom level

Maximum map zoom level {number} default 22 Mapbox (0-24) Amap (2-19)

### rotateEnable whether to allow rotation

Whether the map can be rotated {Boolean} default true

## Register to use Gaode plug-in

```javascript
const scene = new Scene({
  id: 'map',
  map: new GaodeMap({
    center: [116.475, 39.99],
    pitch: 0,
    zoom: 13,
    plugin: ['AMap.ToolBar', 'AMap.LineSearch'],
  }),
});
// plugin: ['AMap.ToolBar', 'AMap.LineSearch'],
// In order to use the capabilities of the corresponding plug-in, the corresponding plug-in should first be registered in plugin

//The loaded AMap will be mounted on the global window object
scene.on('loaded', () => {
  window.AMap.plugin(['AMap.ToolBar', 'AMap.LineSearch'], () => {
    // add control
    scene.map.addControl(new AMap.ToolBar());

    var linesearch = new AMap.LineSearch({
      pageIndex: 1, //Page number, default value is 1
      pageSize: 1, //The number of results displayed on a single page, the default value is 20, the maximum value is 50
      city: 'Beijing', //Limit the query city, which can be the city name (Chinese/Chinese full spelling), city code, the default value is "National"
      extensions: 'all', //Whether to return bus route details, the default value is "base"
    });

    //Execute bus route keyword query
    linesearch.search('536', function (status, result) {
      //Print status information status and result information result
      // ...do something
    });
  });
});
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*ag-nSrIPPEUAAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/amapplugin/bus#busstop)
---
title: 百度地图
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## 简介

L7 地理可视化侧重于地理数据的可视化表达，地图层需要依赖第三方地图，第三方地图通过 Scene 统一创建管理，只需要通过 Scene 传入地图配置项即可。

L7 在内部解决了不同地图底图之间差异，同时 L7 层面统一管理地图的操作方法。

L7 目前支持的百度地图是[API GL版本](https://lbsyun.baidu.com/index.php?title=jspopularGL)，也是百度地图官方推荐使用版本。

### 申请token

使用百度地图之前，需要申请百度地图密钥，如何申请百度地图密钥[点我查看](https://lbs.baidu.com/index.php?title=jspopularGL/guide/getkey)。

⚠️  L7 内部设置了默认 token，仅供测试使用

### import

```javascript
import { BaiduMap } from '@antv/l7-maps';
```

### 实例化

L7 提供 BaiduMap直接实例化地图，也可外部传入方式实例化地图。

新项目推荐 BaiduMap 直接实例化，已有地图项目可外部传入方式，以便快速接入 L7 的能力。

#### BaiduMap 实例化

```js
import { BaiduMap } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new BaiduMap({
    // 填写百度地图密钥，此为测试token，不可用于生产
    token: 'zLhopYPPERGtpGOgimcdKcCimGRyyIsh',
    center: [103, 30],
    pitch: 4,
    zoom: 10,
    rotation: 19,
  }),
});
```

#### 外部传入实例化

⚠️ scene id 参数需要与 BMapGL.Map 实例是同个容器。

⚠️ 传入地图实例需要自行引入[百度地图的 API](https://lbs.baidu.com/index.php?title=jspopularGL/guide/show)

```javascript
const map = new BMapGL.Map('map', {
  zoom: 11, // 初始化地图层级
  minZoom: 4,
  maxZoom: 23,
  enableWheelZoom: true
});

const scene = new Scene({
  id: 'map',
  map: new BaiduMap({
    mapInstance: map,
  }),
});
```

BaiduMap [示例地址](/examples/map/map/#baidumap)、外部传入[示例地址](/examples/map/map/#bmapInstance)

## options

### zoom 初始化缩放等级

地图初始显示级别 {number} 百度地图（3-21）

### center 地图中心

地图初始中心经纬度 {Lnglat}

### pitch 地图倾角

地图初始俯仰角度 {number}  default 0

### style 地图样式

地图初始样式 {'normal' | string | Array}

- 值 'normal' 默认主题样式。

- 值 string 类型时，为个性化配置的[样式ID](https://lbsyun.baidu.com/index.php?title=jspopularGL/guide/custom)。

```javascript
{
  // 测试账号，已发布的样式ID 
  style: '90dbaeacad6d1d1663046eed2555ab9e'
}
```

- 值 Array 时，为自定义的[样式JSON](https://lbsyun.baidu.com/index.php?title=jspopularGL/guide/custom)

```javascript
{
  style: [{
    featureType: 'background',
    elementType: 'geometry',
    stylers: {
        color: '#070c17ff'
    }
  }]
}
```

### minZoom 最小缩放等级

地图最小缩放等级 {number} 百度地图（3-21）

### maxZoom 最大缩放等级

地图最大缩放等级 {number} 百度地图（3-21）

### rotateEnable 是否允许旋转

地图是否可旋转 {Boolean} default true

---
title: 高德地图
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## 简介

### 高德地图 Token


## 引入

## 初始化化

### 地图配置



---
title: 腾讯地图
order: 1
------
title: 场景 Scene
description:  地图场景初始 
keywords: 地图 Scene 
order: 0
redirect_from:
  - /zh/docs/api
---

<embed src="@/docs/common/style.md"></embed>

## 简介

场景对象 `scene` 是包含地图、地图控件、组件、加载资源的全局对象，通过 `scene` 场景对象，我们可以获取到操作地图需要的所有内容。

<div>
  <div style="width:40%;float:left; margin: 10px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*3wMCR7vIlCwAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

## options

### id

<description> _string | HTMLElement_ **必选** </description>

需传入 dom 容器或者容器 id。

### map

<description> MapInstance **必选** </description>

可以通过 scene map 属性获取 map 实例。

```javascript
const map = scene.map;
```

为了统一不同底图之前的接口差异 `L7` 在 `Scene` 层对 `map` 的方法做了统一，因此一些地图的操作方法可以通过 `Scene` 调用，这样，切换不同底图时可以保证表现一致。

示例代码

```javascript
const scene = new L7.Scene({
  id: 'map',
  map: new L7.GaodeMap({
    style: 'dark',
    center: [110.770672, 34.159869],
    pitch: 45,
  }),
});
```

### logoPosition

<description> _bottomleft_ **可选** </description>

`L7` 默认提供的 `Logo` 可以配置显示位置，默认在左下角。

- bottomright
- topright
- bottomleft
- topleft
- topcenter
- bottomcenter
- leftcenter
- rightcenter

### logoVisible logo 是否可见

<description> _bottomleft_ **可选** _default: true_ </description>

配置 `L7` 的 `Logo` 是否显示，默认显示。

### antialias 是否开启抗锯齿

<description> _boolean_ **可选** _default: true_ </description>

是否开始前抗锯齿。

### stencil 是否开启裁减

<description> _boolean_ **可选** _default: false_ </description>

是否开始开启裁剪。

🌟 从 v2.7.2 版本开始支持， 图层 `Mask` 掩模能力以及矢量瓦片需要开始该配置。

### preserveDrawingBuffer

<description> _boolean_ **可选** _default: false_ </description>

是否保留缓冲区数据 `boolean` `false`。

## Layer 方法

### addLayer(layer): void 增加图层对象

把图层添加到 `Scene` 场景中。

参数 :

- `layer` 图层对象

```javascript
scene.addLayer(layer);
```

### getLayer(id: string): ILayer 获取对应的图层对象

获取对应的图层。

```javascript
scene.getLayer('layerID');
```

### getLayers(): ILayer[] 获取所有的地图图层

获取所有的地图图层。

```javascript
scene.getLayers();
```

### getLayerByName(name: string): ILayer 根据图层名称获取图层

根据图层名称获取图层。

- `name` 图层在初始化的时候配置图层的 `name`。

```javascript
scene.getLayerByName(name);
```

### removeLayer(layer: ILayer): void 移除 layer 图层

移除 `layer` 图层。

```javascript
scene.removeLayer(layer);
```

🌟 移除的同时会将图层进行销毁。

### removeAllLayer(): void 移除所有的图层对象

移除所有的图层对象。

```javascript
scene.removeAllLayer();
```

🌟 移除的同时会将图层进行销毁。

## 控制组件方法

### addControl(ctl: IControl): void 添加组件控件

添加组件控件。

- `crl` 用户创建的控件对象。

```javascript
scene.addControl(ctl);
```

### removeControl(ctr: IControl): void 移除用户添加的组件控件

移除用户添加的组件控件。

- `ctl` 用户创建的控件对象。

```javascript
scene.removeControl(ctl);
```

### getControlByName(name: string): IControl 根据控件的名称来获取控件

根据控件的名称来获取控件。

```javascript
const zoomControl = new Zoom({
  // zoom 控件
  name: 'z1', // 用户传入的控件名称（也可以不传入，该控件默认名称为 zoom）
  position: 'topright',
});

scene.getControlByName('z1');
```

## 气泡方法

### addPopup(popup: Popup): void 添加气泡

往场景中添加气泡对象，气泡用于展示用户自定义信息。

```javascript
scene.addPopup(popup);
```

### removePopup(popup: Popup): void 移除气泡

往场景中移除气泡对象

```javascript
scene.removePopup(popup);
```

## 标记方法

### addMarker(maker: IMarker): void 添加标记

往场景中添加标记对象，`Marker` 实例是用户自由控制的 `DOM`。

- `maker` 用户创建的 `Marker` 实例。

```javascript
const marker = new Marker({
  element: el,
}).setLnglat({ lng: nodes[i].x * 1, lat: nodes[i].y });
scene.addMarker(marker);
```

### addMarkerLayer(layer: IMarkerLayer): void 添加 Marker 统一管理图层

当用户需要添加许多个 `Marker` 实例时，为了方便管理可以使用 `MarkerLayer` 对象统一管理。

- `layer` 标记图层对象。

```javascript
const markerLayer = new MarkerLayer();
scene.addMarkerLayer(markerLayer);
```

### removeMarkerLayer(layer: IMarkerLayer): void 移除标签图层

移除标签图层。

- `layer` 标记图层对象。

```javascript
scene.removeMarkerLayer(markerLayer);
```

### removeAllMarkers(): void 移除场景中所有的标签对象

移除场景中所有的标签对象。

```javascript
scene.removeAllMarkers();
```
## 静态方法
静态方法通过 Scene 类去调用，不是 scene 实例
### addProtocol
添加自定义数据协议，设置一个自定义加载瓦片函数，当使用以自定义 URL 模式开头的数据时，该函数将被调用。
-  protocol 协议名称
-  handler 数据处理回调函数
    -  requestParameters: RequestParameters,
        - url 瓦片 URL，携带瓦片行列号 x,y,z 
    -  callback: ResponseCallback<any>) => Cancelable
        - Cancelable： {
            cancel: () => void;
          };


#### 自定义函数

```ts
    Scene.addProtocol('custom', (params, callback) => {
          fetch(`https://${params.url.split("://")[1]}`)
              .then(t => {
                  if (t.status == 200) {
                      t.arrayBuffer().then(arr => {
                          callback(null, arr, null, null);
                      });
                  } else {
                      callback(new Error(`Tile fetch error: ${t.statusText}`));
                  }
              })
              .catch(e => {
                  callback(new Error(e));
              });
          return { cancel: () => { } };
      });
// the following is an example of a way to return an error when trying to load a tile
    Scene.addProtocol('custom2', (params, callback) => {
        callback(new Error('someErrorMessage'));
        return { cancel: () => { } };
    });
```

#### 加载 PMTiles

```ts
import * as pmtiles from "pmtiles";
const protocol = new pmtiles.Protocol();
const scene = new Scene({
      id: 'map',
      map: new Map({
        center: [11.2438, 43.7799],
        zoom: 12,
      }),
    });

    scene.addProtocol('pmtiles',protocol.tile);
    const source = new Source('pmtiles://https://mdn.alipayobjects.com/afts/file/A*HYvHSZ-wQmIAAAAAAAAAAAAADrd2AQ/protomaps(vector)ODbL_firenze.bin', {
        parser: {
          type: 'mvt',
          tileSize: 256,
          maxZoom: 14,
          extent: [-180, -85.051129, 179, 85.051129],
        },
      })


```

### removeProtocol
  删除之前添加的协议
  - name: 协议名称

```ts
 scene.removeProtocol('pmtiles',protocol.tile);
```


## 地图方法

### getZoom(): number 获取缩放等级

获取当前缩放等级。

```javascript
scene.getZoom();
```

### getCenter(): ILngLat 获取地图中心

获取地图中心点

```javascript
interface ILngLat {
  lng: number;
  lat: number;
}

scene.getCenter();
```

### getSize(): [number, number] 获取地图容器大小

获取地图容器大小，width、height。

```javascript
scene.getSize();
```

### getPitch(): number 获取地图倾角

获取地图俯仰角。

```javascript
scene.getPitch();
```

### getContainer(): HTMLElement | null 获取地图容器

获取地图容器。

```javascript
scene.getContainer();
```

### setMapStyle(style: string): void 设置地图样式

参数 `style` 参数是字符串，可以选择内置的地图样式 具体样式格式和各底图设置方法一致。

`L7` 内置了三种地图样式，`AMAP` 和 `MapBox` 都适用。

- light
- dark
- normal

设置地图底图样式的方法。

```javascript
// 快捷名称设置
scene.setMapStyle('light');

// mapbox 主题设置
scene.setMapStyle('mapbox://styles/mapbox/streets-v11');

// AMap
scene.setMapStyle(
  'amap://styles/2a09079c3daac9420ee53b67307a8006?isPublic=true',
);
```

### setCenter(center: ICenter, option?: ICameraOptions): void 设置地图中心点

设置地图中心点坐标。`L7` 提供了 `setCenter` 方法，允许用户动态的设置地图的中心点位，同时允许通过可选的 `options` 属性设置偏移。

```js
type ICenter = [number, number];
interface ICameraOptions {
  padding:
    | number
    | [number, number, number, number]
    | {
        top?: number,
        bottom?: number,
        right?: number,
        left?: number,
      };
}

scene.setCenter([lng, lat]);
scene.setCenter([lng, lat], {
  padding: {
    top: 100,
  },
});
```

🌟 `padding` 参数支持如下的三种传值方式，数值的单位是 `px`，表示地图中心点距离容器边缘的偏移距离。

```javascript
export interface ICameraOptions {
  padding:
    | number
    | [number, number, number, number]
    | {
        top?: number,
        bottom?: number,
        right?: number,
        left?: number,
      };
}
```

[在线案例](/examples/point/bubble#point)

### setZoomAndCenter(zoom: number, center: ICenter): void 设置地图缩放等级和中心点

设置地图等级和中心。

```javascript
type ICenter = [number, number];
scene.setZoomAndCenter(zoom, center);
```

### setZoom(zoom: number): void 设置地图缩放等级

设置地图缩放等级

```javascript
scene.setZoom(10);
```

### setRotation(rotation: number): void 设置地图旋转

设置地图顺时针旋转角度，旋转原点为地图容器中心点，取值范围 [0-360]。

```javascript
scene.setRotation(rotation);
```

### zoomIn(); void 地图放大一级

地图放大一级。

```javascript
scene.zoomIn();
```

### zoomOut(): void 地图缩小一级

地图缩小一级。

```javascript
scene.zoomOut();
```

### panTo(lnglat: ILngLat): void 地图移动

地图平移到指定的经纬度位置。

```javascript
type ILngLat = [number, number];
scene.panTo(LngLat);
```

### panBy(x: number, y: number): void 地图平移

以像素为单位沿 X 方向和 Y 方向移动地图。

- `x` 水平方向移动像素 向右为正方向。
- `y` 垂直方向移动像素 向下为正方向。

```javascript
scene.panBy(x, y);
```

### setPitch(pitch: number): void 设置地图倾角

设置地图仰俯角度。

```javascript
scene.setPitch(pitch);
```

### setMapStatus(statusOption: IStatusOptions): void 设置地图状态

用来设置地图的一些交互配置。

```javascript
interface IStatusOptions {
  showIndoorMap: boolean;
  resizeEnable: boolean;
  dragEnable: boolean;
  keyboardEnable: boolean;
  doubleClickZoom: boolean;
  zoomEnable: boolean;
  rotateEnable: boolean;
}

scene.setMapStatus({ dragEnable: false });
```

### fitBounds(bound: IBounds, options?: IOptions): void 设置地图缩放范围

地图缩放到某个范围内。

- `bound` 表示经纬度范围 [[minlng,minlat],[maxlng,maxlat]]。
- `options` 用户传入，覆盖 `animate` 直接配置，覆盖 `Scene` 传入的配置项。

```javascript
type IBounds = [[number, number], [number, number]];
interface IOptions {
  [key]: any;
  animate: boolean;
}

scene.fitBounds([
  [112, 32],
  [114, 35],
]);
```

### containerToLngLat(point: IPoint): ILngLat 画布坐标转经纬度

将画布坐标转经纬度坐标

```javascript
type IPoint = [number, number];
interface ILngLat {
  lng: number;
  lat: number;
}

scene.pixelToLngLat([10, 10]);
```

### lngLatToContainer(lnglat: ILngLat): IPoint 经纬度转画布坐标

经纬度坐标转画布坐标。

```javascript
type ILngLat = [number, number];
interface IPoint {
  x: number;
  y: number;
}

scene.lngLatToPixel([120, 10]);
```

### pixelToLngLat(pixel: IPoint): ILngLat 像素坐标转经纬度

地图像素坐标转经纬度坐标，像素坐标地图上某点距离容器左上角的位置。

```javascript
type IPoint = [number, number];
interface ILngLat {
  lng: number;
  lat: number;
}
scene.pixelToLngLat([10, 10]);
```

### lngLatToPixel(lnglat: ILngLat): IPoint 经纬度转像素坐标

经纬度坐标转像素坐标。

```javascript
type ILngLat = [number, number];
interface IPoint {
  x: number;
  y: number;
}
scene.lngLatToPixel([120, 10]);
```

### exportMap(type?: IImage): string 导出

导出地图，目前仅支持导出可视化层，不支持底图导出。

```javascript
type IImage = 'png' | 'jpg';
scene.exportMap('png');
```

### destroy(): void 场景销毁

`scene` 销毁方法，离开页面，不需要使用地图的时候调用，调用后 `scene` 中的资源和都会被销毁。

```javascript
scene.destroy();
```

## iconfont 映射支持

### addIconFont(name: string, unicode: string): void 增加映射支持

支持对用户传入的数据进行 `unicode` 的映射，在内部维护一组名称和对应 `key` 的键值对。

```javascript
scene.addIconFont('icon1', '&#xe64b;');
scene.addIconFont('icon2', '&#xe64c;');
scene.addFontFace(fontFamily, fontPath);
const pointIconFontLayer = new PointLayer({})
  .source(
    [
      {
        j: 140,
        w: 34,
        m: 'icon1',
      },
      {
        j: 140,
        w: 36,
        m: 'icon2',
      },
    ],
    {
      parser: {
        type: 'json',
        x: 'j',
        y: 'w',
      },
    },
  )
  .shape('m', 'text')
  .size(12)
  .color('w', ['#f00', '#f00', '#0f0'])
  .style({
    fontFamily,
    iconfont: true,
    textAllowOverlap: true,
  });
```

### addIconFonts(option: IOption): void 同时传入多组 name - unicode 的键值对

同时传入多组 `name - unicode` 的键值对。

```javascript
type IKeyValue = [name: string, unicode: string];
type IOption = Array<IKeyValue>;

scene.addIconFonts([
  ['icon1', '&#xe64b;'],
  ['icon2', '&#xe64c;'],
]);
```

## 全局资源

### addImage(id: string, img: IImage): void 添加全局资源

在 `scene` 全局中添加 `L7` 的图层对象可以使用的图片资源在。

```javascript
type IImage = HTMLImageElement | string | File；

scene.addImage( '02','https://gw.alipayobjects.com/zos/bmw-prod/ce83fc30-701f-415b-9750-4b146f4b3dd6.svg');
```

[示例地址](/examples/gallery/animate#animate_path_texture)

### hasImage(id: string): boolean 判断全局图片资源

判断是否已经在全局添加过相应的图片资源。

```javascript
scene.hasImage('imageID');
```

### removeImage(id: string): void 全局删除图片资源

从全局删除对应的图片资源。

```javascript
scene.removeImage('imageID');
```

### addFontFace(fontFamily: string, fontPath: string): void 添加字体文件

添加 `iconfont` 字体文件。

- `fontFamily` 用户为自己定义的字体名称
- `fontPath` 导入的文件地址

```javascript
let fontFamily = 'iconfont';
let fontPath =
  '//at.alicdn.com/t/font_2534097_iiet9d3nekn.woff2?t=1620444089776';
scene.addFontFace(fontFamily, fontPath);
```

## 其他

### getPointSizeRange(): Float32Array

获取当前设备支持绘制的 `WebGL` 点精灵的大小。

## 事件

### on(eventName: string, handler: function): void

在 `scene` 上绑定事件监听。

- `eventName` 事件名。
- `handler` 事件回调函数。

### off(eventName: string, handler: function): void

移除在 `scene` 上绑定的事件监听。

- `eventName` 事件名。
- `handler` 事件回调函数。

### 场景事件

`scene` 会触发一些常见的场景事件，用户在需要的时候可以进行监听。

#### loaded

`scene` 初始化完成事件，我们经常在 `scene` 初始化完成后添加 `Layer`。

```javascript
scene.on('loaded', () => {
  scene.addLayer(layer);
});
```

#### resize

地图容器变化事件

```javascript
scene.on('resize', () => {}); // 地图容器大小改变事件
```


### 地图事件

```javascript
scene.on('loaded', () => {}); //地图加载完成触发
scene.on('mapmove', () => {}); // 地图平移时触发事件
scene.on('movestart', () => {}); // 地图平移开始时触发
scene.on('moveend', () => {}); // 地图移动结束后触发，包括平移，以及中心点变化的缩放。如地图有拖拽缓动效果，则在缓动结束后触发
scene.on('zoomchange', () => {}); // 地图缩放级别更改后触发
scene.on('zoomstart', () => {}); // 缩放开始时触发
scene.on('zoomend', () => {}); // 缩放停止时触发
```

其他地图事件可以查看相应底图的事件文档,地图事件也可以通过 `Scene.map` 进行设置。

[Mapbox](https://docs.mapbox.com/mapbox-gl-js/api/#map.event)
[高德](https://lbs.amap.com/api/javascript-api/reference/map)

### 鼠标事件

```javascript
scene.on('click', (ev) => {}); // 鼠标左键点击事件
scene.on('dblclick', (ev) => {}); // 鼠标左键双击事件
scene.on('mousemove', (ev) => {}); // 鼠标在地图上移动时触发
scene.on('mousewheel', (ev) => {}); // 鼠标滚轮开始缩放地图时触发
scene.on('mouseover', (ev) => {}); // 鼠标移入地图容器内时触发
scene.on('mouseout', (ev) => {}); // 鼠标移出地图容器时触发
scene.on('mouseup', (ev) => {}); // 鼠标在地图上单击抬起时触发
scene.on('mousedown', (ev) => {}); // 鼠标在地图上单击按下时触发
scene.on('contextmenu', (ev) => {}); // 鼠标右键单击事件
scene.on('dragstart', (ev) => {}); //开始拖拽地图时触发
scene.on('dragging', (ev) => {}); // 拖拽地图过程中触发
scene.on('dragend', (ev) => {}); //停止拖拽地图时触发。如地图有拖拽缓动效果，则在拽停止，缓动开始前触发

scene.on('webglcontextlost', () => {}); // webgl 上下文丢失
```



## 实验参数

实验参数可能会废弃。

### offsetCoordinate: boolean

高德地图适用，是否关闭偏移坐标系， 默认为 `true`。

```js
const scene = new Scene({
  offsetCoordinate: true,
});
```
---
title: Shape
order: 3
---

<embed src="@/docs/common/style.md"></embed>

`shape` 方法用于指定热力图层绘制热力的类型，现在支持经典热力、蜂窝热力、网格热力三种类型。

### shape('heatmap')

`shape` 为 `heatmap` 热力图层用于绘制 2D 经典热力。

### shape('heatmap3D')

`shape` 为 `heatmap3D` 热力图层用于绘制 3D 热力。

### transforms

网格热力和蜂窝热力的实现依赖配置 `transforms` 的参数，[具体说明使用](/api/source/source/#transforms)。

```js
fetch(
  'https://gw.alipayobjects.com/os/basement_prod/513add53-dcb2-4295-8860-9e7aa5236699.json',
)
  .then((res) => res.json())
  .then((data) => {
    const layer = new HeatmapLayer({})
      .source(data, {
        transforms: [
          {
            type: 'hexagon',
            size: 100,
            field: 'h12',
            method: 'sum',
          },
        ],
      })
      .size('sum', [0, 600])
      .shape('hexagonColumn')
      .style({
        coverage: 0.8,
        angle: 0,
      })
      .color(
        'sum',
        [
          '#094D4A',
          '#146968',
          '#1D7F7E',
          '#289899',
          '#34B6B7',
          '#4AC5AF',
          '#5FD3A6',
          '#7BE39E',
          '#A1EDB8',
          '#CEF8D6',
        ].reverse(),
      );
    scene.addLayer(layer);
  });
```
---
title: Shape
order: 3
---

<embed src="@/docs/common/style.md"></embed>

`shape`The method is used to specify the type of heat drawn by the heat layer. Now it supports three types: classic heat, cellular heat, and grid heat.

### shape('heatmap')

`shape`for`heatmap`Heat layers are used to draw classic heat in 2D.

### shape('heatmap3D')

`shape`for`heatmap3D`Thermal layers are used to draw 3D heat.

### transforms

Implementation of Grid Thermal and Cellular Thermal depends on configuration`transforms`parameters,[Specific instructions for use](/api/source/source/#transforms)。

```js
fetch(
  'https://gw.alipayobjects.com/os/basement_prod/513add53-dcb2-4295-8860-9e7aa5236699.json',
)
  .then((res) => res.json())
  .then((data) => {
    const layer = new HeatmapLayer({})
      .source(data, {
        transforms: [
          {
            type: 'hexagon',
            size: 100,
            field: 'h12',
            method: 'sum',
          },
        ],
      })
      .size('sum', [0, 600])
      .shape('hexagonColumn')
      .style({
        coverage: 0.8,
        angle: 0,
      })
      .color(
        'sum',
        [
          '#094D4A',
          '#146968',
          '#1D7F7E',
          '#289899',
          '#34B6B7',
          '#4AC5AF',
          '#5FD3A6',
          '#7BE39E',
          '#A1EDB8',
          '#CEF8D6',
        ].reverse(),
      );
    scene.addLayer(layer);
  });
```
---
title: Style
order: 4
---

<embed src="@/docs/common/style.md"></embed>

`style` 方法用于配制图层的样式，相同图层拥有不同的 `shape` 图形，不同 `shape` 的图层 `style` 方法接受不同的参数。

🌟 蜂窝热力图和网格热力图的 `style` 样式可以参考实际绘制的图层。

```js
layer.style({
  opacity: 0.5,
});
```

### common

通用 `style` 参数，所有图形都支持的参数。

| style   | 类型     | 描述         | 默认值 |
| ------- | -------- | ------------ | ------ |
| opacity | `number` | 图形的透明度 | `1`    |

### heatmap

`shape` 为 `heatmap`、`heatmap3D` 类型的时候，绘制经典热力图。

| style      | 类型     | 描述         | 默认值 |
| ---------- | -------- | ------------ | ------ |
| intensity  | `number` | 热力的强度   | `10`   |
| radius     | `number` | 热力点的半径 | `10`   |
| rampColors | `number` | 热力的色值   | `1`    |

#### rampColors

- colors  颜色数组
- positions 数据区间

配置值域映射颜色的色带，值域的范围为 `[0 - 1]`, 对应的我们需要为每一个 `position` 位置设置一个颜色值。

⚠️ colors, positions 的长度要相同

```javascript
layer.style({
  rampColors: {
    colors: ['#FF4818', '#F7B74A', '#FFF598', '#91EABC', '#2EA9A1', '#206C7C'],
    positions: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
  },
});
```

### hexagon

绘制蜂窝热力图。

| style    | 类型     | 描述         | 默认值 |
| -------- | -------- | ------------ | ------ |
| angle    | `number` | 图形旋转角度 | `0`    |
| coverage | `number` | 图形覆盖比率 | `0.9`  |

### grid

绘制网格热力图。

| style    | 类型     | 描述         | 默认值 |
| -------- | -------- | ------------ | ------ |
| coverage | `number` | 图形覆盖比率 | `1`    |
---
title: Style
order: 4
---

<embed src="@/docs/common/style.md"></embed>

`style`The method is used to configure the style of the layer. The same layer has different`shape`graphics, different`shape`layer`style`Methods accept different parameters.

🌟 Honeycomb heat map and grid heat map`style`The style can refer to the actual drawn layer.

```js
layer.style({
  opacity: 0.5,
});
```

### common

Universal`style`Parameters, parameters supported by all graphics.

| style   | type     | describe             | default value |
| ------- | -------- | -------------------- | ------------- |
| opacity | `number` | Graphic transparency | `1`           |

### heatmap

`shape`for`heatmap`、`heatmap3D`type, draw a classic heat map.

| style      | type     | describe                   | default value |
| ---------- | -------- | -------------------------- | ------------- |
| intensity  | `number` | intensity of heat          | `10`          |
| radius     | `number` | The radius of the hot spot | `10`          |
| rampColors | `number` | thermal color value        | `1`           |

#### rampColors

* colors color array
* positions data interval

Configure the color band of the value range mapping color. The range of the value range is`[0 - 1]`, correspondingly we need to provide each`position`Position sets a color value.

⚠️ colors, positions must be the same length

```javascript
layer.style({
  rampColors: {
    colors: ['#FF4818', '#F7B74A', '#FFF598', '#91EABC', '#2EA9A1', '#206C7C'],
    positions: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
  },
});
```

### hexagon

Draw cellular heat maps.

| style    | type     | describe                | default value |
| -------- | -------- | ----------------------- | ------------- |
| angle    | `number` | Graphic rotation angle  | `0`           |
| coverage | `number` | graphics coverage ratio | `0.9`         |

### grid

Draw a grid heat map.

| style    | type     | describe                | default value |
| -------- | -------- | ----------------------- | ------------- |
| coverage | `number` | graphics coverage ratio | `1`           |
---
title: Scale
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/scale.zh.md"></embed>
---
title: Scale
order: 6
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/scale.en.md"></embed>
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/options.zh.md"></embed>
---
title: Source
order: 2
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/source.zh.md"></embed>

🌟 热力图的数据使用和点图层保持一致。

### GeoJSON

```js
// 传入 GeoJSON 类型数据 *** L7 默认支持，不需要 parser 解析
var data = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'Polygon',
            coordinates: [
              [120, 30],
              ...
            ]
          },
        },
      ],
    };

var layer = new HeatmapLayer()
.source(data)
```

### CSV

```js
// 传入 txt 类型数据
var data = `from,to,value,type,lng1,lat1,lng2,lat2
鎷夎惃,娴疯タ,6.91,move_out,91.111891,29.662557,97.342625,37.373799
鎷夎惃,鎴愰兘,4.79,move_out,91.111891,29.662557,104.067923,30.679943
鎷夎惃,閲嶅簡,2.41,move_out,91.111891,29.662557,106.530635,29.544606
鎷夎惃,鍖椾含,2.05,move_out,91.111891,29.662557,116.395645,39.929986
...`;

var layer = new HeatmapLayer().source(data, {
  parser: {
    type: 'csv',
    x: 'lng1',
    y: 'lat1',
  },
});
```

### JSON

```js
// 传入 JSON 类型的数据
var data = [
  {
    lng: 120,
    lat: 30
  },
  ...
]

var layer = new HeatmapLayer()
.source(data, {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat',
  }
})
```
---
title: Source
order: 2
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/source.en.md"></embed>

🌟 The data usage of heat map is consistent with that of point layer.

### GeoJSON

```js
// Pass in GeoJSON type data *** L7 supports it by default and does not require parser analysis
var data = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'Polygon',
            coordinates: [
              [120, 30],
              ...
            ]
          },
        },
      ],
    };

var layer = new HeatmapLayer()
.source(data)
```

### CSV

```js
// Pass in txt type data
var data = `from,to,value,type,lng1,lat1,lng2,lat2
鎷夎惃,仙魔タ,6.91,move_out,91.111891,29.662557,97.342625,37.373799
鎷厎惃,鎴愰嘘,4.79,move_out,91.111891,29.662557,104.067923,30.679943
鎷厎惃,玷夎惃,月充经,2.41,move_out,91.111891,29.662557,106.530635,29.544606
鎷厎惃,鍖椾han,2.05,move_out,91.111891,29.662557,116.395645,39.929986
...`;

var layer = new HeatmapLayer().source(data, {
  parser: {
    type: 'csv',
    x: 'lng1',
    y: 'lat1',
  },
});
```

### JSON

```js
// Pass in JSON type data
var data = [
  {
    lng: 120,
    lat: 30
  },
  ...
]

var layer = new HeatmapLayer()
.source(data, {
  parser: {
    type: 'json',
    x: 'lng',
    y: 'lat',
  }
})
```
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/options.en.md"></embed>
---
title: Heatmap
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## 简介

热力图以特殊高亮的形式显示数据在地理区域的聚集程度，L7 提供了以多种表现形式的热力图，通过切换 `shape` 参数，用户可以得到不同的热力图

<div>
  <div style="width:40%;float:right; margin-left: 16px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*QstiQq4JBOIAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

```javascript
layer
  .shape('heatmap')
  .size('mag', [0, 1.0]) // weight映射通道
  .style({
    radius: 20,
    rampColors: rampColors,
  });
```
---
title: Heatmap
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

Heat maps display the degree of aggregation of data in geographical areas in a special highlighted form. L7 provides heat maps in a variety of presentation forms. By switching`shape`parameters, users can get different heat maps

<div>
  <div style="width:40%;float:right; margin-left: 16px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/antv_site/afts/img/A*QstiQq4JBOIAAAAAAAAAAABkARQnAQ'>
  </div>
</div>

```javascript
layer
  .shape('heatmap')
  .size('mag', [0, 1.0]) // weight mapping channel
  .style({
    radius: 20,
    rampColors: rampColors,
  });
```
---
title: 飞线
order: 2
---

<embed src="@/docs/common/style.md"></embed>

用户在地球模式下使用飞线图层无需做额外的操作，L7 会自动识别地球模式并相关的转化

## 使用

地球飞线图通过 `LineLayer` 和 `EarthLayer` 实例化

```javascript
import { EarthLayer, LineLayer } from '@antv/l7';
```

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*4ZCnQaH_nLIAAAAAAAAAAAAAARQnAQ" style="display: block; margin: 0 auto" alt="L7地球飞线图层" width="450px">

### shape

地球飞线图层 shape 只支持 **arc3d**
---
title: CanvasLayer
order: 7
---

CanvasLayer 允许用户通过 canvas 绘制的方法自定义图层的内容和样式。相比于 Marker 通过创建实际 DOM 的方式，CanvasLayer 无疑有更佳的性能。

## 使用

```jsx
import { CanvasLayer } from '@antv/l7';
const layer = new CanvasLayer({}).style({
  drawingOnCanvas: (option) => {
    const { size, ctx, mapService } = option;
    const [width, height] = size;

    ctx.clearRect(0, 0, width, height);
    // canvas 绘制
  },
});
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*hUmNQJ1sAb8AAAAAAAAAAAAAARQnAQ'/>

[在线案例](/examples/point/chart#custom)

### source

🌟 CanvasLayer 不需要设置 source。

### event

🌟 CanvasLayer 暂不支持交互动作。

### animate

当用户在绘制 canvas 动画的时候，为了实现动画的更新，需要执行 animate 方法。

```javascript
layer.animate(true);
```

[在线案例](/examples/point/chart#custom)

### style

#### zIndex

每个创建一个 CanvasLayer，L7 会生成一个 Canvas DOM 的实例，我们通过设置 zIndex 的值来调整 CanvasLayer 的层级。

#### update

指定 CanavsLayer 的更新方式，update 有两个值 'always'、'dragend'，默认为 'always'

- always 总是更新
- dragend 地图拖动完后/缩放完后更新

#### drawingOnCanvas(options)

```javascript
options: {
  canvas: HTMLCanvasELement;
  ctx: CanvasRenderingContext2D;
  mapService: IMapService;
  size: [number, number];
}
```

drawingOnCanvas，这是一个函数，接受相关参数，用户在该函数中写 canvas 的绘制逻辑

- canvas CanvasLayer 生成的 canvas DOM 节点
- ctx 生成的 canvas DOM 的上下文
- mapService 当前地图的 mapService，主要提供 lngLatToContainer 方法
- size 当前视图的实际绘图范围的大小

#### lngLatToContainer([lng,lat]): {x: x, y: y}

该方法是由 mapService 参数提供的，主要用于将经纬度点位数据实时转化成 Canvas 绘图能够使用的 xy 坐标，从而达到绘图内容与地图的位置的对应。

```javascript
var center = [120, 30];
var centerXY = mapService.lngLatToContainer(center); // {x: 100, y: 100}
// centerXY 表示距离视图左上角 x 轴方向 100px，y 轴方向 100px
// canvas 绘图坐标系
```
---
title: CanvasLayer
order: 7
---

CanvasLayer allows users to customize the content and style of the layer through canvas drawing methods. Compared to Marker by creating the actual DOM, CanvasLayer undoubtedly has better performance.

## use

```jsx
import { CanvasLayer } from '@antv/l7';
const layer = new CanvasLayer({}).style({
  drawingOnCanvas: (option) => {
    const { size, ctx, mapService } = option;
    const [width, height] = size;

    ctx.clearRect(0, 0, width, height);
    // canvas 绘制
  },
});
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*hUmNQJ1sAb8AAAAAAAAAAAAAARQnAQ'/>

[Online case](/examples/point/chart#custom)

### source

🌟 CanvasLayer does not need to set source.

### event

🌟 CanvasLayer does not support interactive actions yet.

### animate

When the user is drawing a canvas animation, in order to update the animation, the animate method needs to be executed.

```javascript
layer.animate(true);
```

[Online case](/examples/point/chart#custom)

### style

#### zIndex

Each time a CanvasLayer is created, L7 will generate an instance of the Canvas DOM. We adjust the level of the CanvasLayer by setting the zIndex value.

#### update

Specify the update method of CanavsLayer. update has two values ​​'always' and 'dragend'. The default is 'always'

* always always updated
* dragend The map is updated after dragging/zooming.

#### drawingOnCanvas(options)

```javascript
options: {
  canvas: HTMLCanvasELement;
  ctx: CanvasRenderingContext2D;
  mapService: IMapService;
  size: [number, number];
}
```

drawingOnCanvas, this is a function that accepts relevant parameters. The user writes the canvas drawing logic in this function.

* canvas DOM node generated by canvas CanvasLayer
* The context of the canvas DOM generated by ctx
* mapService mapService of the current map, mainly provides lngLatToContainer method
* size The actual drawing range size of the current view

#### lngLatToContainer(\[lng,lat]): {x: x, y: y}

This method is provided by the mapService parameter and is mainly used to convert latitude and longitude point data into xy coordinates that can be used in Canvas drawing in real time, so as to achieve the correspondence between the drawing content and the location of the map.

```javascript
var center = [120, 30];
var centerXY = mapService.lngLatToContainer(center); // {x: 100, y: 100}
// centerXY means 100px from the upper left corner of the view in the x-axis direction and 100px in the y-axis direction
// canvas drawing coordinate system
```
---
title: FlyLine
order: 2
---

<embed src="@/docs/common/style.md"></embed>

Users do not need to do additional operations when using the fly line layer in earth mode. L7 will automatically recognize the earth mode and perform related conversions.

## use

Earth Flying Line Diagram Passed`LineLayer`and`EarthLayer`Instantiate

```javascript
import { EarthLayer, LineLayer } from '@antv/l7';
```

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*4ZCnQaH_nLIAAAAAAAAAAAAAARQnAQ" style="display: block; margin: 0 auto" alt="L7地球飞线图层" width="450px">

### shape

Earth fly line layer shape only supports**arc3d**
---
title: 点图层
order: 3
---

<embed src="@/docs/common/style.md"></embed>

用户在地球模式下使用点图层无需做额外的操作，L7 会自动识别地球模式并相关的转化

## 使用

地球点图层通过 `PointLayer` 和 `EarthLayer` 实例化

```javascript
import { PointLayer, EarthLayer } from '@antv/l7';
```

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*ck1XSZ4Vw0QAAAAAAAAAAAAAARQnAQ" style="display: block; margin: 0 auto" alt="L7 地球点图层" width="450px" >---
title: Earth Mode
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

l7-maps provides`Earth`Maps, compared to Amap and mapbox maps, are a completely different form of expression, providing visual display capabilities from a global perspective and providing users with more visual expressions of geographical information.

✨ In order to distinguish from ordinary maps, l7-maps provides a brand new`Earth`Map type, L7 provides corresponding`EarthLayer`Layers

```js
import { EarthLayer } from '@antv/l7';
import { Earth } from '@antv/l7-maps';
```

## Currently supported layer types in Earth mode

### point layer

**Plane point: circle**

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*PD6fTbs7E3gAAAAAAAAAAAAAARQnAQ'>

**cylindrical point: cylinder**

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*n6tYQKceveUAAAAAAAAAAAAAARQnAQ'>

### line layer

**3D arc: arc3d**

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*FjhGT77aCaIAAAAAAAAAAAAAARQnAQ'>

## use

```javascript
// 1. Introduce the corresponding module
import { Scene, Earth } from '@antv/l7-maps';
import { EarthLayer } from '@antv/l7-layers';

// 2. Build Earth Map
const scene = new Scene({
  id: 'map',
  map: new Earth({}),
});

// 3. Construct the earth layer. The current shape is base, which represents the basic sphere.
const earthlayer = new EarthLayer()
  .source(
    //Texture of the Earth's surface
    'https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*3-3NSpqRqUoAAAAAAAAAAAAARQnAQ',
    {
      parser: {
        type: 'image',
        extent: [121.168, 30.2828, 121.384, 30.421],
      },
    },
  )
  .color('#f00')
  .shape('base')
  .style({
    opacity: 1.0,
    radius: 40,
    globalOptions: {
      ambientRatio: 0.6, // ambient light
      diffuseRatio: 0.4, // diffuse reflection
      specularRatio: 0.1, // specular reflection
      earthTime: 0.1,
    },
  })
  .animate(true);

scene.on('loaded', () => {
  // 4. Add a basic earth sphere
  scene.addLayer(earthlayer);
});
//After the above steps, we can add a basic earth to the scene
```

## Independent map type Earth

### Constructor Earth

As the base map type of l7-maps,`Earth`The camera system of the earth system is provided. Currently, only an empty object needs to be passed in.

* args:**{}**

```js
import { Scene, Earth } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new Earth({}),
});
```

### rotateY

Provides a simple method to control the rotation of the earth system (actually controlling the rotation of the camera, you need to pass in an object

* force:`false`Determine whether to force it to take effect. By default, this method has a lower priority than the user's mouse operation. When the user operates the camera, this method will fail.
* reg:`0.01`Angle of rotation (visual rotation angle of the earth),`reg`It does not represent the actual rotation angle, but the ratio of the unit rotation angle.\
  🌟Unit rotation angle = Math.min(this.earthCameraZoom \* this.earthCameraZoom, 1)

```js
import { Scene, Earth } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new Earth({}),
});

function step() {
  scene.map.rotateY({
    option: {
      force: true,
      reg: 0.1,
    },
  });
  requestAnimationFrame(step);
}

scene.on('loaded', () => {
  scene.addLayer(earthlayer);
  step();
});
```

## Map layer EarthLayer

The earth layer is different from the layers of ordinary Gaode maps and Mapbox maps. It can only be used in earth mode and is used to represent the earth's sphere, atmosphere, glow and other effects.\
🌟 Use different`shape`Parameters represent the differences between different earth layers.

### Earth sphere layer baseLayer

* source: data

  * map: The address of the earth's surface texture map
  * parser: Parser, currently you only need to write fixed object values:`{ parser: { type: "image" } }`

* shape: layer type

  The default value is`base`, currently supported`shape`Types are:

  * base: sphere
  * atomSphere: atmosphere
  * bloomSphere: Shining

  When the user's`shape`When the parameter is not recognized, it is automatically downgraded to`base`type

* globalOptions: layer style
  * ambientRatio: ambient light
  * diffuseRatio: diffuse reflection
  * specularRatio: specular reflection

```javascript
const earthlayer = new EarthLayer()
  .source(
    'https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*3-3NSpqRqUoAAAAAAAAAAAAARQnAQ',
    {
      parser: {
        type: 'image',
      },
    },
  )
  .shape('base')
  .style({
    globalOptions: {
      ambientRatio: 0.6, // ambient light
      diffuseRatio: 0.4, // diffuse reflection
      specularRatio: 0.1, // specular reflection
    },
  });
```

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*i_TBRZRLSuYAAAAAAAAAAAAAARQnAQ" style="display: block; margin: 0 auto" alt="L7 地球图层" width="450px">

### Earth Inner Glow/Atmosphere layer atomLayer

`atomLayer`As the effect layer of the earth, there is no need to pass in data, so you don’t need to call it.`source`method

```javascript
const atomLayer = new EarthLayer()
  .color('#2E8AE6')
  .shape('atomSphere')
  .style({
    //Can control the luminescence level
    opacity: 1,
  });
```

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*1MU_RZQyFTkAAAAAAAAAAAAAARQnAQ" style="display: block; margin: 0 auto" alt="L7 地球图层大气效果" width="450px" >

### Earth's internal and external glow/glow layer bloomLayer

`bloomLayer`As the effect layer of the earth, there is no need to pass in data, so you don’t need to call it.`source`method

```javascript
const bloomLayer = new EarthLayer()
  .color('#fff')
  .shape('bloomSphere')
  .style({
    opacity: 0.5,
  });
```

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*FTniTZOZkNUAAAAAAAAAAAAAARQnAQ" style="display: block; margin: 0 auto" alt="L7 地球图层辉光效果" width="450px" >
---
title: Earth Mode
order: 1
---

<embed src="@/docs/common/style.md"></embed>

## 简介

l7-maps 提供 `Earth` 地图，相较于高德地图、mapbox 地图，是完全不同的一种表现形式，提供了全球视角下的可视化展示能力，为用户提供了更多的地理信息可视化表现形式。

✨ 为了区别普通的地图，l7-maps 提供了全新的 `Earth` 地图类型， L7 提供对应的 `EarthLayer` 图层

```js
import { EarthLayer } from '@antv/l7';
import { Earth } from '@antv/l7-maps';
```

## 目前在地球模式下支持的图层类型

### 点图层

**平面点: circle**

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*PD6fTbs7E3gAAAAAAAAAAAAAARQnAQ'>

**圆柱点: cylinder**

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*n6tYQKceveUAAAAAAAAAAAAAARQnAQ'>

### 线图层

**3D 弧线: arc3d**

<img width="450px" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*FjhGT77aCaIAAAAAAAAAAAAAARQnAQ'>

## 使用

```javascript
// 1、引入对应模块
import { Scene, Earth } from '@antv/l7-maps';
import { EarthLayer } from '@antv/l7-layers';

// 2、构建 Earth Map
const scene = new Scene({
  id: 'map',
  map: new Earth({}),
});

// 3、构建地球图层，当前的 shape 为 base，表示基础球体
const earthlayer = new EarthLayer()
  .source(
    // 地球表面的纹理
    'https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*3-3NSpqRqUoAAAAAAAAAAAAAARQnAQ',
    {
      parser: {
        type: 'image',
        extent: [121.168, 30.2828, 121.384, 30.421],
      },
    },
  )
  .color('#f00')
  .shape('base')
  .style({
    opacity: 1.0,
    radius: 40,
    globalOptions: {
      ambientRatio: 0.6, // 环境光
      diffuseRatio: 0.4, // 漫反射
      specularRatio: 0.1, // 高光反射
      earthTime: 0.1,
    },
  })
  .animate(true);

scene.on('loaded', () => {
  // 4、添加基础地球球体
  scene.addLayer(earthlayer);
});
// 经过上述的步骤，我们就可以在场景中添加一个基础的地球了
```

## 独立的地图类型 Earth

### 构造函数 Earth

作为 l7-maps 的基础地图类型，`Earth` 提供了地球系统的相机系统，目前只需要传入一个空对象。

- args: **{}**

```js
import { Scene, Earth } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new Earth({}),
});
```

### rotateY

提供了简单的方法控制地球系统的旋转（实际上控制的是相机的旋转，需要传入一个对象

- force: `false` 判断是否强制生效，默认该方法的优先级比用户鼠标操作要低，当用户操作相机的时候，该方法会失效
- reg: `0.01` 旋转的角度（视觉上地球的旋转角度）， `reg` 表示的并不是实际的旋转角度，而是单位旋转角度的比例  
  🌟 单位旋转角度 = Math.min(this.earthCameraZoom \* this.earthCameraZoom, 1)

```js
import { Scene, Earth } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new Earth({}),
});

function step() {
  scene.map.rotateY({
    option: {
      force: true,
      reg: 0.1,
    },
  });
  requestAnimationFrame(step);
}

scene.on('loaded', () => {
  scene.addLayer(earthlayer);
  step();
});
```

## 地图图层 EarthLayer

地球图层区别于普通高德地图和 Mapbox 地图的图层，只在地球模式下可以被使用，用于表示地球的球体、大气层、辉光等效果。  
🌟 使用不同的 `shape` 参数表示区别不同的地球图层。

### 地球球体图层 baseLayer

- source: 数据

  - map: 地球表面纹理贴图的地址
  - parser: 解析器，目前只需要写固定的对象值即可: `{ parser: { type: "image" } }`

- shape: 图层类型

  默认值是 `base`, 目前支持的 `shape` 类型有:

  - base: 球体
  - atomSphere: 大气层
  - bloomSphere: 辉光

  当用户的 `shape` 参数不被识别时，自动降级为 `base` 类型

- globalOptions: 图层样式
  - ambientRatio: 环境光
  - diffuseRatio: 漫反射
  - specularRatio: 高光反射

```javascript
const earthlayer = new EarthLayer()
  .source(
    'https://gw.alipayobjects.com/mdn/rms_23a451/afts/img/A*3-3NSpqRqUoAAAAAAAAAAAAAARQnAQ',
    {
      parser: {
        type: 'image',
      },
    },
  )
  .shape('base')
  .style({
    globalOptions: {
      ambientRatio: 0.6, // 环境光
      diffuseRatio: 0.4, // 漫反射
      specularRatio: 0.1, // 高光反射
    },
  });
```

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*i_TBRZRLSuYAAAAAAAAAAAAAARQnAQ" style="display: block; margin: 0 auto" alt="L7 地球图层" width="450px">

### 地球内发光/大气图层 atomLayer

`atomLayer` 作为地球的效果图层，不需要传入数据，所以可以不调用 `source` 方法

```javascript
const atomLayer = new EarthLayer()
  .color('#2E8AE6')
  .shape('atomSphere')
  .style({
    // 可以控制发光程度
    opacity: 1,
  });
```

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*1MU_RZQyFTkAAAAAAAAAAAAAARQnAQ" style="display: block; margin: 0 auto" alt="L7 地球图层大气效果" width="450px" >

### 地球内外发光/辉光图层 bloomLayer

`bloomLayer` 作为地球的效果图层，不需要传入数据，所以可以不调用 `source` 方法

```javascript
const bloomLayer = new EarthLayer()
  .color('#fff')
  .shape('bloomSphere')
  .style({
    opacity: 0.5,
  });
```

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*FTniTZOZkNUAAAAAAAAAAAAAARQnAQ" style="display: block; margin: 0 auto" alt="L7 地球图层辉光效果" width="450px" >
---
title: 点图层
order: 3
---

<embed src="@/docs/common/style.md"></embed>

Users do not need to do additional operations when using point layers in earth mode. L7 will automatically recognize the earth mode and perform related conversions.

## use

Earth point layer passes`PointLayer`and`EarthLayer`Instantiate

```javascript
import { PointLayer, EarthLayer } from '@antv/l7';
```

<img src="https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*ck1XSZ4Vw0QAAAAAAAAAAAAAARQnAQ" style="display: block; margin: 0 auto" alt="L7 地球点图层" width="450px" >
---
title: threejs 引擎兼容
order: 3
---

<embed src="@/docs/common/style.md"></embed>

## 简介

1、L7 支持允许用户接入第三方的渲染引擎对地图场景进行开发，threejs 作为当前最广泛使用的通用 3D 渲染引擎，L7 将其集成后可以满足
用户自定义开发的需求，可以让 L7 覆盖更多的应用场景。

2、目前 L7Three 模块为了抹平不同地图底图之间的差异，提供了一些兼容方法，如 setMeshScale 方法，通过这些方法用户可以在不同的底图
环境中使用同一套代码。

3、L7 提供的适配方法只负责 threejs 世界坐标到不同地图底图坐标的转化、 gl 上下文的共享以及渲染帧的同步，其余关于 3D 场景内容的搭建
与普通 threejs 应用的开发没有任何区别。

4、L7 本身并没有集成 threejs，所以用于在使用 L7Three 模块的时候需要独立安装 threejs。

✨ 目前 L7 官方提供的 threejs 兼容是根据 0.115.0 版本进行开发的，使用其他版本 threejs 可能会存在兼容问题

## 使用

```javascript
// 1、引入对应模块
import { ThreeLayer, ThreeRender } from '@antv/l7-three';
import * as THREE from 'three';
...
// 2、注册服务
scene.registerRenderService(ThreeRender);
...
// 3、构建 threejs 图层对象并在其中添加 threejs 构建的网格对象
const threeJSLayer = new ThreeLayer({
  onAddMeshes: (threeScene: THREE.Scene, layer: ThreeLayer) => {
    threeScene.add(new THREE.AmbientLight(0xffffff));

    const sunlight = new THREE.DirectionalLight(0xffffff, 0.25);
    sunlight.position.set(0, 80000000, 100000000);
    sunlight.matrixWorldNeedsUpdate = true;
    threeScene.add(sunlight);

    let center = scene.getCenter();

    let cubeGeometry = new THREE.BoxBufferGeometry(10000, 10000, 10000);
    let cubeMaterial = new THREE.MeshNormalMaterial();
    let cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

    layer.setObjectLngLat(cube, [center.lng + 0.05, center.lat], 0);
    threeScene.add(cube);
  },
})
.source(data)
.animate(true);

// 4、添加 threejs 图层对象
scene.addLayer(threeJSLayer);

```

L7 将 threejs 的引用封装成一个特殊的图层对象，在使用上与其他的图层相同。

## 构造函数 new ThreeLayer

### onAddMeshes

该方法接受两个参数 threeScene: THREE.Scene, layer: ThreeLayer

- threeScene: 这是普通的 threejs 场景对象
- layer: 这是 L7 提供的 threeLayer 对象，上面挂载了 threejs 空间适配到地图空间所需要的方法

## ThreeLayer

用户新建的图层对象，同时也会在 onAddMesh 方法的第二个参数返回。

以下是挂载在 ThreeLayer 实例上的适配方法。

### getModelMatrix(lnglat, altitude, rotation, scale): Matrix

- lnglat: [number, number] 经纬度
- altitude: number = 0 相对高度
- rotation: [number, number, number] = [0, 0, 0] 旋转角度
- scale: [number, number, number] = [1, 1, 1] 缩放比例

用户可以通过该方法计算在对应经纬度点位、相对高度、旋转角度和缩放的模型矩阵
该方法的返回值是 THREE.Matrix4 类型的矩阵

### applyObjectLngLat(object, lnglat, altibute): void

- object: Object3D threejs 对象
- lnglat: ILngLat[number, number] 经纬度
- altitude = 0 相对高度

用户可以通过该方法将 object 对象从当前位置向指定位置移动（地图经纬度坐标）

### setObjectLngLat(object, lnglat, altibute): void

- object: Object3D threejs 对象
- lnglat: ILngLat[number, number] 经纬度
- altitude = 0 相对高度

用户可以通过该方法设置 object 对象的位置（地图经纬度坐标）

### lnglatToCoord(lnglat): [number, number]

- lnglat: ILngLat[number, number] 经纬度

用户可以通过该方法将经纬度坐标转化成 threejs 世界坐标

### adjustMeshToMap(object): void

- object: Object3D threejs 对象

用户在添加 threejs 对象的前可以通过该方法调整 3D 对象的姿态，保证添加对象能正确显示

✨ 在 threejs 世界坐标中，默认的上方向为 Y 轴正方向，而在地图坐标中，默认的上方向为 Z 轴正方向

✨ 用户不一定使用该方法调整物体的姿态，也可以自己实现

### setMeshScale(object, x, y, z): void

- object: Object3D threejs 对象
- x: number = 1 x 轴方向的缩放比例
- y: number = 1 y 轴方向的缩放比例
- z: number = 1 z 轴方向的缩放比例

用户可以通过该方法设置 threejs 对象缩放

✨ 其实通过设置 threejs 对象的 scale 属性一样能达到同样的效果，但是由于 mapbox 在计算模型矩阵的时候引入了特殊计算，所以无法直接设置 scale 属性进行缩放

✨ 同样的，可以直接修改 threejs 的 position、rotation 等调整 3D 对象的姿态

### addAnimateMixer(mixer): void

- mixer: AnimationMixer threejs 的动画混合器

用户通过该方法管理加载模型的动画

### getRenderCamera(): THREE.Camera

返回根据当前地图场景参数下对应的 THREEJS 相机

## 加载模型

用户可以使用 threejs 提供的能力加载其支持的任意模型

### 简单案例

✨ 以加载 gltf 模型为例

```javascript
// 1、引入加载器
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
...
const threeJSLayer = new ThreeLayer({
  onAddMeshes: (threeScene: THREE.Scene, layer: ThreeLayer) => {
    ...
    // 2、构建加载器
    const loader = new GLTFLoader();
    // 3、加载模型
    loader.load('https://gw.alipayobjects.com/os/bmw-prod/3ca0a546-92d8-4ba0-a89c-017c218d5bea.gltf',
    (gltf) => {
      const model = gltf.scene;
      layer.adjustMeshToMap(model);
      layer.setMeshScale(model, 1000, 1000, 1000);
      layer.setObjectLngLat( model, [center.lng, center.lat], 0 );

      // 4、播放模型上绑定的动画
      const animations = gltf.animations;
      if (animations && animations.length) {
        const mixer = new THREE.AnimationMixer(model);
        const animation = animations[2];
        const action = mixer.clipAction(animation);
        action.play();
        // 5、由 L7 控制模型动画的播放
        layer.addAnimateMixer(mixer);
      }
    })
  }
}).source(data)
.animate(true) // 若需要播放模型动画，请开启动画模式（或者场景中已经存在开启动画的图层）

```
---
title: threejs 引擎兼容
order: 3
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

1\. L7 supports allowing users to access third-party rendering engines to develop map scenes. Threejs is currently the most widely used general-purpose 3D rendering engine. L7 can meet the requirements after integrating it.
User-defined development needs allow L7 to cover more application scenarios.

2\. Currently, in order to smooth out the differences between different map basemaps, the L7Three module provides some compatibility methods, such as the setMeshScale method. Through these methods, users can
environment using the same set of code.

3\. The adaptation method provided by L7 is only responsible for the conversion of threejs world coordinates to different map basemap coordinates, the sharing of gl context and the synchronization of rendering frames. The rest is related to the construction of 3D scene content.
There is no difference from the development of ordinary threejs applications.

4\. L7 itself does not integrate threejs, so you need to install threejs independently when using the L7Three module.

✨ Currently, the threejs compatibility officially provided by L7 is developed based on version 0.115.0. There may be compatibility issues when using other versions of threejs.

## use

```javascript
// 1. Introduce the corresponding module
import { ThreeLayer, ThreeRender } from '@antv/l7-three';
import * as THREE from 'three';
...
// 2. Registration service
scene.registerRenderService(ThreeRender);
...
// 3. Build the threejs layer object and add the grid object built by threejs to it.
const threeJSLayer = new ThreeLayer({
  onAddMeshes: (threeScene: THREE.Scene, layer: ThreeLayer) => {
    threeScene.add(new THREE.AmbientLight(0xffffff));

    const sunlight = new THREE.DirectionalLight(0xffffff, 0.25);
    sunlight.position.set(0, 80000000, 100000000);
    sunlight.matrixWorldNeedsUpdate = true;
    threeScene.add(sunlight);

    let center = scene.getCenter();

    let cubeGeometry = new THREE.BoxBufferGeometry(10000, 10000, 10000);
    let cubeMaterial = new THREE.MeshNormalMaterial();
    let cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

    layer.setObjectLngLat(cube, [center.lng + 0.05, center.lat], 0);
    threeScene.add(cube);
  },
})
.source(data)
.animate(true);

// 4. Add threejs layer object
scene.addLayer(threeJSLayer);
```

L7 encapsulates the reference of threejs into a special layer object, which is used the same as other layers.

## Constructor new ThreeLayer

### onAddMeshes

This method accepts two parameters threeScene: THREE.Scene, layer: ThreeLayer

* threeScene: This is a normal threejs scene object
* layer: This is the threeLayer object provided by L7, which mounts the methods needed to adapt the threejs space to the map space.

## ThreeLayer

The layer object created by the user will also be returned in the second parameter of the onAddMesh method.

The following is the adaptation method mounted on the ThreeLayer instance.

### getModelMatrix(lnglat, altitude, rotation, scale): Matrix

* lnglat: \[number, number] latitude and longitude
* altitude: number = 0 relative altitude
* rotation: \[number, number, number] = \[0, 0, 0] rotation angle
* scale: \[number, number, number] = \[1, 1, 1] scaling

Users can use this method to calculate the model matrix at the corresponding longitude and latitude point, relative height, rotation angle and scaling.
The return value of this method is a matrix of type THREE.Matrix4

### applyObjectLngLat(object, lnglat, altibute): void

* object: Object3D threejs object
* lnglat: ILngLat\[number, number] latitude and longitude
* altitude = 0 relative altitude

The user can use this method to move the object object from the current location to the specified location (map longitude and latitude coordinates)

### setObjectLngLat(object, lnglat, altibute): void

* object: Object3D threejs object
* lnglat: ILngLat\[number, number] latitude and longitude
* altitude = 0 relative altitude

The user can set the location of the object object (map longitude and latitude coordinates) through this method

### lnglatToCoord(lnglat): \[number, number]

* lnglat: ILngLat\[number, number] latitude and longitude

Users can use this method to convert latitude and longitude coordinates into threejs world coordinates

### adjustMeshToMap(object): void

* object: Object3D threejs object

Users can use this method to adjust the posture of the 3D object before adding the threejs object to ensure that the added object can be displayed correctly.

✨ In threejs world coordinates, the default upward direction is the positive Y-axis direction, while in map coordinates, the default upward direction is the positive Z-axis direction.

✨ Users do not necessarily use this method to adjust the posture of objects, they can also implement it themselves

### setMeshScale(object, x, y, z): void

* object: Object3D threejs object
* x: number = 1 Scaling ratio in x-axis direction
* y: number = 1 Scaling ratio in the y-axis direction
* z: number = 1 Scaling ratio in z-axis direction

Users can set the threejs object zoom through this method

✨ In fact, the same effect can be achieved by setting the scale attribute of the threejs object. However, because mapbox introduces special calculations when calculating the model matrix, it cannot directly set the scale attribute for scaling.

✨ Similarly, you can directly modify the position, rotation, etc. of threejs to adjust the posture of the 3D object.

### addAnimateMixer(mixer): void

* mixer: AnimationMixer animation mixer for threejs

The user manages the animation of loading the model through this method.

### getRenderCamera(): THREE.Camera

Returns the corresponding THREEJS camera based on the current map scene parameters.

## Load model

Users can use the capabilities provided by threejs to load any model it supports.

### Simple case

✨ Take loading gltf model as an example

```javascript
// 1. Introduce loader
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
...
const threeJSLayer = new ThreeLayer({
  onAddMeshes: (threeScene: THREE.Scene, layer: ThreeLayer) => {
    ...
    // 2. Build the loader
    const loader = new GLTFLoader();
    // 3. Load model
    loader.load('https://gw.alipayobjects.com/os/bmw-prod/3ca0a546-92d8-4ba0-a89c-017c218d5bea.gltf',
    (gltf) => {
      const model = gltf.scene;
      layer.adjustMeshToMap(model);
      layer.setMeshScale(model, 1000, 1000, 1000);
      layer.setObjectLngLat( model, [center.lng, center.lat], 0 );

      // 4. Play the animation bound to the model
      const animations = gltf.animations;
      if (animations && animations.length) {
        const mixer = new THREE.AnimationMixer(model);
        const animation = animations[2];
        const action = mixer.clipAction(animation);
        action.play();
        // 5. L7 controls the playback of model animation
        layer.addAnimateMixer(mixer);
      }
    })
  }
}).source(data)
.animate(true) // If you need to play model animation, please turn on the animation mode (or there is already a layer with animation turned on in the scene)
```
---
title: 风场图层
order: 7
---

`WindLayer` 用于将存储风场信息的图片，设置其风速线采样相关参数，将采样后的风场线的走向、强度通过可视化的方式在地图上呈现出来。

## 使用

```jsx
import { WindLayer } from '@antv/l7';
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*ADr-SIxhM9AAAAAAAAAAAAAAARQnAQ' />

### source

(data, options) => WindLayer, 设置风场相关信息的函数

- data: string 存储风场信息的图片地址
  🌟 [数据获取](https://github.com/mapbox/webgl-wind#downloading-weather-data)
- options:

```js
{
  parser: {
    type: 'image',
      extent: [-180, -85, 180, 85],  // 用于设置风场图片作用到地图上的经纬图区间
  },
}
```

### animate

开启动画效果。

```javascript
layer.animate(true);
```

### style

- `uMin`: 风速 `X` 轴/横向最小值。
- `uMax`: 风速 `X` 轴/横向最大值。
- `vMin`: 风速 `Y` 轴/纵向最小值。
- `vMax`: 风速 `Y` 轴/纵向最大值。
- `sizeScale`: 风场线条粗细缩放比，`0 - 2`。
- `fadeOpacity`: 线条透明度，`0 - 1`。
- `numParticles`: 线条数量。
- `rampColors`: 线条填充颜色映射。

```js
const rampColors = {
  colors: [
    '#3288bd',
    '#66c2a5',
    '#abdda4',
    '#e6f598',
    '#fee08b',
    '#fdae61',
    '#f46d43',
    '#d53e4f',
  ],
  positions: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 1.0],
};
```

#### rampColors

- colors  颜色数组
- positions 数据区间

配置值域映射颜色的色带，值域的范围为 `[0 - 1]`, 对应的我们需要为每一个 `position` 位置设置一个颜色值。

⚠️ colors, positions 的长度要相同

```javascript
layer.style({
  rampColors: {
    colors: ['#FF4818', '#F7B74A', '#FFF598', '#91EABC', '#2EA9A1', '#206C7C'],
    positions: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
  },
});
```

[在线案例](/examples/wind/basic#wind)
---
title: 风场图层
order: 7
---

`WindLayer`It is used to store pictures of wind field information, set parameters related to wind speed line sampling, and present the direction and intensity of the sampled wind field lines on the map in a visual way.

## use

```jsx
import { WindLayer } from '@antv/l7';
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*ADr-SIxhM9AAAAAAAAAAAAAAARQnAQ' />

### source

(data, options) => WindLayer, function to set wind field related information

* data: string image address to store wind farm information
  🌟[data collection](https://github.com/mapbox/webgl-wind#downloading-weather-data)
* options:

```js
{
  parser: {
    type: 'image',
      extent: [-180, -85, 180, 85], // Used to set the latitude and longitude chart interval where the wind field image is applied to the map
  },
}
```

### animate

Turn on animation effects.

```javascript
layer.animate(true);
```

### style

* `uMin`: wind speed`X`Axial/lateral minimum.
* `uMax`: wind speed`X`Axis/lateral maximum.
* `vMin`: wind speed`Y`Axis/longitudinal minimum.
* `vMax`: wind speed`Y`Axis/longitudinal maximum.
* `sizeScale`: Wind field line thickness scaling ratio,`0 - 2`。
* `fadeOpacity`: line transparency,`0 - 1`。
* `numParticles`: Number of lines.
* `rampColors`: Line fill color mapping.

```js
const rampColors = {
  colors: [
    '#3288bd',
    '#66c2a5',
    '#abdda4',
    '#e6f598',
    '#fee08b',
    '#fdae61',
    '#f46d43',
    '#d53e4f',
  ],
  positions: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 1.0],
};
```

#### rampColors

* colors color array
* positions data interval

Configure the color band of the value range mapping color. The range of the value range is`[0 - 1]`, correspondingly we need to provide each`position`Position sets a color value.

⚠️ colors, positions must be the same length

```javascript
layer.style({
  rampColors: {
    colors: ['#FF4818', '#F7B74A', '#FFF598', '#91EABC', '#2EA9A1', '#206C7C'],
    positions: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
  },
});
```

[Online case](/examples/wind/basic#wind)
---
title: 简单坐标系（非地理坐标系）
order: 1
---

<embed src="@/docs/common/style.md"></embed>

我们通常使用经纬度来描述地理位置，但是在某些特殊的场景，我们往往倾向于使用更加简单的平面坐标系(xyz)来描述位置的相对坐标，为此 L7 提供了简单坐标系的模式。

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*HenKR5VsXX0AAAAAAAAAAAAAARQnAQ'>

[在线案例](/examples/point/text#simplecoordinate)

### Map

为了使用简单坐标系，我们需要是使用 L7 自定义的 Map 地图类型，同时制定 map 的 version 属性

```javascript
import { Scene, ImageLayer, PointLayer } from '@antv/l7';
import { Map } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new Map({
    center: [500, 500],
    pitch: 0,
    zoom: 3,
    version: 'SIMPLE',
    mapSize: 1000,
    maxZoom: 5,
    minZoom: 2,
    pitchEnabled: false,
    rotateEnabled: false,
  }),
});
```

#### version

用户在使用自定义坐标系的时候，需要将地图的类型设置成 'SIMPLE'

#### mapSize: number

用户在使用自定义坐标系的时候，可以设置绘图区域的大小。绘图区域默认是 10000 X 10000 的矩形区域，坐标起点是左下角，水平向右为 X 正方向，垂直向上是 Y 正方向。

<img width="50%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*qimkTLy0P6IAAAAAAAAAAAAAARQnAQ'>

#### pitchEnabled/rotateEnabled

用户在使用自定义坐标系的时候，推荐将 pitchEnabled/rotateEnabled 设置为 false

#### layer

用户在使用自定义坐标系的时候，可以正常使用普通的图层，唯一的区别就是需要将原本的经纬度坐标转化为平面坐标

```javascript
const imagelayer = new ImageLayer({}).source(
   'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*I0X5R4jAUQ4AAAAAAAAAAAAAARQnAQ',
   {
   parser: {
      type: 'image',
      extent: [360, 400, 640, 600],
   },
   },
);

const textlayer = new PointLayer({ zIndex: 2 })
.source(
  [
    {
      x: 515,
      y: 575,
      t: '小屋',
    },
    ...
  ],
  {
    parser: {
      type: 'json',
      x: 'x',
      y: 'y',
    },
  },
)
.shape('t', 'text')
.size(12)
.active({
  color: '#00f',
  mix: 0.9
})
.color('rgb(86, 156, 214)')
.style({
  textAnchor: 'center', // 文本相对锚点的位置 center|left|right|top|bottom|top-left
  spacing: 2, // 字符间距
  fontWeight: '800',
  padding: [1, 1], // 文本包围盒 padding [水平，垂直]，影响碰撞检测结果，避免相邻文本靠的太近
  stroke: '#ffffff', // 描边颜色
  strokeWidth: 2, // 描边宽度
  textAllowOverlap: true,
});

const lineData = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          properties: {
            testOpacity: 0.8,
          },
          geometry: {
            type: 'Polygon',
            coordinates: [
              [
                [6000, 6000],
                [6000, 7000],
                [7000, 7000],
                [7000, 6000],
              ],
            ],
          },
        },
      ],
    };

    const linelayer = new LineLayer()
      .source(lineData)
      .shape('line')
      .size(10)
      .color('#0f0')
      .active(true);


const polygonData = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          properties: {
            testOpacity: 0.4,
          },
          geometry: {
            type: 'MultiPolygon',
            coordinates: [
              [
                [
                  [6000, 6000],
                  [6000, 7000],
                  [7000, 7000],
                  [7000, 6000],
                  [6000, 6000],
                ],
                [
                  [6300, 6300],
                  [6300, 6700],
                  [6700, 6700],
                  [6700, 6300],
                  [6300, 6300],
                ],
              ],
              [
                [
                  [5000, 5000],
                  [5000, 6000],
                  [6000, 6000],
                  [6000, 5000],
                  [5000, 5000],
                ],
              ],
            ],
          },
        },
      ],
    };

    const polygonLayer = new PolygonLayer()
      .source(polygonData)
      .shape('fill')
      .color('#f00')
      .style({
        opacity: 0.6,
      })
      .active(true);
```
---
title: 简单坐标系（非地理坐标系）
order: 1
---

<embed src="@/docs/common/style.md"></embed>

We usually use longitude and latitude to describe geographical location, but in some special scenarios, we tend to use a simpler plane coordinate system (xyz) to describe the relative coordinates of a location. For this reason, L7 provides a simple coordinate system mode.

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*HenKR5VsXX0AAAAAAAAAAAAAARQnAQ'>

[Online case](/examples/point/text#simplecoordinate)

### Map

In order to use a simple coordinate system, we need to use the L7 custom Map map type and specify the version attribute of the map.

```javascript
import { Scene, ImageLayer, PointLayer } from '@antv/l7';
import { Map } from '@antv/l7-maps';

const scene = new Scene({
  id: 'map',
  map: new Map({
    center: [500, 500],
    pitch: 0,
    zoom: 3,
    version: 'SIMPLE',
    mapSize: 1000,
    maxZoom: 5,
    minZoom: 2,
    pitchEnabled: false,
    rotateEnabled: false,
  }),
});
```

#### version

When using a custom coordinate system, users need to set the map type to 'SIMPLE'

#### mapSize: number

When using a custom coordinate system, users can set the size of the drawing area. The default drawing area is a rectangular area of ​​10000

<img width="50%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*qimkTLy0P6IAAAAAAAAAAAAAARQnAQ'>

#### pitchEnabled/rotateEnabled

When users use a custom coordinate system, it is recommended to set pitchEnabled/rotateEnabled to false

#### layer

When users use a custom coordinate system, they can use ordinary layers normally. The only difference is that they need to convert the original longitude and latitude coordinates into plane coordinates.

```javascript
const imagelayer = new ImageLayer({}).source(
   'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*I0X5R4jAUQ4AAAAAAAAAAAAARQnAQ',
   {
   parser: {
      type: 'image',
      extent: [360, 400, 640, 600],
   },
   },
);

const textlayer = new PointLayer({ zIndex: 2 })
.source(
  [
    {
      x: 515,
      y: 575,
      t: 'hut',
    },
    ...
  ],
  {
    parser: {
      type: 'json',
      x: 'x',
      y: 'y',
    },
  },
)
.shape('t', 'text')
.size(12)
.active({
  color: '#00f',
  mix: 0.9
})
.color('rgb(86, 156, 214)')
.style({
  textAnchor: 'center', // The position of the text relative to the anchor point center|left|right|top|bottom|top-left
  spacing: 2, // character spacing
  fontWeight: '800',
  padding: [1, 1], // Text bounding box padding [horizontal, vertical], which affects the collision detection results and prevents adjacent texts from being too close.
  stroke: '#ffffff', // stroke color
  strokeWidth: 2, // Stroke width
  textAllowOverlap: true,
});

const lineData = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          properties: {
            testOpacity: 0.8,
          },
          geometry: {
            type: 'Polygon',
            coordinates: [
              [
                [6000, 6000],
                [6000, 7000],
                [7000, 7000],
                [7000, 6000],
              ],
            ],
          },
        },
      ],
    };

    const linelayer = new LineLayer()
      .source(lineData)
      .shape('line')
      .size(10)
      .color('#0f0')
      .active(true);


const polygonData = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          properties: {
            testOpacity: 0.4,
          },
          geometry: {
            type: 'MultiPolygon',
            coordinates: [
              [
                [
                  [6000, 6000],
                  [6000, 7000],
                  [7000, 7000],
                  [7000, 6000],
                  [6000, 6000],
                ],
                [
                  [6300, 6300],
                  [6300, 6700],
                  [6700, 6700],
                  [6700, 6300],
                  [6300, 6300],
                ],
              ],
              [
                [
                  [5000, 5000],
                  [5000, 6000],
                  [6000, 6000],
                  [6000, 5000],
                  [5000, 5000],
                ],
              ],
            ],
          },
        },
      ],
    };

    const polygonLayer = new PolygonLayer()
      .source(polygonData)
      .shape('fill')
      .color('#f00')
      .style({
        opacity: 0.6,
      })
      .active(true);
```
---
title: 后处理模块
order: 10
---

后处理（Post-Process Effect）是 3D 渲染常见的处理效果，是一种对渲染之后的画面进行再加工的技术，一般用于实现各种特效。L7 的后处理模块为用户提供了一些常见的后处理效果，同时也提供了标准规范，允许用户自定义后处理效果。

🌟 需要注意的是，使用后处理通常会产生额外的性能消耗，用户应该根据项目的实际情况合理使用后处理。

## 使用

```jsx
const layer = new LineLayer({
  enableMultiPassRenderer: true,
  passes: [
    [
      'bloom',
      {
        bloomBaseRadio: 0.8,
        bloomRadius: 2,
        bloomIntensity: 1
      }
    ]
  ]
}).source(data)
  .size('ELEV', h => [ h % 50 === 0 ? 1.0 : 0.5, (h - 1300) * 0.2 ])
  .shape('line')
  .scale('ELEV', {
    type: 'quantize'
  })
  .color('ELEV', [
    '#094D4A',
    ...
  ]);
scene.addLayer(layer);
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*PIXmQ6m1C10AAAAAAAAAAAAAARQnAQ' />

### 开启后处理

为了开启图层的后处理能力，我们需要在初始化图层的时候配置 enableMultiPassRenderer 为 true，同时传入该图层作用的处理效果配置。

```javascript
let pointLayer = new PointLayer({
  zIndex: 1,
  enableMultiPassRenderer: false,
  passes: [
    [
      'bloom',
      {
        bloomBaseRadio: 0.95,
        bloomRadius: 4,
        bloomIntensity: 1.1,
      },
    ],
  ],
});
```

- enableMultiPassRenderer 配置该图层是否开始后处理能力
- passes 后处理配置列表  
  🌟 passes 需要根据一定的规则配置

### 单图层后处理

传统的后处理渲染往往会对场景中所有的对象做统一的后处理，而许多时候我们只需要对场景中的一部分内容做后处理。L7 的后处理模块天然支持以图层为单位进行后处理，这使的用户对 L7 场景内容的处理有更高的自由度。

### update pass options

用户在初始化完图层对象之后，若想调整后处理效果的参数，可以直接使用 style 方法

```javascript
layer.style({
  passes: [
    [
      'colorHalftone',
      {
        // 更新 cenrter 的位置
        center: [newX, newY],
      },
    ],
  ],
});
scene.render();
```

### setMultiPass(enableMultiPassRenderer: boolean, passes?: pass[])

为了方便用户切换后处理的状态（开启、关闭后处理），我们为用户提供了专门的方法

```javascript
// 当前图层存在 multiPass，我们需要关闭时
// 直接关闭
layer.setMultiPass(false);
// 关闭的同时清除 passes
layer.setMultiPass(false, []);

// 当前图层不存在 multiPass，我们需要开启时
// 图层初始化时已经传入 passes
const layer = new PolygonLayer({
  zIndex: 0,
  enableMultiPassRenderer: false,
  passes: [
    [
      'bloom',
      {
        bloomBaseRadio: 0.5,
        bloomRadius: 20,
        bloomIntensity: 1,
      },
    ],
  ],
});
layer.setMultiPass(true);

// 图层初始化时没有传入 passes
layer.setMultiPass(true, [
  [
    'bloom',
    {
      bloomRadius: 10,
      bloomIntensity: 1,
    },
  ],
]);
```

### 后处理链路

passes 可以传入多种后处理，普通渲染的结果是第一个后处理的输入，前一种后处理的输出是后一个后处理的输入，最后的结果输出到屏幕。

### 预制的后处理

L7 的后处理模块预置了几种后处理效果，因此用户可以直接在 passes 中配置使用。

#### bloom

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*I3FCSo-gZR4AAAAAAAAAAAAAARQnAQ' />

```javascript
const bloomPass = [
  'bloom',
  {
    bloomBaseRadio: 0.5,
    bloomRadius: 20,
    bloomIntensity: 1,
  },
];
```

辉光后处理

- bloomBaseRadio  
  设置保持图形原本样式的比例，值在 0 - 1 之间，值为 1 时完全保存本身的样式
- bloomRadius
  设置 bloom 的半径，值越大，bloom 范围越大
- bloomIntensity
  设置 bloom 的强度，值越大，辉光越强

#### blurV/blurH

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*NrNGSIQuZ4oAAAAAAAAAAAAAARQnAQ' />

垂直方向模糊/水平方向模糊

```javascript
const blurVPass = [
  'blurV',
  {
    blurRadius: 5,
  },
];
const blurHPass = [
  'blurH',
  {
    blurRadius: 5,
  },
];
```

- blurRadius
  设置模糊半径

#### colorHalftone

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*QstwSr4dj20AAAAAAAAAAAAAARQnAQ' />

colorHalftone

```javascript
const colorHalftonePass = [
  'colorHalftone',
  {
    angle: 0,
    size: 8,
    centerX: 0.5,
    centerY: 0.5,
  },
];
```

- angle
  设置角度
- size
  设置大小
- centerX
  设置中心点 X
- centerY
  设置中心点 Y

#### hexagonalPixelate

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*IQOMQrbDQ5IAAAAAAAAAAAAAARQnAQ' />

六边形像素

```javascript
const hexagonalPixelatePass = [
  'hexagonalPixelate',
  {
    scale: 10,
    centerX: 0.5,
    centerY: 0.5,
  },
];
```

- scale
  设置缩放
- centerX
  设置中心点 X
- centerY
  设置中心点 Y

#### ink

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*IpogQbe-5K4AAAAAAAAAAAAAARQnAQ' />

ink

```javascript
const inkPass = [
  'ink',
  {
    strength: 1,
  },
];
```

- strength
  设置强度

#### noise

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*6lcVS7YFrvUAAAAAAAAAAAAAARQnAQ' />

噪声

```javascript
const noisePass = [
  'noise',
  {
    amount: 1,
  },
];
```

- amount
  设置噪点数量

### 自定义后处理

用户通过 L7 定义的标准可以轻松的自定义后处理效果。

```javascript
import { BasePostProcessingPass, PolygonLayer, Scene } from '@antv/l7';

interface IDotScreenEffectConfig {
  center: [number, number]; // pattern 圆心
  angle: number; // dot 旋转角度
  size: number; // dot 尺寸
}

class DotScreenEffect extends BasePostProcessingPass<IDotScreenEffectConfig> {
  protected setupShaders() {
    this.shaderModuleService.registerModule('dotScreenEffect', {
      vs: this.quad,
      fs: `
      varying vec2 v_UV;

      uniform sampler2D u_Texture;
      uniform vec2 u_ViewportSize : [1.0, 1.0];
      uniform vec2 u_Center : [0.5, 0.5];
      uniform float u_Angle : 1;
      uniform float u_Size : 3;

      float pattern(vec2 texSize, vec2 texCoord) {
        float scale = 3.1415 / u_Size;
        float s = sin(u_Angle), c = cos(u_Angle);
        vec2 tex = texCoord * texSize - u_Center * texSize;
        vec2 point = vec2(
          c * tex.x - s * tex.y,
          s * tex.x + c * tex.y
        ) * scale;
        return (sin(point.x) * sin(point.y)) * 4.0;
      }
      vec4 dotScreen_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
        float average = (color.r + color.g + color.b) / 3.0;
        return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);
      }

      void main() {
        gl_FragColor = vec4(texture2D(u_Texture, v_UV));
        gl_FragColor = dotScreen_filterColor(gl_FragColor, u_ViewportSize, v_UV);
      }
      `,
    });
    const { vs, fs, uniforms } = this.shaderModuleService.getModule('dotScreenEffect');
    const { width, height } = this.rendererService.getViewportSize();
    return {
      vs,
      fs,
      uniforms: {
        ...uniforms,
        u_ViewportSize: [width, height],
      },
    };
  }
}

// 注册自定义后处理效果
scene.registerPostProcessingPass(DotScreenEffect, 'dotScreenEffect');
const layer = new PolygonLayer({
  enableMultiPassRenderer: true,
  passes: [
    [
      'dotScreenEffect',
      {
        size: 8,
        angle: 1,
      },
    ],
  ],
});
```
---
title: 后处理模块
order: 10
---

Post-Process Effect is a common processing effect in 3D rendering. It is a technology for reprocessing the rendered images and is generally used to achieve various special effects. L7's post-processing module provides users with some common post-processing effects, and also provides standard specifications to allow users to customize post-processing effects.

🌟 It should be noted that using post-processing usually results in additional performance consumption. Users should use post-processing reasonably according to the actual situation of the project.

## use

```jsx
const layer = new LineLayer({
  enableMultiPassRenderer: true,
  passes: [
    [
      'bloom',
      {
        bloomBaseRadio: 0.8,
        bloomRadius: 2,
        bloomIntensity: 1
      }
    ]
  ]
}).source(data)
  .size('ELEV', h => [ h % 50 === 0 ? 1.0 : 0.5, (h - 1300) * 0.2 ])
  .shape('line')
  .scale('ELEV', {
    type: 'quantize'
  })
  .color('ELEV', [
    '#094D4A',
    ...
  ]);
scene.addLayer(layer);
```

<img width="60%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*PIXmQ6m1C10AAAAAAAAAAAAAARQnAQ' />

### Turn on post-processing

In order to enable the post-processing capability of the layer, we need to configure enableMultiPassRenderer to true when initializing the layer, and also pass in the processing effect configuration of the layer.

```javascript
let pointLayer = new PointLayer({
  zIndex: 1,
  enableMultiPassRenderer: false,
  passes: [
    [
      'bloom',
      {
        bloomBaseRadio: 0.95,
        bloomRadius: 4,
        bloomIntensity: 1.1,
      },
    ],
  ],
});
```

* enableMultiPassRenderer configures whether the layer starts post-processing capabilities
* passes post-processing configuration list\
  🌟 passes need to be configured according to certain rules

### Single layer post-processing

Traditional post-processing rendering often performs unified post-processing on all objects in the scene, but many times we only need to post-process a part of the scene. L7’s post-processing module naturally supports post-processing on a layer-by-layer basis, which gives users a higher degree of freedom in processing L7 scene content.

### update pass options

After the user initializes the layer object, if he wants to adjust the parameters of the post-processing effect, he can directly use the style method.

```javascript
layer.style({ passes: [ [ 'color Halftone', { // Update the position of center center: [newX, newY], }, ], ],
});
scene.render();
```

### setMultiPass(enableMultiPassRenderer: boolean, passes?: pass\[])

In order to facilitate users to switch the state of post-processing (on or off post-processing), we provide users with a special method

```javascript
// MultiPass exists in the current layer and we need to close it
//Close directly
layer.setMultiPass(false);
// Clear passes while closing
layer.setMultiPass(false, []);

// MultiPass does not exist in the current layer, when we need to enable it
// passes have been passed in during layer initialization
const layer = new PolygonLayer({
  zIndex: 0,
  enableMultiPassRenderer: false,
  passes: [
    [
      'bloom',
      {
        bloomBaseRadio: 0.5,
        bloomRadius: 20,
        bloomIntensity: 1,
      },
    ],
  ],
});
layer.setMultiPass(true);

// No passes are passed in when initializing the layer
layer.setMultiPass(true, [
  [
    'bloom',
    {
      bloomRadius: 10,
      bloomIntensity: 1,
    },
  ],
]);
```

### Post-processing link

passes can pass in a variety of post-processing. The result of ordinary rendering is the input of the first post-processing, the output of the previous post-processing is the input of the next post-processing, and the final result is output to the screen.

### Prefabricated post-processing

L7's post-processing module presets several post-processing effects, so users can configure and use them directly in passes.

#### bloom

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*I3FCSo-gZR4AAAAAAAAAAAAAARQnAQ' />

```javascript
const bloomPass = [
  'bloom',
  {
    bloomBaseRadio: 0.5,
    bloomRadius: 20,
    bloomIntensity: 1,
  },
];
```

Glow post-processing

* bloomBaseRadio\
  Set the proportion that maintains the original style of the graphic. The value is between 0 and 1. When the value is 1, the original style is completely preserved.
* bloomRadius
  Set the radius of bloom. The larger the value, the larger the bloom range.
* bloomIntensity
  Set the intensity of bloom. The larger the value, the stronger the glow.

#### blurv

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*NrNGSIQuZ4oAAAAAAAAAAAAAARQnAQ' />

Vertical Blur/Horizontal Blur

```javascript
const blurVPass = [
  'blurV',
  {
    blurRadius: 5,
  },
];
const blurHPass = [
  'blurH',
  {
    blurRadius: 5,
  },
];
```

* blurRadius
  Set blur radius

#### colorHalftone

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*QstwSr4dj20AAAAAAAAAAAAAARQnAQ' />

colorHalftone

```javascript
const colorHalftonePass = [
  'colorHalftone',
  {
    angle: 0,
    size: 8,
    centerX: 0.5,
    centerY: 0.5,
  },
];
```

* angle
  Set angle
* size
  Set size
* centerX
  Set center point X
* centerY
  Set center point Y

#### hexagonalPixelate

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*IQOMQrbDQ5IAAAAAAAAAAAAAARQnAQ' />

hexagonal pixels

```javascript
const hexagonalPixelatePass = [
  'hexagonalPixelate',
  {
    scale: 10,
    centerX: 0.5,
    centerY: 0.5,
  },
];
```

* scale
  Set zoom
* centerX
  Set center point X
* centerY
  Set center point Y

#### ink

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*IpogQbe-5K4AAAAAAAAAAAAAARQnAQ' />

ink

```javascript
const inkPass = [
  'ink',
  {
    strength: 1,
  },
];
```

* strength
  Set intensity

#### noise

<img width="40%" style="display: block;margin: 0 auto;" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*6lcVS7YFrvUAAAAAAAAAAAAAARQnAQ' />

noise

```javascript
const noisePass = [
  'noise',
  {
    amount: 1,
  },
];
```

* amount
  Set the amount of noise

### Custom post-processing

Users can easily customize post-processing effects through L7-defined standards.

```javascript
import { BasePostProcessingPass, PolygonLayer, Scene } from '@antv/l7';

interface IDotScreenEffectConfig {
  center: [number, number]; // pattern 圆心
  angle: number; // dot 旋转角度
  size: number; // dot 尺寸
}

class DotScreenEffect extends BasePostProcessingPass<IDotScreenEffectConfig> {
  protected setupShaders() {
    this.shaderModuleService.registerModule('dotScreenEffect', {
      vs: this.quad,
      fs: `
      varying vec2 v_UV;

      uniform sampler2D u_Texture;
      uniform vec2 u_ViewportSize : [1.0, 1.0];
      uniform vec2 u_Center : [0.5, 0.5];
      uniform float u_Angle : 1;
      uniform float u_Size : 3;

      float pattern(vec2 texSize, vec2 texCoord) {
        float scale = 3.1415 / u_Size;
        float s = sin(u_Angle), c = cos(u_Angle);
        vec2 tex = texCoord * texSize - u_Center * texSize;
        vec2 point = vec2(
          c * tex.x - s * tex.y,
          s * tex.x + c * tex.y
        ) * scale;
        return (sin(point.x) * sin(point.y)) * 4.0;
      }
      vec4 dotScreen_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
        float average = (color.r + color.g + color.b) / 3.0;
        return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);
      }

      void main() {
        gl_FragColor = vec4(texture2D(u_Texture, v_UV));
        gl_FragColor = dotScreen_filterColor(gl_FragColor, u_ViewportSize, v_UV);
      }
      `,
    });
    const { vs, fs, uniforms } = this.shaderModuleService.getModule('dotScreenEffect');
    const { width, height } = this.rendererService.getViewportSize();
    return {
      vs,
      fs,
      uniforms: {
        ...uniforms,
        u_ViewportSize: [width, height],
      },
    };
  }
}

// 注册自定义后处理效果
scene.registerPostProcessingPass(DotScreenEffect, 'dotScreenEffect');
const layer = new PolygonLayer({
  enableMultiPassRenderer: true,
  passes: [
    [
      'dotScreenEffect',
      {
        size: 8,
        angle: 1,
      },
    ],
  ],
});
```
---
title: Style
order: 4
---

<embed src="@/docs/common/style.md"></embed>

`imagelayer` 的 `style` 参数只支持 `opacity`。

| style   | 类型     | 描述         | 默认值 |
| ------- | -------- | ------------ | ------ |
| opacity | `number` | 图形的透明度 | `1`    |
---
title: Style
order: 4
---

<embed src="@/docs/common/style.md"></embed>

`imagelayer`of`style`Parameters only support`opacity`。

| style   | type     | describe             | default value |
| ------- | -------- | -------------------- | ------------- |
| opacity | `number` | Graphic transparency | `1`           |
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/options.zh.md"></embed>
---
title: Source
order: 2
---

<embed src="@/docs/common/style.md"></embed>

`imagelayer` 通过提供在线图片的 `url` 指定数据，通过 `extent` 指定图片在地图上的位置。

```js
layer.source(
  'https://gw.alipayobjects.com/zos/rmsportal/FnHFeFklTzKDdUESRNDv.jpg',
  {
    parser: {
      type: 'image',
      extent: [121.168, 30.2828, 121.384, 30.4219],
    },
  },
);
```
---
title: Source
order: 2
---

<embed src="@/docs/common/style.md"></embed>

`imagelayer`By providing online pictures`url`Specify data via`extent`Specify the image's location on the map.

```js
layer.source(
  'https://gw.alipayobjects.com/zos/rmsportal/FnHFeFklTzKDdUESRNDv.jpg',
  {
    parser: {
      type: 'image',
      extent: [121.168, 30.2828, 121.384, 30.4219],
    },
  },
);
```
---
title: Options
order: 1
---

<embed src="@/docs/common/style.md"></embed>

<embed src="@/docs/common/layer/options.zh.md"></embed>
---
title: ImageLayer
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

When adding a picture to the map, you need to specify the latitude and longitude range of the picture and the data parsing type.

<div>
  <div style="width:40%; margin: 16px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*8MtWSIGTN8UAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

```javascript
const layer = new ImageLayer({});
layer.source(
  'https://gw.alipayobjects.com/zos/rmsportal/FnHFeFklTzKDdUESRNDv.jpg',
  {
    parser: {
      type: 'image',
      extent: [121.168, 30.2828, 121.384, 30.4219],
    },
  },
);
```
---
title: ImageLayer
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## 简介

将图片添加到地图上，同时需要指定图片的经纬度范围和数据解析类型。

<div>
  <div style="width:40%; margin: 16px;">
    <img  width="80%" alt="案例" src='https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*8MtWSIGTN8UAAAAAAAAAAAAAARQnAQ'>
  </div>
</div>

```javascript
const layer = new ImageLayer({});
layer.source(
  'https://gw.alipayobjects.com/zos/rmsportal/FnHFeFklTzKDdUESRNDv.jpg',
  {
    parser: {
      type: 'image',
      extent: [121.168, 30.2828, 121.384, 30.4219],
    },
  },
);
```
---
title: DebugService
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## 简介

L7 在通过 debugService 的形式对外提供调试服务，通过 debugService 用户可以获得一些有助于性能监控的信息。

### serEnable(enable: boolean)

用户可以通过 scene 初始化的时候和 debugService 提供的方法来开启监控。

```js
// 可以在 scene 初始化的时候打开监控
const scene = new Scene({
  debug: true, // 默认为 false
});

// 可以通过 debugService 单独控制监控
const debugService = scene.getDebugService();
debugService.serEnable(true); // 开启监控
```

### getLog(field: undefined | string | string[]): ILog[] | ILog | undefined

用户通过 getLog 方法获取日志，通过传入不通的参数，用户可以准确获得自己需要的日志内容。

```js
// 获取地图初始化日志
debugService.getLog('map'); // map 为固定值

// 在获取图层的创建日志时，为了获取到全部的数据，需要在 layer 创建完成之后获取
layer.on('inited', () => {
  debugService.getLog(layer.id); // 获取单个图层创建日志
});

layerAllLoad([pointLayer1, pointLayer2], () => {
  // layerAllLoad 自己实现监听
  debugService.getLog([pointLayer1.id, pointLayer2.id]); // 获取多个图层创建日志
});

// 获取所有日志
debugService.getLog();
```

- 通过 getLog 方法可以获得如下的日志信息

```js
const enum IDebugLog {
  MapInitStart = 'mapInitStart', 			// 地图初始化时间

  LayerInitStart = 'layerInitStart',	// 图层初始化开始时间
  LayerInitEnd = 'layerInitEnd',			// 图层初始化结束时间

  SourceInitStart = 'sourceInitStart',// souce 初始化开始时间
  SourceInitEnd = 'sourceInitEnd',		// souce 初始化结束时间

  // scale：将数据进行 scale 映射处理 => 将数据从定义域转化到值域
  // 如： layer.size('v', [1, 10]);
  //  		根据字段 v 表示的定义域将 size 的结果映射到 1 ～ 10 之间
  ScaleInitStart = 'scaleInitStart',	// scale 初始化开始时间
  ScaleInitEnd = 'scaleInitEnd',			// scale 初始化结束时间

  // mapping：构建渲染数据
  MappingStart = 'mappingStart',			// mapping 初始化开始时间
  MappingEnd = 'mappingEnd',					// mapping 初始化结束时间

  // build model：构建渲染使用的程序对象、构建网格、纹理等
  BuildModelStart = 'buildModelStart',// souce 初始化开始时间
  BuildModelEnd = 'buildModelEnd',		// souce 初始化结束时间
}
```

### renderDebug(enable: boolean)

debugService 提供了监听图层渲染时间的便捷方法, 通过 renderDebug 开启。

### on(name: string, options: any)

debugService 支持事件监听，常用与监听渲染。

```js
debugService.on('renderEnd', renderInfo => {
  const {
    renderUid,			// 当前帧渲染唯一编号
    renderStart,		// 当前帧渲染开始时间
    renderEnd,			// 当前帧渲染结束时间
    renderDuration	// 当前帧渲染时间
  } = renderInfo;
  ...
}
```

### off(name: string, func: Function)

debugService 事件取消监听。
---
title: DebugService
order: 0
---

<embed src="@/docs/common/style.md"></embed>

## Introduction

L7 provides external debugging services in the form of debugService. Through debugService, users can obtain some information that is helpful for performance monitoring.

### serEnable(enable: boolean)

Users can enable monitoring through the methods provided by debugService during scene initialization.

```js
// Monitoring can be turned on during scene initialization
const scene = new Scene({
  debug: true, //default is false
});

// Monitoring can be controlled individually through debugService
const debugService = scene.getDebugService();
debugService.serEnable(true); // Enable monitoring
```

### getLog(field: undefined | string | string\[]): ILog\[] | Log | undefined

Users obtain logs through the getLog method. By passing in different parameters, users can accurately obtain the log content they need.

```js
// Get map initialization log
debugService.getLog('map'); // map is a fixed value

// When obtaining the creation log of the layer, in order to obtain all the data, it needs to be obtained after the layer creation is completed.
layer.on('initiated', () => {
  debugService.getLog(layer.id); // Get a single layer creation log
});

layerAllLoad([pointLayer1, pointLayer2], () => {
  // layerAllLoad implements monitoring by itself
  debugService.getLog([pointLayer1.id, pointLayer2.id]); // Get multiple layer creation logs
});

// Get all logs
debugService.getLog();
```

* The following log information can be obtained through the getLog method

```js
const enum IDebugLog {
  MapInitStart = 'mapInitStart', // Map initialization time

  LayerInitStart = 'layerInitStart', //Layer initialization start time
  LayerInitEnd = 'layerInitEnd', //Layer initialization end time

  SourceInitStart = 'sourceInitStart', // source initialization start time
  SourceInitEnd = 'sourceInitEnd', // souce initialization end time

  // scale: perform scale mapping on the data => convert the data from the definition domain to the value domain
  // Such as: layer.size('v', [1, 10]);
  //Map the result of size to between 1 and 10 according to the domain represented by field v
  ScaleInitStart = 'scaleInitStart', // scale initialization start time
  ScaleInitEnd = 'scaleInitEnd', // scale initialization end time

  //mapping: construct rendering data
  MappingStart = 'mappingStart', // mapping initialization start time
  MappingEnd = 'mappingEnd', // mapping initialization end time

  // build model: build program objects used for rendering, build meshes, textures, etc.
  BuildModelStart = 'buildModelStart',// souce initialization start time
  BuildModelEnd = 'buildModelEnd', // souce initialization end time
}
```

### renderDebug(enable: boolean)

debugService provides a convenient method to monitor the rendering time of a layer, which is enabled through renderDebug.

### on(name: string, options: any)

debugService supports event monitoring and is commonly used to monitor rendering.

```js
debugService.on('renderEnd', renderInfo => {
  const {
    renderUid, // The unique number of the current frame rendering
    renderStart, // current frame rendering start time
    renderEnd, // current frame rendering end time
    renderDuration // current frame rendering time
  } = renderInfo;
  ...
}
```

### off(name: string, func: Function)

debugService event cancels listening.
