"use strict";(self.webpackChunk_antv_l7_site=self.webpackChunk_antv_l7_site||[]).push([[7833],{98437:function(n,e,r){r.r(e);r(35164),r(43801),r(6974),r(27068),r(33574);var t=r(7808),d=(r(19480),r(97595),r(22593),r(99500)),a=r(13273),c=r(92379),o=r(2675),i=r(651);e.default=function(){return(0,i.jsx)(d.dY,{children:(0,i.jsx)(c.Suspense,{fallback:(0,i.jsx)(a.Z,{}),children:(0,i.jsx)(i.Fragment,{children:(0,i.jsxs)("div",{className:"markdown",children:[(0,i.jsx)("style",{dangerouslySetInnerHTML:{__html:"\n h3 { color: #873bf4; border-bottom: 1px solid #f0f0f0; margin: 1.2em 0 0.4em; } p { margin: 0.6em 0; } h4 { border-bottom: 1px solid #f0f0f0; }h4::before { content: '> '; opacity: 0.5; } "}}),(0,i.jsx)("p",{children:o.texts[0].value}),(0,i.jsxs)("h3",{id:"实现",children:[(0,i.jsx)("a",{"aria-hidden":"true",tabIndex:"-1",href:"#实现",children:(0,i.jsx)("span",{className:"icon icon-link"})}),"实现"]}),(0,i.jsx)("p",{children:o.texts[1].value}),(0,i.jsx)(t.Z,{lang:"javascript",children:o.texts[2].value})]})})})})}},23832:function(n,e,r){r.d(e,{T:function(){return t.T}});var t=r(87575)},90779:function(n,e,r){r.d(e,{p:function(){return t.p}});var t=r(25441)},41102:function(n,e,r){r.d(e,{G:function(){return t.G}});var t=r(4481)},3088:function(n,e,r){r.d(e,{S:function(){return t.S}});var t=r(74284)},2675:function(n,e,r){r.r(e),r.d(e,{texts:function(){return t}});const t=[{value:"在地图应用中，渲染大数据的地理数据是十分常见的需求，为了保证应用的流畅性，需要追求极致的渲染性能，为此监控引擎渲染内容对于优化性能，建设地图可视化应用性能指标有切实的意义。",paraId:0},{value:"下面介绍如何使用 L7 提供的能力简单获取应用的渲染性能信息。",paraId:1,tocIndex:0},{value:"import { Scene } from '@antv/l7';\nimport { GaodeMap } from '@antv/l7-maps';\n\nconst scene = new Scene({\n  id: 'map',\n  map: new GaodeMap({\n    center: [ 60, 40.7128 ],\n    zoom: 2\n  }),\n  debug: true\n});\nscene.on('loaded', () => {\n  const debugService = scene.getDebugService();\n  // 开启每帧渲染的监控\n  debugService.renderDebug(true)\n  debugService.on('renderEnd', renderInfo => {\n    const {\n      renderUid,\t\t\t// 当前帧渲染唯一编号\n      renderStart,\t\t// 当前帧渲染开始时间\n      renderEnd,\t\t\t// 当前帧渲染结束时间\n      renderDuration\t// 当前帧渲染时间\n    } = renderInfo;\n    ...\n  }\n\n  setTimeout(() => {\n    debugService.renderDebug(false);\n    debugService.off('renderEnd');\n  }, 1000); // 监听 1s 内的渲染情况\n});\n",paraId:2,tocIndex:0}]}}]);