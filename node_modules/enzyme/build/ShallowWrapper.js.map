{"version":3,"sources":["../src/ShallowWrapper.js"],"names":["NODE","NODES","RENDERER","UNRENDERED","ROOT","OPTIONS","SET_STATE","ROOT_NODES","CHILD_CONTEXT","WRAPPING_COMPONENT","PRIMARY_WRAPPER","ROOT_FINDER","PROVIDER_VALUES","findWhereUnwrapped","wrapper","predicate","filter","treeFilter","flatMap","n","getNodeInternal","filterWhereUnwrapped","wrap","getNodesInternal","Boolean","validateOptions","options","lifecycleExperimental","disableLifecycleMethods","enableComponentDidUpdateOnSetState","supportPrevContextArgumentOfComponentDidUpdate","lifecycles","Error","componentDidUpdate","onSetState","TypeError","prevContext","getAdapterLifecycles","hasLegacySetStateArg","hasLegacyPrevContextArg","originalGDSFP","getDerivedStateFromProps","hasShouldComponentUpdateBug","setState","getChildContext","calledByRenderer","getRootNode","node","nodeType","rendered","getRootNodeInternal","length","nodeParents","privateSetNodes","nodes","Array","isArray","pureComponentShouldComponentUpdate","prevProps","props","prevState","state","isPureComponent","instance","isPureReactComponent","hierarchy","renderer","Component","type","componentName","childContextTypes","console","warn","childContext","Object","keys","forEach","key","checkPropTypes","spyOnGetChildContextInitialRender","adapter","prototype","privateSetChildContext","renderedNode","getChildContextSpy","legacyContextMode","getLastReturnValue","restore","nodeHierarchy","concat","mockSCUIfgDSFPReturnNonNull","shouldComponentUpdate","args","sCUResult","originalSCU","apply","nextState","deepRender","target","element","nodeToElement","dive","children","i","found","at","undefined","getContextFromWrappingComponent","rootFinder","legacyContext","context","providerValues","makeShallowOptions","root","passedOptions","wrappingComponent","wrapWithWrappingComponent","wrappedNode","RootFinder","WrappingComponentWrapper","wrappingComponentLegacyContext","wrappingComponentProviderValues","ShallowWrapper","isValidElement","createRenderer","mode","Map","render","getNode","updater","callback","componentDidMount","batchedUpdates","update","single","map","unmount","nextContext","shouldRender","shouldComponentUpdateSpy","gDSFP","getSnapshotBeforeUpdate","snapshot","freeze","arguments","rerender","statePayload","call","maybeHasUpdate","skipsComponentDidUpdateOnNullish","invokeSetStateCallback","nodeOrNodes","nodeEqual","other","elementToNode","rstNode","a","b","every","containsMatchingElement","some","selector","getTextFromNode","cheerio","load","html","event","simulateEvent","error","thisNode","simulateError","rootNode","propsOfNode","name","_state","_context","allChildren","index","allParents","parents","get","is","matchingAncestors","first","findWhere","propName","handler","prop","response","RangeError","propValue","wrapped","displayNameOfNode","className","indexOf","fn","initialValue","reduce","accum","reduceRight","begin","end","slice","flattened","getElements","exists","find","fnName","intercepter","el","childOptions","filterWhere","updatePrimaryRootContext","primaryWrapper","primaryRenderer","primaryNode","prevProviderValues","setContext","isContextConsumer","Consumer","Provider","getProviderFromConsumer","newValue","oldValue","result","ITERATOR_SYMBOL","defineProperty","configurable","value","iterator","iter","next","done","privateWarning","extraMessage","enumerable"],"mappings":"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","file":"ShallowWrapper.js","sourcesContent":["import flat from 'array.prototype.flat';\nimport cheerio from 'cheerio';\nimport has from 'has';\n\nimport {\n  nodeEqual,\n  nodeMatches,\n  containsChildrenSubArray,\n  withSetStateAllowed,\n  typeOfNode,\n  isReactElementAlike,\n  displayNameOfNode,\n  isCustomComponent,\n  isCustomComponentElement,\n  ITERATOR_SYMBOL,\n  makeOptions,\n  sym,\n  privateSet,\n  cloneElement,\n  spyMethod,\n  shallowEqual,\n  isEmptyValue,\n} from './Utils';\nimport getAdapter from './getAdapter';\nimport { debugNodes } from './Debug';\nimport {\n  propsOfNode,\n  getTextFromNode,\n  hasClassName,\n  childrenOfNode,\n  parentsOfNode,\n  treeFilter,\n} from './RSTTraversal';\nimport { buildPredicate, reduceTreesBySelector } from './selectors';\n\nconst NODE = sym('__node__');\nconst NODES = sym('__nodes__');\nconst RENDERER = sym('__renderer__');\nconst UNRENDERED = sym('__unrendered__');\nconst ROOT = sym('__root__');\nconst OPTIONS = sym('__options__');\nconst SET_STATE = sym('__setState__');\nconst ROOT_NODES = sym('__rootNodes__');\nconst CHILD_CONTEXT = sym('__childContext__');\nconst WRAPPING_COMPONENT = sym('__wrappingComponent__');\nconst PRIMARY_WRAPPER = sym('__primaryWrapper__');\nconst ROOT_FINDER = sym('__rootFinder__');\nconst PROVIDER_VALUES = sym('__providerValues__');\n\n/**\n * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n * function.\n *\n * @param {ShallowWrapper} wrapper\n * @param {Function} predicate\n * @param {Function} filter\n * @returns {ShallowWrapper}\n */\nfunction findWhereUnwrapped(wrapper, predicate, filter = treeFilter) {\n  return wrapper.flatMap(n => filter(n.getNodeInternal(), predicate));\n}\n\n/**\n * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n * the provided predicate function.\n *\n * @param {ShallowWrapper} wrapper\n * @param {Function} predicate\n * @returns {ShallowWrapper}\n */\nfunction filterWhereUnwrapped(wrapper, predicate) {\n  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));\n}\n\n/**\n * Ensure options passed to ShallowWrapper are valid. Throws otherwise.\n * @param {Object} options\n */\nfunction validateOptions(options) {\n  const {\n    lifecycleExperimental,\n    disableLifecycleMethods,\n    enableComponentDidUpdateOnSetState,\n    supportPrevContextArgumentOfComponentDidUpdate,\n    lifecycles,\n  } = options;\n  if (typeof lifecycleExperimental !== 'undefined' && typeof lifecycleExperimental !== 'boolean') {\n    throw new Error('lifecycleExperimental must be either true or false if provided');\n  }\n\n  if (typeof disableLifecycleMethods !== 'undefined' && typeof disableLifecycleMethods !== 'boolean') {\n    throw new Error('disableLifecycleMethods must be either true or false if provided');\n  }\n\n  if (\n    lifecycleExperimental != null\n    && disableLifecycleMethods != null\n    && lifecycleExperimental === disableLifecycleMethods\n  ) {\n    throw new Error('lifecycleExperimental and disableLifecycleMethods cannot be set to the same value');\n  }\n\n  if (\n    typeof enableComponentDidUpdateOnSetState !== 'undefined'\n    && lifecycles.componentDidUpdate\n    && lifecycles.componentDidUpdate.onSetState !== enableComponentDidUpdateOnSetState\n  ) {\n    throw new TypeError('the legacy enableComponentDidUpdateOnSetState option should be matched by `lifecycles: { componentDidUpdate: { onSetState: true } }`, for compatibility');\n  }\n\n  if (\n    typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined'\n    && lifecycles.componentDidUpdate\n    && lifecycles.componentDidUpdate.prevContext !== supportPrevContextArgumentOfComponentDidUpdate\n  ) {\n    throw new TypeError('the legacy supportPrevContextArgumentOfComponentDidUpdate option should be matched by `lifecycles: { componentDidUpdate: { prevContext: true } }`, for compatibility');\n  }\n}\n\nfunction getAdapterLifecycles({ options }) {\n  const {\n    lifecycles = {},\n    enableComponentDidUpdateOnSetState,\n    supportPrevContextArgumentOfComponentDidUpdate,\n  } = options;\n\n  const hasLegacySetStateArg = typeof enableComponentDidUpdateOnSetState !== 'undefined';\n  const hasLegacyPrevContextArg = typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined';\n  const componentDidUpdate = hasLegacySetStateArg || hasLegacyPrevContextArg\n    ? {\n      ...(hasLegacySetStateArg && {\n        onSetState: !!enableComponentDidUpdateOnSetState,\n      }),\n      ...(hasLegacyPrevContextArg && {\n        prevContext: !!supportPrevContextArgumentOfComponentDidUpdate,\n      }),\n    }\n    : null;\n  const { getDerivedStateFromProps: originalGDSFP } = lifecycles;\n  const getDerivedStateFromProps = originalGDSFP ? {\n    hasShouldComponentUpdateBug: !!originalGDSFP.hasShouldComponentUpdateBug,\n  } : false;\n\n  return {\n    ...lifecycles,\n    setState: {\n      ...lifecycles.setState,\n    },\n    getChildContext: {\n      calledByRenderer: true,\n      ...lifecycles.getChildContext,\n    },\n    ...(componentDidUpdate && { componentDidUpdate }),\n    getDerivedStateFromProps,\n  };\n}\n\nfunction getRootNode(node) {\n  if (node.nodeType === 'host') {\n    return node;\n  }\n  return node.rendered;\n}\n\nfunction getRootNodeInternal(wrapper) {\n  if (wrapper[ROOT].length !== 1) {\n    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');\n  }\n  if (wrapper[ROOT] !== wrapper) {\n    return wrapper[ROOT_NODES][0];\n  }\n  return wrapper[ROOT][NODE];\n}\n\nfunction nodeParents(wrapper, node) {\n  return parentsOfNode(node, getRootNodeInternal(wrapper));\n}\n\nfunction privateSetNodes(wrapper, nodes) {\n  if (!Array.isArray(nodes)) {\n    privateSet(wrapper, NODE, nodes);\n    privateSet(wrapper, NODES, [nodes]);\n  } else {\n    privateSet(wrapper, NODE, nodes[0]);\n    privateSet(wrapper, NODES, nodes);\n  }\n  privateSet(wrapper, 'length', wrapper[NODES].length);\n}\n\nfunction pureComponentShouldComponentUpdate(prevProps, props, prevState, state) {\n  return !shallowEqual(prevProps, props) || !shallowEqual(prevState, state);\n}\n\nfunction isPureComponent(instance) {\n  return instance && instance.isPureReactComponent;\n}\n\nfunction getChildContext(node, hierarchy, renderer) {\n  const { instance, type: Component } = node;\n  const componentName = displayNameOfNode(node);\n  // Warn like react if childContextTypes is not defined:\n  // https://github.com/facebook/react/blob/1454a8be03794f5e0b23a7e7696cbbbdcf8b0f5d/packages/react-dom/src/server/ReactPartialRenderer.js#L639-L646\n  if (typeof Component.childContextTypes !== 'object') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `${componentName}.getChildContext(): childContextTypes must be defined in order to use getChildContext().`,\n    );\n    return {};\n  }\n  // Check childContextTypes like react:\n  // https://github.com/facebook/react/blob/1454a8be03794f5e0b23a7e7696cbbbdcf8b0f5d/packages/react-dom/src/server/ReactPartialRenderer.js#L630-L637\n  const childContext = instance.getChildContext();\n  Object.keys(childContext).forEach((key) => {\n    if (!(key in Component.childContextTypes)) {\n      throw new Error(\n        `${componentName}.getChildContext(): key \"${key}\" is not defined in childContextTypes.`,\n      );\n    }\n  });\n  if (typeof renderer.checkPropTypes === 'function') {\n    renderer.checkPropTypes(Component.childContextTypes, childContext, 'child context', hierarchy);\n  }\n  return childContext;\n}\n\nfunction spyOnGetChildContextInitialRender(nodes, adapter) {\n  if (\n    !isCustomComponentElement(nodes, adapter)\n    || !nodes.type.prototype\n    || typeof nodes.type.prototype.getChildContext !== 'function'\n  ) {\n    return null;\n  }\n\n  return spyMethod(nodes.type.prototype, 'getChildContext');\n}\n\nfunction privateSetChildContext(adapter, wrapper, instance, renderedNode, getChildContextSpy) {\n  const renderer = wrapper[RENDERER];\n  // We only support parent-based context.\n  if (adapter.options.legacyContextMode !== 'parent') { return; }\n  if (getChildContextSpy) {\n    privateSet(wrapper, CHILD_CONTEXT, getChildContextSpy.getLastReturnValue());\n    getChildContextSpy.restore();\n  } else if (typeof instance.getChildContext === 'function') {\n    // If there's no spy but getChildContext is a function, that means our renderer\n    // is not going to call it for us, so we need to call it ourselves.\n    const nodeHierarchy = [wrapper[NODE]].concat(nodeParents(wrapper, wrapper[NODE]));\n    const childContext = getChildContext(renderedNode, nodeHierarchy, renderer);\n    privateSet(wrapper, CHILD_CONTEXT, childContext);\n  } else {\n    privateSet(wrapper, CHILD_CONTEXT, null);\n  }\n}\n\nfunction mockSCUIfgDSFPReturnNonNull(node, state) {\n  const { getDerivedStateFromProps } = node.type;\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    // we try to fix a React shallow renderer bug here.\n    // (facebook/react#14607, which has been fixed in react 16.8):\n    // when gDSFP return derived state, it will set instance state in shallow renderer before SCU,\n    // this will cause `this.state` in sCU be the updated state, which is wrong behavior.\n    // so we have to wrap sCU to pass the old state to original sCU.\n    const { instance } = node;\n    const { restore } = spyMethod(\n      instance,\n      'shouldComponentUpdate',\n      originalSCU => function shouldComponentUpdate(...args) {\n        instance.state = state;\n        const sCUResult = originalSCU.apply(instance, args);\n        const [, nextState] = args;\n        instance.state = nextState;\n        restore();\n        return sCUResult;\n      },\n    );\n  }\n}\n\n/**\n * Recursively dive()s every custom component in a wrapper until\n * the target component is found.\n *\n * @param {ShallowWrapper} wrapper A ShallowWrapper to search\n * @param {ComponentType} target A react custom component that, when found, will end recursion\n * @param {Adapter} adapter An Enzyme adapter\n * @returns {ShallowWrapper|undefined} A ShallowWrapper for the target, or\n *  undefined if it can't be found\n */\nfunction deepRender(wrapper, target, adapter) {\n  const node = wrapper[NODE];\n  const element = node && adapter.nodeToElement(node);\n  if (wrapper.type() === target) {\n    return wrapper.dive();\n  }\n  if (element && isCustomComponentElement(element, adapter)) {\n    return deepRender(wrapper.dive(), target, adapter);\n  }\n  const children = wrapper.children();\n  for (let i = 0; i < children.length; i += 1) {\n    const found = deepRender(children.at(i), target, adapter);\n    if (typeof found !== 'undefined') {\n      return found;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Deep-renders the `wrappingComponent` and returns the context that should\n * be accessible to the primary wrapper.\n *\n * @param {WrappingComponentWrapper} wrapper The `WrappingComponentWrapper` for a\n *  `wrappingComponent`\n * @param {Adapter} adapter An Enzyme adapter\n * @returns {object} An object containing an object of legacy context values and a Map of\n *  `createContext()` Provider values.\n */\nfunction getContextFromWrappingComponent(wrapper, adapter) {\n  const rootFinder = deepRender(wrapper, wrapper[ROOT_FINDER], adapter);\n  if (!rootFinder) {\n    throw new Error('`wrappingComponent` must render its children!');\n  }\n  return {\n    legacyContext: rootFinder[OPTIONS].context,\n    providerValues: rootFinder[PROVIDER_VALUES],\n  };\n}\n\n/**\n * Makes options specifically for `ShallowWrapper`. Most of the logic here is around rendering\n * a `wrappingComponent` (if one was provided) and adding the child context of that component\n * to `options.context`.\n *\n * @param {ReactElement} nodes the nodes passed to `ShallowWrapper`\n * @param {ShallowWrapper} root this `ShallowWrapper`'s parent. If this is passed, options are\n *  not transformed.\n * @param {*} passedOptions the options passed to `ShallowWrapper`.\n * @param {*} wrapper the `ShallowWrapper` itself\n * @returns {Object} the decorated and transformed options\n */\nfunction makeShallowOptions(nodes, root, passedOptions, wrapper) {\n  const options = makeOptions(passedOptions);\n  const adapter = getAdapter(passedOptions);\n  privateSet(options, PROVIDER_VALUES, passedOptions[PROVIDER_VALUES]);\n  if (root || !isCustomComponent(options.wrappingComponent, adapter)) {\n    return options;\n  }\n  if (typeof adapter.wrapWithWrappingComponent !== 'function') {\n    throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');\n  }\n  const { node: wrappedNode, RootFinder } = adapter.wrapWithWrappingComponent(nodes, options);\n  // eslint-disable-next-line no-use-before-define\n  const wrappingComponent = new WrappingComponentWrapper(wrappedNode, wrapper, RootFinder);\n  const {\n    legacyContext: wrappingComponentLegacyContext,\n    providerValues: wrappingComponentProviderValues,\n  } = getContextFromWrappingComponent(wrappingComponent, adapter);\n  privateSet(wrapper, WRAPPING_COMPONENT, wrappingComponent);\n  return {\n    ...options,\n    context: {\n      ...options.context,\n      ...wrappingComponentLegacyContext,\n    },\n    [PROVIDER_VALUES]: wrappingComponentProviderValues,\n  };\n}\n\n\n/**\n * @class ShallowWrapper\n */\nclass ShallowWrapper {\n  constructor(nodes, root, passedOptions = {}) {\n    validateOptions(passedOptions);\n\n    const options = makeShallowOptions(nodes, root, passedOptions, this);\n    const adapter = getAdapter(options);\n    const lifecycles = getAdapterLifecycles(adapter);\n\n    // mounting a ShallowRender component\n    if (!root) {\n      if (!adapter.isValidElement(nodes)) {\n        throw new TypeError('ShallowWrapper can only wrap valid elements');\n      }\n\n      const getChildContextSpy = lifecycles.getChildContext.calledByRenderer\n        ? spyOnGetChildContextInitialRender(nodes, adapter)\n        : null;\n      privateSet(this, ROOT, this);\n      privateSet(this, UNRENDERED, nodes);\n      const renderer = adapter.createRenderer({ mode: 'shallow', ...options });\n      privateSet(this, RENDERER, renderer);\n      const providerValues = new Map(options[PROVIDER_VALUES] || []);\n      this[RENDERER].render(nodes, options.context, { providerValues });\n      const renderedNode = this[RENDERER].getNode();\n      privateSetNodes(this, getRootNode(renderedNode));\n      privateSet(this, OPTIONS, options);\n      privateSet(this, PROVIDER_VALUES, providerValues);\n\n      const { instance } = renderedNode;\n      if (instance && !options.disableLifecycleMethods) {\n        // Ensure to call componentDidUpdate when instance.setState is called\n        if (lifecycles.componentDidUpdate.onSetState && !instance[SET_STATE]) {\n          privateSet(instance, SET_STATE, instance.setState);\n          instance.setState = (updater, callback = undefined) => this.setState(\n            ...(callback == null ? [updater] : [updater, callback]),\n          );\n        }\n\n        if (typeof instance.componentDidMount === 'function') {\n          this[RENDERER].batchedUpdates(() => {\n            instance.componentDidMount();\n          });\n        }\n        privateSetChildContext(adapter, this, instance, renderedNode, getChildContextSpy);\n      }\n    // creating a child component through enzyme's ShallowWrapper APIs.\n    } else {\n      privateSet(this, ROOT, root);\n      privateSet(this, UNRENDERED, null);\n      privateSet(this, RENDERER, root[RENDERER]);\n      privateSetNodes(this, nodes);\n      privateSet(this, OPTIONS, root[OPTIONS]);\n      privateSet(this, ROOT_NODES, root[NODES]);\n      privateSet(this, PROVIDER_VALUES, null);\n    }\n  }\n\n  /**\n   * Returns the root wrapper\n   *\n   * @return {ShallowWrapper}\n   */\n  root() {\n    return this[ROOT];\n  }\n\n  /**\n   * Returns the wrapped component.\n   *\n   * @return {ReactComponent}\n   */\n  getNodeInternal() {\n    if (this.length !== 1) {\n      throw new Error('ShallowWrapper::getNode() can only be called when wrapping one node');\n    }\n    if (this[ROOT] === this) {\n      this.update();\n    }\n    return this[NODE];\n  }\n\n  /**\n   * Returns the the wrapped components.\n   *\n   * @return {Array<ReactComponent>}\n   */\n  getNodesInternal() {\n    if (this[ROOT] === this && this.length === 1) {\n      this.update();\n    }\n    return this[NODES];\n  }\n\n  /**\n   * Returns the wrapped ReactElement.\n   *\n   * @return {ReactElement}\n   */\n  getElement() {\n    return this.single('getElement', n => getAdapter(this[OPTIONS]).nodeToElement(n));\n  }\n\n  /**\n   * Returns the wrapped ReactElements.\n   *\n   * @return {Array<ReactElement>}\n   */\n  getElements() {\n    return this.getNodesInternal().map(n => getAdapter(this[OPTIONS]).nodeToElement(n));\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNode() {\n    throw new Error('ShallowWrapper::getNode() is no longer supported. Use ShallowWrapper::getElement() instead');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNodes() {\n    throw new Error('ShallowWrapper::getNodes() is no longer supported. Use ShallowWrapper::getElements() instead');\n  }\n\n  /**\n   * Gets the instance of the component being rendered as the root node passed into `shallow()`.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * Example:\n   * ```\n   * const wrapper = shallow(<MyComponent />);\n   * const inst = wrapper.instance();\n   * expect(inst).to.be.instanceOf(MyComponent);\n   * ```\n   * @returns {ReactComponent}\n   */\n  instance() {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::instance() can only be called on the root');\n    }\n    return this[RENDERER].getNode().instance;\n  }\n\n  /**\n   * If a `wrappingComponent` was passed in `options`, this methods returns a `ShallowWrapper`\n   * around the rendered `wrappingComponent`. This `ShallowWrapper` can be used to update the\n   * `wrappingComponent`'s props, state, etc.\n   *\n   * @returns ShallowWrapper\n   */\n  getWrappingComponent() {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::getWrappingComponent() can only be called on the root');\n    }\n    if (!this[OPTIONS].wrappingComponent) {\n      throw new Error('ShallowWrapper::getWrappingComponent() can only be called on a wrapper that was originally passed a `wrappingComponent` option');\n    }\n    return this[WRAPPING_COMPONENT];\n  }\n\n  /**\n   * Forces a re-render. Useful to run before checking the render output if something external\n   * may be updating the state of the component somewhere.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @returns {ShallowWrapper}\n   */\n  update() {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::update() can only be called on the root');\n    }\n    if (this.length !== 1) {\n      throw new Error('ShallowWrapper::update() can only be called when wrapping one node');\n    }\n    privateSetNodes(this, getRootNode(this[RENDERER].getNode()));\n    return this;\n  }\n\n  /**\n   * A method that unmounts the component. This can be used to simulate a component going through\n   * and unmount/mount lifecycle.\n   * @returns {ShallowWrapper}\n   */\n  unmount() {\n    this[RENDERER].unmount();\n    if (this[ROOT][WRAPPING_COMPONENT]) {\n      this[ROOT][WRAPPING_COMPONENT].unmount();\n    }\n    return this;\n  }\n\n  /**\n   * A method is for re-render with new props and context.\n   * This calls componentDidUpdate method if disableLifecycleMethods is not enabled.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} props\n   * @param {Object} context\n   * @returns {ShallowWrapper}\n   */\n  rerender(props, context) {\n    const adapter = getAdapter(this[OPTIONS]);\n    this.single('rerender', () => {\n      withSetStateAllowed(() => {\n        // NOTE(lmr): In react 16, instances will be null for SFCs, but\n        // rerendering with props/context is still a valid thing to do. In\n        // this case, state will be undefined, but props/context will exist.\n        const node = this[RENDERER].getNode();\n        const instance = node.instance || {};\n        const type = node.type || {};\n        const { state } = instance;\n        const prevProps = instance.props || this[UNRENDERED].props;\n        const prevContext = instance.context || this[OPTIONS].context;\n        const nextContext = context || prevContext;\n        if (context) {\n          this[OPTIONS] = { ...this[OPTIONS], context: nextContext };\n        }\n        this[RENDERER].batchedUpdates(() => {\n          // When shouldComponentUpdate returns false we shouldn't call componentDidUpdate.\n          // so we spy shouldComponentUpdate to get the result.\n          const lifecycles = getAdapterLifecycles(adapter);\n          let shouldRender = true;\n          let shouldComponentUpdateSpy;\n          let getChildContextSpy;\n          if (\n            !this[OPTIONS].disableLifecycleMethods\n            && instance\n          ) {\n            if (typeof instance.shouldComponentUpdate === 'function') {\n              const { getDerivedStateFromProps: gDSFP } = lifecycles;\n              if (gDSFP && gDSFP.hasShouldComponentUpdateBug) {\n                mockSCUIfgDSFPReturnNonNull(node, state);\n              }\n              shouldComponentUpdateSpy = spyMethod(instance, 'shouldComponentUpdate');\n            }\n            if (\n              lifecycles.getChildContext.calledByRenderer\n              && typeof instance.getChildContext === 'function'\n            ) {\n              getChildContextSpy = spyMethod(instance, 'getChildContext');\n            }\n          }\n          if (!shouldComponentUpdateSpy && isPureComponent(instance)) {\n            shouldRender = pureComponentShouldComponentUpdate(\n              prevProps,\n              props,\n              state,\n              instance.state,\n            );\n          }\n          if (props) this[UNRENDERED] = cloneElement(adapter, this[UNRENDERED], props);\n          this[RENDERER].render(this[UNRENDERED], nextContext, {\n            providerValues: this[PROVIDER_VALUES],\n          });\n          if (shouldComponentUpdateSpy) {\n            shouldRender = shouldComponentUpdateSpy.getLastReturnValue();\n            shouldComponentUpdateSpy.restore();\n          }\n          if (\n            shouldRender\n            && !this[OPTIONS].disableLifecycleMethods\n            && instance\n          ) {\n            privateSetChildContext(adapter, this, instance, node, getChildContextSpy);\n            if (lifecycles.getSnapshotBeforeUpdate) {\n              let snapshot;\n              if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                snapshot = instance.getSnapshotBeforeUpdate(prevProps, state);\n              }\n              if (\n                lifecycles.componentDidUpdate\n                && typeof instance.componentDidUpdate === 'function'\n                && (\n                  !state\n                  || shallowEqual(state, this.instance().state)\n                  || typeof type.getDerivedStateFromProps === 'function'\n                )\n              ) {\n                instance.componentDidUpdate(prevProps, state, snapshot);\n              }\n            } else if (\n              lifecycles.componentDidUpdate\n              && typeof instance.componentDidUpdate === 'function'\n            ) {\n              if (lifecycles.componentDidUpdate.prevContext) {\n                instance.componentDidUpdate(prevProps, state, prevContext);\n              } else if (!state || shallowEqual(this.instance().state, state)) {\n                instance.componentDidUpdate(prevProps, state);\n              }\n            }\n          // If it doesn't need to rerender, update only its props.\n          } else if (!shallowEqual(props, instance.props)) {\n            instance.props = (Object.freeze || Object)({ ...instance.props, ...props });\n          }\n          this.update();\n        });\n      });\n    });\n    return this;\n  }\n\n  /**\n   * A method that sets the props of the root component, and re-renders. Useful for when you are\n   * wanting to test how the component behaves over time with changing props. Calling this, for\n   * instance, will call the `componentWillReceiveProps` lifecycle method.\n   *\n   * Similar to `setState`, this method accepts a props object and will merge it in with the already\n   * existing props.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} props object\n   * @param {Function} cb - callback function\n   * @returns {ShallowWrapper}\n   */\n  setProps(props, callback = undefined) {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::setProps() can only be called on the root');\n    }\n    if (arguments.length > 1 && typeof callback !== 'function') {\n      throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');\n    }\n    this.rerender(props);\n    if (callback) {\n      callback();\n    }\n    return this;\n  }\n\n  /**\n   * A method to invoke `setState` on the root component instance similar to how you might in the\n   * definition of the component, and re-renders.  This method is useful for testing your component\n   * in hard to achieve states, however should be used sparingly. If possible, you should utilize\n   * your component's external API in order to get it into whatever state you want to test, in order\n   * to be as accurate of a test as possible. This is not always practical, however.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} state to merge\n   * @param {Function} cb - callback function\n   * @returns {ShallowWrapper}\n   */\n  setState(state, callback = undefined) {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::setState() can only be called on the root');\n    }\n    if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {\n      throw new Error('ShallowWrapper::setState() can only be called on class components');\n    }\n    if (arguments.length > 1 && typeof callback !== 'function') {\n      throw new TypeError('ReactWrapper::setState() expects a function as its second argument');\n    }\n\n    this.single('setState', () => {\n      withSetStateAllowed(() => {\n        const adapter = getAdapter(this[OPTIONS]);\n\n        const lifecycles = getAdapterLifecycles(adapter);\n\n        const node = this[RENDERER].getNode();\n        const { instance } = node;\n        const prevProps = instance.props;\n        const prevState = instance.state;\n        const prevContext = instance.context;\n\n        const statePayload = typeof state === 'function'\n          ? state.call(instance, prevState, prevProps)\n          : state;\n\n        // returning null or undefined prevents the update in React 16+\n        // https://github.com/facebook/react/pull/12756\n        const maybeHasUpdate = !lifecycles.setState.skipsComponentDidUpdateOnNullish\n          || statePayload != null;\n\n        // When shouldComponentUpdate returns false we shouldn't call componentDidUpdate.\n        // so we spy shouldComponentUpdate to get the result.\n        let shouldComponentUpdateSpy;\n        let getChildContextSpy;\n        let shouldRender = true;\n        if (\n          !this[OPTIONS].disableLifecycleMethods\n          && instance\n        ) {\n          if (\n            lifecycles.componentDidUpdate\n            && lifecycles.componentDidUpdate.onSetState\n            && typeof instance.shouldComponentUpdate === 'function'\n          ) {\n            const { getDerivedStateFromProps: gDSFP } = lifecycles;\n            if (gDSFP && gDSFP.hasShouldComponentUpdateBug) {\n              mockSCUIfgDSFPReturnNonNull(node, state);\n            }\n            shouldComponentUpdateSpy = spyMethod(instance, 'shouldComponentUpdate');\n          }\n          if (\n            lifecycles.getChildContext.calledByRenderer\n            && typeof instance.getChildContext === 'function'\n          ) {\n            getChildContextSpy = spyMethod(instance, 'getChildContext');\n          }\n        }\n        if (!shouldComponentUpdateSpy && isPureComponent(instance)) {\n          shouldRender = pureComponentShouldComponentUpdate(\n            prevProps,\n            instance.props,\n            prevState,\n            { ...prevState, ...statePayload },\n          );\n        }\n\n        // We don't pass the setState callback here\n        // to guarantee to call the callback after finishing the render\n        if (instance[SET_STATE]) {\n          instance[SET_STATE](statePayload);\n        } else {\n          instance.setState(statePayload);\n        }\n        if (shouldComponentUpdateSpy) {\n          shouldRender = shouldComponentUpdateSpy.getLastReturnValue();\n          shouldComponentUpdateSpy.restore();\n        }\n        if (\n          maybeHasUpdate\n          && shouldRender\n          && !this[OPTIONS].disableLifecycleMethods\n        ) {\n          privateSetChildContext(adapter, this, instance, node, getChildContextSpy);\n          if (\n            lifecycles.componentDidUpdate\n            && lifecycles.componentDidUpdate.onSetState\n          ) {\n            if (\n              lifecycles.getSnapshotBeforeUpdate\n              && typeof instance.getSnapshotBeforeUpdate === 'function'\n            ) {\n              const snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);\n              if (typeof instance.componentDidUpdate === 'function') {\n                instance.componentDidUpdate(prevProps, prevState, snapshot);\n              }\n            } else if (typeof instance.componentDidUpdate === 'function') {\n              if (lifecycles.componentDidUpdate.prevContext) {\n                instance.componentDidUpdate(prevProps, prevState, prevContext);\n              } else {\n                instance.componentDidUpdate(prevProps, prevState);\n              }\n            }\n          }\n        }\n        this.update();\n        // call the setState callback\n        if (callback) {\n          if (adapter.invokeSetStateCallback) {\n            adapter.invokeSetStateCallback(instance, callback);\n          } else {\n            callback.call(instance);\n          }\n        }\n      });\n    });\n    return this;\n  }\n\n  /**\n   * A method that sets the context of the root component, and re-renders. Useful for when you are\n   * wanting to test how the component behaves over time with changing contexts.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} context object\n   * @returns {ShallowWrapper}\n   */\n  setContext(context) {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::setContext() can only be called on the root');\n    }\n    if (!this[OPTIONS].context) {\n      throw new Error('ShallowWrapper::setContext() can only be called on a wrapper that was originally passed a context option');\n    }\n    return this.rerender(null, context);\n  }\n\n  /**\n   * Whether or not a given react element exists in the shallow render tree.\n   *\n   * Example:\n   * ```\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement|Array<ReactElement>} nodeOrNodes\n   * @returns {Boolean}\n   */\n  contains(nodeOrNodes) {\n    const adapter = getAdapter(this[OPTIONS]);\n    if (!isReactElementAlike(nodeOrNodes, adapter)) {\n      throw new Error('ShallowWrapper::contains() can only be called with a ReactElement (or an array of them), a string, or a number as an argument.');\n    }\n    const predicate = Array.isArray(nodeOrNodes)\n      ? other => containsChildrenSubArray(\n        nodeEqual,\n        other,\n        nodeOrNodes.map(node => adapter.elementToNode(node)),\n      )\n      : other => nodeEqual(adapter.elementToNode(nodeOrNodes), other);\n\n    return findWhereUnwrapped(this, predicate).length > 0;\n  }\n\n  /**\n   * Whether or not a given react element exists in the shallow render tree.\n   * Match is based on the expected element and not on wrappers element.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * // MyComponent outputs <div><div class=\"foo\">Hello</div></div>\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.containsMatchingElement(<div>Hello</div>)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  containsMatchingElement(node) {\n    const adapter = getAdapter(this[OPTIONS]);\n    const rstNode = adapter.elementToNode(node);\n    const predicate = other => nodeMatches(rstNode, other, (a, b) => a <= b);\n    return findWhereUnwrapped(this, predicate).length > 0;\n  }\n\n  /**\n   * Whether or not all the given react elements exists in the shallow render tree.\n   * Match is based on the expected element and not on wrappers element.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.containsAllMatchingElements([\n   *   <div>Hello</div>,\n   *   <div>Goodbye</div>,\n   * ])).to.equal(true);\n   * ```\n   *\n   * @param {Array<ReactElement>} nodes\n   * @returns {Boolean}\n   */\n  containsAllMatchingElements(nodes) {\n    if (!Array.isArray(nodes)) {\n      throw new TypeError('nodes should be an Array');\n    }\n\n    return nodes.every(node => this.containsMatchingElement(node));\n  }\n\n  /**\n   * Whether or not one of the given react elements exists in the shallow render tree.\n   * Match is based on the expected element and not on wrappers element.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.containsAnyMatchingElements([\n   *   <div>Hello</div>,\n   *   <div>Goodbye</div>,\n   * ])).to.equal(true);\n   * ```\n   *\n   * @param {Array<ReactElement>} nodes\n   * @returns {Boolean}\n   */\n  containsAnyMatchingElements(nodes) {\n    return Array.isArray(nodes) && nodes.some(node => this.containsMatchingElement(node));\n  }\n\n  /**\n   * Whether or not a given react element exists in the render tree.\n   *\n   * Example:\n   * ```\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  equals(node) {\n    return this.single('equals', () => nodeEqual(this.getNodeInternal(), node));\n  }\n\n  /**\n   * Whether or not a given react element matches the render tree.\n   * Match is based on the expected element and not on wrapper root node.\n   * It will determine if the wrapper root node \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrapper root node and equals to each other.\n   *\n   * Example:\n   * ```\n   * // MyComponent outputs <div class=\"foo\">Hello</div>\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.matchesElement(<div>Hello</div>)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  matchesElement(node) {\n    return this.single('matchesElement', () => {\n      const adapter = getAdapter(this[OPTIONS]);\n      const rstNode = adapter.elementToNode(node);\n      return nodeMatches(rstNode, this.getNodeInternal(), (a, b) => a <= b);\n    });\n  }\n\n  /**\n   * Finds every node in the render tree of the current wrapper that matches the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ShallowWrapper}\n   */\n  find(selector) {\n    return this.wrap(reduceTreesBySelector(selector, this.getNodesInternal()));\n  }\n\n  /**\n   * Returns whether or not current node matches a provided selector.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {boolean}\n   */\n  is(selector) {\n    const predicate = buildPredicate(selector);\n    return this.single('is', n => predicate(n));\n  }\n\n  /**\n   * Returns true if the component rendered nothing, i.e., null or false.\n   *\n   * @returns {boolean}\n   */\n  isEmptyRender() {\n    const nodes = this.getNodesInternal();\n\n    return nodes.every(n => isEmptyValue(n));\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n   * the provided predicate function. The predicate should receive a wrapped node as its first\n   * argument.\n   *\n   * @param {Function} predicate\n   * @returns {ShallowWrapper}\n   */\n  filterWhere(predicate) {\n    return filterWhereUnwrapped(this, n => predicate(this.wrap(n)));\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n   * the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ShallowWrapper}\n   */\n  filter(selector) {\n    const predicate = buildPredicate(selector);\n    return filterWhereUnwrapped(this, predicate);\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper that did not match\n   * the provided selector. Essentially the inverse of `filter`.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ShallowWrapper}\n   */\n  not(selector) {\n    const predicate = buildPredicate(selector);\n    return filterWhereUnwrapped(this, n => !predicate(n));\n  }\n\n  /**\n   * Returns a string of the rendered text of the current render tree.  This function should be\n   * looked at with skepticism if being used to test what the actual HTML output of the component\n   * will be. If that is what you would like to test, use enzyme's `render` function instead.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {String}\n   */\n  text() {\n    return this.single('text', getTextFromNode);\n  }\n\n  /**\n   * Returns the HTML of the node.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {String}\n   */\n  html() {\n    return this.single('html', (n) => {\n      if (this.type() === null) return null;\n      const adapter = getAdapter(this[OPTIONS]);\n      const renderer = adapter.createRenderer({ ...this[OPTIONS], mode: 'string' });\n      return renderer.render(adapter.nodeToElement(n));\n    });\n  }\n\n  /**\n   * Returns the current node rendered to HTML and wrapped in a CheerioWrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {CheerioWrapper}\n   */\n  render() {\n    return this.type() === null ? cheerio() : cheerio.load('')(this.html());\n  }\n\n  /**\n   * Used to simulate events. Pass an eventname and (optionally) event arguments. This method of\n   * testing events should be met with some skepticism.\n   *\n   * @param {String} event\n   * @param {Array} args\n   * @returns {ShallowWrapper}\n   */\n  simulate(event, ...args) {\n    return this.single('simulate', (n) => {\n      this[RENDERER].simulateEvent(n, event, ...args);\n      this[ROOT].update();\n      return this;\n    });\n  }\n\n  /**\n   * Used to simulate throwing a rendering error. Pass an error to throw.\n   *\n   * @param {String} error\n   * @returns {ShallowWrapper}\n   */\n  simulateError(error) {\n    // in shallow, the \"root\" is the \"rendered\" thing.\n\n    return this.single('simulateError', (thisNode) => {\n      if (thisNode.nodeType === 'host') {\n        throw new TypeError('ShallowWrapper::simulateError() can only be called on custom components');\n      }\n\n      const renderer = this[RENDERER];\n      if (typeof renderer.simulateError !== 'function') {\n        throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');\n      }\n\n      const rootNode = getRootNodeInternal(this);\n      const nodeHierarchy = [thisNode].concat(nodeParents(this, thisNode));\n      renderer.simulateError(nodeHierarchy, rootNode, error);\n\n      return this;\n    });\n  }\n\n  /**\n   * Returns the props hash for the current node of the wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {Object}\n   */\n  props() {\n    return this.single('props', propsOfNode);\n  }\n\n  /**\n   * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it\n   * will return just that value.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} name (optional)\n   * @returns {*}\n   */\n  state(name) {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::state() can only be called on the root');\n    }\n    if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {\n      throw new Error('ShallowWrapper::state() can only be called on class components');\n    }\n    const _state = this.single('state', () => this.instance().state);\n    if (typeof name !== 'undefined') {\n      if (_state == null) {\n        throw new TypeError(`ShallowWrapper::state(\"${name}\") requires that \\`state\\` not be \\`null\\` or \\`undefined\\``);\n      }\n      return _state[name];\n    }\n    return _state;\n  }\n\n  /**\n   * Returns the context hash for the root node of the wrapper.\n   * Optionally pass in a prop name and it will return just that value.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} name (optional)\n   * @returns {*}\n   */\n  context(name) {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::context() can only be called on the root');\n    }\n    if (!this[OPTIONS].context) {\n      throw new Error('ShallowWrapper::context() can only be called on a wrapper that was originally passed a context option');\n    }\n    if (this.instance() === null) {\n      throw new Error('ShallowWrapper::context() can only be called on wrapped nodes that have a non-null instance');\n    }\n    const _context = this.single('context', () => this.instance().context);\n    if (name) {\n      return _context[name];\n    }\n    return _context;\n  }\n\n  /**\n   * Returns a new wrapper with all of the children of the current wrapper.\n   *\n   * @param {EnzymeSelector} [selector]\n   * @returns {ShallowWrapper}\n   */\n  children(selector) {\n    const allChildren = this.flatMap(n => childrenOfNode(n.getNodeInternal()));\n    return selector ? allChildren.filter(selector) : allChildren;\n  }\n\n  /**\n   * Returns a new wrapper with a specific child\n   *\n   * @param {Number} [index]\n   * @returns {ShallowWrapper}\n   */\n  childAt(index) {\n    return this.single('childAt', () => this.children().at(index));\n  }\n\n  /**\n   * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node\n   * in the current wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {EnzymeSelector} [selector]\n   * @returns {ShallowWrapper}\n   */\n  parents(selector) {\n    return this.single('parents', (n) => {\n      const allParents = this.wrap(nodeParents(this, n));\n      return selector ? allParents.filter(selector) : allParents;\n    });\n  }\n\n  /**\n   * Returns a wrapper around the immediate parent of the current node.\n   *\n   * @returns {ShallowWrapper}\n   */\n  parent() {\n    return this.flatMap(n => [n.parents().get(0)]);\n  }\n\n  /**\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ShallowWrapper}\n   */\n  closest(selector) {\n    if (this.is(selector)) {\n      return this;\n    }\n    const matchingAncestors = this.parents().filter(selector);\n    return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(() => false);\n  }\n\n  /**\n   * Shallow renders the current node and returns a shallow wrapper around it.\n   *\n   * NOTE: can only be called on wrapper of a single node.\n   *\n   * @param {Object} options\n   * @returns {ShallowWrapper}\n   */\n  shallow(options) {\n    return this.single('shallow', n => (\n      this.wrap(getAdapter(this[OPTIONS]).nodeToElement(n), null, options)\n    ));\n  }\n\n  /**\n   * Returns the value of prop with the given name of the current node.\n   *\n   * @param propName\n   * @returns {*}\n   */\n  prop(propName) {\n    return this.props()[propName];\n  }\n\n  /**\n   * Used to invoke a function prop.\n   * Will invoke an function prop and return its value.\n   *\n   * @param {String} propName\n   * @returns {Any}\n   */\n  invoke(propName) {\n    return this.single('invoke', () => {\n      const handler = this.prop(propName);\n      if (typeof handler !== 'function') {\n        throw new TypeError('ShallowWrapper::invoke() requires the name of a prop whose value is a function');\n      }\n      return (...args) => {\n        const response = handler(...args);\n        this[ROOT].update();\n        return response;\n      };\n    });\n  }\n\n  /**\n   * Returns a wrapper of the node rendered by the provided render prop.\n   *\n   * @param {String} propName\n   * @returns {Function}\n   */\n  renderProp(propName) {\n    const adapter = getAdapter(this[OPTIONS]);\n    if (typeof adapter.wrap !== 'function') {\n      throw new RangeError('your adapter does not support `wrap`. Try upgrading it!');\n    }\n\n    return this.single('renderProp', (n) => {\n      if (n.nodeType === 'host') {\n        throw new TypeError('ShallowWrapper::renderProp() can only be called on custom components');\n      }\n      if (typeof propName !== 'string') {\n        throw new TypeError('ShallowWrapper::renderProp(): `propName` must be a string');\n      }\n      const props = this.props();\n      if (!has(props, propName)) {\n        throw new Error(`ShallowWrapper::renderProp(): no prop called ${propName} found`);\n      }\n      const propValue = props[propName];\n      if (typeof propValue !== 'function') {\n        throw new TypeError(`ShallowWrapper::renderProp(): expected prop ${propName} to contain a function, but it holds ${typeof propValue}`);\n      }\n\n      return (...args) => {\n        const element = propValue(...args);\n        const wrapped = adapter.wrap(element);\n        return this.wrap(wrapped, null, this[OPTIONS]);\n      };\n    });\n  }\n\n  /**\n   * Returns the key assigned to the current node.\n   *\n   * @returns {String}\n   */\n  key() {\n    return this.single('key', n => (n.key === undefined ? null : n.key));\n  }\n\n  /**\n   * Returns the type of the current node of this wrapper. If it's a composite component, this will\n   * be the component constructor. If it's a native DOM node, it will be a string of the tag name.\n   * If it's null, it will be null.\n   *\n   * @returns {String|Function|null}\n   */\n  type() {\n    return this.single('type', n => typeOfNode(n));\n  }\n\n  /**\n   * Returns the name of the current node of this wrapper.\n   *\n   * In order of precedence => type.displayName -> type.name -> type.\n   *\n   * @returns {String}\n   */\n  name() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('name', n => (\n      adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : displayNameOfNode(n)\n    ));\n  }\n\n  /**\n   * Returns whether or not the current node has the given class name or not.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param className\n   * @returns {Boolean}\n   */\n  hasClass(className) {\n    if (typeof className === 'string' && className.indexOf('.') !== -1) {\n      // eslint-disable-next-line no-console\n      console.warn('It looks like you\\'re calling `ShallowWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');\n    }\n    return this.single('hasClass', n => hasClassName(n, className));\n  }\n\n  /**\n   * Iterates through each node of the current wrapper and executes the provided function with a\n   * wrapper around the corresponding node passed in as the first argument.\n   *\n   * @param {Function} fn\n   * @returns {ShallowWrapper}\n   */\n  forEach(fn) {\n    this.getNodesInternal().forEach((n, i) => fn.call(this, this.wrap(n), i));\n    return this;\n  }\n\n  /**\n   * Maps the current array of nodes to another array. Each node is passed in as a `ShallowWrapper`\n   * to the map function.\n   *\n   * @param {Function} fn\n   * @returns {Array}\n   */\n  map(fn) {\n    return this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Reduces the current array of nodes to a value. Each node is passed in as a `ShallowWrapper`\n   * to the reducer function.\n   *\n   * @param {Function} fn - the reducer function\n   * @param {*} initialValue - the initial value\n   * @returns {*}\n   */\n  reduce(fn, initialValue = undefined) {\n    if (arguments.length > 1) {\n      return this.getNodesInternal().reduce(\n        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),\n        initialValue,\n      );\n    }\n    return this.getNodesInternal().reduce((accum, n, i) => fn.call(\n      this,\n      i === 1 ? this.wrap(accum) : accum,\n      this.wrap(n),\n      i,\n    ));\n  }\n\n  /**\n   * Reduces the current array of nodes to another array, from right to left. Each node is passed\n   * in as a `ShallowWrapper` to the reducer function.\n   *\n   * @param {Function} fn - the reducer function\n   * @param {*} initialValue - the initial value\n   * @returns {*}\n   */\n  reduceRight(fn, initialValue = undefined) {\n    if (arguments.length > 1) {\n      return this.getNodesInternal().reduceRight(\n        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),\n        initialValue,\n      );\n    }\n    return this.getNodesInternal().reduceRight((accum, n, i) => fn.call(\n      this,\n      i === 1 ? this.wrap(accum) : accum,\n      this.wrap(n),\n      i,\n    ));\n  }\n\n  /**\n   * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the\n   * rules of `Array#slice`.\n   *\n   * @param {Number} begin\n   * @param {Number} end\n   * @returns {ShallowWrapper}\n   */\n  slice(begin, end) {\n    return this.wrap(this.getNodesInternal().slice(begin, end));\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper match the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {Boolean}\n   */\n  some(selector) {\n    if (this[ROOT] === this) {\n      throw new Error('ShallowWrapper::some() can not be called on the root');\n    }\n    const predicate = buildPredicate(selector);\n    return this.getNodesInternal().some(predicate);\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {Boolean}\n   */\n  someWhere(predicate) {\n    return this.getNodesInternal().some((n, i) => predicate.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Returns whether or not all of the nodes in the wrapper match the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {Boolean}\n   */\n  every(selector) {\n    const predicate = buildPredicate(selector);\n    return this.getNodesInternal().every(predicate);\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {Boolean}\n   */\n  everyWhere(predicate) {\n    return this.getNodesInternal().every((n, i) => predicate.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Utility method used to create new wrappers with a mapping function that returns an array of\n   * nodes in response to a single node wrapper. The returned wrapper is a single wrapper around\n   * all of the mapped nodes flattened (and de-duplicated).\n   *\n   * @param {Function} fn\n   * @returns {ShallowWrapper}\n   */\n  flatMap(fn) {\n    const nodes = this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));\n    const flattened = flat(nodes, 1);\n    return this.wrap(flattened.filter(Boolean));\n  }\n\n  /**\n   * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n   * function. The predicate function will receive the nodes inside a ShallowWrapper as its\n   * first argument.\n   *\n   * @param {Function} predicate\n   * @returns {ShallowWrapper}\n   */\n  findWhere(predicate) {\n    return findWhereUnwrapped(this, (n) => {\n      const node = this.wrap(n);\n      return node.length > 0 && predicate(node);\n    });\n  }\n\n  /**\n   * Returns the node at a given index of the current wrapper.\n   *\n   * @param index\n   * @returns {ReactElement}\n   */\n  get(index) {\n    return this.getElements()[index];\n  }\n\n  /**\n   * Returns a wrapper around the node at a given index of the current wrapper.\n   *\n   * @param index\n   * @returns {ShallowWrapper}\n   */\n  at(index) {\n    const nodes = this.getNodesInternal();\n    if (index < nodes.length) {\n      return this.wrap(nodes[index]);\n    }\n    return this.wrap([]);\n  }\n\n  /**\n   * Returns a wrapper around the first node of the current wrapper.\n   *\n   * @returns {ShallowWrapper}\n   */\n  first() {\n    return this.at(0);\n  }\n\n  /**\n   * Returns a wrapper around the last node of the current wrapper.\n   *\n   * @returns {ShallowWrapper}\n   */\n  last() {\n    return this.at(this.length - 1);\n  }\n\n  /**\n   * Delegates to exists()\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    // eslint-disable-next-line no-console\n    console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');\n    return !this.exists();\n  }\n\n  /**\n   * Returns true if the current wrapper has nodes. False otherwise.\n   * If called with a selector it returns `.find(selector).exists()` instead.\n   *\n   * @param {EnzymeSelector} selector (optional)\n   * @returns {boolean}\n   */\n  exists(selector = null) {\n    return arguments.length > 0 ? this.find(selector).exists() : this.length > 0;\n  }\n\n  /**\n   * Utility method that throws an error if the current instance has a length other than one.\n   * This is primarily used to enforce that certain methods are only run on a wrapper when it is\n   * wrapping a single node.\n   *\n   * @param fn\n   * @returns {*}\n   */\n  single(name, fn) {\n    const fnName = typeof name === 'string' ? name : 'unknown';\n    const callback = typeof fn === 'function' ? fn : name;\n    if (this.length !== 1) {\n      throw new Error(`Method ${fnName} is meant to be run on 1 node. ${this.length} found instead.`);\n    }\n    return callback.call(this, this.getNodeInternal());\n  }\n\n  /**\n   * Helpful utility method to create a new wrapper with the same root as the current wrapper, with\n   * any nodes passed in as the first parameter automatically wrapped.\n   *\n   * @param node\n   * @returns {ShallowWrapper}\n   */\n  wrap(node, root = this[ROOT], ...args) {\n    if (node instanceof ShallowWrapper) {\n      return node;\n    }\n    return new ShallowWrapper(node, root, ...args);\n  }\n\n  /**\n   * Returns an HTML-like string of the shallow render for debugging purposes.\n   *\n   * @param {Object} [options] - Property bag of additional options.\n   * @param {boolean} [options.ignoreProps] - if true, props are omitted from the string.\n   * @param {boolean} [options.verbose] - if true, arrays and objects to be verbosely printed.\n   * @returns {String}\n   */\n  debug(options = {}) {\n    return debugNodes(this.getNodesInternal(), options);\n  }\n\n  /**\n   * Invokes intercepter and returns itself. intercepter is called with itself.\n   * This is helpful when debugging nodes in method chains.\n   * @param fn\n   * @returns {ShallowWrapper}\n   */\n  tap(intercepter) {\n    intercepter(this);\n    return this;\n  }\n\n  /**\n   * Primarily useful for HOCs (higher-order components), this method may only be\n   * run on a single, non-DOM node, and will return the node, shallow-rendered.\n   *\n   * @param {Object} options\n   * @returns {ShallowWrapper}\n   */\n  dive(options = {}) {\n    const adapter = getAdapter(this[OPTIONS]);\n    const name = 'dive';\n    return this.single(name, (n) => {\n      if (n && n.nodeType === 'host') {\n        throw new TypeError(`ShallowWrapper::${name}() can not be called on Host Components`);\n      }\n      const el = getAdapter(this[OPTIONS]).nodeToElement(n);\n      if (!isCustomComponentElement(el, adapter)) {\n        throw new TypeError(`ShallowWrapper::${name}() can only be called on components`);\n      }\n      const childOptions = {\n        ...this[OPTIONS],\n        ...options,\n        context: options.context || {\n          ...this[OPTIONS].context,\n          ...this[ROOT][CHILD_CONTEXT],\n        },\n      };\n      privateSet(childOptions, PROVIDER_VALUES, this[ROOT][PROVIDER_VALUES]);\n      return this.wrap(el, null, childOptions);\n    });\n  }\n\n  /**\n   * Strips out all the not host-nodes from the list of nodes\n   *\n   * This method is useful if you want to check for the presence of host nodes\n   * (actually rendered HTML elements) ignoring the React nodes.\n   */\n  hostNodes() {\n    return this.filterWhere(n => typeof n.type() === 'string');\n  }\n}\n\n/**\n * Updates the context of the primary wrapper when the\n * `wrappingComponent` re-renders.\n */\nfunction updatePrimaryRootContext(wrappingComponent) {\n  const adapter = getAdapter(wrappingComponent[OPTIONS]);\n  const primaryWrapper = wrappingComponent[PRIMARY_WRAPPER];\n  const primaryRenderer = primaryWrapper[RENDERER];\n  const primaryNode = primaryRenderer.getNode();\n  const {\n    legacyContext,\n    providerValues,\n  } = getContextFromWrappingComponent(wrappingComponent, adapter);\n  const prevProviderValues = primaryWrapper[PROVIDER_VALUES];\n\n  primaryWrapper.setContext({\n    ...wrappingComponent[PRIMARY_WRAPPER][OPTIONS].context,\n    ...legacyContext,\n  });\n  primaryWrapper[PROVIDER_VALUES] = new Map([...prevProviderValues, ...providerValues]);\n\n  if (typeof adapter.isContextConsumer === 'function' && adapter.isContextConsumer(primaryNode.type)) {\n    const Consumer = primaryNode.type;\n    // Adapters with an `isContextConsumer` method will definitely have a `getProviderFromConsumer`\n    // method.\n    const Provider = adapter.getProviderFromConsumer(Consumer);\n    const newValue = providerValues.get(Provider);\n    const oldValue = prevProviderValues.get(Provider);\n\n    // Use referential comparison like React\n    if (newValue !== oldValue) {\n      primaryWrapper.rerender();\n    }\n  }\n}\n\n/**\n * A *special* \"root\" wrapper that represents the component passed as `wrappingComponent`.\n * It is linked to the primary root such that updates to it will update the primary.\n *\n * @class WrappingComponentWrapper\n */\nclass WrappingComponentWrapper extends ShallowWrapper {\n  constructor(nodes, root, RootFinder) {\n    super(nodes);\n    privateSet(this, PRIMARY_WRAPPER, root);\n    privateSet(this, ROOT_FINDER, RootFinder);\n  }\n\n  /**\n   * Like rerender() on ShallowWrapper, except it also does a \"full render\" of\n   * itself and updates the primary ShallowWrapper's context.\n   */\n  rerender(...args) {\n    const result = super.rerender(...args);\n    updatePrimaryRootContext(this);\n    return result;\n  }\n\n  /**\n   * Like setState() on ShallowWrapper, except it also does a \"full render\" of\n   * itself and updates the primary ShallowWrapper's context.\n   */\n  setState(...args) {\n    const result = super.setState(...args);\n    updatePrimaryRootContext(this);\n    return result;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getWrappingComponent() {\n    throw new Error('ShallowWrapper::getWrappingComponent() can only be called on the root');\n  }\n}\n\nif (ITERATOR_SYMBOL) {\n  Object.defineProperty(ShallowWrapper.prototype, ITERATOR_SYMBOL, {\n    configurable: true,\n    value: function iterator() {\n      const iter = this.getNodesInternal()[ITERATOR_SYMBOL]();\n      const adapter = getAdapter(this[OPTIONS]);\n      return {\n        [ITERATOR_SYMBOL]() { return this; },\n        next() {\n          const next = iter.next();\n          if (next.done) {\n            return { done: true };\n          }\n          return {\n            done: false,\n            value: adapter.nodeToElement(next.value),\n          };\n        },\n      };\n    },\n  });\n}\n\nfunction privateWarning(prop, extraMessage) {\n  Object.defineProperty(ShallowWrapper.prototype, prop, {\n    get() {\n      throw new Error(`\n        Attempted to access ShallowWrapper::${prop}, which was previously a private property on\n        Enzyme ShallowWrapper instances, but is no longer and should not be relied upon.\n        ${extraMessage}\n      `);\n    },\n    enumerable: false,\n    configurable: false,\n  });\n}\n\nprivateWarning('node', 'Consider using the getElement() method instead.');\nprivateWarning('nodes', 'Consider using the getElements() method instead.');\nprivateWarning('renderer', '');\nprivateWarning('options', '');\nprivateWarning('complexSelector', '');\n\nexport default ShallowWrapper;\n"]}