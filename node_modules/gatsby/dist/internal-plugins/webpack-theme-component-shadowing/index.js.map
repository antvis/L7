{"version":3,"sources":["../../../src/internal-plugins/webpack-theme-component-shadowing/index.js"],"names":["path","require","debug","fs","_","pathWithoutExtension","fullPath","parsed","parse","join","dir","name","module","exports","GatsbyThemeComponentShadowingResolverPlugin","constructor","projectRoot","themes","extensions","map","themeName","apply","resolver","hooks","relative","tapAsync","request","stack","callback","matchingThemes","getMatchingThemesForPath","length","Error","theme","component","split","themeDir","context","issuer","requestPathIsIssuerShadowPath","requestPath","issuerPath","userSiteDir","doResolve","describedRelative","builtComponentPath","resolveComponentPath","matchingTheme","ogThemes","filter","concat","Array","from","reverse","find","possibleComponentPath","readdirSync","dirname","e","existsDir","filepath","basename","exists","includes","ext","allMatchingThemes","uniqBy","getBaseShadowDirsForThemes","shadowFiles"],"mappings":"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","sourcesContent":["const path = require(`path`)\nconst debug = require(`debug`)(`gatsby:component-shadowing`)\nconst fs = require(`fs`)\nconst _ = require(`lodash`)\n\nconst pathWithoutExtension = fullPath => {\n  const parsed = path.parse(fullPath)\n  return path.join(parsed.dir, parsed.name)\n}\n\nmodule.exports = class GatsbyThemeComponentShadowingResolverPlugin {\n  cache = {}\n\n  constructor({ projectRoot, themes, extensions }) {\n    debug(\n      `themes list`,\n      themes.map(({ themeName }) => themeName)\n    )\n    this.themes = themes\n    this.projectRoot = projectRoot\n    this.extensions = extensions\n  }\n\n  apply(resolver) {\n    resolver.hooks.relative.tapAsync(\n      `GatsbyThemeComponentShadowingResolverPlugin`,\n      (request, stack, callback) => {\n        const matchingThemes = this.getMatchingThemesForPath(request.path)\n\n        // 0 matching themes happens a lot for paths we don't want to handle\n        // > 1 matching theme means we have a path like\n        //   `gatsby-theme-blog/src/components/gatsby-theme-something/src/components`\n        if (matchingThemes.length > 1) {\n          throw new Error(\n            `Gatsby can't differentiate between themes ${matchingThemes\n              .map(theme => theme.themeName)\n              .join(` and `)} for path ${request.path}`\n          )\n        }\n\n        if (matchingThemes.length !== 1) {\n          return callback()\n        }\n\n        // theme is the theme package from which we're requiring the relative component\n        const [theme] = matchingThemes\n        // get the location of the component relative to src/\n        const [, component] = request.path.split(\n          path.join(theme.themeDir, `src`)\n        )\n\n        if (\n          /**\n           * if someone adds\n           * ```\n           * modules: [path.resolve(__dirname, 'src'), 'node_modules'],\n           * ```\n           * to the webpack config, `issuer` is `null`, so we skip this check.\n           * note that it's probably a bad idea in general to set `modules`\n           * like this in a theme, but we also shouldn't artificially break\n           * people that do.\n           */\n          request.context.issuer &&\n          /**\n           * An issuer is the file making the require request. It can\n           * be in a user's site or a theme. If the issuer is requesting\n           * a path in the shadow chain that it participates in, then we\n           * will let the request through as normal. Otherwise, we\n           * engage the shadowing algorithm.\n           */\n          this.requestPathIsIssuerShadowPath({\n            requestPath: request.path,\n            issuerPath: request.context.issuer,\n            userSiteDir: this.projectRoot,\n          })\n        ) {\n          return resolver.doResolve(\n            resolver.hooks.describedRelative,\n            request,\n            null,\n            {},\n            callback\n          )\n        }\n\n        // This is the shadowing algorithm.\n        const builtComponentPath = this.resolveComponentPath({\n          matchingTheme: theme.themeName,\n          themes: this.themes,\n          component,\n        })\n\n        return resolver.doResolve(\n          resolver.hooks.describedRelative,\n          { ...request, path: builtComponentPath || request.path },\n          null,\n          {},\n          callback\n        )\n      }\n    )\n  }\n\n  // check the cache, the user's project, and finally the theme files\n  resolveComponentPath({ matchingTheme: theme, themes: ogThemes, component }) {\n    // don't include matching theme in possible shadowing paths\n    const themes = ogThemes.filter(({ themeName }) => themeName !== theme)\n\n    return [path.join(this.projectRoot, `src`, theme)]\n      .concat(\n        Array.from(themes)\n          .reverse()\n          .map(({ themeDir }) => path.join(themeDir, `src`, theme))\n      )\n      .map(dir => path.join(dir, component))\n      .find(possibleComponentPath => {\n        debug(`possibleComponentPath`, possibleComponentPath)\n        let dir\n        try {\n          // we use fs/path instead of require.resolve to work with\n          // TypeScript and alternate syntaxes\n          dir = fs.readdirSync(path.dirname(possibleComponentPath))\n        } catch (e) {\n          return false\n        }\n        const existsDir = dir.map(filepath => path.basename(filepath))\n        const exists =\n          // has extension, will match styles.css;\n\n          // import Thing from 'whatever.tsx'\n          // extensions: [.js, .tsx]\n          // site/src/whatever.tsx site/src/whatever.js.\n\n          //exact matches\n          existsDir.includes(path.basename(possibleComponentPath)) ||\n          // .js matches\n          // styles.css.js\n          // whatever.tsx.js\n          this.extensions.find(ext =>\n            existsDir.includes(path.basename(possibleComponentPath) + ext)\n          )\n        return exists\n      })\n  }\n\n  getMatchingThemesForPath(filepath) {\n    // find out which theme's src/components dir we're requiring from\n    const allMatchingThemes = this.themes.filter(({ themeDir }) =>\n      filepath.includes(path.join(themeDir, `src`))\n    )\n\n    // The same theme can be included twice in the themes list causing multiple\n    // matches. This case should only be counted as a single match for that theme.\n    return _.uniqBy(allMatchingThemes, `themeName`)\n  }\n\n  // given a theme name, return all of the possible shadow locations\n  getBaseShadowDirsForThemes(theme) {\n    return Array.from(this.themes)\n      .reverse()\n      .map(({ themeName, themeDir }) => {\n        if (themeName === theme) {\n          return path.join(themeDir, `src`)\n        } else {\n          return path.join(themeDir, `src`, theme)\n        }\n      })\n  }\n\n  requestPathIsIssuerShadowPath({ requestPath, issuerPath, userSiteDir }) {\n    // get the issuer's theme\n    const matchingThemes = this.getMatchingThemesForPath(requestPath)\n    if (matchingThemes.length !== 1) {\n      return false\n    }\n    const [theme] = matchingThemes\n\n    // get the location of the component relative to src/\n    const [, component] = requestPath.split(path.join(theme.themeDir, `src`))\n\n    // get list of potential shadow locations\n    const shadowFiles = this.getBaseShadowDirsForThemes(theme.themeName)\n      .concat(path.join(userSiteDir, `src`, theme.themeName))\n      .map(dir => path.join(dir, component))\n\n    // if the issuer is requesting a path that is a potential shadow path of itself\n    return shadowFiles.includes(pathWithoutExtension(issuerPath))\n  }\n}\n"],"file":"index.js"}