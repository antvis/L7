{"version":3,"sources":["../src/sequenceOf.js"],"names":["minValidator","nonNegativeInteger","maxValidator","gte","validateRange","min","max","RangeError","specifierShape","validator","props","propName","propValue","TypeError","getMinMax","minimum","maximum","Infinity","chunkByType","items","chunk","lastType","reduce","chunks","item","itemType","push","concat","length","validateChunks","specifiers","componentName","rest","i","arrayOfValidator","isRequired","shift","chunkError","unshift","specifierValidator","sequenceOfValidator","errors","map","specifier","some","Boolean","e","message","join","sequenceOf","error","array","sequenceOfRequired"],"mappings":"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","sourcesContent":["import { array, arrayOf } from 'prop-types';\n\nimport and from './and';\nimport between from './between';\nimport nonNegativeInteger from './nonNegativeInteger';\nimport object from './object';\nimport withShape from './withShape';\nimport typeOf from './helpers/typeOf';\nimport wrapValidator from './helpers/wrapValidator';\n\nconst minValidator = nonNegativeInteger;\nconst maxValidator = and([nonNegativeInteger, between({ gte: 1 })]);\n\nfunction validateRange(min, max) {\n  if (typeof max !== 'number' || typeof min !== 'number') {\n    return null; // no additional checking needed unless both are present\n  }\n\n  if (min <= max) {\n    return null;\n  }\n  return new RangeError('min must be less than or equal to max');\n}\n\nconst specifierShape = {\n  validator(props, propName) {\n    const { [propName]: propValue } = props;\n    if (typeof propValue !== 'function') {\n      return new TypeError('\"validator\" must be a propType validator function');\n    }\n    return null;\n  },\n\n  min(props, propName) {\n    return minValidator(props, propName) || validateRange(props.min, props.max);\n  },\n\n  max(props, propName) {\n    return maxValidator(props, propName) || validateRange(props.min, props.max);\n  },\n};\n\nfunction getMinMax({ min, max }) {\n  let minimum;\n  let maximum;\n  if (typeof min !== 'number' && typeof max !== 'number') {\n    // neither provided, default to \"1\"\n    minimum = 1;\n    maximum = 1;\n  } else {\n    minimum = typeof min === 'number' ? min : 1;\n    maximum = typeof max === 'number' ? max : Infinity;\n  }\n  return { minimum, maximum };\n}\n\nfunction chunkByType(items) {\n  let chunk = [];\n  let lastType;\n  return items.reduce((chunks, item) => {\n    const itemType = typeOf(item);\n    if (!lastType || itemType === lastType) {\n      chunk.push(item);\n    } else {\n      chunks.push(chunk);\n      chunk = [item];\n    }\n    lastType = itemType;\n    return chunks;\n  }, []).concat(chunk.length > 0 ? [chunk] : []);\n}\n\nfunction validateChunks(specifiers, props, propName, componentName, ...rest) {\n  const { [propName]: items } = props;\n  const chunks = chunkByType(items);\n\n  for (let i = 0; i < specifiers.length; i += 1) {\n    const { validator, min, max } = specifiers[i];\n\n    const { minimum, maximum } = getMinMax({ min, max });\n\n    if (chunks.length === 0 && minimum === 0) {\n      // no chunks left, but this specifier does not require any items\n      continue; // eslint-disable-line no-continue\n    }\n\n    const arrayOfValidator = arrayOf(validator).isRequired;\n\n    const chunk = chunks.shift(); // extract the next chunk to test\n\n    const chunkError = arrayOfValidator(\n      { ...props, [propName]: chunk },\n      propName,\n      componentName,\n      ...rest,\n    );\n\n    if (chunkError) { // this chunk is invalid\n      if (minimum === 0) { // but, specifier has a min of 0 and can be skipped\n        chunks.unshift(chunk); // put the chunk back, for the next iteration\n        continue; // eslint-disable-line no-continue\n      }\n      return chunkError;\n    }\n\n    // chunk is valid!\n\n    if (chunk.length < minimum) {\n      return new RangeError(`${componentName}: specifier index ${i} requires a minimum of ${min} items, but only has ${chunk.length}.`);\n    }\n\n    if (chunk.length > maximum) {\n      return new RangeError(`${componentName}: specifier index ${i} requires a maximum of ${max} items, but has ${chunk.length}.`);\n    }\n  }\n\n  if (chunks.length > 0) {\n    return new TypeError(`${componentName}: after all ${specifiers.length} specifiers matched, ${chunks.length} types of items were remaining.`);\n  }\n\n  return null;\n}\n\nconst specifierValidator = withShape(object(), specifierShape).isRequired;\n\nexport default function sequenceOfValidator(...specifiers) {\n  if (specifiers.length === 0) {\n    throw new RangeError('sequenceOf: at least one specifier is required');\n  }\n\n  const errors = specifiers.map((specifier, i) => specifierValidator(\n    { specifier },\n    'specifier',\n    'sequenceOf specifier',\n    `suequenceOf specifier, index ${i}`,\n    `specifier, index ${i}`,\n  ));\n  if (errors.some(Boolean)) {\n    throw new TypeError(`\n      sequenceOf: all specifiers must match the appropriate shape.\n\n      Errors:\n        ${errors.map((e, i) => ` - Argument index ${i}: ${e.message}`).join(',\\n        ')}\n    `);\n  }\n\n  const validator = function sequenceOf(props, propName, ...rest) {\n    const { [propName]: propValue } = props;\n\n    if (propValue == null) {\n      return null;\n    }\n\n    const error = array(props, propName, ...rest);\n    if (error) {\n      return error;\n    }\n\n    return validateChunks(specifiers, props, propName, ...rest);\n  };\n\n  validator.isRequired = function sequenceOfRequired(props, propName, componentName, ...rest) {\n    const error = array.isRequired(props, propName, componentName, ...rest);\n    if (error) {\n      return error;\n    }\n\n    return validateChunks(specifiers, props, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(validator, 'sequenceOf', specifiers);\n}\n"],"file":"sequenceOf.js"}